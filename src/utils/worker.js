"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __commonJS = (cb, mod2) => function __require() {
    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all2) => {
    for (var name in all2)
      __defProp(target, name, { get: all2[name], enumerable: true });
  };
  var __copyProps = (to, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
    mod2
  ));
  var __decorateClass = (decorators, target, key, kind) => {
    var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
    for (var i = decorators.length - 1, decorator; i >= 0; i--)
      if (decorator = decorators[i])
        result = (kind ? decorator(target, key, result) : decorator(result)) || result;
    if (kind && result)
      __defProp(target, key, result);
    return result;
  };
  var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };

  // ../node_modules/.pnpm/numfmt@2.5.2/node_modules/numfmt/numfmt.js
  var require_numfmt = __commonJS({
    "../node_modules/.pnpm/numfmt@2.5.2/node_modules/numfmt/numfmt.js"(exports, module) {
      !function(e, t) {
        "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.numfmt = t() : e.numfmt = t();
      }("undefined" != typeof self ? self : exports, function() {
        return function() {
          "use strict";
          var e = { d: function(t2, n2) {
            for (var a2 in n2)
              e.o(n2, a2) && !e.o(t2, a2) && Object.defineProperty(t2, a2, { enumerable: true, get: n2[a2] });
          }, o: function(e2, t2) {
            return Object.prototype.hasOwnProperty.call(e2, t2);
          } }, t = {};
          e.d(t, { default: function() {
            return pe;
          } });
          var n = { 1078: "af", 1052: "sq", 1118: "am", 5121: "ar_DZ", 15361: "ar_BH", 3073: "ar_EG", 2049: "ar_IQ", 11265: "ar_JO", 13313: "ar_KW", 12289: "ar_LB", 4097: "ar_LY", 6145: "ar_MA", 8193: "ar_OM", 16385: "ar_QA", 1025: "ar_SA", 10241: "ar_SY", 7169: "ar_TN", 14337: "ar_AE", 9217: "ar_YE", 1067: "hy", 1101: "as", 2092: "az_AZ", 1068: "az_AZ", 1069: "eu", 1059: "be", 2117: "bn", 1093: "bn_IN", 5146: "bs", 1026: "bg", 1109: "my", 1027: "ca", 2052: "zh_CN", 3076: "zh_HK", 5124: "zh_MO", 4100: "zh_SG", 1028: "zh_TW", 1050: "hr", 1029: "cs", 1030: "da", 1125: "dv", 2067: "nl_BE", 1043: "nl_NL", 1126: "bin", 3081: "en_AU", 10249: "en_BZ", 4105: "en_CA", 9225: "en_CB", 2057: "en_GB", 16393: "en_IN", 6153: "en_IE", 8201: "en_JM", 5129: "en_NZ", 13321: "en_PH", 7177: "en_ZA", 11273: "en_TT", 1033: "en_US", 12297: "en_ZW", 1061: "et", 1071: "mk", 1080: "fo", 1065: "fa", 1124: "fil", 1035: "fi", 2060: "fr_BE", 11276: "fr_CM", 3084: "fr_CA", 9228: "fr_CG", 12300: "fr_CI", 1036: "fr_FR", 5132: "fr_LU", 13324: "fr_ML", 6156: "fr_MC", 14348: "fr_MA", 10252: "fr_SN", 4108: "fr_CH", 7180: "fr", 1122: "fy_NL", 2108: "gd_IE", 1084: "gd", 1110: "gl", 1079: "ka", 3079: "de_AT", 1031: "de_DE", 5127: "de_LI", 4103: "de_LU", 2055: "de_CH", 1032: "el", 1140: "gn", 1095: "gu", 1279: "en", 1037: "he", 1081: "hi", 1038: "hu", 1039: "is", 1136: "ig_NG", 1057: "id", 1040: "it_IT", 2064: "it_CH", 1041: "ja", 1099: "kn", 1120: "ks", 1087: "kk", 1107: "km", 1111: "kok", 1042: "ko", 1088: "ky", 1108: "lo", 1142: "la", 1062: "lv", 1063: "lt", 2110: "ms_BN", 1086: "ms_MY", 1100: "ml", 1082: "mt", 1112: "mni", 1153: "mi", 1102: "mr", 1104: "mn", 2128: "mn", 1121: "ne", 1044: "no_NO", 2068: "no_NO", 1096: "or", 1045: "pl", 1046: "pt_BR", 2070: "pt_PT", 1094: "pa", 1047: "rm", 2072: "ro_MO", 1048: "ro_RO", 1049: "ru", 2073: "ru_MO", 1083: "se", 1103: "sa", 3098: "sr_SP", 2074: "sr_SP", 1072: "st", 1074: "tn", 1113: "sd", 1115: "si", 1051: "sk", 1060: "sl", 1143: "so", 1070: "sb", 11274: "es_AR", 16394: "es_BO", 13322: "es_CL", 9226: "es_CO", 5130: "es_CR", 7178: "es_DO", 12298: "es_EC", 17418: "es_SV", 4106: "es_GT", 18442: "es_HN", 2058: "es_MX", 19466: "es_NI", 6154: "es_PA", 15370: "es_PY", 10250: "es_PE", 20490: "es_PR", 1034: "es_ES", 14346: "es_UY", 8202: "es_VE", 1089: "sw", 2077: "sv_FI", 1053: "sv_SE", 1114: "syc", 1064: "tg", 1097: "ta", 1092: "tt", 1098: "te", 1054: "th", 1105: "bo", 1073: "ts", 1055: "tr", 1090: "tk", 1058: "uk", 1056: "ur", 2115: "uz_UZ", 1091: "uz_UZ", 1075: "ve", 1066: "vi", 1106: "cy", 1076: "xh", 1085: "yi", 1077: "zu" };
          const a = /^([a-z\d]+)(?:[_-]([a-z\d]+))?(?:\.([a-z\d]+))?(?:@([a-z\d]+))?$/i, r = {}, i = { group: "\xA0", decimal: ".", positive: "+", negative: "-", percent: "%", exponent: "E", nan: "NaN", infinity: "\u221E", ampm: ["AM", "PM"], mmmm6: ["Muharram", "Safar", "Rabi\u02BB I", "Rabi\u02BB II", "Jumada I", "Jumada II", "Rajab", "Sha\u02BBban", "Ramadan", "Shawwal", "Dhu\u02BBl-Qi\u02BBdah", "Dhu\u02BBl-Hijjah"], mmm6: ["Muh.", "Saf.", "Rab. I", "Rab. II", "Jum. I", "Jum. II", "Raj.", "Sha.", "Ram.", "Shaw.", "Dhu\u02BBl-Q.", "Dhu\u02BBl-H."], mmmm: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], mmm: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dddd: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ddd: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] };
          function s(e2) {
            const t2 = a.exec(e2);
            if (!t2)
              throw new SyntaxError("Malformed locale: ".concat(e2));
            return { lang: t2[1] + (t2[2] ? "_" + t2[2] : ""), language: t2[1], territory: t2[2] || "", codeset: t2[3] || "", modifier: t2[4] || "" };
          }
          function o(e2) {
            if ("number" == typeof e2)
              return n[65535 & e2] || null;
            const t2 = parseInt(e2, 16);
            return isFinite(t2) && n[65535 & t2] ? n[65535 & t2] || null : a.test(e2) ? e2 : null;
          }
          function l(e2) {
            const t2 = o(e2);
            let n2 = null;
            if (t2) {
              const e3 = s(t2);
              n2 = r[e3.lang] || r[e3.language] || null;
            }
            return n2;
          }
          function d(e2) {
            return Object.assign({}, i, e2);
          }
          function m(e2, t2) {
            const n2 = "object" == typeof t2 ? t2 : s(t2);
            return r[n2.lang] = d(e2), n2.language === n2.lang || r[n2.language] || (r[n2.language] = d(e2)), r[n2.lang];
          }
          const u = d({ group: "," });
          function c(e2, t2) {
            if ("number" != typeof e2)
              return e2;
            if (e2 < 0)
              return -c(-e2, t2);
            if (t2) {
              const n2 = 10 ** (t2 || 0) || 1;
              return c(e2 * n2, 0) / n2;
            }
            return Math.round(e2);
          }
          u.isDefault = true, m({ group: ",", ampm: ["\u4E0A\u5348", "\u4E0B\u5348"], mmmm: ["\u4E00\u6708", "\u4E8C\u6708", "\u4E09\u6708", "\u56DB\u6708", "\u4E94\u6708", "\u516D\u6708", "\u4E03\u6708", "\u516B\u6708", "\u4E5D\u6708", "\u5341\u6708", "\u5341\u4E00\u6708", "\u5341\u4E8C\u6708"], mmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], dddd: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"], ddd: ["\u5468\u65E5", "\u5468\u4E00", "\u5468\u4E8C", "\u5468\u4E09", "\u5468\u56DB", "\u5468\u4E94", "\u5468\u516D"] }, "zh_CN"), m({ group: ",", nan: "\u975E\u6578\u503C", ampm: ["\u4E0A\u5348", "\u4E0B\u5348"], mmmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], mmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], dddd: ["\u661F\u671F\u65E5", "\u661F\u671F\u4E00", "\u661F\u671F\u4E8C", "\u661F\u671F\u4E09", "\u661F\u671F\u56DB", "\u661F\u671F\u4E94", "\u661F\u671F\u516D"], ddd: ["\u9031\u65E5", "\u9031\u4E00", "\u9031\u4E8C", "\u9031\u4E09", "\u9031\u56DB", "\u9031\u4E94", "\u9031\u516D"] }, "zh_TW"), m({ group: ",", ampm: ["\u5348\u524D", "\u5348\u5F8C"], mmmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], mmm: ["1\u6708", "2\u6708", "3\u6708", "4\u6708", "5\u6708", "6\u6708", "7\u6708", "8\u6708", "9\u6708", "10\u6708", "11\u6708", "12\u6708"], dddd: ["\u65E5\u66DC\u65E5", "\u6708\u66DC\u65E5", "\u706B\u66DC\u65E5", "\u6C34\u66DC\u65E5", "\u6728\u66DC\u65E5", "\u91D1\u66DC\u65E5", "\u571F\u66DC\u65E5"], ddd: ["\u65E5", "\u6708", "\u706B", "\u6C34", "\u6728", "\u91D1", "\u571F"] }, "ja"), m({ group: ",", ampm: ["\uC624\uC804", "\uC624\uD6C4"], mmmm: ["1\uC6D4", "2\uC6D4", "3\uC6D4", "4\uC6D4", "5\uC6D4", "6\uC6D4", "7\uC6D4", "8\uC6D4", "9\uC6D4", "10\uC6D4", "11\uC6D4", "12\uC6D4"], mmm: ["1\uC6D4", "2\uC6D4", "3\uC6D4", "4\uC6D4", "5\uC6D4", "6\uC6D4", "7\uC6D4", "8\uC6D4", "9\uC6D4", "10\uC6D4", "11\uC6D4", "12\uC6D4"], dddd: ["\uC77C\uC694\uC77C", "\uC6D4\uC694\uC77C", "\uD654\uC694\uC77C", "\uC218\uC694\uC77C", "\uBAA9\uC694\uC77C", "\uAE08\uC694\uC77C", "\uD1A0\uC694\uC77C"], ddd: ["\uC77C", "\uC6D4", "\uD654", "\uC218", "\uBAA9", "\uAE08", "\uD1A0"] }, "ko"), m({ group: ",", ampm: ["\u0E01\u0E48\u0E2D\u0E19\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07", "\u0E2B\u0E25\u0E31\u0E07\u0E40\u0E17\u0E35\u0E48\u0E22\u0E07"], mmmm: ["\u0E21\u0E01\u0E23\u0E32\u0E04\u0E21", "\u0E01\u0E38\u0E21\u0E20\u0E32\u0E1E\u0E31\u0E19\u0E18\u0E4C", "\u0E21\u0E35\u0E19\u0E32\u0E04\u0E21", "\u0E40\u0E21\u0E29\u0E32\u0E22\u0E19", "\u0E1E\u0E24\u0E29\u0E20\u0E32\u0E04\u0E21", "\u0E21\u0E34\u0E16\u0E38\u0E19\u0E32\u0E22\u0E19", "\u0E01\u0E23\u0E01\u0E0E\u0E32\u0E04\u0E21", "\u0E2A\u0E34\u0E07\u0E2B\u0E32\u0E04\u0E21", "\u0E01\u0E31\u0E19\u0E22\u0E32\u0E22\u0E19", "\u0E15\u0E38\u0E25\u0E32\u0E04\u0E21", "\u0E1E\u0E24\u0E28\u0E08\u0E34\u0E01\u0E32\u0E22\u0E19", "\u0E18\u0E31\u0E19\u0E27\u0E32\u0E04\u0E21"], mmm: ["\u0E21.\u0E04.", "\u0E01.\u0E1E.", "\u0E21\u0E35.\u0E04.", "\u0E40\u0E21.\u0E22.", "\u0E1E.\u0E04.", "\u0E21\u0E34.\u0E22.", "\u0E01.\u0E04.", "\u0E2A.\u0E04.", "\u0E01.\u0E22.", "\u0E15.\u0E04.", "\u0E1E.\u0E22.", "\u0E18.\u0E04."], dddd: ["\u0E27\u0E31\u0E19\u0E2D\u0E32\u0E17\u0E34\u0E15\u0E22\u0E4C", "\u0E27\u0E31\u0E19\u0E08\u0E31\u0E19\u0E17\u0E23\u0E4C", "\u0E27\u0E31\u0E19\u0E2D\u0E31\u0E07\u0E04\u0E32\u0E23", "\u0E27\u0E31\u0E19\u0E1E\u0E38\u0E18", "\u0E27\u0E31\u0E19\u0E1E\u0E24\u0E2B\u0E31\u0E2A\u0E1A\u0E14\u0E35", "\u0E27\u0E31\u0E19\u0E28\u0E38\u0E01\u0E23\u0E4C", "\u0E27\u0E31\u0E19\u0E40\u0E2A\u0E32\u0E23\u0E4C"], ddd: ["\u0E2D\u0E32.", "\u0E08.", "\u0E2D.", "\u0E1E.", "\u0E1E\u0E24.", "\u0E28.", "\u0E2A."] }, "th"), m({ decimal: ",", ampm: ["dop.", "odp."], mmmm: ["ledna", "\xFAnora", "b\u0159ezna", "dubna", "kv\u011Btna", "\u010Dervna", "\u010Dervence", "srpna", "z\xE1\u0159\xED", "\u0159\xEDjna", "listopadu", "prosince"], mmm: ["led", "\xFAno", "b\u0159e", "dub", "kv\u011B", "\u010Dvn", "\u010Dvc", "srp", "z\xE1\u0159", "\u0159\xEDj", "lis", "pro"], dddd: ["ned\u011Ble", "pond\u011Bl\xED", "\xFAter\xFD", "st\u0159eda", "\u010Dtvrtek", "p\xE1tek", "sobota"], ddd: ["ne", "po", "\xFAt", "st", "\u010Dt", "p\xE1", "so"] }, "cs"), m({ group: ".", decimal: ",", mmmm: ["januar", "februar", "marts", "april", "maj", "juni", "juli", "august", "september", "oktober", "november", "december"], mmm: ["jan.", "feb.", "mar.", "apr.", "maj", "jun.", "jul.", "aug.", "sep.", "okt.", "nov.", "dec."], dddd: ["s\xF8ndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "l\xF8rdag"], ddd: ["s\xF8n.", "man.", "tir.", "ons.", "tor.", "fre.", "l\xF8r."] }, "da"), m({ group: ".", decimal: ",", ampm: ["a.m.", "p.m."], mmmm: ["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"], mmm: ["jan.", "feb.", "mrt.", "apr.", "mei", "jun.", "jul.", "aug.", "sep.", "okt.", "nov.", "dec."], dddd: ["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"], ddd: ["zo", "ma", "di", "wo", "do", "vr", "za"] }, "nl"), m({ group: "," }, "en"), m({ decimal: ",", nan: "ep\xE4luku", ampm: ["ap.", "ip."], mmmm: ["tammikuuta", "helmikuuta", "maaliskuuta", "huhtikuuta", "toukokuuta", "kes\xE4kuuta", "hein\xE4kuuta", "elokuuta", "syyskuuta", "lokakuuta", "marraskuuta", "joulukuuta"], mmm: ["tammik.", "helmik.", "maalisk.", "huhtik.", "toukok.", "kes\xE4k.", "hein\xE4k.", "elok.", "syysk.", "lokak.", "marrask.", "jouluk."], dddd: ["sunnuntaina", "maanantaina", "tiistaina", "keskiviikkona", "torstaina", "perjantaina", "lauantaina"], ddd: ["su", "ma", "ti", "ke", "to", "pe", "la"] }, "fi"), m({ group: "\u202F", decimal: ",", mmmm: ["janvier", "f\xE9vrier", "mars", "avril", "mai", "juin", "juillet", "ao\xFBt", "septembre", "octobre", "novembre", "d\xE9cembre"], mmm: ["janv.", "f\xE9vr.", "mars", "avr.", "mai", "juin", "juil.", "ao\xFBt", "sept.", "oct.", "nov.", "d\xE9c."], dddd: ["dimanche", "lundi", "mardi", "mercredi", "jeudi", "vendredi", "samedi"], ddd: ["dim.", "lun.", "mar.", "mer.", "jeu.", "ven.", "sam."] }, "fr"), m({ group: ".", decimal: ",", mmmm: ["Januar", "Februar", "M\xE4rz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"], mmm: ["Jan.", "Feb.", "M\xE4rz", "Apr.", "Mai", "Juni", "Juli", "Aug.", "Sept.", "Okt.", "Nov.", "Dez."], dddd: ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"], ddd: ["So.", "Mo.", "Di.", "Mi.", "Do.", "Fr.", "Sa."] }, "de"), m({ group: ".", decimal: ",", ampm: ["\u03C0.\u03BC.", "\u03BC.\u03BC."], mmmm: ["\u0399\u03B1\u03BD\u03BF\u03C5\u03B1\u03C1\u03AF\u03BF\u03C5", "\u03A6\u03B5\u03B2\u03C1\u03BF\u03C5\u03B1\u03C1\u03AF\u03BF\u03C5", "\u039C\u03B1\u03C1\u03C4\u03AF\u03BF\u03C5", "\u0391\u03C0\u03C1\u03B9\u03BB\u03AF\u03BF\u03C5", "\u039C\u03B1\u0390\u03BF\u03C5", "\u0399\u03BF\u03C5\u03BD\u03AF\u03BF\u03C5", "\u0399\u03BF\u03C5\u03BB\u03AF\u03BF\u03C5", "\u0391\u03C5\u03B3\u03BF\u03CD\u03C3\u03C4\u03BF\u03C5", "\u03A3\u03B5\u03C0\u03C4\u03B5\u03BC\u03B2\u03C1\u03AF\u03BF\u03C5", "\u039F\u03BA\u03C4\u03C9\u03B2\u03C1\u03AF\u03BF\u03C5", "\u039D\u03BF\u03B5\u03BC\u03B2\u03C1\u03AF\u03BF\u03C5", "\u0394\u03B5\u03BA\u03B5\u03BC\u03B2\u03C1\u03AF\u03BF\u03C5"], mmm: ["\u0399\u03B1\u03BD", "\u03A6\u03B5\u03B2", "\u039C\u03B1\u03C1", "\u0391\u03C0\u03C1", "\u039C\u03B1\u0390", "\u0399\u03BF\u03C5\u03BD", "\u0399\u03BF\u03C5\u03BB", "\u0391\u03C5\u03B3", "\u03A3\u03B5\u03C0", "\u039F\u03BA\u03C4", "\u039D\u03BF\u03B5", "\u0394\u03B5\u03BA"], dddd: ["\u039A\u03C5\u03C1\u03B9\u03B1\u03BA\u03AE", "\u0394\u03B5\u03C5\u03C4\u03AD\u03C1\u03B1", "\u03A4\u03C1\u03AF\u03C4\u03B7", "\u03A4\u03B5\u03C4\u03AC\u03C1\u03C4\u03B7", "\u03A0\u03AD\u03BC\u03C0\u03C4\u03B7", "\u03A0\u03B1\u03C1\u03B1\u03C3\u03BA\u03B5\u03C5\u03AE", "\u03A3\u03AC\u03B2\u03B2\u03B1\u03C4\u03BF"], ddd: ["\u039A\u03C5\u03C1", "\u0394\u03B5\u03C5", "\u03A4\u03C1\u03AF", "\u03A4\u03B5\u03C4", "\u03A0\u03AD\u03BC", "\u03A0\u03B1\u03C1", "\u03A3\u03AC\u03B2"] }, "el"), m({ decimal: ",", ampm: ["de.", "du."], mmmm: ["janu\xE1r", "febru\xE1r", "m\xE1rcius", "\xE1prilis", "m\xE1jus", "j\xFAnius", "j\xFAlius", "augusztus", "szeptember", "okt\xF3ber", "november", "december"], mmm: ["jan.", "febr.", "m\xE1rc.", "\xE1pr.", "m\xE1j.", "j\xFAn.", "j\xFAl.", "aug.", "szept.", "okt.", "nov.", "dec."], dddd: ["vas\xE1rnap", "h\xE9tf\u0151", "kedd", "szerda", "cs\xFCt\xF6rt\xF6k", "p\xE9ntek", "szombat"], ddd: ["V", "H", "K", "Sze", "Cs", "P", "Szo"] }, "hu"), m({ group: ".", decimal: ",", ampm: ["f.h.", "e.h."], mmmm: ["jan\xFAar", "febr\xFAar", "mars", "apr\xEDl", "ma\xED", "j\xFAn\xED", "j\xFAl\xED", "\xE1g\xFAst", "september", "okt\xF3ber", "n\xF3vember", "desember"], mmm: ["jan.", "feb.", "mar.", "apr.", "ma\xED", "j\xFAn.", "j\xFAl.", "\xE1g\xFA.", "sep.", "okt.", "n\xF3v.", "des."], dddd: ["sunnudagur", "m\xE1nudagur", "\xFEri\xF0judagur", "mi\xF0vikudagur", "fimmtudagur", "f\xF6studagur", "laugardagur"], ddd: ["sun.", "m\xE1n.", "\xFEri.", "mi\xF0.", "fim.", "f\xF6s.", "lau."] }, "is"), m({ group: ".", decimal: ",", mmmm: ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"], mmm: ["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agu", "Sep", "Okt", "Nov", "Des"], dddd: ["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"], ddd: ["Min", "Sen", "Sel", "Rab", "Kam", "Jum", "Sab"] }, "id"), m({ group: ".", decimal: ",", mmmm: ["gennaio", "febbraio", "marzo", "aprile", "maggio", "giugno", "luglio", "agosto", "settembre", "ottobre", "novembre", "dicembre"], mmm: ["gen", "feb", "mar", "apr", "mag", "giu", "lug", "ago", "set", "ott", "nov", "dic"], dddd: ["domenica", "luned\xEC", "marted\xEC", "mercoled\xEC", "gioved\xEC", "venerd\xEC", "sabato"], ddd: ["dom", "lun", "mar", "mer", "gio", "ven", "sab"] }, "it"), m({ decimal: ",", ampm: ["a.m.", "p.m."], mmmm: ["januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember"], mmm: ["jan.", "feb.", "mar.", "apr.", "mai", "jun.", "jul.", "aug.", "sep.", "okt.", "nov.", "des."], dddd: ["s\xF8ndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "l\xF8rdag"], ddd: ["s\xF8n.", "man.", "tir.", "ons.", "tor.", "fre.", "l\xF8r."] }, "nb"), m({ decimal: ",", mmmm: ["stycznia", "lutego", "marca", "kwietnia", "maja", "czerwca", "lipca", "sierpnia", "wrze\u015Bnia", "pa\u017Adziernika", "listopada", "grudnia"], mmm: ["sty", "lut", "mar", "kwi", "maj", "cze", "lip", "sie", "wrz", "pa\u017A", "lis", "gru"], dddd: ["niedziela", "poniedzia\u0142ek", "wtorek", "\u015Broda", "czwartek", "pi\u0105tek", "sobota"], ddd: ["niedz.", "pon.", "wt.", "\u015Br.", "czw.", "pt.", "sob."] }, "pl"), m({ group: ".", decimal: ",", mmmm: ["janeiro", "fevereiro", "mar\xE7o", "abril", "maio", "junho", "julho", "agosto", "setembro", "outubro", "novembro", "dezembro"], mmm: ["jan.", "fev.", "mar.", "abr.", "mai.", "jun.", "jul.", "ago.", "set.", "out.", "nov.", "dez."], dddd: ["domingo", "segunda-feira", "ter\xE7a-feira", "quarta-feira", "quinta-feira", "sexta-feira", "s\xE1bado"], ddd: ["dom.", "seg.", "ter.", "qua.", "qui.", "sex.", "s\xE1b."] }, "pt"), m({ decimal: ",", nan: "\u043D\u0435\xA0\u0447\u0438\u0441\u043B\u043E", mmmm: ["\u044F\u043D\u0432\u0430\u0440\u044F", "\u0444\u0435\u0432\u0440\u0430\u043B\u044F", "\u043C\u0430\u0440\u0442\u0430", "\u0430\u043F\u0440\u0435\u043B\u044F", "\u043C\u0430\u044F", "\u0438\u044E\u043D\u044F", "\u0438\u044E\u043B\u044F", "\u0430\u0432\u0433\u0443\u0441\u0442\u0430", "\u0441\u0435\u043D\u0442\u044F\u0431\u0440\u044F", "\u043E\u043A\u0442\u044F\u0431\u0440\u044F", "\u043D\u043E\u044F\u0431\u0440\u044F", "\u0434\u0435\u043A\u0430\u0431\u0440\u044F"], mmm: ["\u044F\u043D\u0432.", "\u0444\u0435\u0432\u0440.", "\u043C\u0430\u0440.", "\u0430\u043F\u0440.", "\u043C\u0430\u044F", "\u0438\u044E\u043D.", "\u0438\u044E\u043B.", "\u0430\u0432\u0433.", "\u0441\u0435\u043D\u0442.", "\u043E\u043A\u0442.", "\u043D\u043E\u044F\u0431.", "\u0434\u0435\u043A."], dddd: ["\u0432\u043E\u0441\u043A\u0440\u0435\u0441\u0435\u043D\u044C\u0435", "\u043F\u043E\u043D\u0435\u0434\u0435\u043B\u044C\u043D\u0438\u043A", "\u0432\u0442\u043E\u0440\u043D\u0438\u043A", "\u0441\u0440\u0435\u0434\u0430", "\u0447\u0435\u0442\u0432\u0435\u0440\u0433", "\u043F\u044F\u0442\u043D\u0438\u0446\u0430", "\u0441\u0443\u0431\u0431\u043E\u0442\u0430"], ddd: ["\u0432\u0441", "\u043F\u043D", "\u0432\u0442", "\u0441\u0440", "\u0447\u0442", "\u043F\u0442", "\u0441\u0431"] }, "ru"), m({ decimal: ",", mmmm: ["janu\xE1ra", "febru\xE1ra", "marca", "apr\xEDla", "m\xE1ja", "j\xFAna", "j\xFAla", "augusta", "septembra", "okt\xF3bra", "novembra", "decembra"], mmm: ["jan", "feb", "mar", "apr", "m\xE1j", "j\xFAn", "j\xFAl", "aug", "sep", "okt", "nov", "dec"], dddd: ["nede\u013Ea", "pondelok", "utorok", "streda", "\u0161tvrtok", "piatok", "sobota"], ddd: ["ne", "po", "ut", "st", "\u0161t", "pi", "so"] }, "sk"), m({ group: ".", decimal: ",", ampm: ["a.\xA0m.", "p.\xA0m."], mmmm: ["enero", "febrero", "marzo", "abril", "mayo", "junio", "julio", "agosto", "septiembre", "octubre", "noviembre", "diciembre"], mmm: ["ene.", "feb.", "mar.", "abr.", "may.", "jun.", "jul.", "ago.", "sept.", "oct.", "nov.", "dic."], dddd: ["domingo", "lunes", "martes", "mi\xE9rcoles", "jueves", "viernes", "s\xE1bado"], ddd: ["dom.", "lun.", "mar.", "mi\xE9.", "jue.", "vie.", "s\xE1b."] }, "es"), m({ decimal: ",", ampm: ["fm", "em"], mmmm: ["januari", "februari", "mars", "april", "maj", "juni", "juli", "augusti", "september", "oktober", "november", "december"], mmm: ["jan.", "feb.", "mars", "apr.", "maj", "juni", "juli", "aug.", "sep.", "okt.", "nov.", "dec."], dddd: ["s\xF6ndag", "m\xE5ndag", "tisdag", "onsdag", "torsdag", "fredag", "l\xF6rdag"], ddd: ["s\xF6n", "m\xE5n", "tis", "ons", "tors", "fre", "l\xF6r"] }, "sv"), m({ group: ".", decimal: ",", ampm: ["\xD6\xD6", "\xD6S"], mmmm: ["Ocak", "\u015Eubat", "Mart", "Nisan", "May\u0131s", "Haziran", "Temmuz", "A\u011Fustos", "Eyl\xFCl", "Ekim", "Kas\u0131m", "Aral\u0131k"], mmm: ["Oca", "\u015Eub", "Mar", "Nis", "May", "Haz", "Tem", "A\u011Fu", "Eyl", "Eki", "Kas", "Ara"], dddd: ["Pazar", "Pazartesi", "Sal\u0131", "\xC7ar\u015Famba", "Per\u015Fembe", "Cuma", "Cumartesi"], ddd: ["Paz", "Pzt", "Sal", "\xC7ar", "Per", "Cum", "Cmt"] }, "tr");
          function p(e2, t2, n2) {
            const a2 = e2 < 0 ? -1 : 1, r2 = 10 ** (t2 || 2), i2 = 10 ** (n2 || 2);
            let s2, o2, l2 = Math.abs(e2), d2 = 0, m2 = 0, u2 = 0, c2 = 1;
            if ((e2 = l2) % 1 == 0)
              o2 = [e2 * a2, 1];
            else if (e2 < 1e-19)
              o2 = [a2, 1e19];
            else if (e2 > 1e19)
              o2 = [1e19 * a2, 1];
            else {
              do {
                if (l2 = 1 / (l2 - Math.floor(l2)), s2 = c2, c2 = c2 * Math.floor(l2) + d2, d2 = s2, m2 = u2, u2 = Math.floor(e2 * c2 + 0.5), u2 >= r2 || c2 >= i2)
                  return [a2 * m2, d2];
              } while (Math.abs(e2 - u2 / c2) >= 1e-10 && l2 !== Math.floor(l2));
              o2 = [a2 * u2, c2];
            }
            return o2;
          }
          const f = { overflow: "######", dateErrorThrows: false, dateErrorNumber: true, dateSpanLarge: true, leap1900: true, nbsp: true, throws: true, invalid: "######", locale: "", ignoreTimezone: false }, g = Object.assign({}, f);
          function h(e2) {
            if (null === e2 && (e2 = f), e2) {
              for (const t2 in e2)
                if (t2 in f) {
                  const n2 = e2[t2];
                  g[t2] = null == n2 ? f[t2] : n2;
                }
            }
            return { ...g };
          }
          const y = { "#": "", 0: "0", "?": "\xA0" }, _820 = { "@": "text", "-": "minus", "+": "plus" }, b = ["#000", "#FFF", "#F00", "#0F0", "#00F", "#FF0", "#F0F", "#0FF", "#000", "#FFF", "#F00", "#0F0", "#00F", "#FF0", "#F0F", "#0FF", "#800", "#080", "#008", "#880", "#808", "#088", "#CCC", "#888", "#99F", "#936", "#FFC", "#CFF", "#606", "#F88", "#06C", "#CCF", "#008", "#F0F", "#FF0", "#0FF", "#808", "#800", "#088", "#00F", "#0CF", "#CFF", "#CFC", "#FF9", "#9CF", "#F9C", "#C9F", "#FC9", "#36F", "#3CC", "#9C0", "#FC0"], j = ["\xA4", "$", "\xA3", "\xA5", "\u058F", "\u060B", "\u09F3", "\u0E3F", "\u17DB", "\u20A1", "\u20A6", "\u20A9", "\u20AA", "\u20AB", "\u20AC", "\u20AD", "\u20AE", "\u20B1", "\u20B2", "\u20B4", "\u20B8", "\u20B9", "\u20BA", "\u20BC", "\u20BD", "\u20BE", "\u20BF"], v = new RegExp("[" + j.join("") + "]");
          function M(e2, t2, n2) {
            return t2[n2 + "_max"] = e2.length, t2[n2 + "_min"] = e2.replace(/#/g, "").length, t2;
          }
          const k = {};
          function x(e2) {
            if (!(e2 in k)) {
              const t2 = [], n2 = e2.replace(/^[#,]+/, "").replace(/[1-9]\d*/g, (e3) => "?".repeat(e3.length));
              for (let e3 = 0; e3 < n2.length; e3++) {
                const a2 = n2.charAt(e3);
                t2[e3] = a2 in y ? y[a2] : a2;
              }
              k[e2] = t2.join("");
            }
            return k[e2];
          }
          function F(e2, t2) {
            "string" == typeof e2 && (e2 = { type: "string", value: e2 = e2.replace(/ /g, y["?"]) }), t2.push(e2);
          }
          function z(e2) {
            const t2 = [], n2 = { scale: 1, percent: false, text: false, date: 0, date_eval: false, date_system: 1, sec_decimals: 0, general: false, clock: 24, int_pattern: [], frac_pattern: [], man_pattern: [], den_pattern: [], num_pattern: [], tokens: t2 };
            let a2 = e2 + "", r2 = "int", i2 = false, s2 = null;
            const l2 = [];
            let d2, m2, u2 = false;
            for (; a2 && !i2; ) {
              if (d2 = /^General/i.exec(a2))
                n2.general = true, F({ type: "general" }, t2);
              else if ("int" === r2 && (d2 = /^[#?0]+(?:,[#?0]+)*/.exec(a2)) || "den" === r2 && (d2 = /^[#?\d]+/.exec(a2)) || (d2 = /^[#?0]+/.exec(a2)))
                n2[r2 + "_pattern"].push(d2[0]), s2 = { type: r2, num: d2[0] }, F(s2, t2);
              else if ((d2 = /^\//.exec(a2)) && n2[r2 + "_pattern"].length) {
                if (!s2)
                  throw new SyntaxError("Missing a numerator in pattern ".concat(e2));
                n2.fractions = true, n2.num_pattern.push(n2[r2 + "_pattern"].pop()), s2.type = "num", r2 = "den", F({ type: "div" }, t2);
              } else if (d2 = /^,+/.exec(a2)) {
                const e3 = a2.charAt(1) in y;
                m2.slice(-1) in y && (d2[0].length > 1 || !e3) ? n2.scale = 1e-3 ** d2[0].length : n2.dec_fractions || F(d2[0], t2);
              } else {
                if (d2 = /^;/.exec(a2)) {
                  i2 = true;
                  break;
                }
                if (d2 = /^[@+-]/.exec(a2))
                  "@" === d2[0] && (n2.text = true), F({ type: _820[d2[0]] }, t2);
                else if (d2 = /^(?:\[(h+|m+|s+)\])/i.exec(a2)) {
                  const e3 = d2[1].toLowerCase(), a3 = e3[0], r3 = { type: "", size: 0, date: 1, raw: d2[0], pad: e3.length };
                  "h" === a3 ? (r3.size = 16, r3.type = "hour-elap") : "m" === a3 ? (r3.size = 32, r3.type = "min-elap") : (r3.size = 64, r3.type = "sec-elap"), n2.date = n2.date | r3.size, l2.push(r3), F(r3, t2);
                } else if (d2 = /^(?:B2)/i.exec(a2))
                  u2 || (n2.date_system = 6);
                else if (d2 = /^(?:B1)/i.exec(a2))
                  u2 || (n2.date_system = 1);
                else if (d2 = /^(?:([hHmMsSyYbBdDegG])\1*)/.exec(a2)) {
                  const e3 = { type: "", size: 0, date: 1, raw: d2[0] }, a3 = d2[0].toLowerCase(), r3 = a3[0];
                  if ("y" === a3 || "yy" === a3)
                    e3.size = 2, e3.type = "year-short";
                  else if ("y" === r3 || "e" === r3)
                    e3.size = 2, e3.type = "year";
                  else if ("b" === a3 || "bb" === a3)
                    e3.size = 2, e3.type = "b-year-short";
                  else if ("b" === r3)
                    e3.size = 2, e3.type = "b-year";
                  else if ("d" === a3 || "dd" === a3)
                    e3.size = 8, e3.type = "day", e3.pad = /dd/.test(a3);
                  else if ("ddd" === a3)
                    e3.size = 8, e3.type = "weekday-short";
                  else if ("d" === r3)
                    e3.size = 8, e3.type = "weekday";
                  else if ("h" === r3)
                    e3.size = 16, e3.type = "hour", e3.pad = /hh/i.test(a3);
                  else if ("m" === r3) {
                    3 === a3.length ? (e3.size = 4, e3.type = "monthname-short") : 5 === a3.length ? (e3.size = 4, e3.type = "monthname-single") : a3.length >= 4 && (e3.size = 4, e3.type = "monthname");
                    const t3 = l2[l2.length - 1];
                    !e3.type && t3 && !t3.used && 80 & t3.size && (t3.used = true, e3.size = 32, e3.type = "min", e3.pad = /mm/.test(a3)), e3.type || (e3.size = 4, e3.type = "month", e3.pad = /mm/.test(a3), e3.indeterminate = true);
                  } else if ("s" === r3) {
                    e3.size = 64, e3.type = "sec", e3.pad = /ss/.test(a3);
                    const t3 = l2[l2.length - 1];
                    t3 && 32 & t3.size ? e3.used = true : t3 && t3.indeterminate && (delete t3.indeterminate, t3.size = 32, t3.type = "min", e3.used = true);
                  }
                  n2.date = n2.date | e3.size, n2.date_eval = true, l2.push(e3), F(e3, t2);
                } else if (d2 = /^(?:AM\/PM|am\/pm|A\/P)/.exec(a2))
                  n2.clock = 12, n2.date = 16 | n2.date, n2.date_eval = true, F({ type: "am", short: "A/P" === d2[0] }, t2);
                else if (n2.date && (d2 = /^\.0{1,3}/i.exec(a2))) {
                  const e3 = d2[0].length - 1, a3 = [64, 128, 256, 512][e3];
                  n2.date = n2.date | a3, n2.date_eval = true, n2.sec_decimals = Math.max(n2.sec_decimals, e3), F({ type: "subsec", size: a3, decimals: e3, date: 1, raw: d2[0] }, t2);
                } else if ((d2 = /^\\(.)/.exec(a2)) || (d2 = /^"([^"]*?)"/.exec(a2)))
                  F(d2[1], t2);
                else if (d2 = /^\[(<[=>]?|>=?|=)\s*(-?[.\d]+)\]/.exec(a2))
                  n2.condition = [d2[1], parseFloat(d2[2], 10)];
                else if (d2 = /^\[\$([^\]]+)\]/.exec(a2)) {
                  const e3 = d2[1].split("-"), a3 = e3.length < 2 ? "" : e3[e3.length - 1], r3 = e3[0];
                  r3 && F(r3, t2);
                  const i3 = o(a3);
                  i3 && (n2.locale = i3);
                  const s3 = parseInt(a3, 16);
                  if (isFinite(s3) && 16711680 & s3) {
                    6 === (s3 >> 16 & 255) && (n2.date_system = 6);
                  }
                  u2 = true;
                } else if (d2 = /^\[(black|blue|cyan|green|magenta|red|white|yellow|color\s*(\d+))\]/i.exec(a2))
                  n2.color = d2[2] ? b[parseInt(d2[2], 10)] || "#000" : d2[1].toLowerCase();
                else if (d2 = /^\[(DBNum1|ENG|HIJ|JPN|TWN)\]/i.exec(a2))
                  ;
                else if (d2 = /^%/.exec(a2))
                  n2.scale = 100, n2.percent = true, F("%", t2);
                else if (d2 = /^_(\\.|.)/.exec(a2))
                  F(" ", t2);
                else if (d2 = /^\./.exec(a2))
                  F({ type: "point", value: d2[0] }, t2), n2.dec_fractions = true, r2 = "frac";
                else if (d2 = /^[Ee]([+-]?|(?=[0#?]))/.exec(a2))
                  n2.exponential = true, n2.exp_plus = "+" === d2[1], r2 = "man", F({ type: "exp", plus: "+" === d2[1] }, t2);
                else if (d2 = /^\*(\\.|.)/.exec(a2))
                  ;
                else {
                  if (d2 = /^[BENn[]/.exec(a2))
                    throw new SyntaxError("Unexpected char ".concat(a2.charAt(0), " in pattern ").concat(e2));
                  "(" === a2[0] && (n2.parens = true), d2 = [a2[0]], F(d2[0], t2);
                }
              }
              m2 = d2[0], a2 = a2.slice(d2 ? d2[0].length : 1);
            }
            if (n2.pattern = e2.slice(0, e2.length - a2.length), /^((?:\[[^\]]+\])+)(;|$)/.test(n2.pattern) && !/^\[(?:h+|m+|s+)\]/.test(n2.pattern) && F({ type: "text" }, t2), n2.fractions && n2.dec_fractions || n2.fractions && n2.exponential)
              throw new SyntaxError("Invalid pattern: ".concat(n2.pattern));
            const c2 = n2.int_pattern.join("");
            if (n2.grouping = c2.indexOf(",") >= 0, n2.grouping) {
              const e3 = c2.split(","), t3 = e3.length;
              2 === t3 ? (n2.group_pri = e3[1].length, n2.group_sec = n2.group_pri) : t3 > 2 && (n2.group_pri = e3[t3 - 1].length, n2.group_sec = e3[t3 - 2].length);
            } else
              n2.group_pri = 0, n2.group_sec = 0;
            M(c2.replace(/[,]/g, ""), n2, "int"), M(n2.frac_pattern.join(""), n2, "frac"), M(n2.man_pattern.join(""), n2, "man");
            let p2 = n2.num_pattern.join(""), f2 = n2.den_pattern.join("");
            const g2 = /\?/.test(f2) || /\?/.test(p2);
            return f2 = f2.replace(/\d/g, g2 ? "?" : "#"), g2 && (f2 = f2.replace(/#$/g, "?")), M(p2, n2, "num"), M(f2, n2, "den"), g2 && (p2 = p2.replace(/#$/g, "?")), n2.int_padding = x(n2.int_pattern.join("")), n2.man_padding = x(n2.man_pattern.join("")), n2.num_padding = x(p2), n2.den_padding = x(f2), n2.den_pattern.length && (n2.denominator = parseInt(n2.den_pattern.join("").replace(/\D/g, ""), 10)), n2.integer = !!n2.int_pattern.join("").length, n2.fractions && t2.forEach((e3, n3) => {
              const a3 = t2[n3 + 1];
              "string" === e3.type && a3 && ("num" === a3.type ? e3.rule = "num+int" : "div" === a3.type ? e3.rule = "num" : "den" === a3.type && (e3.rule = "den"));
            }), n2;
          }
          const w = (e2) => {
            const t2 = e2.condition;
            t2 && t2[1] < 0 && ("<" === t2[0] || "<=" === t2[0] || "=" === t2[0]) || e2.tokens.unshift({ type: "minus", volatile: true });
          };
          function D(e2) {
            const t2 = [];
            let n2, a2 = false, r2 = null, i2 = e2, s2 = 0, l2 = false, d2 = 0, m2 = 0;
            do {
              if (l2 = z(i2), (l2.date || l2.general) && (l2.int_pattern.length || l2.frac_pattern.length || 1 !== l2.scale || l2.text))
                throw new Error("Illegal format");
              if (l2.condition && (m2++, a2 = true), l2.text) {
                if (r2)
                  throw new Error("Unexpected partition");
                r2 = l2;
              }
              l2.locale && (n2 = o(l2.locale)), t2.push(l2), s2 = ";" === i2.charAt(l2.pattern.length) ? 1 : 0, i2 = i2.slice(l2.pattern.length + s2), d2++;
            } while (s2 && d2 < 4 && m2 < 3);
            if (s2)
              throw new Error("Unexpected partition");
            if (m2 > 2)
              throw new Error("Unexpected condition");
            const u2 = t2[3];
            if (u2 && (u2.int_pattern.length || u2.frac_pattern.length || u2.date))
              throw new Error("Unexpected partition");
            if (a2) {
              const e3 = t2.length;
              if (1 === e3 && (t2[1] = z("General"), t2[1].generated = true), e3 < 3) {
                const e4 = t2[0], n3 = t2[1];
                if (w(e4), n3.condition)
                  w(n3);
                else {
                  const t3 = e4.condition;
                  ("=" === t3[0] || t3[1] >= 0 && (">" === t3[0] || ">=" === t3[0])) && n3.tokens.unshift({ type: "minus", volatile: true });
                }
              } else
                t2.forEach(w);
            } else {
              if (t2.length < 4 && r2)
                for (let e3 = 0, n3 = t2.length; e3 < n3; e3++)
                  t2[e3] === r2 && t2.splice(e3, 1);
              if (t2.length < 1 && r2 && (t2[0] = z("General"), t2[0].generated = true), t2.length < 2) {
                const e3 = z(t2[0].pattern);
                e3.tokens.unshift({ type: "minus", volatile: true }), e3.generated = true, t2.push(e3);
              }
              if (t2.length < 3) {
                const e3 = z(t2[0].pattern);
                e3.generated = true, t2.push(e3);
              }
              if (t2.length < 4)
                if (r2)
                  t2.push(r2);
                else {
                  const e3 = z("@");
                  e3.generated = true, t2.push(e3);
                }
              t2[0].condition = [">", 0], t2[1].condition = ["<", 0], t2[2].condition = null;
            }
            return { pattern: e2, partitions: t2, locale: n2 };
          }
          const S2 = Math.floor;
          function C(e2) {
            let t2 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
            if (t2 && e2 >= 0) {
              if (0 === e2)
                return [1900, 1, 0];
              if (60 === e2)
                return [1900, 2, 29];
              if (e2 < 60)
                return [1900, e2 < 32 ? 1 : 2, (e2 - 1) % 31 + 1];
            }
            let n2 = e2 + 68569 + 2415019;
            const a2 = S2(4 * n2 / 146097);
            n2 -= S2((146097 * a2 + 3) / 4);
            const r2 = S2(4e3 * (n2 + 1) / 1461001);
            n2 = n2 - S2(1461 * r2 / 4) + 31;
            const i2 = S2(80 * n2 / 2447), s2 = n2 - S2(2447 * i2 / 80);
            n2 = S2(i2 / 11);
            const o2 = i2 + 2 - 12 * n2, l2 = 100 * (a2 - 49) + r2 + n2;
            return [0 | l2, 0 | o2, 0 | s2];
          }
          function E(e2) {
            return C(e2 + 1462);
          }
          function A(e2) {
            if (60 === e2)
              throw new Error("#VALUE!");
            if (e2 <= 1)
              return [1317, 8, 29];
            if (e2 < 60)
              return [1317, e2 < 32 ? 9 : 10, 1 + (e2 - 2) % 30];
            const t2 = 10631 / 30, n2 = 0.1335;
            let a2 = e2 + 466935;
            const r2 = S2(a2 / 10631);
            a2 -= 10631 * r2;
            const i2 = S2((a2 - n2) / t2);
            a2 -= S2(i2 * t2 + n2);
            const s2 = S2((a2 + 28.5001) / 29.5);
            return 13 === s2 ? [30 * r2 + i2, 12, 30] : [30 * r2 + i2, s2, a2 - S2(29.5001 * s2 - 29)];
          }
          function Y(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
            const a2 = S2(e2);
            return 6 === t2 ? A(a2) : -1 === t2 ? E(a2) : C(a2, n2);
          }
          const T = Math.floor, N2 = 86400;
          function P2(e2, t2) {
            let n2 = null;
            if (Array.isArray(e2)) {
              const [t3, a2, r2, i2, s2, o2] = e2;
              n2 = Date.UTC(t3, null == a2 ? 0 : a2 - 1, null != r2 ? r2 : 1, i2 || 0, s2 || 0, o2 || 0);
            } else if (e2 instanceof Date && (n2 = 1 * e2, !t2 || !t2.ignoreTimezone)) {
              const t3 = /* @__PURE__ */ new Date();
              t3.setUTCFullYear(e2.getFullYear(), e2.getMonth(), e2.getDate()), t3.setUTCHours(e2.getHours(), e2.getMinutes(), e2.getSeconds(), e2.getMilliseconds()), n2 = 1 * t3;
            }
            if (null != n2 && isFinite(n2)) {
              const e3 = n2 / 864e5;
              return e3 - (e3 <= -25509 ? -25568 : -25569);
            }
            return e2;
          }
          function I2(e2, t2) {
            let n2 = 0 | e2;
            const a2 = N2 * (e2 - n2);
            let r2 = T(a2);
            a2 - r2 > 0.9999 && (r2 += 1, r2 === N2 && (r2 = 0, n2 += 1));
            const i2 = r2 < 0 ? N2 + r2 : r2, [s2, o2, l2] = Y(e2, 0, t2 && t2.leap1900), d2 = T(i2 / 60 / 60) % 60, m2 = T(i2 / 60) % 60, u2 = T(i2) % 60;
            if (t2 && t2.nativeDate) {
              const e3 = /* @__PURE__ */ new Date(0);
              return e3.setUTCFullYear(s2, o2 - 1, l2), e3.setUTCHours(d2, m2, u2), e3;
            }
            return [s2, o2, l2, d2, m2, u2];
          }
          function O(e2) {
            return !!(e2[0] && e2[0].percent || e2[1] && e2[1].percent || e2[2] && e2[2].percent || e2[3] && e2[3].percent);
          }
          function J(e2) {
            return !!(e2[0] && e2[0].date || e2[1] && e2[1].date || e2[2] && e2[2].date || e2[3] && e2[3].date);
          }
          function L(e2) {
            const [t2, n2, a2, r2] = e2;
            return !(t2 && !t2.generated || n2 && !n2.generated || a2 && !a2.generated || !r2 || !r2.text || r2.generated);
          }
          const U = { text: 15, datetime: 10.8, date: 10.8, time: 10.8, percent: 10.6, currency: 10.4, grouped: 10.2, scientific: 6, number: 4, fraction: 2, general: 0, error: 0 }, R = [["DMY", 1], ["DM", 2], ["MY", 3], ["MDY", 4], ["MD", 5], ["hmsa", 6], ["hma", 7], ["hms", 8], ["hm", 9]];
          const G = { total: 1, sign: 0, period: 0, int: 1, frac: 0 };
          const H = (e2, t2) => e2.replace(/\./, t2.decimal);
          function B(e2, t2, n2, a2) {
            const r2 = 0 | n2;
            if ("string" == typeof n2)
              e2.push(n2);
            else if (n2 === r2)
              e2.push(Math.abs(r2));
            else {
              const t3 = Math.abs(n2);
              let r3 = t3 ? Math.floor(Math.log10(t3)) : 0, i2 = r3 < 0 ? t3 * 10 ** -r3 : t3 / 10 ** r3;
              10 === i2 && (i2 = 1, r3++);
              const s2 = function(e3) {
                let t4 = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                const n3 = Math.abs(e3);
                if (!n3)
                  return G;
                const a3 = t4 && e3 < 0 ? 1 : 0, r4 = Math.floor(n3), i3 = Math.floor(Math.log10(n3) + 1);
                let s3 = 0, o3 = 0;
                if (r4 !== n3) {
                  s3 = 1;
                  const e4 = String(c(i3 < 0 ? n3 * 10 ** -i3 : n3 / 10 ** i3, 15));
                  let t5 = e4.length, a4 = true, r5 = 0;
                  for (; r5 <= e4.length; ) {
                    if ("." === e4[r5]) {
                      t5--;
                      break;
                    }
                    "0" === e4[r5] && a4 ? t5-- : a4 = false, r5++;
                  }
                  o3 = t5 - i3, o3 < 0 && (o3 = 0, s3 = 0);
                }
                return { total: a3 + Math.max(i3, 1) + s3 + o3, digits: Math.max(i3, 0) + o3, sign: a3, period: s3, int: Math.max(i3, 1), frac: o3 };
              }(t3), o2 = () => {
                const t4 = Math.abs(r3);
                let n3;
                n3 = 1 === i2 ? i2 : c(i2, 5), e2.push(H(n3 + "", a2), a2.exponent, r3 < 0 ? a2.negative : a2.positive, t4 < 10 ? "0" : "", t4);
              };
              if (r3 >= -4 && r3 <= -1) {
                const n3 = t3.toPrecision(10 + r3).replace(/\.?0+$/, "");
                e2.push(H(n3, a2));
              } else if (10 === r3) {
                const n3 = t3.toFixed(10).slice(0, 12).replace(/\.$/, "");
                e2.push(H(n3, a2));
              } else if (Math.abs(r3) <= 9)
                if (s2.total <= 11) {
                  const n3 = c(t3, 9).toFixed(s2.frac);
                  e2.push(H(n3, a2));
                } else
                  9 === r3 ? e2.push(Math.floor(t3)) : r3 >= 0 && r3 < 9 ? e2.push(c(t3, 9 - r3)) : o2();
              else
                s2.total >= 12 ? o2() : Math.floor(t3) === t3 ? e2.push(Math.floor(t3)) : e2.push(H(c(t3, 9).toFixed(s2.frac), a2));
            }
            return e2;
          }
          const $ = 86400, W = { int: "integer", frac: "fraction", man: "mantissa", num: "numerator", den: "denominator" }, Z = function(e2) {
            let t2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
            const n2 = Math.floor(Math.log10(e2));
            return t2 > 1 ? Math.floor(n2 / t2) * t2 : n2;
          };
          function K(e2, t2, n2, a2) {
            let r2 = "", i2 = "", s2 = "", o2 = "", l2 = "", d2 = 0, m2 = 0 | e2, f2 = 0, g2 = 0, h2 = 1, _821 = 0, b2 = 0, j2 = 0, v2 = 0, M2 = 0, k2 = 0;
            const x2 = a2 || u;
            if (!t2.text && isFinite(t2.scale) && 1 !== t2.scale && (e2 = function(e3) {
              if (0 === e3)
                return e3;
              const t3 = Math.ceil(Math.log10(e3 < 0 ? -e3 : e3)), n3 = 10 ** (16 - Math.floor(t3));
              return Math.round(e3 * n3) / n3;
            }(e2 * t2.scale)), t2.exponential) {
              let n3 = Math.abs(e2);
              if (n3) {
                const e3 = 10 ** -Z(n3, t2.int_max), a3 = c(n3 * e3, t2.frac_max) / e3;
                d2 = Z(a3, t2.int_max);
              }
              n3 /= 10 ** d2, e2 = e2 < 0 ? -n3 : n3, r2 += Math.abs(d2);
            }
            if (t2.integer) {
              const n3 = Math.abs(c(e2, t2.fractions ? 1 : t2.frac_max));
              l2 += n3 < 1 ? "" : Math.floor(n3);
            }
            if (t2.grouping) {
              let e3 = "", n3 = l2.length;
              for (n3 > t2.group_pri && (n3 -= t2.group_pri, e3 = x2.group + l2.slice(n3, n3 + t2.group_pri) + e3); n3 > t2.group_sec; )
                n3 -= t2.group_sec, e3 = x2.group + l2.slice(n3, n3 + t2.group_sec) + e3;
              l2 = n3 ? l2.slice(0, n3) + e3 : e3;
            }
            t2.dec_fractions && (o2 = String(c(e2, t2.frac_max)).split(".")[1] || "");
            let F2 = false;
            if (t2.fractions) {
              const n3 = Math.abs(t2.integer ? e2 % 1 : e2);
              if (n3)
                if (F2 = true, isFinite(t2.denominator))
                  s2 += t2.denominator, i2 += c(n3 * t2.denominator), "0" === i2 && (i2 = "", s2 = "", F2 = false, l2 || (l2 = "0"));
                else {
                  const e3 = p(n3, t2.integer ? t2.num_max : 1 / 0, t2.den_max);
                  i2 += e3[0], s2 += e3[1], t2.integer && "0" === i2 && (l2 || (l2 = "0"), i2 = "", s2 = "", F2 = false);
                }
            }
            if (t2.date) {
              m2 = Math.trunc(e2);
              const a3 = $ * (e2 - m2);
              if (f2 = Math.floor(a3), k2 = a3 - f2, Math.abs(k2) < 1e-6 ? k2 = 0 : k2 > 0.9999 && (k2 = 0, f2 += 1, f2 === $ && (f2 = 0, m2 += 1)), k2) {
                const e3 = 512 & t2.date || 256 & t2.date || 128 & t2.date;
                (512 === e3 && k2 > 0.9995 || 256 === e3 && k2 > 0.995 || 128 === e3 && k2 > 0.95 || !e3 && k2 >= 0.5) && (f2++, k2 = 0);
              }
              if (m2 || t2.date_system) {
                const a4 = Y(e2, t2.date_system, n2.leap1900);
                g2 = a4[0], h2 = a4[1], _821 = a4[2];
              }
              if (f2) {
                const e3 = f2 < 0 ? $ + f2 : f2;
                M2 = Math.floor(e3) % 60, v2 = Math.floor(e3 / 60) % 60, j2 = Math.floor(e3 / 60 / 60) % 60;
              }
              if (b2 = (6 + m2) % 7, t2.date_eval && (z2 = e2, w2 = m2 + f2 / $, n2.dateSpanLarge ? z2 < -694324 || w2 >= 35830291 : z2 < 0 || w2 >= 2958466)) {
                if (n2.dateErrorThrows)
                  throw new Error("Date out of bounds");
                if (n2.dateErrorNumber) {
                  return B(e2 < 0 ? [x2.negative] : [], 0, e2, x2).join("");
                }
                return n2.overflow;
              }
            }
            var z2, w2;
            if (t2.int_padding && (l2 = 1 === t2.int_padding.length ? l2 || t2.int_padding : t2.int_padding.substring(0, t2.int_padding.length - l2.length) + l2), t2.num_padding && (i2 = 1 === t2.num_padding.length ? i2 || t2.num_padding : t2.num_padding.substring(0, t2.num_padding.length - i2.length) + i2), t2.den_padding && (s2 = 1 === t2.den_padding.length ? s2 || t2.den_padding : s2 + t2.den_padding.slice(s2.length)), t2.man_padding) {
              const e3 = t2.exp_plus ? "+" : "";
              r2 = 1 === t2.man_padding.length ? (d2 < 0 ? "-" : e3) + (r2 || t2.man_padding) : (d2 < 0 ? "-" : e3) + t2.man_padding.slice(0, t2.man_padding.length - r2.length) + r2;
            }
            const D2 = [];
            let S3 = 0;
            const C2 = { int: 0, frac: 0, man: 0, num: 0, den: 0 };
            for (let d3 = 0, u2 = t2.tokens.length; d3 < u2; d3++) {
              const u3 = t2.tokens[d3], c2 = u3.num ? u3.num.length : 0;
              if ("string" === u3.type)
                u3.rule ? "num" === u3.rule ? F2 ? D2.push(u3.value) : (t2.num_min > 0 || t2.den_min > 0) && D2.push(u3.value.replace(/./g, y["?"])) : "num+int" === u3.rule ? F2 && l2 ? D2.push(u3.value) : t2.den_min > 0 && (l2 || t2.num_min) && D2.push(u3.value.replace(/./g, y["?"])) : "den" === u3.rule && (F2 ? D2.push(u3.value) : (t2.den_min > 0 || t2.den_min > 0) && D2.push(u3.value.replace(/./g, y["?"]))) : D2.push(u3.value);
              else if ("error" === u3.type)
                D2.push(n2.invalid);
              else if ("point" === u3.type)
                D2.push(t2.date ? u3.value : x2.decimal);
              else if ("general" === u3.type)
                B(D2, 0, e2, x2);
              else if ("exp" === u3.type)
                D2.push(x2.exponent);
              else if ("minus" === u3.type)
                u3.volatile && t2.date || u3.volatile && (e2 >= 0 || "number" != typeof e2) || (u3.volatile && !t2.fractions && (t2.integer || t2.dec_fractions) ? (e2 < 0 && l2 && "0" !== l2 || o2) && D2.push(x2.negative) : D2.push(x2.negative));
              else if ("plus" === u3.type)
                D2.push(x2.positive);
              else if ("text" === u3.type)
                D2.push(e2);
              else if ("div" === u3.type)
                F2 ? D2.push("/") : t2.num_min > 0 || t2.den_min > 0 ? D2.push(y["?"]) : D2.push(y["#"]);
              else if ("int" === u3.type)
                if (1 === t2.int_pattern.length)
                  D2.push(l2);
                else {
                  const e3 = S3 ? t2.int_pattern.join("").length - C2.int : 1 / 0, n3 = S3 === t2.int_pattern.length - 1 ? 0 : t2.int_pattern.join("").length - (C2.int + u3.num.length);
                  D2.push(l2.substring(l2.length - e3, l2.length - n3)), S3++, C2.int += u3.num.length;
                }
              else if ("frac" === u3.type) {
                const e3 = C2.frac;
                for (let t3 = 0; t3 < c2; t3++)
                  D2.push(o2[t3 + e3] || y[u3.num[t3]]);
                C2.frac += c2;
              } else if (u3.type in W)
                1 === t2[u3.type + "_pattern"].length ? ("int" === u3.type && D2.push(l2), "frac" === u3.type && D2.push(o2), "man" === u3.type && D2.push(r2), "num" === u3.type && D2.push(i2), "den" === u3.type && D2.push(s2)) : (D2.push(W[u3.type].slice(C2[u3.type], C2[u3.type] + c2)), C2[u3.type] += c2);
              else if ("year" === u3.type)
                g2 < 0 && D2.push(x2.negative), D2.push(String(Math.abs(g2)).padStart(4, "0"));
              else if ("year-short" === u3.type) {
                const e3 = g2 % 100;
                D2.push(e3 < 10 ? "0" : "", e3);
              } else if ("month" === u3.type)
                D2.push(u3.pad && h2 < 10 ? "0" : "", h2);
              else if ("monthname-single" === u3.type)
                6 === t2.date_system ? D2.push(x2.mmmm6[h2 - 1].charAt(0)) : D2.push(x2.mmmm[h2 - 1].charAt(0));
              else if ("monthname-short" === u3.type)
                6 === t2.date_system ? D2.push(x2.mmm6[h2 - 1]) : D2.push(x2.mmm[h2 - 1]);
              else if ("monthname" === u3.type)
                6 === t2.date_system ? D2.push(x2.mmmm6[h2 - 1]) : D2.push(x2.mmmm[h2 - 1]);
              else if ("weekday-short" === u3.type)
                D2.push(x2.ddd[b2]);
              else if ("weekday" === u3.type)
                D2.push(x2.dddd[b2]);
              else if ("day" === u3.type)
                D2.push(u3.pad && _821 < 10 ? "0" : "", _821);
              else if ("hour" === u3.type) {
                const e3 = j2 % t2.clock || (t2.clock < 24 ? t2.clock : 0);
                D2.push(u3.pad && e3 < 10 ? "0" : "", e3);
              } else if ("min" === u3.type)
                D2.push(u3.pad && v2 < 10 ? "0" : "", v2);
              else if ("sec" === u3.type)
                D2.push(u3.pad && M2 < 10 ? "0" : "", M2);
              else if ("subsec" === u3.type) {
                D2.push(x2.decimal);
                const e3 = k2.toFixed(t2.sec_decimals);
                D2.push(e3.slice(2, 2 + u3.decimals));
              } else if ("am" === u3.type) {
                const e3 = j2 < 12 ? 0 : 1;
                u3.short && !a2 ? D2.push("AP"[e3]) : D2.push(x2.ampm[e3]);
              } else if ("hour-elap" === u3.type) {
                e2 < 0 && D2.push(x2.negative);
                const t3 = 24 * m2 + Math.floor(Math.abs(f2) / 3600);
                D2.push(String(Math.abs(t3)).padStart(u3.pad, "0"));
              } else if ("min-elap" === u3.type) {
                e2 < 0 && D2.push(x2.negative);
                const t3 = 1440 * m2 + Math.floor(Math.abs(f2) / 60);
                D2.push(String(Math.abs(t3)).padStart(u3.pad, "0"));
              } else if ("sec-elap" === u3.type) {
                e2 < 0 && D2.push(x2.negative);
                const t3 = m2 * $ + Math.abs(f2);
                D2.push(String(Math.abs(t3)).padStart(u3.pad, "0"));
              } else if ("b-year" === u3.type)
                D2.push(g2 + 543);
              else if ("b-year-short" === u3.type) {
                const e3 = (g2 + 543) % 100;
                D2.push(e3 < 10 ? "0" : "", e3);
              }
            }
            return n2.nbsp ? D2.join("") : D2.join("").replace(/\u00a0/g, " ");
          }
          function q(e2, t2) {
            for (let n2 = 0; n2 < 3; n2++) {
              const a2 = t2[n2];
              if (a2) {
                let t3;
                if (a2.condition) {
                  const n3 = a2.condition[0], r2 = a2.condition[1];
                  "=" === n3 ? t3 = e2 === r2 : ">" === n3 ? t3 = e2 > r2 : "<" === n3 ? t3 = e2 < r2 : ">=" === n3 ? t3 = e2 >= r2 : "<=" === n3 ? t3 = e2 <= r2 : "<>" === n3 && (t3 = e2 !== r2);
                } else
                  t3 = true;
                if (t3)
                  return a2;
              }
            }
          }
          const V = z("@"), Q = "black";
          const X = {};
          function ee(e2, t2) {
            if (e2) {
              const n2 = e2[0];
              t2[n2] = t2[n2] || {}, ee(e2.slice(1), t2[n2]);
            } else
              t2.$ = true;
          }
          ["d-F-y", "d-F-Y", "d-M-y", "d-M-Y", "F-d-y", "F-d-Y", "F-j-y", "F-j-Y", "j-F-y", "j-F-Y", "j-M-y", "j-M-Y", "M-d-y", "M-d-Y", "M-j-y", "M-j-Y", "m-d-y", "m-d-Y", "m-j-y", "m-j-Y", "n-d-y", "n-d-Y", "n-j-y", "n-j-Y", "y-F-d", "y-F-j", "y-M-d", "y-M-j", "Y-F-d", "Y-F-j", "Y-M-d", "Y-m-d", "Y-M-j", "Y-m-j", "Y-n-d", "Y-n-j", "j-F", "j-M", "d-F", "d-M", "n-d", "n-j", "n-Y", "m-d", "m-j", "m-Y", "M-Y", "M-y", "F-y", "F-Y", "Y-M", "Y-n", "Y-m", "Y-F", "Y-M"].forEach((e2) => {
            ee(e2, X), ee(e2 + " x", X), ee(e2 + " l", X), ee(e2 + " l x", X), ee("l " + e2, X), ee("l " + e2 + " x", X), ee(e2 + " D", X), ee(e2 + " D x", X), ee("D " + e2, X), ee("D " + e2 + " x", X);
          });
          const te = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12 }, ne = { january: 1, february: 2, march: 3, april: 4, june: 6, july: 7, august: 8, september: 9, october: 10, november: 11, december: 12 }, ae = { sunday: "l", monday: "l", tuesday: "l", wednesday: "l", thursday: "l", friday: "l", saturday: "l", sun: "D", mon: "D", tue: "D", wed: "D", thu: "D", fri: "D", sat: "D" }, re = (/* @__PURE__ */ new Date()).getUTCFullYear();
          function ie(e2) {
            const t2 = new RegExp("^([\\s+%" + j.join("") + "(-]*)(((?:(?:\\d[\\d,]*)(?:\\.\\d*)?|(?:\\.\\d+)))([eE][+-]?\\d+)?)([\\s%" + j.join("") + ")]*)$").exec(e2);
            if (t2) {
              const [, e3, n2, a2, r2, i2] = t2;
              let s2 = 1, o2 = "", l2 = false, d2 = false, m2 = false, u2 = false, c2 = false, p2 = null, f2 = false, g2 = parseFloat(n2.replace(/,/g, ""));
              if (!isFinite(g2))
                return null;
              for (let t3 = 0; t3 < e3.length; t3++) {
                const n3 = e3[t3];
                if ("-" === n3) {
                  if (l2 || d2)
                    return null;
                  l2 = true, s2 = -1;
                } else if (v.test(n3)) {
                  if (c2)
                    return null;
                  c2 = true, p2 = n3;
                } else if ("(" === n3) {
                  if (d2 || l2)
                    return null;
                  d2 = true, s2 = -1;
                } else if ("%" === n3) {
                  if (u2)
                    return null;
                  u2 = true;
                }
              }
              for (let e4 = 0; e4 < i2.length; e4++) {
                const t3 = i2[e4];
                if (v.test(t3)) {
                  if (c2)
                    return null;
                  c2 = true, p2 = t3, f2 = true;
                } else if (")" === t3) {
                  if (m2 || !d2)
                    return null;
                  m2 = true;
                } else if ("%" === t3) {
                  if (u2)
                    return null;
                  u2 = true;
                }
              }
              if (r2) {
                if (u2 || c2)
                  return null;
                o2 = "0.00E+00";
              } else if (u2) {
                if (c2)
                  return null;
                o2 = a2.includes(".") ? "0.00%" : "0%", g2 *= 0.01;
              } else if (c2) {
                const e4 = a2.includes(".") ? "#,##0.00" : "#,##0";
                o2 = f2 ? e4 + p2 : p2 + e4;
              } else
                a2.includes(",") && (o2 = a2.includes(".") ? "#,##0.00" : "#,##0");
              const h2 = { v: g2 * s2 };
              return o2 && (h2.z = o2), h2;
            }
          }
          const se = (e2, t2, n2) => {
            const a2 = n2.path || "", r2 = Object.keys(t2);
            for (let i2 = 0; i2 < r2.length; i2++) {
              let s2;
              const o2 = r2[i2];
              if (t2[o2]) {
                if ("$" === o2 || "\u20AC" === o2)
                  e2 || (s2 = n2);
                else if ("-" === o2) {
                  const r3 = /^(\s*([./-]|,\s)\s*|\s+)/.exec(e2);
                  if (r3) {
                    const i3 = "-" === r3[1] || "/" === r3[1] || "." === r3[1] ? r3[1] : " ";
                    if (!n2.sep || n2.sep === i3) {
                      const l2 = r3[0].replace(/\s+/g, " ");
                      s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, sep: i3, path: a2 + l2 });
                    }
                  }
                } else if (" " === o2) {
                  const r3 = /^[,.]?\s+/.exec(e2);
                  if (r3) {
                    const i3 = r3[0].replace(/\s+/g, " ");
                    s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, path: a2 + i3 });
                  }
                } else if ("j" === o2 || "d" === o2) {
                  const r3 = /^(0?[1-9]|1\d|2\d|3[01])\b/.exec(e2);
                  r3 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, day: r3[0], path: a2 + o2 }));
                } else if ("n" === o2 || "m" === o2) {
                  const r3 = /^(0?[1-9]|1[012])\b/.exec(e2);
                  r3 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, month: +r3[0], _mon: r3[0], path: a2 + o2 }));
                } else if ("F" === o2 || "M" === o2) {
                  const r3 = /^([a-z]{3,9})\b/i.exec(e2), i3 = r3 && ("F" === o2 ? ne : te)[r3[0].toLowerCase()];
                  i3 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, month: i3, _mon: r3[0], path: a2 + o2 }));
                } else if ("l" === o2 || "D" === o2) {
                  const r3 = /^([a-z]{3,9})\b/i.exec(e2);
                  (r3 && ae[r3[0].toLowerCase()]) === o2 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, path: a2 + o2 }));
                } else if ("y" === o2) {
                  const r3 = /^\d\d\b/.exec(e2);
                  if (r3) {
                    const i3 = +r3[0] >= 30 ? +r3[0] + 1900 : +r3[0] + 2e3;
                    s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, year: i3, path: a2 + o2 });
                  }
                } else if ("Y" === o2) {
                  const r3 = /^\d\d\d\d\b/.exec(e2);
                  r3 && (s2 = se(e2.slice(r3[0].length), t2[o2], { ...n2, year: +r3[0], path: a2 + o2 }));
                } else {
                  if ("x" !== o2)
                    throw new Error('Unknown date token "'.concat(o2, '"'));
                  {
                    const r3 = le(e2);
                    r3 && (s2 = se("", t2[o2], { ...n2, time: r3.v, tf: r3.z, path: a2 + o2 }));
                  }
                }
                if (s2)
                  return s2;
              }
            }
          };
          function oe(e2, t2) {
            const n2 = se(e2.trim(), X, { path: "" });
            if (n2) {
              var a2;
              if ("." === n2.sep && 3 === n2.path.length)
                return null;
              const e3 = +(null !== (a2 = n2.year) && void 0 !== a2 ? a2 : re);
              if (n2.day || (n2.day = 1), !function(e4, t3, n3) {
                if (n3 < 1)
                  return false;
                if (t3 < 1 || t3 > 12)
                  return false;
                if (2 === t3) {
                  if (n3 > (e4 % 4 == 0 && e4 % 100 != 0 || e4 % 400 == 0 || 1900 === e4 ? 29 : 28))
                    return false;
                } else if ((4 === t3 || 6 === t3 || 9 === t3 || 11 === t3) && n3 > 30 || (1 === t3 || 3 === t3 || 5 === t3 || 7 === t3 || 8 === t3 || 10 === t3 || 12 === t3) && n3 > 31)
                  return false;
                return true;
              }(e3, n2.month, n2.day))
                return null;
              let r2 = -1 / 0;
              if (e3 < 1900)
                return null;
              e3 <= 1900 && n2.month <= 2 ? r2 = 25568 : e3 < 1e4 && (r2 = 25569);
              const i2 = Date.UTC(e3, n2.month - 1, n2.day) / 864e5 + r2 + (n2.time || 0);
              if (i2 >= 0 && i2 <= 2958465) {
                const e4 = "0" === n2._mon[0] || "0" === n2.day[0] || 2 === n2._mon.length && 2 === n2.day.length, a3 = n2.path.replace(/[jdlDnmMFyYx-]/g, (t3) => "j" === t3 || "d" === t3 ? e4 ? "dd" : "d" : "D" === t3 ? "ddd" : "l" === t3 ? "dddd" : "n" === t3 || "m" === t3 ? e4 ? "mm" : "m" : "M" === t3 ? "mmm" : "F" === t3 ? "mmmm" : "y" === t3 ? "yy" : "x" === t3 ? n2.tf || "" : "Y" === t3 ? "yyyy" : t3);
                return t2 && t2.nativeDate ? { v: I2(i2, t2), z: a3 } : { v: i2, z: a3 };
              }
            }
            return null;
          }
          function le(e2) {
            const t2 = /^\s*([10]?\d|2[0-4])(?::([0-5]\d|\d))?(?::([0-5]\d|\d))?(\.\d{1,10})?(?:\s*([AP])M?)?\s*$/i.exec(e2);
            if (t2) {
              const [, e3, n2, a2, r2, i2] = t2;
              if (r2 && !a2)
                return null;
              if (!i2 && !n2 && !a2)
                return null;
              let s2 = 1 * (e3 || 0);
              if (i2) {
                if (s2 >= 13)
                  return null;
                "p" !== i2[0] && "P" !== i2[0] || (s2 += 12);
              }
              return { v: (60 * s2 * 60 + 60 * (1 * (n2 || 0)) + 1 * (a2 || 0) + 1 * (r2 || 0)) / 86400, z: (2 === e3.length ? "hh" : "h") + ":mm" + (a2 ? ":ss" : "") + (i2 ? " AM/PM" : "") };
            }
            return null;
          }
          function de(e2) {
            return /^\s*true\s*$/i.test(e2) ? { v: true } : /^\s*false\s*$/i.test(e2) ? { v: false } : null;
          }
          const me = {};
          function ue(e2, t2) {
            const { pattern: n2, partitions: a2, locale: r2 } = e2, i2 = (e3) => {
              const n3 = Object.assign({}, h(), t2, e3);
              return r2 && (n3.locale = r2), n3;
            }, s2 = (e3, t3) => {
              const n3 = i2(t3);
              return function(e4, t4, n4) {
                const a3 = l(n4.locale), r3 = t4[3] ? t4[3] : V;
                if ("boolean" == typeof e4 && (e4 = e4 ? "TRUE" : "FALSE"), null == e4)
                  return "";
                if ("number" != typeof e4)
                  return K(e4, r3, n4, a3);
                if (!isFinite(e4)) {
                  const t5 = a3 || u;
                  return isNaN(e4) ? t5.nan : (e4 < 0 ? t5.negative : "") + t5.infinity;
                }
                const i3 = q(e4, t4);
                return i3 ? K(e4, i3, n4, a3) : n4.overflow;
              }(P2(e3, n3), a2, n3);
            };
            s2.color = (e3, t3) => function(e4, t4) {
              if ("number" != typeof e4 || !isFinite(e4))
                return (t4[3] ? t4[3].color : V.color) || Q;
              const n3 = q(e4, t4);
              return n3 && n3.color || Q;
            }(P2(e3, i2(t3)), a2);
            const o2 = function(e3) {
              var t3;
              let n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
              const [a3, r3] = e3, i3 = a3.frac_max, s3 = { type: "general", isDate: J(e3), isText: L(e3), isPercent: O(e3), maxDecimals: a3.general ? 9 : i3, scale: null !== (t3 = a3.scale) && void 0 !== t3 ? t3 : 1, color: 0, parentheses: 0, grouped: a3.grouping ? 1 : 0, _partitions: e3 }, o3 = !s3.isDate && !s3.isText && !a3.error && a3.tokens.some((e4) => "string" === e4.type && (n3 ? e4.value === n3 : v.test(e4.value)));
              let l2 = "G", d2 = i3 >= 0 ? Math.min(15, i3) : "", m2 = "", u2 = "";
              if (r3 && r3.color && (u2 = "-", s3.color = 1), a3.parens && (m2 = "()", s3.parentheses = 1), o3)
                l2 = "C", s3.type = "currency";
              else if (a3.error)
                s3.type = "error", s3.maxDecimals = 0;
              else if (s3.isDate) {
                let e4 = 0, t4 = 0, n4 = "";
                a3.tokens.forEach((a4) => {
                  const r5 = a4.type;
                  /^(b-)?year/.test(r5) ? (n4 += "Y", t4++) : r5.startsWith("month") ? (n4 += "M", t4++) : /^(week)?day/.test(r5) ? (n4 += "D", t4++) : "hour" !== r5 && "min" !== r5 && "sec" !== r5 && "am" !== r5 || (n4 += r5[0], e4++);
                }), s3.type = "date", t4 && e4 ? s3.type = "datetime" : !t4 && e4 && (s3.type = "time");
                const r4 = R.find((e5) => n4.startsWith(e5[0]));
                l2 = r4 ? "D" : "G", d2 = r4 ? r4[1] : "";
              } else
                s3.isText ? (l2 = "G", s3.type = "text", d2 = "", s3.maxDecimals = 0) : a3.general ? (l2 = "G", s3.type = "general", d2 = "") : a3.fractions ? (l2 = "G", s3.type = "fraction", d2 = "") : a3.exponential ? (l2 = "S", s3.type = "scientific") : s3.isPercent ? (l2 = "P", s3.type = "percent") : a3.grouping ? (l2 = ",", s3.type = "grouped") : (a3.int_max || i3) && (l2 = "F", s3.type = "number");
              return s3.code = l2 + d2 + u2 + m2, s3.level = U[s3.type], Object.freeze(s3);
            }(a2, (t2 || {}).currency) || new SyntaxError();
            return s2.info = o2, s2.dateInfo = function(e3) {
              const [t3] = e3;
              return { year: !!(2 & t3.date), month: !!(4 & t3.date), day: !!(8 & t3.date), hours: !!(16 & t3.date), minutes: !!(32 & t3.date), seconds: !!(64 & t3.date), clockType: 12 === t3.clock ? 12 : 24 };
            }(a2), s2.isPercent = () => !!o2.isPercent, s2.isDate = () => !!o2.isDate, s2.isText = () => !!o2.isText, s2.pattern = n2, e2.error && (s2.error = e2.error), s2.options = i2, s2.locale = r2 || t2 && t2.locale || "", Object.freeze(s2);
          }
          function ce(e2, t2) {
            e2 || (e2 = "General");
            let n2 = null;
            if (me[e2])
              n2 = me[e2];
            else {
              n2 = Object.assign({}, h(), t2).throws ? D(e2) : function(e3) {
                try {
                  return D(e3);
                } catch (t3) {
                  const n3 = { tokens: [{ type: "error" }], error: t3.message };
                  return { pattern: e3, partitions: [n3, n3, n3, n3], error: t3.message, locale: null };
                }
              }(e2), n2.error || (me[e2] = n2);
            }
            return ue(n2, t2);
          }
          ce.isDate = (e2) => ce(e2, { throws: false }).isDate(), ce.isPercent = (e2) => ce(e2, { throws: false }).isPercent(), ce.isText = (e2) => ce(e2, { throws: false }).isText(), ce.getInfo = (e2, t2) => ce(e2, { ...t2, throws: false }).info, ce.getDateInfo = (e2, t2) => ce(e2, { ...t2, throws: false }).dateInfo, ce.dateToSerial = P2, ce.dateFromSerial = I2, ce.options = h, ce.dec2frac = p, ce.round = c, ce.codeToLocale = n, ce.parseLocale = s, ce.getLocale = l, ce.addLocale = (e2, t2) => {
            const n2 = s(t2);
            return delete me[n2.lang], delete me[n2.language], m(e2, n2);
          }, ce.format = function(e2, t2, n2) {
            let a2 = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
            const r2 = n2 && "object" == typeof n2 ? n2 : { locale: n2, throws: !a2 };
            return ce(e2, r2)(P2(t2, r2), r2);
          }, ce.is_date = ce.isDate, ce.parseNumber = ie, ce.parseDate = oe, ce.parseTime = le, ce.parseBool = de, ce.parseValue = function(e2, t2) {
            var n2, a2, r2;
            return null !== (n2 = null !== (a2 = null !== (r2 = ie(e2)) && void 0 !== r2 ? r2 : oe(e2, t2)) && void 0 !== a2 ? a2 : le(e2)) && void 0 !== n2 ? n2 : de(e2);
          };
          var pe = ce;
          return t = t.default;
        }();
      });
    }
  });

  // ../node_modules/.pnpm/numfmt@2.5.2/node_modules/numfmt/index.js
  var require_numfmt2 = __commonJS({
    "../node_modules/.pnpm/numfmt@2.5.2/node_modules/numfmt/index.js"(exports, module) {
      module.exports = require_numfmt();
    }
  });

  // ../packages/core/src/common/shims.ts
  function installShims() {
    installRequestIdleCallback();
  }
  var glob = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : window;
  function installRequestIdleCallback() {
    const TIME_WINDOW = 50;
    if (typeof glob.requestIdleCallback !== "function") {
      glob.requestIdleCallback = function shimRIC(callback) {
        const start = Date.now();
        return setTimeout(function rICCallback() {
          const remaining = Math.max(0, TIME_WINDOW - (Date.now() - start));
          callback({
            didTimeout: remaining === 0,
            timeRemaining() {
              return remaining;
            }
          });
        }, 1);
      };
    }
    if (typeof glob.cancelIdleCallback !== "function") {
      glob.cancelIdleCallback = function shimCancelRIC(id) {
        clearTimeout(id);
      };
    }
  }

  // ../packages/core/src/types/interfaces/i-range.ts
  function selectionToArray(range) {
    return [range.startRow, range.startColumn, range.endRow, range.endColumn];
  }

  // ../packages/core/src/shared/rectangle.ts
  var _Rectangle = class _Rectangle {
    static clone(src) {
      if (src.rangeType !== void 0) {
        return {
          startRow: src.startRow,
          startColumn: src.startColumn,
          endRow: src.endRow,
          endColumn: src.endColumn,
          rangeType: src.rangeType
        };
      }
      return {
        startRow: src.startRow,
        startColumn: src.startColumn,
        endRow: src.endRow,
        endColumn: src.endColumn
      };
    }
    static equals(src, target) {
      if (src == null || target == null) {
        return false;
      }
      return src.endRow === target.endRow && src.endColumn === target.endColumn && src.startRow === target.startRow && src.startColumn === target.startColumn && (src.rangeType === target.rangeType || src.rangeType === void 0 && target.rangeType === 0 /* NORMAL */ || target.rangeType === void 0 && src.rangeType === 0 /* NORMAL */);
    }
    static intersects(src, target) {
      const currentStartRow = src.startRow;
      const currentEndRow = src.endRow;
      const currentStartColumn = src.startColumn;
      const currentEndColumn = src.endColumn;
      const incomingStartRow = target.startRow;
      const incomingEndRow = target.endRow;
      const incomingStartColumn = target.startColumn;
      const incomingEndColumn = target.endColumn;
      const zx = Math.abs(currentStartColumn + currentEndColumn - incomingStartColumn - incomingEndColumn);
      const x = Math.abs(currentStartColumn - currentEndColumn) + Math.abs(incomingStartColumn - incomingEndColumn);
      const zy = Math.abs(currentStartRow + currentEndRow - incomingStartRow - incomingEndRow);
      const y = Math.abs(currentStartRow - currentEndRow) + Math.abs(incomingStartRow - incomingEndRow);
      return zx <= x && zy <= y;
    }
    static getIntersects(src, target) {
      const currentStartRow = src.startRow;
      const currentEndRow = src.endRow;
      const currentStartColumn = src.startColumn;
      const currentEndColumn = src.endColumn;
      const incomingStartRow = target.startRow;
      const incomingEndRow = target.endRow;
      const incomingStartColumn = target.startColumn;
      const incomingEndColumn = target.endColumn;
      let startColumn;
      let startRow;
      let endColumn;
      let endRow;
      if (incomingStartRow <= currentEndRow) {
        if (incomingStartRow >= currentStartRow) {
          startRow = incomingStartRow;
        } else {
          startRow = currentStartRow;
        }
      } else {
        return null;
      }
      if (incomingEndRow >= currentStartRow) {
        if (incomingEndRow >= currentEndRow) {
          endRow = currentEndRow;
        } else {
          endRow = incomingEndRow;
        }
      } else {
        return null;
      }
      if (incomingStartColumn <= currentEndColumn) {
        if (incomingStartColumn > currentStartColumn) {
          startColumn = incomingStartColumn;
        } else {
          startColumn = currentStartColumn;
        }
      } else {
        return null;
      }
      if (incomingEndColumn >= currentStartColumn) {
        if (incomingEndColumn >= currentEndColumn) {
          endColumn = currentEndColumn;
        } else {
          endColumn = incomingEndColumn;
        }
      } else {
        return null;
      }
      return {
        startRow,
        endRow,
        startColumn,
        endColumn,
        rangeType: 0 /* NORMAL */
        // TODO: this may not be accurate
      };
    }
    // static subtract(src: IRange, target: IRange): Nullable<IRange[]> {
    //     const intersected = Rectangle.getIntersects(src, target);
    //     if (!intersected) {
    //         return [src];
    //     }
    //     const result: IRange[] = [];
    //     const { startRow, endRow, startColumn, endColumn } = intersected;
    //     const { startRow: srcStartRow, endRow: srcEndRow, startColumn: srcStartColumn, endColumn: srcEndColumn } = src;
    //     // subtract could result in eight pieces and these eight pieces and be merged to at most four pieces
    // }
    static contains(src, target) {
      return src.startRow <= target.startRow && src.endRow >= target.endRow && src.startColumn <= target.startColumn && src.endColumn >= target.endColumn;
    }
    static realContain(src, target) {
      return _Rectangle.contains(src, target) && (src.startRow < target.startRow || src.endRow > target.endRow || src.startColumn < target.startColumn || src.endColumn > target.endColumn);
    }
    static union(...ranges) {
      return ranges.reduce(
        (acc, current) => ({
          startRow: Math.min(acc.startRow, current.startRow),
          startColumn: Math.min(acc.startColumn, current.startColumn),
          endRow: Math.max(acc.endRow, current.endRow),
          endColumn: Math.max(acc.endColumn, current.endColumn),
          rangeType: 0 /* NORMAL */
        }),
        ranges[0]
      );
    }
    static subtract(range1, range2) {
      if (range2.startRow > range1.endRow || range2.endRow < range1.startRow || range2.startColumn > range1.endColumn || range2.endColumn < range1.startColumn) {
        return [range1];
      }
      const ranges = [];
      if (range2.startRow >= range1.startRow) {
        ranges.push({
          startRow: range1.startRow,
          startColumn: range1.startColumn,
          endRow: range2.startRow - 1,
          endColumn: range1.endColumn
        });
      }
      if (range2.endRow <= range1.endRow) {
        ranges.push({
          startRow: range2.endRow + 1,
          startColumn: range1.startColumn,
          endRow: range1.endRow,
          endColumn: range1.endColumn
        });
      }
      const topBoundary = Math.max(range1.startRow, range2.startRow);
      const bottomBoundary = Math.min(range1.endRow, range2.endRow);
      if (range2.startColumn >= range1.startColumn) {
        ranges.push({
          startRow: topBoundary,
          startColumn: range1.startColumn,
          endRow: bottomBoundary,
          endColumn: range2.startColumn - 1
        });
      }
      if (range2.endColumn <= range1.endColumn) {
        ranges.push({
          startRow: topBoundary,
          startColumn: range2.endColumn + 1,
          endRow: bottomBoundary,
          endColumn: range1.endColumn
        });
      }
      const result = ranges.filter((range) => range.startRow <= range.endRow && range.startColumn <= range.endColumn);
      return result;
    }
  };
  __publicField(_Rectangle, "getRelativeRange", (range, originRange) => ({
    startRow: range.startRow - originRange.startRow,
    endRow: range.endRow - range.startRow,
    startColumn: range.startColumn - originRange.startColumn,
    endColumn: range.endColumn - range.startColumn
  }));
  __publicField(_Rectangle, "getPositionRange", (relativeRange, originRange, absoluteRange) => {
    return {
      ...absoluteRange || {},
      startRow: absoluteRange ? [1 /* ROW */, 3 /* ALL */].includes(absoluteRange.startAbsoluteRefType || 0) ? absoluteRange.startRow : relativeRange.startRow + originRange.startRow : relativeRange.startRow + originRange.startRow,
      endRow: absoluteRange ? [1 /* ROW */, 3 /* ALL */].includes(absoluteRange.endAbsoluteRefType || 0) ? absoluteRange.endRow : relativeRange.endRow + relativeRange.startRow + originRange.startRow : relativeRange.endRow + relativeRange.startRow + originRange.startRow,
      startColumn: absoluteRange ? [2 /* COLUMN */, 3 /* ALL */].includes(absoluteRange.startAbsoluteRefType || 0) ? absoluteRange.startColumn : relativeRange.startColumn + originRange.startColumn : relativeRange.startColumn + originRange.startColumn,
      endColumn: absoluteRange ? [2 /* COLUMN */, 3 /* ALL */].includes(absoluteRange.endAbsoluteRefType || 0) ? absoluteRange.endColumn : relativeRange.endColumn + relativeRange.startColumn + originRange.startColumn : relativeRange.endColumn + relativeRange.startColumn + originRange.startColumn
    };
  });
  __publicField(_Rectangle, "moveHorizontal", (range, step = 0, length = 0) => ({
    ...range,
    startColumn: range.startColumn + step,
    endColumn: range.endColumn + step + length
  }));
  __publicField(_Rectangle, "moveVertical", (range, step = 0, length = 0) => ({
    ...range,
    startRow: range.startRow + step,
    endRow: range.endRow + step + length
  }));
  __publicField(_Rectangle, "moveOffset", (range, offsetX, offsetY) => ({
    ...range,
    startRow: range.startRow + offsetY,
    endRow: range.endRow + offsetY,
    startColumn: range.startColumn + offsetX,
    endColumn: range.endColumn + offsetX
  }));
  var Rectangle = _Rectangle;

  // ../packages/core/src/basics/registry.ts
  var Registry = class _Registry {
    constructor() {
      __publicField(this, "_data", []);
    }
    static create() {
      return new _Registry();
    }
    add(dataInstance) {
      if (this._data.indexOf(dataInstance) > -1) {
        return;
      }
      this._data.push(dataInstance);
    }
    delete(dataInstance) {
      const index = this._data.indexOf(dataInstance);
      this._data.splice(index, 1);
    }
    getData() {
      return this._data;
    }
  };

  // ../node_modules/.pnpm/@wendellhu+redi@0.13.0/node_modules/@wendellhu/redi/fesm/redi.js
  var IdentifierDecoratorSymbol = Symbol("$$IDENTIFIER_DECORATOR");
  function isIdentifierDecorator(thing) {
    return thing && thing[IdentifierDecoratorSymbol] === true;
  }
  function isCtor(thing) {
    return typeof thing === "function";
  }
  function isClassDependencyItem(thing) {
    if (thing && typeof thing.useClass !== "undefined") {
      return true;
    }
    return false;
  }
  function isFactoryDependencyItem(thing) {
    if (thing && typeof thing.useFactory !== "undefined") {
      return true;
    }
    return false;
  }
  function isValueDependencyItem(thing) {
    if (thing && typeof thing.useValue !== "undefined") {
      return true;
    }
    return false;
  }
  function isAsyncDependencyItem(thing) {
    if (thing && typeof thing.useAsync !== "undefined") {
      return true;
    }
    return false;
  }
  var AsyncHookSymbol = Symbol("AsyncHook");
  function isAsyncHook(thing) {
    if (thing && thing["__symbol"] === AsyncHookSymbol) {
      return true;
    }
    return false;
  }
  function prettyPrintIdentifier(id) {
    if (typeof id === "undefined") {
      return "undefined";
    }
    return isCtor(id) && !id[IdentifierDecoratorSymbol] ? id.name : id.toString();
  }
  var Quantity;
  (function(Quantity2) {
    Quantity2["MANY"] = "many";
    Quantity2["OPTIONAL"] = "optional";
    Quantity2["REQUIRED"] = "required";
  })(Quantity || (Quantity = {}));
  var LookUp;
  (function(LookUp2) {
    LookUp2["SELF"] = "self";
    LookUp2["SKIP_SELF"] = "skipSelf";
  })(LookUp || (LookUp = {}));
  var __extends$4 = /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var RediError = (
    /** @class */
    function(_super) {
      __extends$4(RediError2, _super);
      function RediError2(message) {
        return _super.call(this, "[redi]: ".concat(message)) || this;
      }
      return RediError2;
    }(Error)
  );
  var __extends$3 = /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var TARGET = Symbol("$$TARGET");
  var DEPENDENCIES = Symbol("$$DEPENDENCIES");
  var DependencyDescriptorNotFoundError = (
    /** @class */
    function(_super) {
      __extends$3(DependencyDescriptorNotFoundError2, _super);
      function DependencyDescriptorNotFoundError2(index, target) {
        var msg = "Could not find dependency registered on the ".concat(index, ' (indexed) parameter of the constructor of "').concat(prettyPrintIdentifier(target), '".');
        return _super.call(this, msg) || this;
      }
      return DependencyDescriptorNotFoundError2;
    }(RediError)
  );
  var IdentifierUndefinedError = (
    /** @class */
    function(_super) {
      __extends$3(IdentifierUndefinedError2, _super);
      function IdentifierUndefinedError2(target, index) {
        var msg = 'It seems that you register "undefined" as dependency on the '.concat(index + 1, ' parameter of "').concat(prettyPrintIdentifier(target), '". Please make sure that there is not cyclic dependency among your TypeScript files, or consider using "forwardRef". For more info please visit our website https://redi.wendell.fun/docs/debug#could-not-find-dependency-registered-on');
        return _super.call(this, msg) || this;
      }
      return IdentifierUndefinedError2;
    }(RediError)
  );
  function getDependencies(registerTarget) {
    var target = registerTarget;
    return target[DEPENDENCIES] || [];
  }
  function getDependencyByIndex(registerTarget, index) {
    var allDependencies = getDependencies(registerTarget);
    var dep = allDependencies.find(function(descriptor) {
      return descriptor.paramIndex === index;
    });
    if (!dep) {
      throw new DependencyDescriptorNotFoundError(index, registerTarget);
    }
    return dep;
  }
  function setDependency(registerTarget, identifier, paramIndex, quantity, lookUp) {
    if (quantity === void 0) {
      quantity = Quantity.REQUIRED;
    }
    var descriptor = {
      paramIndex,
      identifier,
      quantity,
      lookUp,
      withNew: false
    };
    if (typeof identifier === "undefined") {
      throw new IdentifierUndefinedError(registerTarget, paramIndex);
    }
    var target = registerTarget;
    if (target[TARGET] === target) {
      target[DEPENDENCIES].push(descriptor);
    } else {
      target[DEPENDENCIES] = [descriptor];
      target[TARGET] = target;
    }
  }
  var knownIdentifiers = /* @__PURE__ */ new Set();
  function createIdentifier(id) {
    if (knownIdentifiers.has(id)) {
      throw new RediError('Identifier "'.concat(id, '" already exists.'));
    } else {
      knownIdentifiers.add(id);
    }
    var decorator = function(registerTarget, _key, index) {
      setDependency(registerTarget, decorator, index);
    };
    decorator.toString = function() {
      return id;
    };
    decorator[IdentifierDecoratorSymbol] = true;
    return decorator;
  }
  var __extends$2 = /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var QuantityCheckError = (
    /** @class */
    function(_super) {
      __extends$2(QuantityCheckError2, _super);
      function QuantityCheckError2(id, quantity, actual) {
        var msg = 'Expect "'.concat(quantity, '" dependency items for id "').concat(prettyPrintIdentifier(id), '" but get ').concat(actual, ".");
        return _super.call(this, msg) || this;
      }
      return QuantityCheckError2;
    }(RediError)
  );
  function checkQuantity(id, quantity, length) {
    if (quantity === Quantity.OPTIONAL && length > 1 || quantity === Quantity.REQUIRED && length !== 1) {
      throw new QuantityCheckError(id, quantity, length);
    }
  }
  function retrieveQuantity(quantity, arr) {
    if (quantity === Quantity.MANY) {
      return arr;
    } else {
      return arr[0];
    }
  }
  function changeQuantity(target, index, quantity) {
    var descriptor = getDependencyByIndex(target, index);
    descriptor.quantity = quantity;
  }
  function quantifyDecoratorFactoryProducer(quantity) {
    return function decoratorFactory(id) {
      if (this instanceof decoratorFactory) {
        return this;
      }
      return function(registerTarget, _key, index) {
        if (id) {
          setDependency(registerTarget, id, index, quantity);
        } else {
          if (quantity === Quantity.REQUIRED) {
            throw new IdentifierUndefinedError(registerTarget, index);
          }
          changeQuantity(registerTarget, index, quantity);
        }
      };
    };
  }
  var Many = quantifyDecoratorFactoryProducer(Quantity.MANY);
  var Optional = quantifyDecoratorFactoryProducer(Quantity.OPTIONAL);
  var Inject = quantifyDecoratorFactoryProducer(Quantity.REQUIRED);
  function isForwardRef(thing) {
    return !!thing && typeof thing.unwrap === "function";
  }
  function normalizeForwardRef(id) {
    if (isForwardRef(id)) {
      return id.unwrap();
    }
    return id;
  }
  function isDisposable(thing) {
    return !!thing && typeof thing.dispose === "function";
  }
  var __extends$1 = /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  function isBareClassDependency(thing) {
    return thing.length === 1;
  }
  var DependencyNotFoundForModuleError = (
    /** @class */
    function(_super) {
      __extends$1(DependencyNotFoundForModuleError2, _super);
      function DependencyNotFoundForModuleError2(toInstantiate, id, index) {
        var msg = 'Cannot find "'.concat(prettyPrintIdentifier(id), '" registered by any injector. It is the ').concat(index, 'th param of "').concat(isIdentifierDecorator(toInstantiate) ? prettyPrintIdentifier(toInstantiate) : toInstantiate.name, '".');
        return _super.call(this, msg) || this;
      }
      return DependencyNotFoundForModuleError2;
    }(RediError)
  );
  var DependencyNotFoundError = (
    /** @class */
    function(_super) {
      __extends$1(DependencyNotFoundError2, _super);
      function DependencyNotFoundError2(id) {
        var msg = 'Cannot find "'.concat(prettyPrintIdentifier(id), '" registered by any injector.');
        return _super.call(this, msg) || this;
      }
      return DependencyNotFoundError2;
    }(RediError)
  );
  var DependencyCollection = (
    /** @class */
    function() {
      function DependencyCollection2(dependencies) {
        var _this = this;
        this.dependencyMap = /* @__PURE__ */ new Map();
        this.normalizeDependencies(dependencies).map(function(pair) {
          return _this.add(pair[0], pair[1]);
        });
      }
      DependencyCollection2.prototype.add = function(ctorOrId, val) {
        if (typeof val === "undefined") {
          val = { useClass: ctorOrId, lazy: false };
        }
        var arr = this.dependencyMap.get(ctorOrId);
        if (typeof arr === "undefined") {
          arr = [];
          this.dependencyMap.set(ctorOrId, arr);
        }
        arr.push(val);
      };
      DependencyCollection2.prototype.delete = function(id) {
        this.dependencyMap.delete(id);
      };
      DependencyCollection2.prototype.get = function(id, quantity) {
        if (quantity === void 0) {
          quantity = Quantity.REQUIRED;
        }
        var ret = this.dependencyMap.get(id);
        checkQuantity(id, quantity, ret.length);
        return retrieveQuantity(quantity, ret);
      };
      DependencyCollection2.prototype.has = function(id) {
        return this.dependencyMap.has(id);
      };
      DependencyCollection2.prototype.append = function(dependencies) {
        var _this = this;
        this.normalizeDependencies(dependencies).forEach(function(pair) {
          return _this.add(pair[0], pair[1]);
        });
      };
      DependencyCollection2.prototype.dispose = function() {
        this.dependencyMap.clear();
      };
      DependencyCollection2.prototype.normalizeDependencies = function(dependencies) {
        return dependencies.map(function(dependency) {
          var id = dependency[0];
          var val;
          if (isBareClassDependency(dependency)) {
            val = {
              useClass: dependency[0],
              lazy: false
            };
          } else {
            val = dependency[1];
          }
          return [id, val];
        });
      };
      return DependencyCollection2;
    }()
  );
  var ResolvedDependencyCollection = (
    /** @class */
    function() {
      function ResolvedDependencyCollection2() {
        this.resolvedDependencies = /* @__PURE__ */ new Map();
      }
      ResolvedDependencyCollection2.prototype.add = function(id, val) {
        var arr = this.resolvedDependencies.get(id);
        if (typeof arr === "undefined") {
          arr = [];
          this.resolvedDependencies.set(id, arr);
        }
        arr.push(val);
      };
      ResolvedDependencyCollection2.prototype.has = function(id) {
        return this.resolvedDependencies.has(id);
      };
      ResolvedDependencyCollection2.prototype.delete = function(id) {
        if (this.resolvedDependencies.has(id)) {
          var things = this.resolvedDependencies.get(id);
          things.forEach(function(t) {
            return isDisposable(t) ? t.dispose() : void 0;
          });
          this.resolvedDependencies.delete(id);
        }
      };
      ResolvedDependencyCollection2.prototype.get = function(id, quantity) {
        if (quantity === void 0) {
          quantity = Quantity.REQUIRED;
        }
        var ret = this.resolvedDependencies.get(id);
        if (!ret) {
          throw new DependencyNotFoundError(id);
        }
        checkQuantity(id, quantity, ret.length);
        if (quantity === Quantity.MANY) {
          return ret;
        } else {
          return ret[0];
        }
      };
      ResolvedDependencyCollection2.prototype.dispose = function() {
        Array.from(this.resolvedDependencies.values()).forEach(function(items) {
          items.forEach(function(item) {
            return isDisposable(item) ? item.dispose() : void 0;
          });
        });
        this.resolvedDependencies.clear();
      };
      return ResolvedDependencyCollection2;
    }()
  );
  function changeLookup(target, index, lookUp) {
    var descriptor = getDependencyByIndex(target, index);
    descriptor.lookUp = lookUp;
  }
  function lookupDecoratorFactoryProducer(lookUp) {
    return function DecoratorFactory() {
      if (this instanceof DecoratorFactory) {
        return this;
      }
      return function(target, _key, index) {
        changeLookup(target, index, lookUp);
      };
    };
  }
  var SkipSelf = lookupDecoratorFactoryProducer(LookUp.SKIP_SELF);
  var Self = lookupDecoratorFactoryProducer(LookUp.SELF);
  function changeToSelf(target, index, withNew) {
    var descriptor = getDependencyByIndex(target, index);
    descriptor.withNew = withNew;
  }
  function withNewDecoratorFactoryProducer(withNew) {
    return function DecoratorFactory() {
      if (this instanceof DecoratorFactory) {
        return this;
      }
      return function(target, _key, index) {
        changeToSelf(target, index, withNew);
      };
    };
  }
  var WithNew = withNewDecoratorFactoryProducer(true);
  function normalizeFactoryDeps(deps) {
    if (!deps) {
      return [];
    }
    return deps.map(function(dep, index) {
      if (!Array.isArray(dep)) {
        return {
          paramIndex: index,
          identifier: dep,
          quantity: Quantity.REQUIRED,
          withNew: false
        };
      }
      var modifiers = dep.slice(0, dep.length - 1);
      var identifier = dep[dep.length - 1];
      var lookUp = void 0;
      var quantity = Quantity.REQUIRED;
      var withNew = false;
      modifiers.forEach(function(modifier) {
        if (modifier instanceof Self) {
          lookUp = LookUp.SELF;
        } else if (modifier instanceof SkipSelf) {
          lookUp = LookUp.SKIP_SELF;
        } else if (modifier instanceof Optional) {
          quantity = Quantity.OPTIONAL;
        } else if (modifier instanceof Many) {
          quantity = Quantity.MANY;
        } else if (modifier instanceof WithNew) {
          withNew = true;
        } else {
          throw new RediError("unknown dep modifier ".concat(modifier, "."));
        }
      });
      return {
        paramIndex: index,
        identifier,
        quantity,
        lookUp,
        withNew
      };
    });
  }
  var runWhenIdle;
  (function() {
    if (typeof requestIdleCallback !== "undefined" && typeof cancelIdleCallback !== "undefined") {
      runWhenIdle = function(runner, timeout) {
        var handle = requestIdleCallback(runner, typeof timeout === "number" ? { timeout } : void 0);
        var disposed = false;
        return function() {
          if (disposed) {
            return;
          }
          disposed = true;
          cancelIdleCallback(handle);
        };
      };
    } else {
      var dummyIdle_1 = Object.freeze({
        didTimeout: true,
        timeRemaining: function() {
          return 15;
        }
      });
      runWhenIdle = function(runner) {
        var handle = setTimeout(function() {
          return runner(dummyIdle_1);
        });
        var disposed = false;
        return function() {
          if (disposed) {
            return;
          }
          disposed = true;
          clearTimeout(handle);
        };
      };
    }
  })();
  var IdleValue = (
    /** @class */
    function() {
      function IdleValue2(executor) {
        var _this = this;
        this.didRun = false;
        this.selfExecutor = function() {
          try {
            _this.value = executor();
          } catch (err) {
            _this.error = err;
          } finally {
            _this.didRun = true;
          }
        };
        this.disposeCallback = runWhenIdle(function() {
          return _this.selfExecutor();
        });
      }
      IdleValue2.prototype.hasRun = function() {
        return this.didRun;
      };
      IdleValue2.prototype.dispose = function() {
        this.disposeCallback();
      };
      IdleValue2.prototype.getValue = function() {
        if (!this.didRun) {
          this.dispose();
          this.selfExecutor();
        }
        if (this.error) {
          throw this.error;
        }
        return this.value;
      };
      return IdleValue2;
    }()
  );
  var __extends = /* @__PURE__ */ function() {
    var extendStatics2 = function(d, b) {
      extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2)
          if (Object.prototype.hasOwnProperty.call(b2, p))
            d2[p] = b2[p];
      };
      return extendStatics2(d, b);
    };
    return function(d, b) {
      if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics2(d, b);
      function __() {
        this.constructor = d;
      }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
  }();
  var __assign = function() {
    __assign = Object.assign || function(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  var __spreadArray = function(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  };
  var MAX_RESOLUTIONS_QUEUED = 300;
  var NotInstantiatedSymbol = Symbol("$$NOT_INSTANTIATED_SYMBOL");
  var CircularDependencyError = (
    /** @class */
    function(_super) {
      __extends(CircularDependencyError2, _super);
      function CircularDependencyError2(id) {
        return _super.call(this, 'Detecting cyclic dependency. The last identifier is "'.concat(prettyPrintIdentifier(id), '".')) || this;
      }
      return CircularDependencyError2;
    }(RediError)
  );
  var InjectorAlreadyDisposedError = (
    /** @class */
    function(_super) {
      __extends(InjectorAlreadyDisposedError2, _super);
      function InjectorAlreadyDisposedError2() {
        return _super.call(this, "Injector cannot be accessed after it was disposed.") || this;
      }
      return InjectorAlreadyDisposedError2;
    }(RediError)
  );
  var AsyncItemReturnAsyncItemError = (
    /** @class */
    function(_super) {
      __extends(AsyncItemReturnAsyncItemError2, _super);
      function AsyncItemReturnAsyncItemError2(id) {
        return _super.call(this, 'Async item "'.concat(prettyPrintIdentifier(id), '" returns another async item.')) || this;
      }
      return AsyncItemReturnAsyncItemError2;
    }(RediError)
  );
  var GetAsyncItemFromSyncApiError = (
    /** @class */
    function(_super) {
      __extends(GetAsyncItemFromSyncApiError2, _super);
      function GetAsyncItemFromSyncApiError2(id) {
        return _super.call(this, 'Cannot get async item "'.concat(prettyPrintIdentifier(id), '" from sync api.')) || this;
      }
      return GetAsyncItemFromSyncApiError2;
    }(RediError)
  );
  var AddDependencyAfterResolutionError = (
    /** @class */
    function(_super) {
      __extends(AddDependencyAfterResolutionError2, _super);
      function AddDependencyAfterResolutionError2(id) {
        return _super.call(this, 'Cannot add dependency "'.concat(prettyPrintIdentifier(id), '" after it is already resolved.')) || this;
      }
      return AddDependencyAfterResolutionError2;
    }(RediError)
  );
  var DeleteDependencyAfterResolutionError = (
    /** @class */
    function(_super) {
      __extends(DeleteDependencyAfterResolutionError2, _super);
      function DeleteDependencyAfterResolutionError2(id) {
        return _super.call(this, 'Cannot dependency dependency "'.concat(prettyPrintIdentifier(id), '" after it is already resolved.')) || this;
      }
      return DeleteDependencyAfterResolutionError2;
    }(RediError)
  );
  var Injector = (
    /** @class */
    function() {
      function Injector2(dependencies, parent) {
        if (parent === void 0) {
          parent = null;
        }
        this.parent = parent;
        this.children = [];
        this.resolutionOngoing = 0;
        this.disposed = false;
        this.dependencyCollection = new DependencyCollection(dependencies || []);
        this.resolvedDependencyCollection = new ResolvedDependencyCollection();
        if (parent) {
          parent.children.push(this);
        }
      }
      Injector2.prototype.createChild = function(dependencies) {
        this.ensureInjectorNotDisposed();
        return new Injector2(dependencies, this);
      };
      Injector2.prototype.dispose = function() {
        this.children.forEach(function(c) {
          return c.dispose();
        });
        this.children.length = 0;
        this.dependencyCollection.dispose();
        this.resolvedDependencyCollection.dispose();
        this.deleteSelfFromParent();
        this.disposed = true;
      };
      Injector2.prototype.deleteSelfFromParent = function() {
        if (this.parent) {
          var index = this.parent.children.indexOf(this);
          if (index > -1) {
            this.parent.children.splice(index, 1);
          }
        }
      };
      Injector2.prototype.add = function(dependency) {
        this.ensureInjectorNotDisposed();
        var identifierOrCtor = dependency[0];
        var item = dependency[1];
        if (this.resolvedDependencyCollection.has(identifierOrCtor)) {
          throw new AddDependencyAfterResolutionError(identifierOrCtor);
        }
        if (typeof item === "undefined") {
          this.dependencyCollection.add(identifierOrCtor);
        } else if (isAsyncDependencyItem(item) || isClassDependencyItem(item) || isValueDependencyItem(item) || isFactoryDependencyItem(item)) {
          this.dependencyCollection.add(identifierOrCtor, item);
        } else {
          this.resolvedDependencyCollection.add(identifierOrCtor, item);
        }
      };
      Injector2.prototype.replace = function(dependency) {
        this.ensureInjectorNotDisposed();
        var identifier = dependency[0];
        if (this.resolvedDependencyCollection.has(identifier)) {
          throw new AddDependencyAfterResolutionError(identifier);
        }
        this.dependencyCollection.delete(identifier);
        if (dependency.length === 1) {
          this.dependencyCollection.add(identifier);
        } else {
          this.dependencyCollection.add(identifier, dependency[1]);
        }
      };
      Injector2.prototype.delete = function(identifier) {
        this.ensureInjectorNotDisposed();
        if (this.resolvedDependencyCollection.has(identifier)) {
          throw new DeleteDependencyAfterResolutionError(identifier);
        }
        this.dependencyCollection.delete(identifier);
      };
      Injector2.prototype.invoke = function(cb) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var accessor = {
          get: function(id, quantityOrLookup, lookUp) {
            return _this._get(id, quantityOrLookup, lookUp);
          }
        };
        return cb.apply(void 0, __spreadArray([accessor], args, false));
      };
      Injector2.prototype.has = function(id) {
        var _a2;
        return this.dependencyCollection.has(id) || ((_a2 = this.parent) === null || _a2 === void 0 ? void 0 : _a2.has(id)) || false;
      };
      Injector2.prototype.get = function(id, quantityOrLookup, lookUp) {
        var newResult = this._get(id, quantityOrLookup, lookUp);
        if (Array.isArray(newResult) && newResult.some(function(r) {
          return isAsyncHook(r);
        }) || isAsyncHook(newResult)) {
          throw new GetAsyncItemFromSyncApiError(id);
        }
        return newResult;
      };
      Injector2.prototype._get = function(id, quantityOrLookup, lookUp, toSelf) {
        this.ensureInjectorNotDisposed();
        var quantity = Quantity.REQUIRED;
        if (quantityOrLookup === Quantity.REQUIRED || quantityOrLookup === Quantity.OPTIONAL || quantityOrLookup === Quantity.MANY) {
          quantity = quantityOrLookup;
        } else {
          lookUp = quantityOrLookup;
        }
        if (!toSelf) {
          var cachedResult = this.getValue(id, quantity, lookUp);
          if (cachedResult !== NotInstantiatedSymbol) {
            return cachedResult;
          }
        }
        return this.createDependency(id, quantity, lookUp, !toSelf);
      };
      Injector2.prototype.getAsync = function(id) {
        this.ensureInjectorNotDisposed();
        var cachedResult = this.getValue(id, Quantity.REQUIRED);
        if (cachedResult !== NotInstantiatedSymbol) {
          return Promise.resolve(cachedResult);
        }
        var newResult = this.createDependency(id, Quantity.REQUIRED);
        if (!isAsyncHook(newResult)) {
          return Promise.resolve(newResult);
        }
        return newResult.whenReady();
      };
      Injector2.prototype.createInstance = function(ctor) {
        var customArgs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          customArgs[_i - 1] = arguments[_i];
        }
        this.ensureInjectorNotDisposed();
        return this._resolveClass.apply(this, __spreadArray([ctor], customArgs, false));
      };
      Injector2.prototype.resolveDependency = function(id, item, shouldCache) {
        if (shouldCache === void 0) {
          shouldCache = true;
        }
        if (isValueDependencyItem(item)) {
          return this.resolveValueDependency(id, item);
        } else if (isFactoryDependencyItem(item)) {
          return this.resolveFactory(id, item, shouldCache);
        } else if (isClassDependencyItem(item)) {
          return this.resolveClass(id, item, shouldCache);
        } else {
          return this.resolveAsync(id, item);
        }
      };
      Injector2.prototype.resolveValueDependency = function(id, item) {
        var thing = item.useValue;
        this.resolvedDependencyCollection.add(id, thing);
        return thing;
      };
      Injector2.prototype.resolveClass = function(id, item, shouldCache) {
        var _this = this;
        if (shouldCache === void 0) {
          shouldCache = true;
        }
        var ctor = item.useClass;
        var thing;
        if (item.lazy) {
          var idle_1 = new IdleValue(function() {
            return _this._resolveClass(ctor);
          });
          thing = new Proxy(/* @__PURE__ */ Object.create(null), {
            get: function(target, key) {
              var _a2;
              if (key in target) {
                return target[key];
              }
              if (key === "whenReady") {
                return void 0;
              }
              var hasInstantiated = idle_1.hasRun();
              var thing2 = idle_1.getValue();
              if (!hasInstantiated) {
                (_a2 = item.onInstantiation) === null || _a2 === void 0 ? void 0 : _a2.call(item, thing2);
              }
              var property = thing2[key];
              if (typeof property !== "function") {
                return property;
              }
              property = property.bind(thing2);
              target[key] = property;
              return property;
            },
            set: function(_target, key, value) {
              idle_1.getValue()[key] = value;
              return true;
            }
          });
        } else {
          thing = this._resolveClass(ctor);
        }
        if (id && shouldCache) {
          this.resolvedDependencyCollection.add(id, thing);
        }
        return thing;
      };
      Injector2.prototype._resolveClass = function(ctor) {
        var extraParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          extraParams[_i - 1] = arguments[_i];
        }
        this.markNewResolution(ctor);
        var declaredDependencies = getDependencies(ctor).sort(function(a, b) {
          return a.paramIndex - b.paramIndex;
        }).map(function(descriptor) {
          return __assign(__assign({}, descriptor), { identifier: normalizeForwardRef(descriptor.identifier) });
        });
        var resolvedArgs = [];
        for (var _a2 = 0, declaredDependencies_1 = declaredDependencies; _a2 < declaredDependencies_1.length; _a2++) {
          var dep = declaredDependencies_1[_a2];
          try {
            var thing_1 = this._get(dep.identifier, dep.quantity, dep.lookUp, dep.withNew);
            resolvedArgs.push(thing_1);
          } catch (error) {
            if (error instanceof DependencyNotFoundError) {
              throw new DependencyNotFoundForModuleError(ctor, dep.identifier, dep.paramIndex);
            }
            throw error;
          }
        }
        var args = __spreadArray([], extraParams, true);
        var firstDependencyArgIndex = declaredDependencies.length > 0 ? declaredDependencies[0].paramIndex : args.length;
        if (args.length !== firstDependencyArgIndex) {
          console.warn("[redi]: Expect ".concat(firstDependencyArgIndex, " custom parameter(s) of ").concat(ctor.toString(), " but get ").concat(args.length, "."));
          var delta = firstDependencyArgIndex - args.length;
          if (delta > 0) {
            args = __spreadArray(__spreadArray([], args, true), new Array(delta).fill(void 0), true);
          } else {
            args = args.slice(0, firstDependencyArgIndex);
          }
        }
        var thing = new (ctor.bind.apply(ctor, __spreadArray(__spreadArray([void 0], args, false), resolvedArgs, false)))();
        this.markResolutionCompleted();
        return thing;
      };
      Injector2.prototype.resolveFactory = function(id, item, shouldCache) {
        var _a2;
        this.markNewResolution(id);
        var declaredDependencies = normalizeFactoryDeps(item.deps);
        var resolvedArgs = [];
        for (var _i = 0, declaredDependencies_2 = declaredDependencies; _i < declaredDependencies_2.length; _i++) {
          var dep = declaredDependencies_2[_i];
          try {
            var thing_2 = this._get(dep.identifier, dep.quantity, dep.lookUp, dep.withNew);
            resolvedArgs.push(thing_2);
          } catch (error) {
            if (error instanceof DependencyNotFoundError) {
              throw new DependencyNotFoundForModuleError(id, dep.identifier, dep.paramIndex);
            }
            throw error;
          }
        }
        var thing = item.useFactory.apply(null, resolvedArgs);
        if (shouldCache) {
          this.resolvedDependencyCollection.add(id, thing);
        }
        this.markResolutionCompleted();
        (_a2 = item === null || item === void 0 ? void 0 : item.onInstantiation) === null || _a2 === void 0 ? void 0 : _a2.call(item, thing);
        return thing;
      };
      Injector2.prototype.resolveAsync = function(id, item) {
        var _this = this;
        var asyncLoader = {
          __symbol: AsyncHookSymbol,
          whenReady: function() {
            return _this._resolveAsync(id, item);
          }
        };
        return asyncLoader;
      };
      Injector2.prototype._resolveAsync = function(id, item) {
        var _this = this;
        return item.useAsync().then(function(thing) {
          var resolvedCheck = _this.getValue(id);
          if (resolvedCheck !== NotInstantiatedSymbol) {
            return resolvedCheck;
          }
          var ret;
          if (Array.isArray(thing)) {
            var item_1 = thing[1];
            if (isAsyncDependencyItem(item_1)) {
              throw new AsyncItemReturnAsyncItemError(id);
            } else {
              ret = _this.resolveDependency(id, item_1);
            }
          } else if (isCtor(thing)) {
            ret = _this._resolveClass(thing);
          } else {
            ret = thing;
          }
          _this.resolvedDependencyCollection.add(id, ret);
          return ret;
        });
      };
      Injector2.prototype.getValue = function(id, quantity, lookUp) {
        var _this = this;
        if (quantity === void 0) {
          quantity = Quantity.REQUIRED;
        }
        var onSelf = function() {
          if (_this.dependencyCollection.has(id) && !_this.resolvedDependencyCollection.has(id)) {
            return NotInstantiatedSymbol;
          }
          return _this.resolvedDependencyCollection.get(id, quantity);
        };
        var onParent = function() {
          if (_this.parent) {
            return _this.parent.getValue(id, quantity);
          } else {
            return NotInstantiatedSymbol;
          }
        };
        if (lookUp === LookUp.SKIP_SELF) {
          return onParent();
        }
        if (lookUp === LookUp.SELF) {
          return onSelf();
        }
        if (this.resolvedDependencyCollection.has(id) || this.dependencyCollection.has(id)) {
          return onSelf();
        }
        return onParent();
      };
      Injector2.prototype.createDependency = function(id, quantity, lookUp, shouldCache) {
        var _this = this;
        if (quantity === void 0) {
          quantity = Quantity.REQUIRED;
        }
        if (shouldCache === void 0) {
          shouldCache = true;
        }
        var onSelf = function() {
          var registrations = _this.dependencyCollection.get(id, quantity);
          var ret = null;
          if (Array.isArray(registrations)) {
            ret = registrations.map(function(dependencyItem) {
              return _this.resolveDependency(id, dependencyItem, shouldCache);
            });
          } else if (registrations) {
            ret = _this.resolveDependency(id, registrations, shouldCache);
          }
          return ret;
        };
        var onParent = function() {
          if (_this.parent) {
            return _this.parent.createDependency(id, quantity, void 0, shouldCache);
          } else {
            if (quantity === Quantity.OPTIONAL) {
              return null;
            }
            throw new DependencyNotFoundError(id);
          }
        };
        if (lookUp === LookUp.SKIP_SELF) {
          return onParent();
        }
        if (id === Injector2) {
          return this;
        }
        if (this.dependencyCollection.has(id)) {
          return onSelf();
        }
        return onParent();
      };
      Injector2.prototype.markNewResolution = function(id) {
        this.resolutionOngoing += 1;
        if (this.resolutionOngoing >= MAX_RESOLUTIONS_QUEUED) {
          throw new CircularDependencyError(id);
        }
      };
      Injector2.prototype.markResolutionCompleted = function() {
        this.resolutionOngoing -= 1;
      };
      Injector2.prototype.ensureInjectorNotDisposed = function() {
        if (this.disposed) {
          throw new InjectorAlreadyDisposedError();
        }
      };
      return Injector2;
    }()
  );
  var globalObject = typeof globalThis !== "undefined" && globalThis || typeof window !== "undefined" && window || // @ts-ignore
  typeof global !== "undefined" && global;
  var __REDI_GLOBAL_LOCK__ = "REDI_GLOBAL_LOCK";
  if (globalObject[__REDI_GLOBAL_LOCK__]) {
    console.error("[redi]: You are loading scripts of redi more than once! This may cause undesired behavior in your application.\nMaybe your dependencies added redi as its dependency and bundled redi to its dist files. Or you import different versions of redi.\nFor more info please visit our website: https://redi.wendell.fun/en-US/docs/debug#import-scripts-of-redi-more-than-once");
  } else {
    globalObject[__REDI_GLOBAL_LOCK__] = true;
  }

  // ../packages/core/src/plugin/plugin.ts
  var Plugin = class {
    constructor(name) {
      __publicField(this, "_name");
      this._name = name;
    }
    onStarting(injector) {
    }
    onReady() {
    }
    onRendered() {
    }
    onSteady() {
    }
    onDestroy() {
    }
    getPluginName() {
      return this._name;
    }
  };
  __publicField(Plugin, "type", 0 /* Univer */);
  var PluginStore = class {
    constructor() {
      __publicField(this, "_plugins", []);
    }
    addPlugin(plugin) {
      this._plugins.push(plugin);
    }
    removePlugins() {
      const plugins = this._plugins.slice();
      this._plugins.length = 0;
      return plugins;
    }
    forEachPlugin(callback) {
      this._plugins.forEach(callback);
    }
  };
  var PluginRegistry = class {
    constructor() {
      __publicField(this, "_pluginsRegisteredByBusiness", /* @__PURE__ */ new Map());
    }
    registerPlugin(pluginCtor, options) {
      const type = pluginCtor.type;
      if (!this._pluginsRegisteredByBusiness.has(type)) {
        this._pluginsRegisteredByBusiness.set(type, []);
      }
      this._pluginsRegisteredByBusiness.get(type).push({ plugin: pluginCtor, options });
    }
    getRegisterPlugins(type) {
      return this._pluginsRegisteredByBusiness.get(type) || [];
    }
    clearPluginsOfType(type) {
      this._pluginsRegisteredByBusiness.delete(type);
    }
  };

  // ../packages/core/src/common/array.ts
  function remove(arr, item) {
    const index = arr.indexOf(item);
    if (index > -1) {
      arr.splice(index, 1);
      return true;
    }
    return false;
  }
  function findLast(arr, callback) {
    for (let i = arr.length - 1; i > -1; i--) {
      const item = arr[i];
      if (callback(item, i)) {
        return item;
      }
    }
    return null;
  }

  // ../packages/core/src/common/sequence.ts
  function sequence(tasks) {
    for (const [index, task] of tasks.entries()) {
      try {
        const result = task();
        if (!result) {
          return {
            index,
            result: false
          };
        }
      } catch (e) {
        return {
          index,
          result: false,
          error: e
        };
      }
    }
    return {
      result: true,
      index: -1
    };
  }

  // ../node_modules/.pnpm/tslib@2.6.2/node_modules/tslib/tslib.es6.mjs
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p))
          d2[p] = b2[p];
    };
    return extendStatics(d, b);
  };
  function __extends2(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  function __awaiter(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _820 = { label: 0, sent: function() {
      if (t[0] & 1)
        throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n) {
      return function(v) {
        return step([n, v]);
      };
    }
    function step(op) {
      if (f)
        throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_820 = 0)), _820)
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
            return t;
          if (y = 0, t)
            op = [op[0] & 2, t.value];
          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;
            case 4:
              _820.label++;
              return { value: op[1], done: false };
            case 5:
              _820.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _820.ops.pop();
              _820.trys.pop();
              continue;
            default:
              if (!(t = _820.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _820 = 0;
                continue;
              }
              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _820.label = op[1];
                break;
              }
              if (op[0] === 6 && _820.label < t[1]) {
                _820.label = t[1];
                t = op;
                break;
              }
              if (t && _820.label < t[2]) {
                _820.label = t[2];
                _820.ops.push(op);
                break;
              }
              if (t[2])
                _820.ops.pop();
              _820.trys.pop();
              continue;
          }
          op = body.call(thisArg, _820);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      if (op[0] & 5)
        throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m)
      return m.call(o);
    if (o && typeof o.length === "number")
      return {
        next: function() {
          if (o && i >= o.length)
            o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m)
      return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
        ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"]))
          m.call(i);
      } finally {
        if (e)
          throw e.error;
      }
    }
    return ar;
  }
  function __spreadArray2(to, from2, pack) {
    if (pack || arguments.length === 2)
      for (var i = 0, l = from2.length, ar; i < l; i++) {
        if (ar || !(i in from2)) {
          if (!ar)
            ar = Array.prototype.slice.call(from2, 0, i);
          ar[i] = from2[i];
        }
      }
    return to.concat(ar || Array.prototype.slice.call(from2));
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i;
    function verb(n) {
      if (g[n])
        i[n] = function(v) {
          return new Promise(function(a, b) {
            q.push([n, v, a, b]) > 1 || resume(n, v);
          });
        };
    }
    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }
    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
      resume("next", value);
    }
    function reject(value) {
      resume("throw", value);
    }
    function settle(f, v) {
      if (f(v), q.shift(), q.length)
        resume(q[0][0], q[0][1]);
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator)
      throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
      return this;
    }, i);
    function verb(n) {
      i[n] = o[n] && function(v) {
        return new Promise(function(resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }
    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function(v2) {
        resolve({ value: v2, done: d });
      }, reject);
    }
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isFunction.js
  function isFunction(value) {
    return typeof value === "function";
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/createErrorClass.js
  function createErrorClass(createImpl) {
    var _super = function(instance) {
      Error.call(instance);
      instance.stack = new Error().stack;
    };
    var ctorFunc = createImpl(_super);
    ctorFunc.prototype = Object.create(Error.prototype);
    ctorFunc.prototype.constructor = ctorFunc;
    return ctorFunc;
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/UnsubscriptionError.js
  var UnsubscriptionError = createErrorClass(function(_super) {
    return function UnsubscriptionErrorImpl(errors) {
      _super(this);
      this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i) {
        return i + 1 + ") " + err.toString();
      }).join("\n  ") : "";
      this.name = "UnsubscriptionError";
      this.errors = errors;
    };
  });

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/arrRemove.js
  function arrRemove(arr, item) {
    if (arr) {
      var index = arr.indexOf(item);
      0 <= index && arr.splice(index, 1);
    }
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscription.js
  var Subscription = function() {
    function Subscription2(initialTeardown) {
      this.initialTeardown = initialTeardown;
      this.closed = false;
      this._parentage = null;
      this._finalizers = null;
    }
    Subscription2.prototype.unsubscribe = function() {
      var e_1, _a2, e_2, _b2;
      var errors;
      if (!this.closed) {
        this.closed = true;
        var _parentage = this._parentage;
        if (_parentage) {
          this._parentage = null;
          if (Array.isArray(_parentage)) {
            try {
              for (var _parentage_1 = __values(_parentage), _parentage_1_1 = _parentage_1.next(); !_parentage_1_1.done; _parentage_1_1 = _parentage_1.next()) {
                var parent_1 = _parentage_1_1.value;
                parent_1.remove(this);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_parentage_1_1 && !_parentage_1_1.done && (_a2 = _parentage_1.return))
                  _a2.call(_parentage_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          } else {
            _parentage.remove(this);
          }
        }
        var initialFinalizer = this.initialTeardown;
        if (isFunction(initialFinalizer)) {
          try {
            initialFinalizer();
          } catch (e) {
            errors = e instanceof UnsubscriptionError ? e.errors : [e];
          }
        }
        var _finalizers = this._finalizers;
        if (_finalizers) {
          this._finalizers = null;
          try {
            for (var _finalizers_1 = __values(_finalizers), _finalizers_1_1 = _finalizers_1.next(); !_finalizers_1_1.done; _finalizers_1_1 = _finalizers_1.next()) {
              var finalizer = _finalizers_1_1.value;
              try {
                execFinalizer(finalizer);
              } catch (err) {
                errors = errors !== null && errors !== void 0 ? errors : [];
                if (err instanceof UnsubscriptionError) {
                  errors = __spreadArray2(__spreadArray2([], __read(errors)), __read(err.errors));
                } else {
                  errors.push(err);
                }
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_finalizers_1_1 && !_finalizers_1_1.done && (_b2 = _finalizers_1.return))
                _b2.call(_finalizers_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
        if (errors) {
          throw new UnsubscriptionError(errors);
        }
      }
    };
    Subscription2.prototype.add = function(teardown) {
      var _a2;
      if (teardown && teardown !== this) {
        if (this.closed) {
          execFinalizer(teardown);
        } else {
          if (teardown instanceof Subscription2) {
            if (teardown.closed || teardown._hasParent(this)) {
              return;
            }
            teardown._addParent(this);
          }
          (this._finalizers = (_a2 = this._finalizers) !== null && _a2 !== void 0 ? _a2 : []).push(teardown);
        }
      }
    };
    Subscription2.prototype._hasParent = function(parent) {
      var _parentage = this._parentage;
      return _parentage === parent || Array.isArray(_parentage) && _parentage.includes(parent);
    };
    Subscription2.prototype._addParent = function(parent) {
      var _parentage = this._parentage;
      this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;
    };
    Subscription2.prototype._removeParent = function(parent) {
      var _parentage = this._parentage;
      if (_parentage === parent) {
        this._parentage = null;
      } else if (Array.isArray(_parentage)) {
        arrRemove(_parentage, parent);
      }
    };
    Subscription2.prototype.remove = function(teardown) {
      var _finalizers = this._finalizers;
      _finalizers && arrRemove(_finalizers, teardown);
      if (teardown instanceof Subscription2) {
        teardown._removeParent(this);
      }
    };
    Subscription2.EMPTY = function() {
      var empty = new Subscription2();
      empty.closed = true;
      return empty;
    }();
    return Subscription2;
  }();
  var EMPTY_SUBSCRIPTION = Subscription.EMPTY;
  function isSubscription(value) {
    return value instanceof Subscription || value && "closed" in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe);
  }
  function execFinalizer(finalizer) {
    if (isFunction(finalizer)) {
      finalizer();
    } else {
      finalizer.unsubscribe();
    }
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/config.js
  var config = {
    onUnhandledError: null,
    onStoppedNotification: null,
    Promise: void 0,
    useDeprecatedSynchronousErrorHandling: false,
    useDeprecatedNextContext: false
  };

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduler/timeoutProvider.js
  var timeoutProvider = {
    setTimeout: function(handler, timeout) {
      var args = [];
      for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
      }
      var delegate = timeoutProvider.delegate;
      if (delegate === null || delegate === void 0 ? void 0 : delegate.setTimeout) {
        return delegate.setTimeout.apply(delegate, __spreadArray2([handler, timeout], __read(args)));
      }
      return setTimeout.apply(void 0, __spreadArray2([handler, timeout], __read(args)));
    },
    clearTimeout: function(handle) {
      var delegate = timeoutProvider.delegate;
      return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearTimeout) || clearTimeout)(handle);
    },
    delegate: void 0
  };

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/reportUnhandledError.js
  function reportUnhandledError(err) {
    timeoutProvider.setTimeout(function() {
      var onUnhandledError = config.onUnhandledError;
      if (onUnhandledError) {
        onUnhandledError(err);
      } else {
        throw err;
      }
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/noop.js
  function noop() {
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/NotificationFactories.js
  var COMPLETE_NOTIFICATION = function() {
    return createNotification("C", void 0, void 0);
  }();
  function errorNotification(error) {
    return createNotification("E", void 0, error);
  }
  function nextNotification(value) {
    return createNotification("N", value, void 0);
  }
  function createNotification(kind, value, error) {
    return {
      kind,
      value,
      error
    };
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/errorContext.js
  var context = null;
  function errorContext(cb) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      var isRoot = !context;
      if (isRoot) {
        context = { errorThrown: false, error: null };
      }
      cb();
      if (isRoot) {
        var _a2 = context, errorThrown = _a2.errorThrown, error = _a2.error;
        context = null;
        if (errorThrown) {
          throw error;
        }
      }
    } else {
      cb();
    }
  }
  function captureError(err) {
    if (config.useDeprecatedSynchronousErrorHandling && context) {
      context.errorThrown = true;
      context.error = err;
    }
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subscriber.js
  var Subscriber = function(_super) {
    __extends2(Subscriber2, _super);
    function Subscriber2(destination) {
      var _this = _super.call(this) || this;
      _this.isStopped = false;
      if (destination) {
        _this.destination = destination;
        if (isSubscription(destination)) {
          destination.add(_this);
        }
      } else {
        _this.destination = EMPTY_OBSERVER;
      }
      return _this;
    }
    Subscriber2.create = function(next, error, complete) {
      return new SafeSubscriber(next, error, complete);
    };
    Subscriber2.prototype.next = function(value) {
      if (this.isStopped) {
        handleStoppedNotification(nextNotification(value), this);
      } else {
        this._next(value);
      }
    };
    Subscriber2.prototype.error = function(err) {
      if (this.isStopped) {
        handleStoppedNotification(errorNotification(err), this);
      } else {
        this.isStopped = true;
        this._error(err);
      }
    };
    Subscriber2.prototype.complete = function() {
      if (this.isStopped) {
        handleStoppedNotification(COMPLETE_NOTIFICATION, this);
      } else {
        this.isStopped = true;
        this._complete();
      }
    };
    Subscriber2.prototype.unsubscribe = function() {
      if (!this.closed) {
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
        this.destination = null;
      }
    };
    Subscriber2.prototype._next = function(value) {
      this.destination.next(value);
    };
    Subscriber2.prototype._error = function(err) {
      try {
        this.destination.error(err);
      } finally {
        this.unsubscribe();
      }
    };
    Subscriber2.prototype._complete = function() {
      try {
        this.destination.complete();
      } finally {
        this.unsubscribe();
      }
    };
    return Subscriber2;
  }(Subscription);
  var _bind = Function.prototype.bind;
  function bind(fn, thisArg) {
    return _bind.call(fn, thisArg);
  }
  var ConsumerObserver = function() {
    function ConsumerObserver2(partialObserver) {
      this.partialObserver = partialObserver;
    }
    ConsumerObserver2.prototype.next = function(value) {
      var partialObserver = this.partialObserver;
      if (partialObserver.next) {
        try {
          partialObserver.next(value);
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    ConsumerObserver2.prototype.error = function(err) {
      var partialObserver = this.partialObserver;
      if (partialObserver.error) {
        try {
          partialObserver.error(err);
        } catch (error) {
          handleUnhandledError(error);
        }
      } else {
        handleUnhandledError(err);
      }
    };
    ConsumerObserver2.prototype.complete = function() {
      var partialObserver = this.partialObserver;
      if (partialObserver.complete) {
        try {
          partialObserver.complete();
        } catch (error) {
          handleUnhandledError(error);
        }
      }
    };
    return ConsumerObserver2;
  }();
  var SafeSubscriber = function(_super) {
    __extends2(SafeSubscriber2, _super);
    function SafeSubscriber2(observerOrNext, error, complete) {
      var _this = _super.call(this) || this;
      var partialObserver;
      if (isFunction(observerOrNext) || !observerOrNext) {
        partialObserver = {
          next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : void 0,
          error: error !== null && error !== void 0 ? error : void 0,
          complete: complete !== null && complete !== void 0 ? complete : void 0
        };
      } else {
        var context_1;
        if (_this && config.useDeprecatedNextContext) {
          context_1 = Object.create(observerOrNext);
          context_1.unsubscribe = function() {
            return _this.unsubscribe();
          };
          partialObserver = {
            next: observerOrNext.next && bind(observerOrNext.next, context_1),
            error: observerOrNext.error && bind(observerOrNext.error, context_1),
            complete: observerOrNext.complete && bind(observerOrNext.complete, context_1)
          };
        } else {
          partialObserver = observerOrNext;
        }
      }
      _this.destination = new ConsumerObserver(partialObserver);
      return _this;
    }
    return SafeSubscriber2;
  }(Subscriber);
  function handleUnhandledError(error) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      captureError(error);
    } else {
      reportUnhandledError(error);
    }
  }
  function defaultErrorHandler(err) {
    throw err;
  }
  function handleStoppedNotification(notification, subscriber) {
    var onStoppedNotification = config.onStoppedNotification;
    onStoppedNotification && timeoutProvider.setTimeout(function() {
      return onStoppedNotification(notification, subscriber);
    });
  }
  var EMPTY_OBSERVER = {
    closed: true,
    next: noop,
    error: defaultErrorHandler,
    complete: noop
  };

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/symbol/observable.js
  var observable = function() {
    return typeof Symbol === "function" && Symbol.observable || "@@observable";
  }();

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/identity.js
  function identity(x) {
    return x;
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/pipe.js
  function pipeFromArray(fns) {
    if (fns.length === 0) {
      return identity;
    }
    if (fns.length === 1) {
      return fns[0];
    }
    return function piped(input) {
      return fns.reduce(function(prev, fn) {
        return fn(prev);
      }, input);
    };
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Observable.js
  var Observable = function() {
    function Observable3(subscribe) {
      if (subscribe) {
        this._subscribe = subscribe;
      }
    }
    Observable3.prototype.lift = function(operator) {
      var observable2 = new Observable3();
      observable2.source = this;
      observable2.operator = operator;
      return observable2;
    };
    Observable3.prototype.subscribe = function(observerOrNext, error, complete) {
      var _this = this;
      var subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);
      errorContext(function() {
        var _a2 = _this, operator = _a2.operator, source = _a2.source;
        subscriber.add(operator ? operator.call(subscriber, source) : source ? _this._subscribe(subscriber) : _this._trySubscribe(subscriber));
      });
      return subscriber;
    };
    Observable3.prototype._trySubscribe = function(sink) {
      try {
        return this._subscribe(sink);
      } catch (err) {
        sink.error(err);
      }
    };
    Observable3.prototype.forEach = function(next, promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var subscriber = new SafeSubscriber({
          next: function(value) {
            try {
              next(value);
            } catch (err) {
              reject(err);
              subscriber.unsubscribe();
            }
          },
          error: reject,
          complete: resolve
        });
        _this.subscribe(subscriber);
      });
    };
    Observable3.prototype._subscribe = function(subscriber) {
      var _a2;
      return (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber);
    };
    Observable3.prototype[observable] = function() {
      return this;
    };
    Observable3.prototype.pipe = function() {
      var operations = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        operations[_i] = arguments[_i];
      }
      return pipeFromArray(operations)(this);
    };
    Observable3.prototype.toPromise = function(promiseCtor) {
      var _this = this;
      promiseCtor = getPromiseCtor(promiseCtor);
      return new promiseCtor(function(resolve, reject) {
        var value;
        _this.subscribe(function(x) {
          return value = x;
        }, function(err) {
          return reject(err);
        }, function() {
          return resolve(value);
        });
      });
    };
    Observable3.create = function(subscribe) {
      return new Observable3(subscribe);
    };
    return Observable3;
  }();
  function getPromiseCtor(promiseCtor) {
    var _a2;
    return (_a2 = promiseCtor !== null && promiseCtor !== void 0 ? promiseCtor : config.Promise) !== null && _a2 !== void 0 ? _a2 : Promise;
  }
  function isObserver(value) {
    return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);
  }
  function isSubscriber(value) {
    return value && value instanceof Subscriber || isObserver(value) && isSubscription(value);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/lift.js
  function hasLift(source) {
    return isFunction(source === null || source === void 0 ? void 0 : source.lift);
  }
  function operate(init) {
    return function(source) {
      if (hasLift(source)) {
        return source.lift(function(liftedSource) {
          try {
            return init(liftedSource, this);
          } catch (err) {
            this.error(err);
          }
        });
      }
      throw new TypeError("Unable to lift unknown Observable type");
    };
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/OperatorSubscriber.js
  function createOperatorSubscriber(destination, onNext, onComplete, onError, onFinalize) {
    return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);
  }
  var OperatorSubscriber = function(_super) {
    __extends2(OperatorSubscriber2, _super);
    function OperatorSubscriber2(destination, onNext, onComplete, onError, onFinalize, shouldUnsubscribe) {
      var _this = _super.call(this, destination) || this;
      _this.onFinalize = onFinalize;
      _this.shouldUnsubscribe = shouldUnsubscribe;
      _this._next = onNext ? function(value) {
        try {
          onNext(value);
        } catch (err) {
          destination.error(err);
        }
      } : _super.prototype._next;
      _this._error = onError ? function(err) {
        try {
          onError(err);
        } catch (err2) {
          destination.error(err2);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._error;
      _this._complete = onComplete ? function() {
        try {
          onComplete();
        } catch (err) {
          destination.error(err);
        } finally {
          this.unsubscribe();
        }
      } : _super.prototype._complete;
      return _this;
    }
    OperatorSubscriber2.prototype.unsubscribe = function() {
      var _a2;
      if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {
        var closed_1 = this.closed;
        _super.prototype.unsubscribe.call(this);
        !closed_1 && ((_a2 = this.onFinalize) === null || _a2 === void 0 ? void 0 : _a2.call(this));
      }
    };
    return OperatorSubscriber2;
  }(Subscriber);

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/ObjectUnsubscribedError.js
  var ObjectUnsubscribedError = createErrorClass(function(_super) {
    return function ObjectUnsubscribedErrorImpl() {
      _super(this);
      this.name = "ObjectUnsubscribedError";
      this.message = "object unsubscribed";
    };
  });

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/Subject.js
  var Subject = function(_super) {
    __extends2(Subject2, _super);
    function Subject2() {
      var _this = _super.call(this) || this;
      _this.closed = false;
      _this.currentObservers = null;
      _this.observers = [];
      _this.isStopped = false;
      _this.hasError = false;
      _this.thrownError = null;
      return _this;
    }
    Subject2.prototype.lift = function(operator) {
      var subject = new AnonymousSubject(this, this);
      subject.operator = operator;
      return subject;
    };
    Subject2.prototype._throwIfClosed = function() {
      if (this.closed) {
        throw new ObjectUnsubscribedError();
      }
    };
    Subject2.prototype.next = function(value) {
      var _this = this;
      errorContext(function() {
        var e_1, _a2;
        _this._throwIfClosed();
        if (!_this.isStopped) {
          if (!_this.currentObservers) {
            _this.currentObservers = Array.from(_this.observers);
          }
          try {
            for (var _b2 = __values(_this.currentObservers), _c = _b2.next(); !_c.done; _c = _b2.next()) {
              var observer = _c.value;
              observer.next(value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a2 = _b2.return))
                _a2.call(_b2);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
      });
    };
    Subject2.prototype.error = function(err) {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.hasError = _this.isStopped = true;
          _this.thrownError = err;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().error(err);
          }
        }
      });
    };
    Subject2.prototype.complete = function() {
      var _this = this;
      errorContext(function() {
        _this._throwIfClosed();
        if (!_this.isStopped) {
          _this.isStopped = true;
          var observers = _this.observers;
          while (observers.length) {
            observers.shift().complete();
          }
        }
      });
    };
    Subject2.prototype.unsubscribe = function() {
      this.isStopped = this.closed = true;
      this.observers = this.currentObservers = null;
    };
    Object.defineProperty(Subject2.prototype, "observed", {
      get: function() {
        var _a2;
        return ((_a2 = this.observers) === null || _a2 === void 0 ? void 0 : _a2.length) > 0;
      },
      enumerable: false,
      configurable: true
    });
    Subject2.prototype._trySubscribe = function(subscriber) {
      this._throwIfClosed();
      return _super.prototype._trySubscribe.call(this, subscriber);
    };
    Subject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._checkFinalizedStatuses(subscriber);
      return this._innerSubscribe(subscriber);
    };
    Subject2.prototype._innerSubscribe = function(subscriber) {
      var _this = this;
      var _a2 = this, hasError = _a2.hasError, isStopped = _a2.isStopped, observers = _a2.observers;
      if (hasError || isStopped) {
        return EMPTY_SUBSCRIPTION;
      }
      this.currentObservers = null;
      observers.push(subscriber);
      return new Subscription(function() {
        _this.currentObservers = null;
        arrRemove(observers, subscriber);
      });
    };
    Subject2.prototype._checkFinalizedStatuses = function(subscriber) {
      var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, isStopped = _a2.isStopped;
      if (hasError) {
        subscriber.error(thrownError);
      } else if (isStopped) {
        subscriber.complete();
      }
    };
    Subject2.prototype.asObservable = function() {
      var observable2 = new Observable();
      observable2.source = this;
      return observable2;
    };
    Subject2.create = function(destination, source) {
      return new AnonymousSubject(destination, source);
    };
    return Subject2;
  }(Observable);
  var AnonymousSubject = function(_super) {
    __extends2(AnonymousSubject2, _super);
    function AnonymousSubject2(destination, source) {
      var _this = _super.call(this) || this;
      _this.destination = destination;
      _this.source = source;
      return _this;
    }
    AnonymousSubject2.prototype.next = function(value) {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.next) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, value);
    };
    AnonymousSubject2.prototype.error = function(err) {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.error) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, err);
    };
    AnonymousSubject2.prototype.complete = function() {
      var _a2, _b2;
      (_b2 = (_a2 = this.destination) === null || _a2 === void 0 ? void 0 : _a2.complete) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
    };
    AnonymousSubject2.prototype._subscribe = function(subscriber) {
      var _a2, _b2;
      return (_b2 = (_a2 = this.source) === null || _a2 === void 0 ? void 0 : _a2.subscribe(subscriber)) !== null && _b2 !== void 0 ? _b2 : EMPTY_SUBSCRIPTION;
    };
    return AnonymousSubject2;
  }(Subject);

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js
  var BehaviorSubject = function(_super) {
    __extends2(BehaviorSubject2, _super);
    function BehaviorSubject2(_value) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      return _this;
    }
    Object.defineProperty(BehaviorSubject2.prototype, "value", {
      get: function() {
        return this.getValue();
      },
      enumerable: false,
      configurable: true
    });
    BehaviorSubject2.prototype._subscribe = function(subscriber) {
      var subscription = _super.prototype._subscribe.call(this, subscriber);
      !subscription.closed && subscriber.next(this._value);
      return subscription;
    };
    BehaviorSubject2.prototype.getValue = function() {
      var _a2 = this, hasError = _a2.hasError, thrownError = _a2.thrownError, _value = _a2._value;
      if (hasError) {
        throw thrownError;
      }
      this._throwIfClosed();
      return _value;
    };
    BehaviorSubject2.prototype.next = function(value) {
      _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject2;
  }(Subject);

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduler/dateTimestampProvider.js
  var dateTimestampProvider = {
    now: function() {
      return (dateTimestampProvider.delegate || Date).now();
    },
    delegate: void 0
  };

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/ReplaySubject.js
  var ReplaySubject = function(_super) {
    __extends2(ReplaySubject2, _super);
    function ReplaySubject2(_bufferSize, _windowTime, _timestampProvider) {
      if (_bufferSize === void 0) {
        _bufferSize = Infinity;
      }
      if (_windowTime === void 0) {
        _windowTime = Infinity;
      }
      if (_timestampProvider === void 0) {
        _timestampProvider = dateTimestampProvider;
      }
      var _this = _super.call(this) || this;
      _this._bufferSize = _bufferSize;
      _this._windowTime = _windowTime;
      _this._timestampProvider = _timestampProvider;
      _this._buffer = [];
      _this._infiniteTimeWindow = true;
      _this._infiniteTimeWindow = _windowTime === Infinity;
      _this._bufferSize = Math.max(1, _bufferSize);
      _this._windowTime = Math.max(1, _windowTime);
      return _this;
    }
    ReplaySubject2.prototype.next = function(value) {
      var _a2 = this, isStopped = _a2.isStopped, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow, _timestampProvider = _a2._timestampProvider, _windowTime = _a2._windowTime;
      if (!isStopped) {
        _buffer.push(value);
        !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);
      }
      this._trimBuffer();
      _super.prototype.next.call(this, value);
    };
    ReplaySubject2.prototype._subscribe = function(subscriber) {
      this._throwIfClosed();
      this._trimBuffer();
      var subscription = this._innerSubscribe(subscriber);
      var _a2 = this, _infiniteTimeWindow = _a2._infiniteTimeWindow, _buffer = _a2._buffer;
      var copy = _buffer.slice();
      for (var i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {
        subscriber.next(copy[i]);
      }
      this._checkFinalizedStatuses(subscriber);
      return subscription;
    };
    ReplaySubject2.prototype._trimBuffer = function() {
      var _a2 = this, _bufferSize = _a2._bufferSize, _timestampProvider = _a2._timestampProvider, _buffer = _a2._buffer, _infiniteTimeWindow = _a2._infiniteTimeWindow;
      var adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;
      _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);
      if (!_infiniteTimeWindow) {
        var now = _timestampProvider.now();
        var last2 = 0;
        for (var i = 1; i < _buffer.length && _buffer[i] <= now; i += 2) {
          last2 = i;
        }
        last2 && _buffer.splice(0, last2 + 1);
      }
    };
    return ReplaySubject2;
  }(Subject);

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/empty.js
  var EMPTY = new Observable(function(subscriber) {
    return subscriber.complete();
  });

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isScheduler.js
  function isScheduler(value) {
    return value && isFunction(value.schedule);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/args.js
  function last(arr) {
    return arr[arr.length - 1];
  }
  function popResultSelector(args) {
    return isFunction(last(args)) ? args.pop() : void 0;
  }
  function popScheduler(args) {
    return isScheduler(last(args)) ? args.pop() : void 0;
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isArrayLike.js
  var isArrayLike = function(x) {
    return x && typeof x.length === "number" && typeof x !== "function";
  };

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isPromise.js
  function isPromise(value) {
    return isFunction(value === null || value === void 0 ? void 0 : value.then);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isInteropObservable.js
  function isInteropObservable(input) {
    return isFunction(input[observable]);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isAsyncIterable.js
  function isAsyncIterable(obj) {
    return Symbol.asyncIterator && isFunction(obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/throwUnobservableError.js
  function createInvalidObservableTypeError(input) {
    return new TypeError("You provided " + (input !== null && typeof input === "object" ? "an invalid object" : "'" + input + "'") + " where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.");
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/symbol/iterator.js
  function getSymbolIterator() {
    if (typeof Symbol !== "function" || !Symbol.iterator) {
      return "@@iterator";
    }
    return Symbol.iterator;
  }
  var iterator = getSymbolIterator();

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isIterable.js
  function isIterable(input) {
    return isFunction(input === null || input === void 0 ? void 0 : input[iterator]);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isReadableStreamLike.js
  function readableStreamLikeToAsyncGenerator(readableStream) {
    return __asyncGenerator(this, arguments, function readableStreamLikeToAsyncGenerator_1() {
      var reader, _a2, value, done;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            reader = readableStream.getReader();
            _b2.label = 1;
          case 1:
            _b2.trys.push([1, , 9, 10]);
            _b2.label = 2;
          case 2:
            if (false)
              return [3, 8];
            return [4, __await(reader.read())];
          case 3:
            _a2 = _b2.sent(), value = _a2.value, done = _a2.done;
            if (!done)
              return [3, 5];
            return [4, __await(void 0)];
          case 4:
            return [2, _b2.sent()];
          case 5:
            return [4, __await(value)];
          case 6:
            return [4, _b2.sent()];
          case 7:
            _b2.sent();
            return [3, 2];
          case 8:
            return [3, 10];
          case 9:
            reader.releaseLock();
            return [7];
          case 10:
            return [2];
        }
      });
    });
  }
  function isReadableStreamLike(obj) {
    return isFunction(obj === null || obj === void 0 ? void 0 : obj.getReader);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/innerFrom.js
  function innerFrom(input) {
    if (input instanceof Observable) {
      return input;
    }
    if (input != null) {
      if (isInteropObservable(input)) {
        return fromInteropObservable(input);
      }
      if (isArrayLike(input)) {
        return fromArrayLike(input);
      }
      if (isPromise(input)) {
        return fromPromise(input);
      }
      if (isAsyncIterable(input)) {
        return fromAsyncIterable(input);
      }
      if (isIterable(input)) {
        return fromIterable(input);
      }
      if (isReadableStreamLike(input)) {
        return fromReadableStreamLike(input);
      }
    }
    throw createInvalidObservableTypeError(input);
  }
  function fromInteropObservable(obj) {
    return new Observable(function(subscriber) {
      var obs = obj[observable]();
      if (isFunction(obs.subscribe)) {
        return obs.subscribe(subscriber);
      }
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    });
  }
  function fromArrayLike(array) {
    return new Observable(function(subscriber) {
      for (var i = 0; i < array.length && !subscriber.closed; i++) {
        subscriber.next(array[i]);
      }
      subscriber.complete();
    });
  }
  function fromPromise(promise) {
    return new Observable(function(subscriber) {
      promise.then(function(value) {
        if (!subscriber.closed) {
          subscriber.next(value);
          subscriber.complete();
        }
      }, function(err) {
        return subscriber.error(err);
      }).then(null, reportUnhandledError);
    });
  }
  function fromIterable(iterable) {
    return new Observable(function(subscriber) {
      var e_1, _a2;
      try {
        for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
          var value = iterable_1_1.value;
          subscriber.next(value);
          if (subscriber.closed) {
            return;
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (iterable_1_1 && !iterable_1_1.done && (_a2 = iterable_1.return))
            _a2.call(iterable_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      subscriber.complete();
    });
  }
  function fromAsyncIterable(asyncIterable) {
    return new Observable(function(subscriber) {
      process(asyncIterable, subscriber).catch(function(err) {
        return subscriber.error(err);
      });
    });
  }
  function fromReadableStreamLike(readableStream) {
    return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));
  }
  function process(asyncIterable, subscriber) {
    var asyncIterable_1, asyncIterable_1_1;
    var e_2, _a2;
    return __awaiter(this, void 0, void 0, function() {
      var value, e_2_1;
      return __generator(this, function(_b2) {
        switch (_b2.label) {
          case 0:
            _b2.trys.push([0, 5, 6, 11]);
            asyncIterable_1 = __asyncValues(asyncIterable);
            _b2.label = 1;
          case 1:
            return [4, asyncIterable_1.next()];
          case 2:
            if (!(asyncIterable_1_1 = _b2.sent(), !asyncIterable_1_1.done))
              return [3, 4];
            value = asyncIterable_1_1.value;
            subscriber.next(value);
            if (subscriber.closed) {
              return [2];
            }
            _b2.label = 3;
          case 3:
            return [3, 1];
          case 4:
            return [3, 11];
          case 5:
            e_2_1 = _b2.sent();
            e_2 = { error: e_2_1 };
            return [3, 11];
          case 6:
            _b2.trys.push([6, , 9, 10]);
            if (!(asyncIterable_1_1 && !asyncIterable_1_1.done && (_a2 = asyncIterable_1.return)))
              return [3, 8];
            return [4, _a2.call(asyncIterable_1)];
          case 7:
            _b2.sent();
            _b2.label = 8;
          case 8:
            return [3, 10];
          case 9:
            if (e_2)
              throw e_2.error;
            return [7];
          case 10:
            return [7];
          case 11:
            subscriber.complete();
            return [2];
        }
      });
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/executeSchedule.js
  function executeSchedule(parentSubscription, scheduler, work, delay, repeat) {
    if (delay === void 0) {
      delay = 0;
    }
    if (repeat === void 0) {
      repeat = false;
    }
    var scheduleSubscription = scheduler.schedule(function() {
      work();
      if (repeat) {
        parentSubscription.add(this.schedule(null, delay));
      } else {
        this.unsubscribe();
      }
    }, delay);
    parentSubscription.add(scheduleSubscription);
    if (!repeat) {
      return scheduleSubscription;
    }
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/observeOn.js
  function observeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source, subscriber) {
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.next(value);
        }, delay);
      }, function() {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.complete();
        }, delay);
      }, function(err) {
        return executeSchedule(subscriber, scheduler, function() {
          return subscriber.error(err);
        }, delay);
      }));
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/subscribeOn.js
  function subscribeOn(scheduler, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return operate(function(source, subscriber) {
      subscriber.add(scheduler.schedule(function() {
        return source.subscribe(subscriber);
      }, delay));
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleObservable.js
  function scheduleObservable(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/schedulePromise.js
  function schedulePromise(input, scheduler) {
    return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleArray.js
  function scheduleArray(input, scheduler) {
    return new Observable(function(subscriber) {
      var i = 0;
      return scheduler.schedule(function() {
        if (i === input.length) {
          subscriber.complete();
        } else {
          subscriber.next(input[i++]);
          if (!subscriber.closed) {
            this.schedule();
          }
        }
      });
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleIterable.js
  function scheduleIterable(input, scheduler) {
    return new Observable(function(subscriber) {
      var iterator2;
      executeSchedule(subscriber, scheduler, function() {
        iterator2 = input[iterator]();
        executeSchedule(subscriber, scheduler, function() {
          var _a2;
          var value;
          var done;
          try {
            _a2 = iterator2.next(), value = _a2.value, done = _a2.done;
          } catch (err) {
            subscriber.error(err);
            return;
          }
          if (done) {
            subscriber.complete();
          } else {
            subscriber.next(value);
          }
        }, 0, true);
      });
      return function() {
        return isFunction(iterator2 === null || iterator2 === void 0 ? void 0 : iterator2.return) && iterator2.return();
      };
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleAsyncIterable.js
  function scheduleAsyncIterable(input, scheduler) {
    if (!input) {
      throw new Error("Iterable cannot be null");
    }
    return new Observable(function(subscriber) {
      executeSchedule(subscriber, scheduler, function() {
        var iterator2 = input[Symbol.asyncIterator]();
        executeSchedule(subscriber, scheduler, function() {
          iterator2.next().then(function(result) {
            if (result.done) {
              subscriber.complete();
            } else {
              subscriber.next(result.value);
            }
          });
        }, 0, true);
      });
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduleReadableStreamLike.js
  function scheduleReadableStreamLike(input, scheduler) {
    return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/scheduled/scheduled.js
  function scheduled(input, scheduler) {
    if (input != null) {
      if (isInteropObservable(input)) {
        return scheduleObservable(input, scheduler);
      }
      if (isArrayLike(input)) {
        return scheduleArray(input, scheduler);
      }
      if (isPromise(input)) {
        return schedulePromise(input, scheduler);
      }
      if (isAsyncIterable(input)) {
        return scheduleAsyncIterable(input, scheduler);
      }
      if (isIterable(input)) {
        return scheduleIterable(input, scheduler);
      }
      if (isReadableStreamLike(input)) {
        return scheduleReadableStreamLike(input, scheduler);
      }
    }
    throw createInvalidObservableTypeError(input);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/from.js
  function from(input, scheduler) {
    return scheduler ? scheduled(input, scheduler) : innerFrom(input);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/of.js
  function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    return from(args, scheduler);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/isObservable.js
  function isObservable(obj) {
    return !!obj && (obj instanceof Observable || isFunction(obj.lift) && isFunction(obj.subscribe));
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/EmptyError.js
  var EmptyError = createErrorClass(function(_super) {
    return function EmptyErrorImpl() {
      _super(this);
      this.name = "EmptyError";
      this.message = "no elements in sequence";
    };
  });

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/firstValueFrom.js
  function firstValueFrom(source, config2) {
    var hasConfig = typeof config2 === "object";
    return new Promise(function(resolve, reject) {
      var subscriber = new SafeSubscriber({
        next: function(value) {
          resolve(value);
          subscriber.unsubscribe();
        },
        error: reject,
        complete: function() {
          if (hasConfig) {
            resolve(config2.defaultValue);
          } else {
            reject(new EmptyError());
          }
        }
      });
      source.subscribe(subscriber);
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/map.js
  function map(project, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        subscriber.next(project.call(thisArg, value, index++));
      }));
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/mapOneOrManyArgs.js
  var isArray = Array.isArray;
  function callOrApply(fn, args) {
    return isArray(args) ? fn.apply(void 0, __spreadArray2([], __read(args))) : fn(args);
  }
  function mapOneOrManyArgs(fn) {
    return map(function(args) {
      return callOrApply(fn, args);
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/argsArgArrayOrObject.js
  var isArray2 = Array.isArray;
  var getPrototypeOf = Object.getPrototypeOf;
  var objectProto = Object.prototype;
  var getKeys = Object.keys;
  function argsArgArrayOrObject(args) {
    if (args.length === 1) {
      var first_1 = args[0];
      if (isArray2(first_1)) {
        return { args: first_1, keys: null };
      }
      if (isPOJO(first_1)) {
        var keys = getKeys(first_1);
        return {
          args: keys.map(function(key) {
            return first_1[key];
          }),
          keys
        };
      }
    }
    return { args, keys: null };
  }
  function isPOJO(obj) {
    return obj && typeof obj === "object" && getPrototypeOf(obj) === objectProto;
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/util/createObject.js
  function createObject(keys, values) {
    return keys.reduce(function(result, key, i) {
      return result[key] = values[i], result;
    }, {});
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js
  function combineLatest() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var scheduler = popScheduler(args);
    var resultSelector = popResultSelector(args);
    var _a2 = argsArgArrayOrObject(args), observables = _a2.args, keys = _a2.keys;
    if (observables.length === 0) {
      return from([], scheduler);
    }
    var result = new Observable(combineLatestInit(observables, scheduler, keys ? function(values) {
      return createObject(keys, values);
    } : identity));
    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;
  }
  function combineLatestInit(observables, scheduler, valueTransform) {
    if (valueTransform === void 0) {
      valueTransform = identity;
    }
    return function(subscriber) {
      maybeSchedule(scheduler, function() {
        var length = observables.length;
        var values = new Array(length);
        var active = length;
        var remainingFirstValues = length;
        var _loop_1 = function(i2) {
          maybeSchedule(scheduler, function() {
            var source = from(observables[i2], scheduler);
            var hasFirstValue = false;
            source.subscribe(createOperatorSubscriber(subscriber, function(value) {
              values[i2] = value;
              if (!hasFirstValue) {
                hasFirstValue = true;
                remainingFirstValues--;
              }
              if (!remainingFirstValues) {
                subscriber.next(valueTransform(values.slice()));
              }
            }, function() {
              if (!--active) {
                subscriber.complete();
              }
            }));
          }, subscriber);
        };
        for (var i = 0; i < length; i++) {
          _loop_1(i);
        }
      }, subscriber);
    };
  }
  function maybeSchedule(scheduler, execute, subscription) {
    if (scheduler) {
      executeSchedule(subscription, scheduler, execute);
    } else {
      execute();
    }
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeInternals.js
  function mergeInternals(source, subscriber, project, concurrent, onBeforeNext, expand, innerSubScheduler, additionalFinalizer) {
    var buffer = [];
    var active = 0;
    var index = 0;
    var isComplete = false;
    var checkComplete = function() {
      if (isComplete && !buffer.length && !active) {
        subscriber.complete();
      }
    };
    var outerNext = function(value) {
      return active < concurrent ? doInnerSub(value) : buffer.push(value);
    };
    var doInnerSub = function(value) {
      expand && subscriber.next(value);
      active++;
      var innerComplete = false;
      innerFrom(project(value, index++)).subscribe(createOperatorSubscriber(subscriber, function(innerValue) {
        onBeforeNext === null || onBeforeNext === void 0 ? void 0 : onBeforeNext(innerValue);
        if (expand) {
          outerNext(innerValue);
        } else {
          subscriber.next(innerValue);
        }
      }, function() {
        innerComplete = true;
      }, void 0, function() {
        if (innerComplete) {
          try {
            active--;
            var _loop_1 = function() {
              var bufferedValue = buffer.shift();
              if (innerSubScheduler) {
                executeSchedule(subscriber, innerSubScheduler, function() {
                  return doInnerSub(bufferedValue);
                });
              } else {
                doInnerSub(bufferedValue);
              }
            };
            while (buffer.length && active < concurrent) {
              _loop_1();
            }
            checkComplete();
          } catch (err) {
            subscriber.error(err);
          }
        }
      }));
    };
    source.subscribe(createOperatorSubscriber(subscriber, outerNext, function() {
      isComplete = true;
      checkComplete();
    }));
    return function() {
      additionalFinalizer === null || additionalFinalizer === void 0 ? void 0 : additionalFinalizer();
    };
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeMap.js
  function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    if (isFunction(resultSelector)) {
      return mergeMap(function(a, i) {
        return map(function(b, ii) {
          return resultSelector(a, b, i, ii);
        })(innerFrom(project(a, i)));
      }, concurrent);
    } else if (typeof resultSelector === "number") {
      concurrent = resultSelector;
    }
    return operate(function(source, subscriber) {
      return mergeInternals(source, subscriber, project, concurrent);
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/mergeAll.js
  function mergeAll(concurrent) {
    if (concurrent === void 0) {
      concurrent = Infinity;
    }
    return mergeMap(identity, concurrent);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/concatAll.js
  function concatAll() {
    return mergeAll(1);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/concat.js
  function concat() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return concatAll()(from(args, popScheduler(args)));
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/observable/fromEvent.js
  var nodeEventEmitterMethods = ["addListener", "removeListener"];
  var eventTargetMethods = ["addEventListener", "removeEventListener"];
  var jqueryMethods = ["on", "off"];
  function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
      resultSelector = options;
      options = void 0;
    }
    if (resultSelector) {
      return fromEvent(target, eventName, options).pipe(mapOneOrManyArgs(resultSelector));
    }
    var _a2 = __read(isEventTarget(target) ? eventTargetMethods.map(function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler, options);
      };
    }) : isNodeStyleEventEmitter(target) ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName)) : isJQueryStyleEventEmitter(target) ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName)) : [], 2), add = _a2[0], remove2 = _a2[1];
    if (!add) {
      if (isArrayLike(target)) {
        return mergeMap(function(subTarget) {
          return fromEvent(subTarget, eventName, options);
        })(innerFrom(target));
      }
    }
    if (!add) {
      throw new TypeError("Invalid event target");
    }
    return new Observable(function(subscriber) {
      var handler = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return subscriber.next(1 < args.length ? args : args[0]);
      };
      add(handler);
      return function() {
        return remove2(handler);
      };
    });
  }
  function toCommonHandlerRegistry(target, eventName) {
    return function(methodName) {
      return function(handler) {
        return target[methodName](eventName, handler);
      };
    };
  }
  function isNodeStyleEventEmitter(target) {
    return isFunction(target.addListener) && isFunction(target.removeListener);
  }
  function isJQueryStyleEventEmitter(target) {
    return isFunction(target.on) && isFunction(target.off);
  }
  function isEventTarget(target) {
    return isFunction(target.addEventListener) && isFunction(target.removeEventListener);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/filter.js
  function filter(predicate, thisArg) {
    return operate(function(source, subscriber) {
      var index = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        return predicate.call(thisArg, value, index++) && subscriber.next(value);
      }));
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/take.js
  function take(count) {
    return count <= 0 ? function() {
      return EMPTY;
    } : operate(function(source, subscriber) {
      var seen = 0;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        if (++seen <= count) {
          subscriber.next(value);
          if (count <= seen) {
            subscriber.complete();
          }
        }
      }));
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/distinctUntilChanged.js
  function distinctUntilChanged(comparator, keySelector) {
    if (keySelector === void 0) {
      keySelector = identity;
    }
    comparator = comparator !== null && comparator !== void 0 ? comparator : defaultCompare;
    return operate(function(source, subscriber) {
      var previousKey;
      var first = true;
      source.subscribe(createOperatorSubscriber(subscriber, function(value) {
        var currentKey = keySelector(value);
        if (first || !comparator(previousKey, currentKey)) {
          first = false;
          previousKey = currentKey;
          subscriber.next(value);
        }
      }));
    });
  }
  function defaultCompare(a, b) {
    return a === b;
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/share.js
  function share(options) {
    if (options === void 0) {
      options = {};
    }
    var _a2 = options.connector, connector = _a2 === void 0 ? function() {
      return new Subject();
    } : _a2, _b2 = options.resetOnError, resetOnError = _b2 === void 0 ? true : _b2, _c = options.resetOnComplete, resetOnComplete = _c === void 0 ? true : _c, _d = options.resetOnRefCountZero, resetOnRefCountZero = _d === void 0 ? true : _d;
    return function(wrapperSource) {
      var connection;
      var resetConnection;
      var subject;
      var refCount = 0;
      var hasCompleted = false;
      var hasErrored = false;
      var cancelReset = function() {
        resetConnection === null || resetConnection === void 0 ? void 0 : resetConnection.unsubscribe();
        resetConnection = void 0;
      };
      var reset = function() {
        cancelReset();
        connection = subject = void 0;
        hasCompleted = hasErrored = false;
      };
      var resetAndUnsubscribe = function() {
        var conn = connection;
        reset();
        conn === null || conn === void 0 ? void 0 : conn.unsubscribe();
      };
      return operate(function(source, subscriber) {
        refCount++;
        if (!hasErrored && !hasCompleted) {
          cancelReset();
        }
        var dest = subject = subject !== null && subject !== void 0 ? subject : connector();
        subscriber.add(function() {
          refCount--;
          if (refCount === 0 && !hasErrored && !hasCompleted) {
            resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);
          }
        });
        dest.subscribe(subscriber);
        if (!connection && refCount > 0) {
          connection = new SafeSubscriber({
            next: function(value) {
              return dest.next(value);
            },
            error: function(err) {
              hasErrored = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnError, err);
              dest.error(err);
            },
            complete: function() {
              hasCompleted = true;
              cancelReset();
              resetConnection = handleReset(reset, resetOnComplete);
              dest.complete();
            }
          });
          innerFrom(source).subscribe(connection);
        }
      })(wrapperSource);
    };
  }
  function handleReset(reset, on) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    if (on === true) {
      reset();
      return;
    }
    if (on === false) {
      return;
    }
    var onSubscriber = new SafeSubscriber({
      next: function() {
        onSubscriber.unsubscribe();
        reset();
      }
    });
    return innerFrom(on.apply(void 0, __spreadArray2([], __read(args)))).subscribe(onSubscriber);
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/shareReplay.js
  function shareReplay(configOrBufferSize, windowTime, scheduler) {
    var _a2, _b2, _c;
    var bufferSize;
    var refCount = false;
    if (configOrBufferSize && typeof configOrBufferSize === "object") {
      _a2 = configOrBufferSize.bufferSize, bufferSize = _a2 === void 0 ? Infinity : _a2, _b2 = configOrBufferSize.windowTime, windowTime = _b2 === void 0 ? Infinity : _b2, _c = configOrBufferSize.refCount, refCount = _c === void 0 ? false : _c, scheduler = configOrBufferSize.scheduler;
    } else {
      bufferSize = configOrBufferSize !== null && configOrBufferSize !== void 0 ? configOrBufferSize : Infinity;
    }
    return share({
      connector: function() {
        return new ReplaySubject(bufferSize, windowTime, scheduler);
      },
      resetOnError: true,
      resetOnComplete: false,
      resetOnRefCountZero: refCount
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/startWith.js
  function startWith() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      values[_i] = arguments[_i];
    }
    var scheduler = popScheduler(values);
    return operate(function(source, subscriber) {
      (scheduler ? concat(values, source, scheduler) : concat(values, source)).subscribe(subscriber);
    });
  }

  // ../node_modules/.pnpm/rxjs@7.8.1/node_modules/rxjs/dist/esm5/internal/operators/takeUntil.js
  function takeUntil(notifier) {
    return operate(function(source, subscriber) {
      innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, function() {
        return subscriber.complete();
      }, noop));
      !subscriber.closed && source.subscribe(subscriber);
    });
  }

  // ../packages/core/src/observer/observable.ts
  var EventState = class {
    /**
     * Create a new EventState
     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     */
    constructor(skipNextObservers = false) {
      /**
       * An WorkBookObserver can set this property to true to prevent subsequent observers of being notified
       */
      __publicField(this, "skipNextObservers");
      /**
       * This will be populated with the return value of the last function that was executed.
       * If it is the first function in the callback chain it will be the event data.
       */
      __publicField(this, "lastReturnValue");
      __publicField(this, "isStopPropagation", false);
      this.initialize(skipNextObservers);
    }
    /**
     * Initialize the current event state
     * @param skipNextObservers defines a flag which will instruct the observable to skip following observers when set to true
     * @param target defines the original target of the state
     * @param currentTarget defines the current target of the state
     * @returns the current event state
     */
    initialize(skipNextObservers = false) {
      this.skipNextObservers = skipNextObservers;
      return this;
    }
    stopPropagation() {
      this.isStopPropagation = true;
    }
  };
  function isObserver2(value) {
    return value instanceof Observer;
  }
  var Observer = class {
    /**
     * Creates a new observer
     * @param callback defines the callback to call when the observer is notified
     */
    constructor(callback, observable2) {
      this.callback = callback;
      this.observable = observable2;
      /** @hidden */
      __publicField(this, "_willBeUnregistered", false);
      /**
       * Gets or sets a property defining that the observer as to be unregistered after the next notification
       */
      __publicField(this, "unregisterOnNextCall", false);
    }
    dispose() {
      this.observable.remove(this);
    }
  };
  var Observable2 = class _Observable {
    /**
     * Creates a new observable
     * @param onObserverAdded defines a callback to call when a new observer is added
     */
    constructor(onObserverAdded) {
      __publicField(this, "_observers", new Array());
      __publicField(this, "_eventState");
      __publicField(this, "_onObserverAdded");
      this._eventState = new EventState();
      if (onObserverAdded) {
        this._onObserverAdded = onObserverAdded;
      }
    }
    /**
     * Gets the list of observers
     */
    get observers() {
      return this._observers;
    }
    /**
     * Create a new WorkBookObserver with the specified callback
     * @param callback the callback that will be executed for that WorkBookObserver
     * @param insertFirst if true the callback will be inserted at the first position, hence executed before the others ones. If false (default behavior) the callback will be inserted at the last position, executed after all the others already present.
     * @param unregisterOnFirstCall defines if the observer as to be unregistered after the next notification
     * @returns the new observer created for the callback
     */
    add(callback, insertFirst = false, unregisterOnFirstCall = false) {
      if (!callback) {
        return null;
      }
      const observer = new Observer(callback, this);
      observer.unregisterOnNextCall = unregisterOnFirstCall;
      if (insertFirst) {
        this._observers.unshift(observer);
      } else {
        this._observers.push(observer);
      }
      if (this._onObserverAdded) {
        this._onObserverAdded(observer);
      }
      return observer;
    }
    /**
     * Create a new WorkBookObserver with the specified callback and unregisters after the next notification
     * @param callback the callback that will be executed for that WorkBookObserver
     * @returns the new observer created for the callback
     */
    addOnce(callback) {
      return this.add(callback, void 0, true);
    }
    /**
     * Remove an WorkBookObserver from the Observable object
     * @param observer the instance of the WorkBookObserver to remove
     * @returns false if it doesn't belong to this Observable
     */
    remove(observer) {
      if (!observer) {
        return false;
      }
      const index = this._observers.indexOf(observer);
      if (index !== -1) {
        this._deferUnregister(observer);
        return true;
      }
      return false;
    }
    /**
     * Remove a callback from the Observable object
     * @param callback the callback to remove
     * @returns false if it doesn't belong to this Observable
     */
    removeCallback(callback) {
      for (let index = 0; index < this._observers.length; index++) {
        const observer = this._observers[index];
        if (observer._willBeUnregistered) {
          continue;
        }
        if (observer.callback === callback) {
          this._deferUnregister(observer);
          return true;
        }
      }
      return false;
    }
    /**
     * Moves the observable to the top of the observer list making it get called first when notified
     * @param observer the observer to move
     */
    makeObserverTopPriority(observer) {
      this._remove(observer);
      this._observers.unshift(observer);
    }
    /**
     * Moves the observable to the bottom of the observer list making it get called last when notified
     * @param observer the observer to move
     */
    makeObserverBottomPriority(observer) {
      this._remove(observer);
      this._observers.push(observer);
    }
    /**
     * Notify all Observers by calling their respective callback with the given data
     * Will return true if all observers were executed, false if an observer set skipNextObservers to true, then prevent the subsequent ones to execute
     * @param eventData defines the data to send to all observers
     * @returns false if the complete observer chain was not processed (because one observer set the skipNextObservers to true)
     */
    notifyObservers(eventData) {
      if (!this._observers.length) {
        return null;
      }
      const state = this._eventState;
      state.skipNextObservers = false;
      state.lastReturnValue = eventData;
      state.isStopPropagation = false;
      let _isStopPropagation = false;
      for (let index = 0; index < this._observers.length; index++) {
        const obs = this._observers[index];
        if (obs._willBeUnregistered) {
          continue;
        }
        state.lastReturnValue = obs.callback(eventData, state);
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
        if (state.isStopPropagation) {
          _isStopPropagation = true;
        }
        if (state.skipNextObservers) {
          return {
            lastReturnValue: state.lastReturnValue,
            stopPropagation: _isStopPropagation
          };
        }
      }
      return {
        lastReturnValue: state.lastReturnValue,
        stopPropagation: _isStopPropagation
      };
    }
    /**
     * Calling this will execute each callback, expecting it to be a promise or return a value.
     * If at any point in the chain one function fails, the promise will fail and the execution will not continue.
     * This is useful when a chain of Events (sometimes async Events) is needed to initialize a certain object
     * and it is crucial that all callbacks will be executed.
     * The order of the callbacks is kept, callbacks are not executed parallel.
     *
     * @param eventData The data to be sent to each callback
     * @returns {Promise<T>} will return a Promise than resolves when all callbacks executed successfully.
     */
    notifyObserversWithPromise(eventData) {
      let p = Promise.resolve(eventData);
      if (!this._observers.length) {
        return p;
      }
      const state = this._eventState;
      state.skipNextObservers = false;
      for (let index = 0; index < this._observers.length; index++) {
        const obs = this._observers[index];
        if (state.skipNextObservers) {
          continue;
        }
        if (obs._willBeUnregistered) {
          continue;
        }
        p = p.then(() => obs.callback(eventData, state));
        if (obs.unregisterOnNextCall) {
          this._deferUnregister(obs);
        }
      }
      return p.then(() => eventData);
    }
    /**
     * Notify a specific observer
     * @param observer defines the observer to notify
     * @param eventData defines the data to be sent to each callback
     */
    notifyObserver(observer, eventData) {
      if (observer._willBeUnregistered) {
        return;
      }
      const state = this._eventState;
      state.skipNextObservers = false;
      observer.callback(eventData, state);
      if (observer.unregisterOnNextCall) {
        this._deferUnregister(observer);
      }
      return {
        lastReturnValue: state.lastReturnValue,
        stopPropagation: state.isStopPropagation
      };
    }
    /**
     * Gets a boolean indicating if the observable has at least one observer
     * @returns true is the Observable has at least one WorkBookObserver registered
     */
    hasObservers() {
      return this._observers.length > 0;
    }
    /**
     * Clear the list of observers
     */
    clear() {
      this._observers = new Array();
      this._onObserverAdded = null;
    }
    /**
     * Clone the current observable
     * @returns a new observable
     */
    clone() {
      const result = new _Observable();
      result._observers = this._observers.slice(0);
      return result;
    }
    _deferUnregister(observer) {
      observer.unregisterOnNextCall = false;
      observer._willBeUnregistered = true;
      setTimeout(() => {
        this._remove(observer);
      }, 0);
    }
    // This should only be called when not iterating over _observers to avoid callback skipping.
    // Removes an observer from the _observer Array.
    _remove(observer) {
      if (!observer) {
        return false;
      }
      const index = this._observers.indexOf(observer);
      if (index !== -1) {
        this._observers.splice(index, 1);
        return true;
      }
      return false;
    }
  };

  // ../packages/core/src/shared/lifecycle.ts
  function toDisposable(v) {
    let disposed = false;
    if (isSubscription(v)) {
      return {
        dispose: () => {
          if (disposed) {
            return;
          }
          disposed = true;
          v.unsubscribe();
        }
      };
    }
    if (isObserver2(v)) {
      return {
        dispose: () => {
          if (disposed) {
            return;
          }
          disposed = true;
          v.dispose();
        }
      };
    }
    return {
      dispose: () => {
        if (disposed) {
          return;
        }
        disposed = true;
        v();
      }
    };
  }
  var DisposableCollection = class {
    constructor() {
      __publicField(this, "_disposables", /* @__PURE__ */ new Set());
    }
    add(disposable) {
      this._disposables.add(disposable);
      return {
        dispose: () => {
          disposable.dispose();
          this._disposables.delete(disposable);
        }
      };
    }
    dispose() {
      this._disposables.forEach((item) => {
        item.dispose();
        this._disposables.delete(item);
      });
    }
  };
  var Disposable = class {
    constructor() {
      __publicField(this, "_disposed", false);
      __publicField(this, "_collection", new DisposableCollection());
    }
    disposeWithMe(disposable) {
      const d = isSubscription(disposable) ? toDisposable(disposable) : disposable;
      return this._collection.add(d);
    }
    dispose() {
      if (this._disposed) {
        return;
      }
      this._disposed = true;
      this._collection.dispose();
    }
  };
  var RxDisposable = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "dispose$", new Subject());
    }
    dispose() {
      super.dispose();
      this.dispose$.next();
      this.dispose$.complete();
    }
  };

  // ../packages/core/src/services/context/context.service.ts
  var IContextService = createIdentifier("univer.context-service");
  var ContextService = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_contextChanged$", new Subject());
      __publicField(this, "contextChanged$", this._contextChanged$.asObservable());
      __publicField(this, "_contextMap", /* @__PURE__ */ new Map());
    }
    dispose() {
      super.dispose();
      this._contextChanged$.complete();
    }
    getContextValue(key) {
      var _a2;
      return (_a2 = this._contextMap.get(key)) != null ? _a2 : false;
    }
    setContextValue(key, value) {
      this._contextMap.set(key, value);
      this._contextChanged$.next({ [key]: value });
    }
    subscribeContextValue$(key) {
      return new Observable((observer) => {
        const contextChangeSubscription = this._contextChanged$.pipe(filter((event) => typeof event[key] !== "undefined")).subscribe((event) => observer.next(event[key]));
        if (this._contextMap.has(key)) {
          observer.next(this._contextMap.get(key));
        }
        return () => contextChangeSubscription.unsubscribe();
      });
    }
  };

  // ../packages/core/src/services/log/log.service.ts
  var ILogService = createIdentifier("univer.log");
  var DesktopLogService = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_logLevel", 3 /* INFO */);
    }
    debug(...args) {
      if (this._logLevel >= 4 /* VERBOSE */) {
        this._log(console.debug, ...args);
      }
    }
    log(...args) {
      if (this._logLevel >= 3 /* INFO */) {
        this._log(console.log, ...args);
      }
    }
    warn(...args) {
      if (this._logLevel >= 2 /* WARN */) {
        this._log(console.warn, ...args);
      }
    }
    error(...args) {
      if (this._logLevel >= 1 /* ERROR */) {
        this._log(console.error, ...args);
      }
    }
    setLogLevel(logLevel) {
      this._logLevel = logLevel;
    }
    _log(method, ...args) {
      const firstArg = args[0];
      const withTag = /^\[(.*?)\]/g.test(firstArg);
      if (withTag) {
        method(`\x1B[97;104m${firstArg}\x1B[0m`, ...args.slice(1));
      } else {
        method(...args);
      }
    }
  };

  // ../packages/core/src/services/command/command.service.ts
  var ICommandService = createIdentifier("anywhere.command-service");
  var CommandRegistry = class {
    constructor() {
      __publicField(this, "_commands", /* @__PURE__ */ new Map());
    }
    registerCommand(command) {
      if (this._commands.has(command.id)) {
        throw new Error(`[CommandRegistry]: command "${command.id}" has been registered before.`);
      }
      this._commands.set(command.id, command);
      return toDisposable(() => {
        var _a2;
        this._commands.delete(command.id);
        (_a2 = command.onDispose) == null ? void 0 : _a2.call(command);
      });
    }
    getCommand(id) {
      if (!this._commands.has(id)) {
        return null;
      }
      return [this._commands.get(id)];
    }
  };
  var CommandService = class {
    constructor(_injector, _logService) {
      this._injector = _injector;
      this._logService = _logService;
      __publicField(this, "_commandRegistry");
      __publicField(this, "_beforeCommandExecutionListeners", []);
      __publicField(this, "_commandExecutedListeners", []);
      __publicField(this, "_multiCommandDisposables", /* @__PURE__ */ new Map());
      __publicField(this, "_commandExecutingLevel", 0);
      __publicField(this, "_commandExecutionStack", []);
      this._commandRegistry = new CommandRegistry();
      this._registerCommand(NilCommand);
    }
    registerCommand(command) {
      return this._registerCommand(command);
    }
    registerMultipleCommand(command) {
      return this._registerMultiCommand(command);
    }
    beforeCommandExecuted(listener) {
      if (this._beforeCommandExecutionListeners.indexOf(listener) === -1) {
        this._beforeCommandExecutionListeners.push(listener);
        return toDisposable(() => {
          const index = this._beforeCommandExecutionListeners.indexOf(listener);
          this._beforeCommandExecutionListeners.splice(index, 1);
        });
      }
      throw new Error("[CommandService]: could not add a listener twice.");
    }
    onCommandExecuted(listener) {
      if (this._commandExecutedListeners.indexOf(listener) === -1) {
        this._commandExecutedListeners.push(listener);
        return toDisposable(() => {
          const index = this._commandExecutedListeners.indexOf(listener);
          this._commandExecutedListeners.splice(index, 1);
        });
      }
      throw new Error("[CommandService]: could not add a listener twice.");
    }
    async executeCommand(id, params, options) {
      const item = this._commandRegistry.getCommand(id);
      if (item) {
        const [command] = item;
        const commandInfo = {
          id: command.id,
          type: command.type,
          params
        };
        const stackItemDisposable = this._pushCommandExecutionStack(commandInfo);
        this._beforeCommandExecutionListeners.forEach((listener) => listener(commandInfo, options));
        const result = await this._execute(command, params, options);
        this._commandExecutedListeners.forEach((listener) => listener(commandInfo, options));
        stackItemDisposable.dispose();
        return result;
      }
      throw new Error(`[CommandService]: command "${id}" is not registered.`);
    }
    syncExecuteCommand(id, params, options) {
      var _a2;
      const item = this._commandRegistry.getCommand(id);
      if (item) {
        const [command] = item;
        const commandInfo = {
          id: command.id,
          type: command.type,
          params
        };
        if (command.type === 2 /* MUTATION */) {
          const triggerCommand = findLast(
            this._commandExecutionStack,
            (item2) => item2.type === 0 /* COMMAND */
          );
          if (triggerCommand) {
            commandInfo.params = (_a2 = commandInfo.params) != null ? _a2 : {};
            commandInfo.params.trigger = triggerCommand.id;
          }
        }
        const stackItemDisposable = this._pushCommandExecutionStack(commandInfo);
        this._beforeCommandExecutionListeners.forEach((listener) => listener(commandInfo, options));
        const result = this._syncExecute(command, params, options);
        this._commandExecutedListeners.forEach((listener) => listener(commandInfo, options));
        stackItemDisposable.dispose();
        return result;
      }
      throw new Error(`[CommandService]: command "${id}" is not registered.`);
    }
    _pushCommandExecutionStack(stackItem) {
      this._commandExecutionStack.push(stackItem);
      return toDisposable(() => remove(this._commandExecutionStack, stackItem));
    }
    _registerCommand(command) {
      return this._commandRegistry.registerCommand(command);
    }
    _registerMultiCommand(command) {
      const registry = this._commandRegistry.getCommand(command.id);
      let multiCommand;
      if (!registry) {
        const disposableCollection = new DisposableCollection();
        multiCommand = new MultiCommand(command.id);
        disposableCollection.add(this._commandRegistry.registerCommand(multiCommand));
        disposableCollection.add(
          toDisposable(() => {
            this._multiCommandDisposables.delete(command.id);
          })
        );
        this._multiCommandDisposables.set(command.id, disposableCollection);
      } else {
        if (registry[0].multi !== true) {
          throw new Error("Command has registered as a single command.");
        } else {
          multiCommand = registry[0];
        }
      }
      const implementationDisposable = multiCommand.registerImplementation(command);
      return toDisposable(() => {
        var _a2;
        implementationDisposable.dispose();
        if (!multiCommand.hasImplementations()) {
          (_a2 = this._multiCommandDisposables.get(command.id)) == null ? void 0 : _a2.dispose();
        }
      });
    }
    async _execute(command, params, options) {
      this._logService.debug(
        "[CommandService]",
        `${"|-".repeat(Math.max(this._commandExecutingLevel, 0))}executing command "${command.id}"`
      );
      this._commandExecutingLevel++;
      let result;
      try {
        result = await this._injector.invoke(command.handler, params, options);
        this._commandExecutingLevel--;
      } catch (e) {
        result = false;
        this._commandExecutingLevel = 0;
        throw e;
      }
      return result;
    }
    _syncExecute(command, params, options) {
      this._logService.debug(
        "[CommandService]",
        `${"|-".repeat(Math.max(0, this._commandExecutingLevel))}executing command "${command.id}".`
      );
      this._commandExecutingLevel++;
      let result;
      try {
        result = this._injector.invoke(command.handler, params, options);
        if (result instanceof Promise) {
          throw new TypeError("[CommandService]: Command handler should not return a promise.");
        }
        this._commandExecutingLevel--;
      } catch (e) {
        result = false;
        this._commandExecutingLevel = 0;
        throw e;
      }
      return result;
    }
  };
  CommandService = __decorateClass([
    __decorateParam(0, Inject(Injector)),
    __decorateParam(1, ILogService)
  ], CommandService);
  var MultiCommand = class {
    constructor(id) {
      this.id = id;
      __publicField(this, "name");
      __publicField(this, "multi", true);
      __publicField(this, "type", 0 /* COMMAND */);
      __publicField(this, "priority", 0);
      __publicField(this, "_implementations", []);
      __publicField(this, "handler", async (accessor, params) => {
        if (!this._implementations.length) {
          return false;
        }
        const logService = accessor.get(ILogService);
        const contextService = accessor.get(IContextService);
        const injector = accessor.get(Injector);
        for (const item of this._implementations) {
          const preconditions = item.command.preconditions;
          if (!preconditions || preconditions && preconditions(contextService)) {
            logService.debug("[MultiCommand]", `executing implementation "${item.command.name}".`);
            const result = await injector.invoke(item.command.handler, params);
            if (result) {
              return true;
            }
          }
        }
        return false;
      });
      this.name = id;
    }
    registerImplementation(implementation) {
      const registry = { command: implementation };
      this._implementations.push(registry);
      this._implementations.sort((a, b) => b.command.priority - a.command.priority);
      return toDisposable(() => {
        var _a2;
        const index = this._implementations.indexOf(registry);
        this._implementations.splice(index, 1);
        (_a2 = implementation.onDispose) == null ? void 0 : _a2.call(implementation);
      });
    }
    hasImplementations() {
      return this._implementations.length > 0;
    }
  };
  function sequenceExecute(tasks, commandService, options) {
    const taskFns = tasks.map((task) => () => commandService.syncExecuteCommand(task.id, task.params, options));
    return sequence(taskFns);
  }
  var NilCommand = {
    id: "nil",
    type: 0 /* COMMAND */,
    handler: () => true
  };

  // ../packages/core/src/services/config/config.service.ts
  var IConfigService = createIdentifier("univer.config-service");
  var ConfigService = class {
    constructor() {
      __publicField(this, "_config", /* @__PURE__ */ new Map());
    }
    getConfig(id) {
      return this._config.get(id);
    }
    setConfig(id, value) {
      this._config.set(id, value);
    }
    deleteConfig(id) {
      this._config.delete(id);
    }
  };

  // ../packages/core/src/services/error/error.service.ts
  var ErrorService = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_error$", new Subject());
      __publicField(this, "error$", this._error$.asObservable());
    }
    dispose() {
      this._error$.complete();
    }
    emit(key) {
      this._error$.next({ errorKey: key });
    }
  };

  // ../packages/core/src/services/floating-object/floating-object-manager.service.ts
  var FloatingObjectManagerService = class {
    constructor() {
      __publicField(this, "_managerInfo", /* @__PURE__ */ new Map());
      /**
       * The deletion action is triggered and broadcasted within the core business plugin.
       * Upon receiving the deletion broadcast, the plugin executes the plugin command logic.
       */
      __publicField(this, "_remove$", new Subject());
      __publicField(this, "remove$", this._remove$.asObservable());
      /**
       * Addition and updates are also triggered and broadcasted within the core business plugin.
       * Upon receiving the update broadcast, the plugin updates the location of its business components.
       */
      __publicField(this, "_andOrUpdate$", new Subject());
      __publicField(this, "andOrUpdate$", this._andOrUpdate$.asObservable());
      /**
       * The position, width, and height of the plugin's business components can be changed by the user through interface operations.
       * Here, it is necessary to notify the core business plugin to update the relevant location model.
       * The logic converges in the core business plugin.
       */
      __publicField(this, "_pluginUpdate$", new Subject());
      __publicField(this, "pluginUpdate$", this._pluginUpdate$.asObservable());
    }
    getFloatObject(searchItem) {
      return this._getFloatingObject(searchItem);
    }
    getFloatObjects(search) {
      return this._getFloatingObjects(search);
    }
    dispose() {
      this._remove$.complete();
      this._andOrUpdate$.complete();
      this._pluginUpdate$.complete();
      this._managerInfo.clear();
    }
    clear(search) {
      const searchObjects = this._clearByParam(search);
      this._remove$.next(searchObjects);
    }
    addOrUpdate(insertParam) {
      const searchObjects = this._addByParam(insertParam);
      this._andOrUpdate$.next(searchObjects);
    }
    BatchAddOrUpdate(insertParams) {
      const searchObjects = [];
      insertParams.forEach((insertParam) => {
        searchObjects.push(...this._addByParam(insertParam));
      });
      this._andOrUpdate$.next(searchObjects);
    }
    remove(searchItem) {
      const searchObjects = this._removeByParam(searchItem);
      this._remove$.next(searchObjects);
    }
    pluginUpdateRefresh(updateObjects) {
      this._pluginUpdate$.next(updateObjects);
    }
    _getFloatingObjects(param) {
      var _a2;
      if (param == null) {
        return;
      }
      const { unitId, subUnitId } = param;
      return (_a2 = this._managerInfo.get(unitId)) == null ? void 0 : _a2.get(subUnitId);
    }
    _getFloatingObject(param) {
      var _a2, _b2;
      if (param == null) {
        return;
      }
      const { unitId, subUnitId, floatingObjectId } = param;
      return (_b2 = (_a2 = this._managerInfo.get(unitId)) == null ? void 0 : _a2.get(subUnitId)) == null ? void 0 : _b2.get(floatingObjectId);
    }
    _addByParam(insertParam) {
      const { unitId, subUnitId, floatingObject, floatingObjectId } = insertParam;
      if (!this._managerInfo.has(unitId)) {
        this._managerInfo.set(unitId, /* @__PURE__ */ new Map());
      }
      const subComponentData = this._managerInfo.get(unitId);
      if (!subComponentData.has(subUnitId)) {
        subComponentData.set(subUnitId, /* @__PURE__ */ new Map());
      }
      subComponentData.get(subUnitId).set(floatingObjectId, floatingObject);
      return [{ unitId, subUnitId, floatingObjectId, floatingObject }];
    }
    _clearByParam(param) {
      const floatingObjects = this._getFloatingObjects(param);
      const { unitId, subUnitId } = param;
      const refreshObjects = [];
      floatingObjects == null ? void 0 : floatingObjects.forEach((value, key) => {
        refreshObjects.push({
          unitId,
          subUnitId,
          floatingObjectId: key,
          floatingObject: value
        });
      });
      floatingObjects == null ? void 0 : floatingObjects.clear();
      return refreshObjects;
    }
    _removeByParam(param) {
      const floatingObjects = this._getFloatingObjects(param);
      const item = floatingObjects == null ? void 0 : floatingObjects.get(param.floatingObjectId);
      if (item == null) {
        return [];
      }
      floatingObjects == null ? void 0 : floatingObjects.delete(param.floatingObjectId);
      return [{ ...param, floatingObject: item }];
    }
  };
  var IFloatingObjectManagerService = createIdentifier(
    "univer.floating-object.service"
  );

  // ../packages/core/src/common/memory-cursor.ts
  var MemoryCursor = class {
    constructor() {
      __publicField(this, "cursor", 0);
    }
    reset() {
      this.cursor = 0;
      return this;
    }
    moveCursor(pos) {
      this.cursor += pos;
    }
    moveCursorTo(pos) {
      this.cursor = pos;
    }
  };

  // ../packages/core/src/shared/array-search.ts
  function binarySearchArray(arr, pos) {
    let low = 0;
    let high = arr.length - 1;
    while (low <= high) {
      const mid = Math.floor((high + low) / 2);
      if (pos < arr[mid] && (mid === 0 || pos >= arr[mid - 1])) {
        return mid;
      }
      if (pos >= arr[mid]) {
        low = mid + 1;
      } else if (pos < arr[mid]) {
        high = mid - 1;
      } else {
        return -1;
      }
    }
    return -1;
  }
  function orderSearchArray(arr, pos) {
    let i = 0;
    let cur = 0;
    let cur_pre = 0;
    let cur_index = -1;
    let i_ed = arr.length - 1;
    while (i < arr.length && i_ed >= 0 && i_ed >= i) {
      cur = arr[i_ed];
      if (i_ed === 0) {
        cur_pre = 0;
      } else {
        cur_pre = arr[i_ed - 1];
      }
      if (pos >= cur_pre && pos <= cur) {
        cur_index = i_ed;
        break;
      }
      cur = arr[i];
      if (i === 0) {
        cur_pre = 0;
      } else {
        cur_pre = arr[i - 1];
      }
      if (pos >= cur_pre && pos < cur) {
        cur_index = i;
        break;
      }
      i++;
      i_ed--;
    }
    return cur_index;
  }
  function searchArray(arr, num) {
    let index = arr.length - 1;
    if (num < 0) {
      return -1;
    }
    if (num < arr[0]) {
      return 0;
    }
    if (num > arr[arr.length - 1]) {
      return Number.POSITIVE_INFINITY;
    }
    if (arr.length < 40 || num <= arr[20] || num >= arr[index - 20]) {
      index = orderSearchArray(arr, num);
    } else {
      index = binarySearchArray(arr, num);
    }
    return index;
  }

  // ../packages/core/src/types/const/theme-color-map.ts
  var THEME_COLORS = {
    ["Office" /* OFFICE */]: {
      [4 /* ACCENT1 */]: "#4472C4",
      [5 /* ACCENT2 */]: "#ED7D31",
      [6 /* ACCENT3 */]: "#A5A5A5",
      [7 /* ACCENT4 */]: "#70AD47",
      [8 /* ACCENT5 */]: "#5B9BD5",
      [9 /* ACCENT6 */]: "#70AD47",
      [0 /* DARK1 */]: "#000000",
      [2 /* DARK2 */]: "#44546A",
      [1 /* LIGHT1 */]: "#FFFFFF",
      [3 /* LIGHT2 */]: "#E7E6E6",
      [10 /* HYPERLINK */]: "#0563C1",
      [11 /* FOLLOWED_HYPERLINK */]: "#954F72"
    }
  };

  // ../packages/core/src/shared/color/color.ts
  var ColorBuilder = class {
    constructor() {
      __publicField(this, "_themeValue", 1 /* LIGHT1 */);
      __publicField(this, "_themeColors");
      __publicField(this, "_themeTint");
      __publicField(this, "_rgbValue", "");
      __publicField(this, "_colorType");
      this._colorType = 0 /* UNSUPPORTED */;
      this._themeColors = "Office" /* OFFICE */;
      this._themeTint = 0;
    }
    asRgbColor() {
      return new RgbColor(this._rgbValue, this);
    }
    asThemeColor() {
      return new ThemeColor(this._themeValue, this._themeTint, this._themeColors, this);
    }
    build() {
      switch (this._colorType) {
        case 3 /* THEME */: {
          return this.asThemeColor();
        }
        case 1 /* RGB */: {
          return this.asRgbColor();
        }
        case 0 /* UNSUPPORTED */: {
          throw new Error("unsupported color type");
        }
      }
    }
    setRgbColor(cssString) {
      this._colorType = 1 /* RGB */;
      this._rgbValue = cssString;
      return this;
    }
    setThemeColors(value) {
      this._colorType = 3 /* THEME */;
      this._themeColors = value;
    }
    setThemeTint(value) {
      this._colorType = 3 /* THEME */;
      this._themeTint = value;
    }
    setThemeColor(theme) {
      this._colorType = 3 /* THEME */;
      this._themeValue = theme;
      return this;
    }
    getColorType() {
      return this._colorType;
    }
  };
  var Color = class _Color {
    constructor(builder) {
      __publicField(this, "_builder");
      this._builder = builder;
    }
    static rgbColorToHexValue(color) {
      return `#${((1 << 24) + (color.getRed() << 16) + (color.getGreen() << 8) + color.getBlue()).toString(16).slice(1)}`;
    }
    static hexValueToRgbColor(hexValue) {
      if (hexValue) {
        if (hexValue.indexOf("#") > -1) {
          hexValue = hexValue.substring(1);
        }
      } else {
        hexValue = "#000000";
      }
      const r = +`0x${hexValue[0]}${hexValue[1]}`;
      const g = +`0x${hexValue[2]}${hexValue[3]}`;
      const b = +`0x${hexValue[4]}${hexValue[5]}`;
      return new ColorBuilder().setRgbColor(`rgb(${r},${g},${b})`).asRgbColor();
    }
    static hexToRgbString(hex) {
      const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      let string = null;
      if (result) {
        const r = Number.parseInt(result[1], 16);
        const g = Number.parseInt(result[2], 16);
        const b = Number.parseInt(result[3], 16);
        string = `rgba(${r},${g},${b})`;
      }
      return string;
    }
    asRgbColor() {
      return this._builder.asRgbColor();
    }
    asThemeColor() {
      return this._builder.asThemeColor();
    }
    getColorType() {
      return this._builder.getColorType();
    }
    clone() {
      return new _Color(this._builder);
    }
    equals(color) {
      return false;
    }
  };
  var HLSColor = class {
    constructor(rgbColor) {
      __publicField(this, "_saturation", 0);
      __publicField(this, "_hue", 0);
      __publicField(this, "_lightness", 0);
      __publicField(this, "_alpha", 0);
      const red = rgbColor.getRed() / 255;
      const green = rgbColor.getGreen() / 255;
      const blue = rgbColor.getBlue() / 255;
      const alpha2 = rgbColor.getAlpha() / 255;
      const min = Math.min(red, Math.min(green, blue));
      const max = Math.max(red, Math.max(green, blue));
      const delta = max - min;
      if (max === min) {
        this._hue = 0;
        this._saturation = 0;
        this._lightness = max;
        return;
      }
      this._lightness = (min + max) / 2;
      if (this._lightness < 0.5) {
        this._saturation = delta / (max + min);
      } else {
        this._saturation = delta / (2 - max - min);
      }
      if (red === max) {
        this._hue = (green - blue) / delta;
      }
      if (green === max) {
        this._hue = 2 + (blue - red) / delta;
      }
      if (blue === max) {
        this._hue = 4 + (red - green) / delta;
      }
      this._hue *= 60;
      if (this._hue < 0) {
        this._hue += 360;
      }
      this._alpha = alpha2;
    }
    asRgbColor() {
      const builder = new ColorBuilder();
      if (this._saturation === 0) {
        builder.setRgbColor(
          `rgba(${this._lightness * 255},${this._lightness * 255},${this._lightness * 255},${this._alpha * 255})`
        );
        return builder.asRgbColor();
      }
      let t1;
      if (this._lightness < 0.5) {
        t1 = this._lightness * (1 + this._saturation);
      } else {
        t1 = this._lightness + this._saturation - this._lightness * this._saturation;
      }
      const t2 = 2 * this._lightness - t1;
      const hue = this._hue / 360;
      const tR = hue + 1 / 3;
      const red = this.setColor(t1, t2, tR);
      const green = this.setColor(t1, t2, hue);
      const tB = hue - 1 / 3;
      const blue = this.setColor(t1, t2, tB);
      builder.setRgbColor(
        `rgba(${Math.round(red * 255)},${Math.round(green * 255)},${Math.round(blue * 255)},${this._alpha * 255})`
      );
      return builder.asRgbColor();
    }
    getLightness() {
      return this._lightness;
    }
    getHue() {
      return this._hue;
    }
    getSaturation() {
      return this._saturation;
    }
    getAlpha() {
      return this._alpha;
    }
    setColor(t1, t2, t3) {
      if (t3 < 0) {
        t3 += 1;
      }
      if (t3 > 1) {
        t3 -= 1;
      }
      let color;
      if (6 * t3 < 1) {
        color = t2 + (t1 - t2) * 6 * t3;
      } else if (2 * t3 < 1) {
        color = t1;
      } else if (3 * t3 < 2) {
        color = t2 + (t1 - t2) * (2 / 3 - t3) * 6;
      } else {
        color = t2;
      }
      return color;
    }
    setLightness(lightness) {
      this._lightness = lightness;
    }
  };
  var _RgbColor = class _RgbColor extends Color {
    constructor(cssString, builder) {
      super(builder);
      __publicField(this, "_cssString");
      __publicField(this, "_red");
      __publicField(this, "_green");
      __publicField(this, "_blue");
      __publicField(this, "_alpha");
      let match = cssString.match(_RgbColor.RGBA_EXTRACT);
      if (match) {
        const red = +match[1];
        const green = +match[2];
        const blue = +match[3];
        const alpha2 = +match[4];
        this._cssString = cssString;
        this._red = red;
        this._green = green;
        this._blue = blue;
        this._alpha = alpha2;
        return;
      }
      match = cssString.match(_RgbColor.RGB_EXTRACT);
      if (match) {
        const red = +match[1];
        const green = +match[2];
        const blue = +match[3];
        this._cssString = cssString;
        this._red = red;
        this._green = green;
        this._blue = blue;
        this._alpha = 1;
        return;
      }
      throw new Error("Invalid rgba or rgb color");
    }
    asHexString() {
      return Color.rgbColorToHexValue(this);
    }
    getRed() {
      let r = this._red + _RgbColor.RGB_COLOR_AMT;
      if (r > 255) {
        r = 255;
      } else if (r < 0) {
        r = 0;
      }
      return r;
    }
    getGreen() {
      let g = this._green + _RgbColor.RGB_COLOR_AMT;
      if (g > 255) {
        g = 255;
      } else if (g < 0) {
        g = 0;
      }
      return g;
    }
    getBlue() {
      let b = this._blue + _RgbColor.RGB_COLOR_AMT;
      if (b > 255) {
        b = 255;
      } else if (b < 0) {
        b = 0;
      }
      return b;
    }
    getAlpha() {
      return this._alpha;
    }
    getColorType() {
      return 1 /* RGB */;
    }
    clone() {
      return new _RgbColor(this._cssString, this._builder);
    }
    asThemeColor() {
      throw new Error("rgb color not support to themeColor");
    }
    equals(color) {
      if (color instanceof _RgbColor) {
        return color._red === this._red && color._blue === this._blue && color._green === this._green && color._alpha === this._alpha;
      }
      return false;
    }
    getCssString() {
      return this._cssString;
    }
  };
  __publicField(_RgbColor, "RGB_COLOR_AMT", 0);
  __publicField(_RgbColor, "RGBA_EXTRACT", new RegExp(
    "\\s*rgba\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d.\\d|\\d\\s*)\\)\\s*"
  ));
  __publicField(_RgbColor, "RGB_EXTRACT", new RegExp("\\s*rgb\\s*\\((\\s*\\d+\\s*),(\\s*\\d+\\s*),(\\s*\\d+\\s*)\\)\\s*"));
  var RgbColor = _RgbColor;
  var _ThemeColor = class _ThemeColor extends Color {
    constructor(theme, themeTint, themeColors, builder) {
      super(builder);
      __publicField(this, "_themeColorType");
      __publicField(this, "_themeTint");
      __publicField(this, "_themeColors");
      this._themeColorType = theme;
      this._themeTint = themeTint;
      this._themeColors = themeColors;
    }
    lumValue(tint, lum) {
      if (tint == null) {
        return lum;
      }
      let value;
      if (tint < 0) {
        value = lum * (1 + tint);
      } else {
        value = lum * (1 - tint) + (255 - 255 * (1 - tint));
      }
      return value;
    }
    asRgbColor() {
      const themeColors = THEME_COLORS[this._themeColors];
      if (themeColors == null) {
        throw new Error("not find themeColors type");
      }
      const hexValue = themeColors[this._themeColorType];
      if (hexValue == null) {
        throw new Error("not find themeColors value");
      }
      let themeCache;
      if (_ThemeColor._cacheThemeColor.has(this._themeColors)) {
        themeCache = _ThemeColor._cacheThemeColor.get(this._themeColors);
        if (themeCache.has(this._themeColorType)) {
          return themeCache.get(this._themeColorType);
        }
      } else {
        themeCache = /* @__PURE__ */ new Map();
        _ThemeColor._cacheThemeColor.set(this._themeColors, themeCache);
      }
      const hlsColor = new HLSColor(Color.hexValueToRgbColor(hexValue));
      hlsColor.setLightness(this.lumValue(this._themeTint, hlsColor.getLightness() * 255) / 255);
      const rgbColor = hlsColor.asRgbColor();
      themeCache.set(this._themeColorType, rgbColor);
      return rgbColor;
    }
    clone() {
      return new _ThemeColor(this._themeColorType, this._themeTint, this._themeColors, this._builder);
    }
    equals(color) {
      if (color instanceof _ThemeColor) {
        return color._themeColorType === this._themeColorType;
      }
      return false;
    }
    getColorType() {
      return 3 /* THEME */;
    }
    getThemeColorType() {
      return this._themeColorType;
    }
  };
  __publicField(_ThemeColor, "_cacheThemeColor", /* @__PURE__ */ new Map());
  var ThemeColor = _ThemeColor;

  // ../packages/core/src/shared/color/color-kit.ts
  var COLORS = {
    aliceBlue: [240, 248, 255],
    antiqueWhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blancheAlmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueViolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlyWood: [222, 184, 135],
    cadetBlue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornFlowerBlue: [100, 149, 237],
    cornSilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkCyan: [0, 139, 139],
    darkGoldenrod: [184, 132, 11],
    darkGray: [169, 169, 169],
    darkGreen: [0, 100, 0],
    darkGrey: [169, 169, 169],
    darkKhaki: [189, 183, 107],
    darkMagenta: [139, 0, 139],
    darkOliveGreen: [85, 107, 47],
    darkOrange: [255, 140, 0],
    darkOrchid: [153, 50, 204],
    darkRed: [139, 0, 0],
    darkSalmon: [233, 150, 122],
    darkSeaGreen: [143, 188, 143],
    darkSlateBlue: [72, 61, 139],
    darkSlateGray: [47, 79, 79],
    darkSlateGrey: [47, 79, 79],
    darkTurquoise: [0, 206, 209],
    darkViolet: [148, 0, 211],
    deepPink: [255, 20, 147],
    deepSkyBlue: [0, 191, 255],
    dimGray: [105, 105, 105],
    dimGrey: [105, 105, 105],
    dodgerBlue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralWhite: [255, 255, 240],
    forestGreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostWhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenYellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotPink: [255, 105, 180],
    indianRed: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderBlush: [255, 240, 245],
    lawnGreen: [124, 252, 0],
    lemonChiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightCoral: [240, 128, 128],
    lightCyan: [224, 255, 255],
    lightGoldenrodYellow: [250, 250, 210],
    lightGray: [211, 211, 211],
    lightGreen: [144, 238, 144],
    lightGrey: [211, 211, 211],
    lightPink: [255, 182, 193],
    lightSalmon: [255, 160, 122],
    lightSeaGreen: [32, 178, 170],
    lightSkyBlue: [135, 206, 250],
    lightSlateGray: [119, 136, 153],
    lightSlateGrey: [119, 136, 153],
    lightSteelBlue: [176, 196, 222],
    lightYellow: [255, 255, 224],
    lime: [0, 255, 0],
    limeGreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumAquamarine: [102, 205, 170],
    mediumBlue: [0, 0, 205],
    mediumOrchid: [186, 85, 211],
    mediumPurple: [147, 112, 219],
    mediumSeaGreen: [60, 179, 113],
    mediumSlateBlue: [123, 104, 238],
    mediumSpringGreen: [0, 250, 154],
    mediumTurquoise: [72, 209, 204],
    mediumVioletRed: [199, 21, 133],
    midBightBlue: [25, 25, 112],
    mintCream: [245, 255, 250],
    mistyRose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajoWhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldLace: [253, 245, 230],
    olive: [128, 128, 0],
    oliveDrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangeRed: [255, 69, 0],
    orchid: [218, 112, 214],
    paleGoldenrod: [238, 232, 170],
    paleGreen: [152, 251, 152],
    paleTurquoise: [175, 238, 238],
    paleVioletRed: [219, 112, 147],
    papayaWhip: [255, 239, 213],
    peachPuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 203],
    powderBlue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccaPurple: [102, 51, 153],
    red: [255, 0, 0],
    rosyBrown: [188, 143, 143],
    royalBlue: [65, 105, 225],
    saddleBrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandyBrown: [244, 164, 96],
    seaGreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyBlue: [135, 206, 235],
    slateBlue: [106, 90, 205],
    slateGray: [119, 128, 144],
    slateGrey: [119, 128, 144],
    snow: [255, 255, 250],
    springGreen: [0, 255, 127],
    steelBlue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    transparent: [255, 255, 255, 0],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whiteSmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowGreen: [154, 205, 5]
  };
  function isWhiteColor(color) {
    const hexRegex = /^#(?:[Ff]{3}|[Ff]{6})\b/;
    const rgbRegex = /^rgb\s*\(\s*255\s*,\s*255\s*,\s*255\s*\)$/;
    const rgbaRegex = /^rgba\s*\(\s*255\s*,\s*255\s*,\s*255\s*,\s*(1|1\.0*|0?\.\d+)\)$/;
    const hslRegex = /^hsl\s*\(\s*0*\s*,\s*0%*\s*,\s*100%*\s*\)$/;
    const hslaRegex = /^hsla\s*\(\s*0*\s*,\s*0%*\s*,\s*100%*\s*,\s*(1|1\.0*|0?\.\d+)\)$/;
    if (hexRegex.test(color)) {
      return true;
    }
    if (rgbRegex.test(color)) {
      return true;
    }
    if (rgbaRegex.test(color)) {
      return true;
    }
    if (hslRegex.test(color)) {
      return true;
    }
    if (hslaRegex.test(color)) {
      return true;
    }
    return false;
  }

  // ../node_modules/.pnpm/nanoid@5.0.6/node_modules/nanoid/url-alphabet/index.js
  var urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";

  // ../node_modules/.pnpm/nanoid@5.0.6/node_modules/nanoid/index.browser.js
  var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
  var customRandom = (alphabet, defaultSize, getRandom) => {
    let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
    let step = -~(1.6 * mask * defaultSize / alphabet.length);
    return (size = defaultSize) => {
      let id = "";
      while (true) {
        let bytes = getRandom(step);
        let j = step;
        while (j--) {
          id += alphabet[bytes[j] & mask] || "";
          if (id.length === size)
            return id;
        }
      }
    };
  };
  var customAlphabet = (alphabet, size = 21) => customRandom(alphabet, size, random);
  var nanoid = (size = 21) => {
    let id = "";
    let bytes = crypto.getRandomValues(new Uint8Array(size));
    while (size--) {
      id += urlAlphabet[bytes[size] & 63];
    }
    return id;
  };

  // ../packages/core/src/shared/tools.ts
  var rmsPrefix = /^-ms-/;
  var rDashAlpha = /-([a-z])/g;
  var alphabets = [
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z"
  ];
  var Tools = class _Tools {
    static stringAt(index) {
      let str = "";
      let idx = index;
      while (idx >= alphabets.length) {
        idx /= alphabets.length;
        idx -= 1;
        str += alphabets[idx % alphabets.length];
      }
      const last2 = index % alphabets.length;
      str += alphabets[last2];
      return str;
    }
    static indexAt(code) {
      let ret = 0;
      for (let i = 0; i < code.length - 1; i += 1) {
        const idx = code.charCodeAt(i) - 65;
        const expoNet = code.length - 1 - i;
        ret += alphabets.length ** expoNet + alphabets.length * idx;
      }
      ret += code.charCodeAt(code.length - 1) - 65;
      return ret;
    }
    static deleteBlank(value) {
      if (_Tools.isString(value)) {
        return value.replace(/\s/g, "");
      }
      return value;
    }
    static getSystemType() {
      const sUserAgent = navigator.userAgent;
      const isWin = navigator.platform === "Win32" || navigator.platform === "Windows";
      const isMac = navigator.platform === "Mac68K" || navigator.platform === "MacPPC" || navigator.platform === "Macintosh" || navigator.platform === "MacIntel";
      if (isMac)
        return "Mac";
      const isUnix = navigator.platform === "X11" && !isWin && !isMac;
      if (isUnix)
        return "Unix";
      const isLinux = String(navigator.platform).indexOf("Linux") > -1;
      if (isLinux)
        return "Linux";
      if (isWin) {
        const isWin2K = sUserAgent.indexOf("Windows NT 5.0") > -1 || sUserAgent.indexOf("Windows 2000") > -1;
        if (isWin2K)
          return "Windows 2000";
        const isWinXP = sUserAgent.indexOf("Windows NT 5.1") > -1 || sUserAgent.indexOf("Windows XP") > -1;
        if (isWinXP)
          return "Windows XP";
        const isWin2003 = sUserAgent.indexOf("Windows NT 5.2") > -1 || sUserAgent.indexOf("Windows 2003") > -1;
        if (isWin2003)
          return "Windows 2003";
        const isWinVista = sUserAgent.indexOf("Windows NT 6.0") > -1 || sUserAgent.indexOf("Windows Vista") > -1;
        if (isWinVista)
          return "Windows Vista";
        const isWin7 = sUserAgent.indexOf("Windows NT 6.1") > -1 || sUserAgent.indexOf("Windows 7") > -1;
        if (isWin7)
          return "Windows 7";
        const isWin10 = sUserAgent.indexOf("Windows NT 10") > -1 || sUserAgent.indexOf("Windows 10") > -1;
        if (isWin10)
          return "Windows 10";
        const isWin11 = sUserAgent.indexOf("Windows NT 11") > -1 || sUserAgent.indexOf("Windows 11") > -1;
        if (isWin11)
          return "Windows 11";
      }
      return "Unknown system";
    }
    static getBrowserType() {
      const userAgent = navigator.userAgent;
      const isOpera = userAgent.indexOf("Opera") > -1;
      const isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1 && !isOpera;
      const isIE11 = userAgent.indexOf("Trident") > -1 && userAgent.indexOf("rv:11.0") > -1;
      const isEdge = userAgent.indexOf("Edge") > -1;
      const isFF = userAgent.indexOf("Firefox") > -1;
      const isSafari = userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1;
      const isChrome = userAgent.indexOf("Chrome") > -1 && userAgent.indexOf("Safari") > -1;
      if (isIE) {
        const reIE = new RegExp("MSIE (\\d+\\.\\d+);");
        reIE.test(userAgent);
        const fIEVersion = Number.parseFloat(RegExp.$1);
        if (fIEVersion === 7) {
          return "IE7";
        }
        if (fIEVersion === 8) {
          return "IE8";
        }
        if (fIEVersion === 9) {
          return "IE9";
        }
        if (fIEVersion === 10) {
          return "IE10";
        }
        return "0";
      }
      if (isFF) {
        return "FF";
      }
      if (isOpera) {
        return "Opera";
      }
      if (isSafari) {
        return "Safari";
      }
      if (isChrome) {
        return "Chrome";
      }
      if (isEdge) {
        return "Edge";
      }
      if (isIE11) {
        return "IE11";
      }
      return "Unknown browser";
    }
    static generateRandomId(n = 21, alphabet) {
      if (alphabet) {
        return customAlphabet(alphabet, n)();
      }
      return nanoid(n);
    }
    static getClassName(instance) {
      return instance.constructor.name;
    }
    static deepMerge(target, ...sources) {
      sources.forEach((item) => item && deepItem(item));
      function deepArray(array, to) {
        array.forEach((value, key) => {
          var _a2, _b2;
          if (_Tools.isArray(value)) {
            const origin = (_a2 = to[key]) != null ? _a2 : [];
            to[key] = origin;
            deepArray(value, origin);
            return;
          }
          if (_Tools.isObject(value)) {
            const origin = (_b2 = to[key]) != null ? _b2 : {};
            to[key] = origin;
            deepObject(value, origin);
            return;
          }
          to[key] = value;
        });
      }
      function deepObject(object, to) {
        Object.keys(object).forEach((key) => {
          var _a2, _b2;
          const value = object[key];
          if (_Tools.isObject(value)) {
            const origin = (_a2 = to[key]) != null ? _a2 : {};
            to[key] = origin;
            deepObject(value, origin);
            return;
          }
          if (_Tools.isArray(value)) {
            const origin = (_b2 = to[key]) != null ? _b2 : [];
            to[key] = origin;
            deepArray(value, origin);
            return;
          }
          to[key] = value;
        });
      }
      function deepItem(item) {
        Object.keys(item).forEach((key) => {
          var _a2, _b2;
          const value = item[key];
          if (_Tools.isArray(value)) {
            const origin = (_a2 = target[key]) != null ? _a2 : [];
            target[key] = origin;
            deepArray(value, origin);
            return;
          }
          if (_Tools.isObject(value)) {
            const origin = (_b2 = target[key]) != null ? _b2 : {};
            target[key] = origin;
            deepObject(value, origin);
            return;
          }
          target[key] = value;
        });
      }
      return target;
    }
    static numberFixed(value, digit) {
      return Number(Number(value).toFixed(digit));
    }
    static diffValue(one, tow) {
      function diffValue(oneValue, towValue) {
        const oneType = _Tools.getValueType(oneValue);
        const towType = _Tools.getValueType(towValue);
        if (oneType !== towType) {
          return false;
        }
        if (_Tools.isArray(oneValue)) {
          return diffArrays(oneValue, towValue);
        }
        if (_Tools.isObject(oneValue)) {
          return diffObject(oneValue, towValue);
        }
        if (_Tools.isDate(oneValue)) {
          return oneValue.getTime() === towValue.getTime();
        }
        if (_Tools.isRegExp(oneValue)) {
          return oneValue.toString() === towValue.toString();
        }
        return oneValue === towValue;
      }
      function diffArrays(oneArray, towArray) {
        if (one.length !== tow.length) {
          return false;
        }
        for (let i = 0, len = oneArray.length; i < len; i++) {
          const oneValue = oneArray[i];
          const towValue = towArray[i];
          if (!diffValue(oneValue, towValue)) {
            return false;
          }
        }
        return true;
      }
      function diffObject(oneObject, towObject) {
        const oneKeys = Object.keys(oneObject);
        const towKeys = Object.keys(towObject);
        if (oneKeys.length !== towKeys.length) {
          return false;
        }
        for (const key of oneKeys) {
          if (!towKeys.includes(key)) {
            return false;
          }
          const oneValue = oneObject[key];
          const towValue = towObject[key];
          if (!diffValue(oneValue, towValue)) {
            return false;
          }
        }
        return true;
      }
      return diffValue(one, tow);
    }
    static deepClone(value) {
      if (!this.isDefine(value)) {
        return value;
      }
      if (this.isRegExp(value)) {
        return new RegExp(value);
      }
      if (this.isDate(value)) {
        return new Date(value);
      }
      if (this.isArray(value)) {
        const clone = [];
        value.forEach((item, index) => {
          clone[index] = _Tools.deepClone(item);
        });
        return clone;
      }
      if (this.isObject(value)) {
        const clone = {};
        Object.keys(value).forEach((key) => {
          const item = value[key];
          clone[key] = _Tools.deepClone(item);
        });
        Object.setPrototypeOf(clone, Object.getPrototypeOf(value));
        return clone;
      }
      return value;
    }
    static getLanguage() {
      const defaultValue = "en-US";
      if (globalThis.navigator) {
        return navigator.languages && navigator.languages[0] || navigator.language || defaultValue;
      }
      return defaultValue;
    }
    static getValueType(value) {
      return Object.prototype.toString.apply(value);
    }
    static isDefine(value) {
      return value !== void 0 && value !== null;
    }
    static isBlank(value) {
      if (!this.isDefine(value)) {
        return true;
      }
      if (this.isString(value)) {
        return value.trim() === "";
      }
      return false;
    }
    static isAssignableFrom(object, clazz) {
      return object instanceof clazz;
    }
    static isBoolean(value) {
      return this.getValueType(value) === "[object Boolean]";
    }
    static isPlainObject(value) {
      if (!this.isDefine(value)) {
        return false;
      }
      return Object.getPrototypeOf(value) === Object.getPrototypeOf({});
    }
    static isFunction(value) {
      return this.getValueType(value) === "[object Function]";
    }
    static isDate(value) {
      return this.getValueType(value) === "[object Date]";
    }
    static isRegExp(value) {
      return this.getValueType(value) === "[object RegExp]";
    }
    static isArray(value) {
      return this.getValueType(value) === "[object Array]";
    }
    static isString(value) {
      return this.getValueType(value) === "[object String]";
    }
    static isNumber(value) {
      return this.getValueType(value) === "[object Number]";
    }
    static isStringNumber(value) {
      return !isNaN(Number.parseFloat(value)) && isFinite(value);
    }
    static isObject(value) {
      return this.getValueType(value) === "[object Object]";
    }
    static isEmptyObject(value) {
      for (const _key in value) {
        return false;
      }
      return true;
    }
    static isMobile() {
      let clientWidth = 0;
      let clientHeight = 0;
      if (document.body.clientWidth) {
        clientWidth = document.body.clientWidth;
      }
      if (document.body.clientHeight) {
        clientHeight = document.body.clientHeight;
      }
      return this.isAndroid() || this.isIPhone() || this.isTablet() || clientWidth < 350 && clientHeight < 500;
    }
    static isTablet() {
      return /ipad|android|android 3.0|xoom|sch-i800|playbook|tablet|kindle/i.test(navigator.userAgent.toLowerCase());
    }
    static isWeChat() {
      const userAgent = navigator.userAgent.toLowerCase();
      return String(userAgent.match(/MicroMessenger/i)) === "micromessenger" ? true : false;
    }
    static isAndroid() {
      const userAgent = navigator.userAgent;
      return userAgent.indexOf("Android") > -1 || userAgent.indexOf("Linux") > -1;
    }
    static isIPhone() {
      return /iPhone/i.test(navigator.userAgent);
    }
    static itCount(count) {
      return (callback) => {
        for (let i = 0; i < count; i++) {
          callback && callback();
        }
      };
    }
    static hasLength(target, length) {
      if (_Tools.isDefine(target)) {
        if (_Tools.isDefine(length)) {
          return target.length === length;
        }
        return target.length > 0;
      }
      return false;
    }
    static capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }
    // Used by camelCase as callback to replace()
    static fCamelCase(_all, letter) {
      return letter.toUpperCase();
    }
    // Convert dashed to camelCase; used by the css and data modules
    // Support: IE <=9 - 11, Edge 12 - 15
    // Microsoft forgot to hump their vendor prefix (#9572)
    static camelCase(str) {
      return str.replace(rmsPrefix, "ms-").replace(rDashAlpha, this.fCamelCase);
    }
    /**
     * remove all null from object
     * @param obj
     * @returns
     */
    static removeNull(value) {
      if (this.isObject(value)) {
        Object.keys(value).forEach((key) => {
          const item = value[key];
          if (item == null) {
            delete value[key];
          } else {
            _Tools.removeNull(item);
          }
        });
      }
      return value;
    }
    /**
     * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
     * @param rows row length
     * @param columns column length
     * @param value value to be set
     * @returns
     */
    static fillTwoDimensionalArray(rows, columns, value) {
      return new Array(rows).fill(value).map((item) => new Array(columns).fill(value));
    }
    /**
     * Generate a two-dimensional array with the specified number of rows and columns, and fill in the values
     * @param rows row length
     * @param columns column length
     * @param value value to be set
     * @returns
     */
    // static fillObjectMatrix<T>(rows: number, columns: number, value: T): IObjectMatrixPrimitiveType<T> {
    //     const matrix = new ObjectMatrix<T>();
    //     for (let r = 0; r < rows; r++) {
    //         for (let c = 0; c < columns; c++) {
    //             matrix.setValue(r, c, value);
    //         }
    //     }
    //     return matrix.getData();
    // }
    static numToWord(x) {
      let s = "";
      while (x > 0) {
        let m = x % 26;
        m = m === 0 ? m = 26 : m;
        s = String.fromCharCode(96 + m) + s;
        x = (x - m) / 26;
      }
      return s.toLocaleUpperCase();
    }
    /**
     *
     * Column subscript letter to number
     *
     * @privateRemarks
     * zh: 列下标  字母转数字
     *
     * @param a - Column subscript letter,e.g.,"A1"
     * @returns Column subscript number,e.g.,0
     *
     */
    static ABCatNum(a) {
      if (a == null || a.length === 0) {
        return Number.NaN;
      }
      const str = a.toLowerCase().split("");
      const al = str.length;
      let numOut = 0;
      let charnum = 0;
      for (let i = 0; i < al; i++) {
        charnum = str[i].charCodeAt(0) - 96;
        numOut += charnum * 26 ** (al - i - 1);
      }
      if (numOut === 0) {
        return Number.NaN;
      }
      return numOut - 1;
    }
    /**
     * en: Column subscript number to letter
     *
     * zh: 列下标  数字转字母
     *
     * @param n Column subscript number,e.g.,0
     * @returns Column subscript letter,e.g.,"A1"
     */
    static chatAtABC(n) {
      const ord_a = "a".charCodeAt(0);
      const ord_z = "z".charCodeAt(0);
      const len = ord_z - ord_a + 1;
      let s = "";
      while (n >= 0) {
        s = String.fromCharCode(n % len + ord_a) + s;
        n = Math.floor(n / len) - 1;
      }
      return s.toUpperCase();
    }
    static randSort(arr) {
      for (let i = 0, len = arr.length; i < len; i++) {
        const rand = Number.parseInt((Math.random() * len).toString());
        const temp = arr[rand];
        arr[rand] = arr[i];
        arr[i] = temp;
      }
      return arr;
    }
    /**
     * extend two objects
     * @param originJson
     * @param extendJson
     * @returns
     */
    static commonExtend(originJson, extendJson) {
      const resultJsonObject = {};
      for (const attr in originJson) {
        resultJsonObject[attr] = originJson[attr];
      }
      for (const attr in extendJson) {
        if (extendJson[attr] == null) {
          continue;
        }
        resultJsonObject[attr] = extendJson[attr];
      }
      return resultJsonObject;
    }
    static commonExtend1(originJson, extendJson) {
      for (const attr in originJson) {
        if (extendJson[attr] == null) {
          extendJson[attr] = originJson[attr];
        }
      }
      return extendJson;
    }
    static arrayToObject(array) {
      const obj = {};
      array.forEach((row, i) => {
        obj[i] = {};
        row.forEach((column, j) => {
          obj[i][j] = column;
        });
      });
      return obj;
    }
    static hasIntersectionBetweenTwoRanges(range1Start, range1End, range2Start, range2End) {
      return range1End >= range2Start && range2End >= range1Start;
    }
  };

  // ../packages/core/src/shared/common.ts
  function isEmptyCell(cell) {
    var _a2;
    if (!cell) {
      return true;
    }
    const content = ((_a2 = cell == null ? void 0 : cell.v) == null ? void 0 : _a2.toString()) || "";
    if (content.length === 0 && !cell.p) {
      return true;
    }
    return false;
  }
  function getColorStyle(color) {
    if (color) {
      if (color.rgb) {
        return color.rgb;
      }
      if (color.th) {
        return new ColorBuilder().setThemeColor(color.th).asThemeColor().asRgbColor().getCssString();
      }
    }
    return null;
  }
  function isFormulaString(value) {
    return Tools.isString(value) && value.substring(0, 1) === "=" && value.length > 1;
  }
  function isFormulaId(value) {
    return Tools.isString(value) && value.indexOf("=") === -1 && value.length === 6;
  }
  function getDocsUpdateBody(model, segmentId) {
    let body = model.body;
    if (segmentId) {
      const { headers, footers } = model;
      if (headers == null ? void 0 : headers[segmentId]) {
        body = headers[segmentId].body;
      } else if (footers == null ? void 0 : footers[segmentId]) {
        body = footers[segmentId].body;
      }
    }
    return body;
  }
  function isValidRange(range) {
    const { startRow, endRow, startColumn, endColumn } = range;
    if (startRow < 0 || startColumn < 0 || endRow < 0 || endColumn < 0 || Number.isNaN(startRow) || Number.isNaN(endRow) || Number.isNaN(startColumn) || Number.isNaN(endColumn)) {
      return false;
    }
    return true;
  }
  function cellToRange(row, col) {
    return { startRow: row, endRow: row, startColumn: col, endColumn: col };
  }

  // ../packages/core/src/shared/compare.ts
  function deepCompare(arg1, arg2) {
    if (Object.prototype.toString.call(arg1) === Object.prototype.toString.call(arg2)) {
      if (Object.prototype.toString.call(arg1) === "[object Object]" || Object.prototype.toString.call(arg1) === "[object Array]") {
        if (Object.keys(arg1).length !== Object.keys(arg2).length) {
          return false;
        }
        return Object.keys(arg1).every((key) => deepCompare(arg1[key], arg2[key]));
      }
      return arg1 === arg2;
    }
    return false;
  }
  function isSameStyleTextRun(tr1, tr2) {
    const ts1 = tr1.ts || {};
    const ts2 = tr2.ts || {};
    if (tr1.sId !== tr2.sId) {
      return false;
    }
    return deepCompare(ts1, ts2);
  }

  // ../packages/core/src/shared/doc-tool.ts
  function horizontalLineSegmentsSubtraction(A1, A2, B1, B2) {
    if (A1 > A2) {
      [A1, A2] = [A2, A1];
    }
    if (B1 > B2) {
      [B1, B2] = [B2, B1];
    }
    if (A2 < B1 || B2 < A1) {
      return [A1, A2];
    }
    if (B1 < A1) {
      B1 = A1;
    }
    if (B2 > A2) {
      B2 = A2;
    }
    const subLength = B2 - B1 + 1;
    let result = [];
    if (A1 === B1) {
      result = [B2 + 1 - subLength, A2 - subLength];
    } else if (A2 === B2) {
      result = [A1, B1 - 1];
    } else {
      result = [A1, A2 - subLength];
    }
    return result;
  }
  function insertTextToContent(content, start, text) {
    return content.slice(0, start) + text + content.slice(start);
  }
  function deleteContent(content, start, end) {
    if (start > end) {
      return content;
    }
    return content.slice(0, start) + content.slice(end);
  }

  // ../packages/core/src/shared/generate.ts
  function isRealNum(val) {
    if (val === null || val.toString().replace(/\s/g, "") === "") {
      return false;
    }
    if (typeof val === "boolean") {
      return false;
    }
    if (!isNaN(val)) {
      return true;
    }
    return false;
  }

  // ../packages/core/src/shared/hash-algorithm.ts
  function hashAlgorithm(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
      hash = str.charCodeAt(i) + (hash << 6) + (hash << 16) - hash;
    }
    return hash >>> 0;
  }

  // ../packages/core/src/shared/lru/lru-helper.ts
  var LRUHelper = class {
    static hasLength(array, size) {
      return array.length === size;
    }
    static getValueType(value) {
      return Object.prototype.toString.apply(value);
    }
    static isObject(value) {
      return this.getValueType(value) === "[object Object]";
    }
    static isIterable(value) {
      return value[Symbol.iterator] != null;
    }
    static isNumber(value) {
      return this.getValueType(value) === "[object Number]";
    }
  };

  // ../packages/core/src/shared/lru/lru-map.ts
  var NEWER = Symbol("newer");
  var OLDER = Symbol("older");
  var KeyIterator = class {
    constructor(oldestEntry) {
      __publicField(this, "entry");
      this.entry = oldestEntry;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return { done: false, value: ent.key };
      }
      return { done: true, value: void 0 };
    }
  };
  var ValueIterator = class {
    constructor(oldestEntry) {
      __publicField(this, "entry");
      this.entry = oldestEntry;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return { done: false, value: ent.value };
      }
      return { done: true, value: void 0 };
    }
  };
  var EntryIterator = class {
    constructor(oldestEntry) {
      __publicField(this, "entry");
      this.entry = oldestEntry;
    }
    [Symbol.iterator]() {
      return this;
    }
    next() {
      const ent = this.entry;
      if (ent) {
        this.entry = ent[NEWER];
        return { done: false, value: [ent.key, ent.value] };
      }
      return { done: true, value: void 0 };
    }
  };
  var _a, _b;
  var Entry = class {
    constructor(key, value) {
      __publicField(this, "key");
      __publicField(this, "value");
      __publicField(this, _a);
      __publicField(this, _b);
      this.key = key;
      this.value = value;
      this[NEWER] = void 0;
      this[OLDER] = void 0;
    }
    toJSON() {
      return {
        key: this.key,
        value: this.value
      };
    }
  };
  _a = NEWER, _b = OLDER;
  var LRUMap = class {
    constructor(...parameter) {
      __publicField(this, "_keymap");
      __publicField(this, "size", 0);
      __publicField(this, "limit");
      __publicField(this, "oldest");
      __publicField(this, "newest");
      __publicField(this, "_onShiftListeners", []);
      if (LRUHelper.hasLength(parameter, 1)) {
        if (LRUHelper.isNumber(parameter[0])) {
          const limit = parameter[0];
          this._initialize(limit, void 0);
          return;
        }
        if (LRUHelper.isIterable(parameter[0])) {
          const entries = parameter[0];
          this._initialize(0, entries);
          return;
        }
        return;
      }
      if (LRUHelper.hasLength(parameter, 2)) {
        const limit = parameter[0];
        const entries = parameter[1];
        this._initialize(limit, entries);
      }
    }
    onShift(callback) {
      if (this._onShiftListeners.indexOf(callback) === -1) {
        this._onShiftListeners.push(callback);
        return toDisposable(() => remove(this._onShiftListeners, callback));
      }
      throw new Error("[LRUMap]: the listener has been registered!");
    }
    _initialize(limit, entries) {
      this.oldest = void 0;
      this.newest = void 0;
      this.size = 0;
      this.limit = limit;
      this._keymap = /* @__PURE__ */ new Map();
      if (entries) {
        this.assign(entries);
        if (limit < 1) {
          this.limit = this.size;
        }
      }
    }
    _markEntryAsUsed(entry) {
      if (entry === this.newest) {
        return;
      }
      if (entry[NEWER]) {
        if (entry === this.oldest) {
          this.oldest = entry[NEWER];
        }
        entry[NEWER][OLDER] = entry[OLDER];
      }
      if (entry[OLDER]) {
        entry[OLDER][NEWER] = entry[NEWER];
      }
      entry[NEWER] = void 0;
      entry[OLDER] = this.newest;
      if (this.newest) {
        this.newest[NEWER] = entry;
      }
      this.newest = entry;
    }
    assign(entries) {
      let entry;
      let limit = this.limit || Number.MAX_VALUE;
      this._keymap.clear();
      const it = entries[Symbol.iterator]();
      for (let itv = it.next(); !itv.done; itv = it.next()) {
        const e = new Entry(itv.value[0], itv.value[1]);
        this._keymap.set(e.key, e);
        if (!entry) {
          this.oldest = e;
        } else {
          entry[NEWER] = e;
          e[OLDER] = entry;
        }
        entry = e;
        if (limit-- === 0) {
          throw new Error("overflow");
        }
      }
      this.newest = entry;
      this.size = this._keymap.size;
    }
    set(key, value) {
      let entry = this._keymap.get(key);
      if (entry) {
        entry.value = value;
        this._markEntryAsUsed(entry);
        return this;
      }
      this._keymap.set(key, entry = new Entry(key, value));
      if (this.newest) {
        this.newest[NEWER] = entry;
        entry[OLDER] = this.newest;
      } else {
        this.oldest = entry;
      }
      this.newest = entry;
      ++this.size;
      if (this.size > this.limit) {
        this.shift();
      }
      return this;
    }
    shift() {
      const entry = this.oldest;
      if (entry) {
        if (this.oldest && this.oldest[NEWER]) {
          this.oldest = this.oldest[NEWER];
          this.oldest[OLDER] = void 0;
        } else {
          this.oldest = void 0;
          this.newest = void 0;
        }
        entry[NEWER] = entry[OLDER] = void 0;
        this._keymap.delete(entry.key);
        --this.size;
        this._onShiftListeners.forEach((callback) => callback(entry));
        return [entry.key, entry.value];
      }
    }
    get(key) {
      const entry = this._keymap.get(key);
      if (!entry)
        return;
      this._markEntryAsUsed(entry);
      return entry.value;
    }
    has(key) {
      return this._keymap.has(key);
    }
    find(key) {
      const e = this._keymap.get(key);
      return e ? e.value : void 0;
    }
    delete(key) {
      const entry = this._keymap.get(key);
      if (!entry)
        return;
      this._keymap.delete(entry.key);
      if (entry[NEWER] && entry[OLDER]) {
        entry[OLDER][NEWER] = entry[NEWER];
        entry[NEWER][OLDER] = entry[OLDER];
      } else if (entry[NEWER]) {
        entry[NEWER][OLDER] = void 0;
        this.oldest = entry[NEWER];
      } else if (entry[OLDER]) {
        entry[OLDER][NEWER] = void 0;
        this.newest = entry[OLDER];
      } else {
        this.oldest = this.newest = void 0;
      }
      this.size--;
      return entry.value;
    }
    clear() {
      this.oldest = void 0;
      this.newest = void 0;
      this.size = 0;
      this._keymap.clear();
    }
    keys() {
      return new KeyIterator(this.oldest);
    }
    values() {
      return new ValueIterator(this.oldest);
    }
    entries() {
      return this[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return new EntryIterator(this.oldest);
    }
    forEach(fun, thisObj) {
      if (typeof thisObj !== "object") {
        thisObj = this;
      }
      let entry = this.oldest;
      while (entry) {
        fun.call(thisObj, entry.value, entry.key, this);
        entry = entry[NEWER];
      }
    }
    toJSON() {
      const s = new Array(this.size);
      let i = 0;
      let entry = this.oldest;
      while (entry) {
        s[i++] = { key: entry.key, value: entry.value };
        entry = entry[NEWER];
      }
      return s;
    }
    toString() {
      let s = String();
      let entry = this.oldest;
      while (entry) {
        s += `${String(entry.key)}:${entry.value}`;
        entry = entry[NEWER];
        if (entry) {
          s += " < ";
        }
      }
      return s;
    }
  };

  // ../packages/core/src/shared/object-matrix.ts
  function getArrayLength(o) {
    let maxIndex = 0;
    const keys = Object.keys(o);
    for (const key of keys) {
      const rowIndex = Number(key);
      maxIndex = Math.max(maxIndex, rowIndex);
    }
    return maxIndex + 1;
  }
  function insertMatrixArray(index, value, o) {
    const length = getArrayLength(o);
    const array = o;
    for (let i = length - 1; i >= index; i--) {
      array[i + 1] = array[i];
    }
    array[index] = value;
  }
  function spliceArray(start, count, o) {
    const length = Object.keys(o).reduce((max, key) => Math.max(max, Number.parseInt(key)), 0) + 1;
    for (let i = start; i < length; i++) {
      if (i < start + count) {
        delete o[i];
      } else {
        if (o[i] !== void 0) {
          o[i - count] = o[i];
          delete o[i];
        }
      }
    }
  }
  function concatMatrixArray(source, target) {
    const srcArray = source;
    const srcKeys = Object.keys(srcArray);
    const srcLength = srcKeys.length;
    const targetArray = target;
    const targetKeys = Object.keys(targetArray);
    const targetLength = targetKeys.length;
    const containerArray = {};
    let master = 0;
    for (let i = 0; i < srcLength; i++, master++) {
      const key = srcKeys[i];
      containerArray[master] = srcArray[key];
    }
    for (let i = 0; i < targetLength; i++, master++) {
      const key = targetKeys[i];
      containerArray[master] = targetArray[key];
    }
    return containerArray;
  }
  function sliceMatrixArray(start, end, matrixArray) {
    const array = matrixArray;
    const length = getArrayLength(matrixArray);
    if (length > 0) {
      const fragment = {};
      let effective = 0;
      for (let i = start; i <= end; i++) {
        const item = array[i];
        if (item) {
          fragment[effective] = array[i];
          effective++;
        }
      }
      return fragment;
    }
    return {};
  }
  function moveMatrixArray(fromIndex, count, toIndex, o) {
    const moveBackward = fromIndex > toIndex;
    if (!moveBackward && fromIndex + count > toIndex) {
      throw new Error("Invalid move operation");
    }
    if (moveBackward) {
      _moveBackward(fromIndex, count, toIndex, o);
    } else {
      _moveForward(fromIndex, count, toIndex, o);
    }
  }
  function _moveBackward(fromIndex, count, toIndex, o) {
    const array = o;
    const toMove = [];
    for (let i = fromIndex; i < fromIndex + count; i++) {
      toMove.push(array[i]);
    }
    for (let i = fromIndex - 1; i >= toIndex; i--) {
      const item = array[i];
      array[i + count] = item;
      if (item === void 0) {
        delete array[i + count];
      }
    }
    toMove.forEach((item, index) => {
      array[toIndex + index] = item;
      if (item === void 0) {
        delete array[toIndex + index];
      }
    });
  }
  function _moveForward(fromIndex, count, toIndex, o) {
    const array = o;
    const toMove = [];
    for (let i = fromIndex; i < fromIndex + count; i++) {
      toMove.push(array[i]);
    }
    for (let i = fromIndex + count; i < toIndex; i++) {
      const item = array[i];
      array[i - count] = item;
      if (item === void 0) {
        delete array[i - count];
      }
    }
    toMove.forEach((item, index) => {
      array[toIndex + index - count] = item;
      if (item === void 0) {
        delete array[toIndex + index - count];
      }
    });
  }
  var ObjectMatrix = class _ObjectMatrix {
    constructor(matrix = {}) {
      __publicField(this, "_matrix");
      this._setOriginValue(matrix);
    }
    static MakeObjectMatrixSize(size) {
      return new _ObjectMatrix({
        [size - 1]: {}
      });
    }
    getMatrix() {
      return this._matrix;
    }
    forEach(callback) {
      const matrix = this._matrix;
      const matrixRow = Object.keys(matrix);
      for (const row of matrixRow) {
        const rowNumber = Number(row);
        const columns = matrix[rowNumber];
        const result = callback(rowNumber, columns);
        if (result === false) {
          return this;
        }
      }
      return this;
    }
    forRow(callback) {
      const matrix = this._matrix;
      const matrixRow = Object.keys(matrix);
      for (const row of matrixRow) {
        const rowNumber = Number(row);
        const columns = matrix[rowNumber];
        const result = callback(
          rowNumber,
          Object.keys(columns).map((col) => {
            return Number(col);
          })
        );
        if (result === false) {
          return this;
        }
      }
      return this;
    }
    /**
     * Iterate the object matrix with row priority, which means it scan the whole range row by row.
     */
    forValue(callback) {
      const matrix = this._matrix;
      const matrixRow = Object.keys(matrix);
      for (const row of matrixRow) {
        const rowNumber = Number(row);
        const columns = matrix[rowNumber];
        if (!columns)
          continue;
        const columnKeys = Object.keys(columns);
        for (const column of columnKeys) {
          const colNumber = Number(column);
          const value = columns[Number(column)];
          const result = callback(rowNumber, colNumber, value);
          if (result === false) {
            return this;
          }
        }
      }
      return this;
    }
    swapRow(src, target) {
      const srcRow = this._matrix[src];
      const targetRow = this._matrix[target];
      this._matrix[src] = targetRow;
      this._matrix[target] = srcRow;
    }
    getRow(rowIndex) {
      return this._matrix[rowIndex];
    }
    getRowOrCreate(rowIndex) {
      let row = this.getRow(rowIndex);
      if (row == null) {
        row = {};
        this._matrix[rowIndex] = row;
      }
      return row;
    }
    reset() {
      this._setOriginValue({});
    }
    hasValue() {
      const matrix = this._matrix;
      const matrixRow = Object.keys(matrix);
      if (matrixRow.length === 0) {
        return false;
      }
      for (const row of matrixRow) {
        const rowNumber = Number(row);
        const columns = matrix[rowNumber];
        const columnKeys = Object.keys(columns);
        if (columnKeys.length > 0) {
          return true;
        }
      }
      return false;
    }
    getValue(row, column) {
      var _a2, _b2;
      return (_b2 = (_a2 = this._matrix) == null ? void 0 : _a2[row]) == null ? void 0 : _b2[column];
    }
    setValue(row, column, value) {
      const objectArray = this.getRowOrCreate(row);
      objectArray[column] = value;
    }
    /**
     * ！！
     * Please +1 ‘！’, who fell into this pit.
     * @deprecated use `realDelete` or `splice`
     */
    deleteValue(row, column) {
      var _a2, _b2;
      (_b2 = (_a2 = this._matrix) == null ? void 0 : _a2[row]) == null ? true : delete _b2[column];
    }
    realDeleteValue(row, column) {
      var _a2, _b2, _c;
      (_b2 = (_a2 = this._matrix) == null ? void 0 : _a2[row]) == null ? true : delete _b2[column];
      if (this.getRow(row)) {
        const objectArray = this.getRow(row);
        if (objectArray == null) {
          return;
        }
        const keys = Object.keys(objectArray);
        if (keys.length === 0) {
          (_c = this._matrix) == null ? true : delete _c[row];
        }
      }
    }
    setRow(rowNumber, row) {
      this._matrix[rowNumber] = row;
    }
    moveRows(start, count, target) {
      moveMatrixArray(start, count, target, this._matrix);
    }
    moveColumns(start, count, target) {
      this.forEach((row, value) => {
        moveMatrixArray(start, count, target, value);
      });
    }
    insertRows(start, count) {
      for (let r = start; r < start + count; r++) {
        const initial = {};
        insertMatrixArray(r, initial, this._matrix);
      }
    }
    insertColumns(start, count) {
      for (let c = start; c < start + count; c++) {
        this.forEach((row, data) => {
          insertMatrixArray(c, void 0, data);
        });
      }
    }
    removeRows(start, count) {
      spliceArray(start, count, this._matrix);
    }
    removeColumns(start, count) {
      this.forEach((row, value) => {
        spliceArray(start, count, value);
      });
    }
    /**
     * Return a fragment of the original data matrix. Note that the returned matrix's row matrix would start from
     * 0 not `startRow`. Neither does its column matrix. If you want to get the original matrix, use `getSlice`.
     *
     * @param startRow
     * @param endRow
     * @param startColumn
     * @param endColumn
     * @returns
     */
    getFragment(startRow, endRow, startColumn, endColumn) {
      const objectMatrix = new _ObjectMatrix();
      let insertRow = 0;
      for (let r = startRow; r <= endRow; r++) {
        const row = {};
        let insertColumn = 0;
        for (let c = startColumn; c <= endColumn; c++) {
          const value = this.getValue(r, c);
          row[insertColumn] = value;
          insertColumn++;
        }
        objectMatrix.setRow(insertRow, row);
        insertRow++;
      }
      return objectMatrix;
    }
    /**
     * Return a slice of the original data matrix. Note that the returned matrix's row matrix would start from
     * `startRow` not 0, and the same does its column index. You may be looking for `getFragment` if you want
     * both of the indexes start from 0.
     *
     * @param startRow
     * @param endRow
     * @param startColumn
     * @param endColumn
     * @returns
     */
    getSlice(startRow, endRow, startColumn, endColumn) {
      const objectMatrix = new _ObjectMatrix();
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startColumn; c <= endColumn; c++) {
          const value = this.getValue(r, c);
          if (value) {
            objectMatrix.setValue(r, c, Tools.deepClone(value));
          }
        }
      }
      return objectMatrix;
    }
    getSizeOf() {
      const keys = Object.keys(this._matrix);
      return keys.length;
    }
    getLength() {
      return getArrayLength(this._matrix);
    }
    getRange() {
      const startRow = 0;
      const startColumn = 0;
      const endRow = this.getLength() - 1;
      let endColumn = 0;
      const length = this.getLength();
      for (let i = 0; i < length; i++) {
        const row = this.getRow(i);
        if (row) {
          const columnLength = getArrayLength(row) - 1;
          endColumn = columnLength > endColumn ? columnLength : endColumn;
        }
      }
      return {
        startRow,
        startColumn,
        endRow,
        endColumn
      };
    }
    toNativeArray() {
      const native = new Array();
      this.forValue((row, col, value) => {
        native.push(value);
      });
      return native;
    }
    toArray() {
      const array = [];
      this.forRow((row, cols) => {
        if (array[row] == null) {
          array[row] = [];
        }
        cols.forEach((column) => {
          array[row][column] = this.getValue(row, column);
        });
      });
      return array;
    }
    toFullArray() {
      const range = this.getRange();
      const { endColumn, endRow } = range;
      const array = [];
      for (let i = 0; i <= endRow; i++) {
        const subArr = Array(endColumn + 1).fill(void 0);
        array.push(subArr);
      }
      this.forValue((row, col, value) => {
        array[row][col] = value;
      });
      return array;
    }
    /**
     * @deprecated Use getMatrix as a substitute.
     */
    toJSON() {
      return this._matrix;
    }
    clone() {
      const json = JSON.stringify(this._matrix);
      return JSON.parse(json);
    }
    /**
     * @deprecated Use clone as a substitute.
     */
    getData() {
      const json = JSON.stringify(this._matrix);
      return JSON.parse(json);
    }
    getArrayData() {
      let startRow = 0;
      let startColumn = 0;
      let initRow = false;
      let initColumn = false;
      const objectMatrix = new _ObjectMatrix();
      this.forEach((rowIndex, rowObject) => {
        if (!initRow) {
          initRow = true;
          startRow = rowIndex;
        }
        Object.keys(rowObject).forEach((column) => {
          const columnIndex = Number(column);
          if (!initColumn) {
            initColumn = true;
            startColumn = columnIndex;
          } else if (columnIndex < startColumn) {
            startColumn = columnIndex;
          }
          const value = this.getValue(rowIndex, columnIndex);
          objectMatrix.setValue(rowIndex - startRow, columnIndex - startColumn, value);
        });
      });
      return objectMatrix.getData();
    }
    getDataRange() {
      let startRow = 0;
      let startColumn = 0;
      let endColumn = 0;
      let endRow = -1;
      let initRow = false;
      let initColumn = false;
      this.forEach((rowIndex, row) => {
        if (!initRow) {
          initRow = true;
          startRow = rowIndex;
        }
        const rowSize = getArrayLength(row) - 1;
        if (rowSize > endColumn) {
          endColumn = rowSize;
        }
        Object.keys(row).forEach((column) => {
          const columnIndex = Number(column);
          if (!initColumn) {
            initColumn = true;
            startColumn = columnIndex;
          } else if (columnIndex < startColumn) {
            startColumn = columnIndex;
          }
        });
        if (rowIndex > endRow) {
          endRow = rowIndex;
        }
      });
      return {
        startRow,
        startColumn,
        endRow,
        endColumn
      };
    }
    getDiscreteRanges() {
      const ranges = [];
      this.forEach((r, row) => {
        Object.keys(row).forEach((col) => {
          const c = Number(col);
          let merged = false;
          for (const range of ranges) {
            if (r >= range.startRow && r <= range.endRow + 1 && c >= range.startColumn && c <= range.endColumn + 1) {
              range.endRow = Math.max(r, range.endRow);
              range.endColumn = Math.max(c, range.endColumn);
              merged = true;
              break;
            }
          }
          if (!merged) {
            ranges.push({
              startRow: r,
              endRow: r,
              startColumn: c,
              endColumn: c
            });
          }
        });
      });
      return ranges;
    }
    merge(newObject) {
      this.forValue((row, column) => {
        const cellValue = newObject.getValue(row, column);
        if (cellValue != null) {
          this.setValue(row, column, cellValue);
        }
      });
    }
    _setOriginValue(matrix = {}) {
      this._matrix = matrix;
    }
  };

  // ../packages/core/src/shared/permission/index.ts
  var PermissionPoint = class {
    constructor() {
      __publicField(this, "status", "init" /* INIT */);
    }
  };
  var getTypeFromPermissionItemList = (list) => list.some((item) => item.status === "init" /* INIT */) ? "init" /* INIT */ : list.some((item) => item.status === "fetching" /* FETCHING */) ? "fetching" /* FETCHING */ : "done" /* DONE */;

  // ../packages/core/src/shared/ref-alias.ts
  var RefAlias = class {
    constructor(values, keys) {
      __publicField(this, "_values", []);
      __publicField(this, "_keys", []);
      __publicField(this, "_keyMaps", /* @__PURE__ */ new Map());
      this._values = values;
      this._keys = keys;
      values.forEach((item) => {
        this._initKeyMap(item);
      });
    }
    _initKeyMap(item) {
      this._keys.forEach((key) => {
        const value = item[key];
        const keyMap = this._keyMaps.get(key) || /* @__PURE__ */ new Map();
        keyMap.set(value, item);
        this._keyMaps.set(key, keyMap);
      });
    }
    /**
     * If a key group is specified, the order of values is determined by the key group, otherwise it depends on the keys at initialization
     * @param {string} key
     * @param {K[]} [keyGroup]
     * @return {*}
     * @memberof RefAlias
     */
    getValue(key, keyGroup) {
      const keys = keyGroup || this._keys;
      for (let index = 0; index < keys.length; index++) {
        const keyMap = this._keyMaps.get(keys[index]);
        if (keyMap == null ? void 0 : keyMap.has(key)) {
          return keyMap.get(key);
        }
      }
      return null;
    }
    hasValue(key) {
      for (let index = 0; index < this._keys.length; index++) {
        const keyMap = this._keyMaps.get(this._keys[index]);
        if (keyMap == null ? void 0 : keyMap.has(key)) {
          return true;
        }
      }
      return false;
    }
    addValue(item) {
      this._values.push(item);
      this._initKeyMap(item);
    }
    setValue(key, attr, value) {
      const item = this.getValue(key);
      if (item) {
        if (Object.keys(item).includes(attr)) {
          item[attr] = value;
        }
      }
    }
    deleteValue(key) {
      const value = this.getValue(key);
      if (value) {
        this._keys.forEach((keyItem) => {
          const keyMap = this._keyMaps.get(keyItem);
          const _key = value[keyItem];
          keyMap == null ? void 0 : keyMap.delete(_key);
        });
        const index = this._values.findIndex((item) => item === value);
        this._values.splice(index, 1);
      }
    }
    getValues() {
      return this._values;
    }
    getKeyMap(key) {
      var _a2;
      return [...((_a2 = this._keyMaps.get(key)) == null ? void 0 : _a2.keys()) || []];
    }
    clear() {
      this._values = [];
      this._keys = [];
      this._keyMaps.clear();
    }
  };

  // ../packages/core/src/shared/row-col-iter.ts
  function createRowColIter(rowStart, rowEnd, colStart, colEnd) {
    return {
      forEach(cb) {
        for (let r = rowStart; r <= rowEnd; r++) {
          for (let c = colStart; c <= colEnd; c++) {
            cb(r, c);
          }
        }
      }
    };
  }

  // ../packages/core/src/shared/sequence.ts
  var orderA = "A".charCodeAt(0);
  var orderZ = "Z".charCodeAt(0);
  var order_a = "a".charCodeAt(0);
  var order_z = "z".charCodeAt(0);
  function numberToABC(n) {
    const len = orderZ - orderA + 1;
    let s = "";
    while (n >= 0) {
      s = String.fromCharCode(n % len + orderA) + s;
      n = Math.floor(n / len) - 1;
    }
    return s;
  }
  function repeatStringNumTimes(string, times) {
    let repeatedString = "";
    while (times > 0) {
      repeatedString += string;
      times--;
    }
    return repeatedString;
  }
  function numberToListABC(n, uppercase = false) {
    const len = orderZ - orderA + 1;
    let order = order_a;
    if (uppercase) {
      order = orderA;
    }
    const abc = String.fromCharCode(n % len + order);
    const times = Math.floor(n / len) + 1;
    return repeatStringNumTimes(abc, times);
  }

  // ../packages/core/src/shared/sort-rules.ts
  function sortRules(oa, ob) {
    if (oa.zIndex > ob.zIndex) {
      return 1;
    }
    if (oa.zIndex === ob.zIndex) {
      return 0;
    }
    return -1;
  }
  function sortRulesByDesc(oa, ob) {
    if (oa.zIndex > ob.zIndex) {
      return -1;
    }
    if (oa.zIndex === ob.zIndex) {
      return 0;
    }
    return 1;
  }
  function sortRulesFactory(key = "index", ruler = 1) {
    return (oa, ob) => {
      if (oa[key] > ob[key]) {
        return ruler;
      }
      if (oa[key] === ob[key]) {
        return 0;
      }
      return -ruler;
    };
  }

  // ../packages/core/src/types/const/const.ts
  var DEFAULT_RANGE_ARRAY = {
    sheetId: "",
    range: {
      startRow: -1,
      endRow: -1,
      startColumn: -1,
      endColumn: -1
    }
  };
  var DEFAULT_STYLES = {
    /**
     * fontFamily
     */
    ff: "Times New Roman",
    /**
     * fontSize
     */
    fs: 14,
    /**
     * italic
     * 0: false
     * 1: true
     */
    it: 0 /* FALSE */,
    /**
     * bold
     * 0: false
     * 1: true
     */
    bl: 0 /* FALSE */,
    /**
     * underline
     */
    ul: {
      s: 0 /* FALSE */
    },
    /**
     * strikethrough
     */
    st: {
      s: 0 /* FALSE */
    },
    /**
     * overline
     */
    ol: {
      s: 0 /* FALSE */
    },
    /**
     * textRotation
     */
    tr: {
      a: 0,
      /**
       * true : 1
       * false : 0
       */
      v: 0 /* FALSE */
    },
    /**
     * textDirection
     */
    td: 0 /* UNSPECIFIED */,
    /**
     * color
     */
    cl: {
      rgb: "#000"
    },
    /**
     * background
     */
    bg: {
      rgb: "#fff"
    },
    /**
     * horizontalAlignment
     */
    ht: 0 /* UNSPECIFIED */,
    /**
     * verticalAlignment
     */
    vt: 0 /* UNSPECIFIED */,
    /**
     * wrapStrategy
     */
    tb: 0 /* UNSPECIFIED */,
    /**
     * padding
     */
    pd: {
      t: 0,
      r: 0,
      b: 0,
      l: 0
    }
  };
  var DEFAULT_SLIDE = {
    id: "default_slide",
    title: "defaultSlide",
    pageSize: {
      width: 300,
      height: 300
    }
  };

  // ../packages/core/src/sheets/range.ts
  function isAllFormatInTextRuns(key, body) {
    const { textRuns = [] } = body;
    let len = 0;
    for (const textRun of textRuns) {
      const { ts = {}, st, ed } = textRun;
      if (ts[key] == null) {
        return 0 /* FALSE */;
      }
      switch (key) {
        case "bl":
        case "it": {
          if (ts[key] === 0 /* FALSE */) {
            return 0 /* FALSE */;
          }
          break;
        }
        case "ul":
        case "st": {
          if (ts[key].s === 0 /* FALSE */) {
            return 0 /* FALSE */;
          }
          break;
        }
        default:
          throw new Error(`unknown style key: ${key} in IStyleBase`);
      }
      len += ed - st;
    }
    const index = body.dataStream.indexOf("\r\n");
    return index === len ? 1 /* TRUE */ : 0 /* FALSE */;
  }
  var Range = class _Range {
    constructor(workSheet, range, _deps) {
      this._deps = _deps;
      __publicField(this, "_range");
      __publicField(this, "_worksheet");
      this._range = range;
      this._worksheet = workSheet;
    }
    static foreach(range, action) {
      const { startRow, startColumn, endRow, endColumn } = range;
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startColumn; j <= endColumn; j++) {
          action(i, j);
        }
      }
    }
    /**
     * get current range data
     *
     * @returns current range
     */
    getRangeData() {
      return this._range;
    }
    /**
     * Returns the value of the top-left cell in the range. The value may be of type Number, Boolean, Date, or String
     * depending on the value of the cell. Empty cells return an empty string.
     * @returns  The value in this cell
     */
    getValue() {
      return this.getValues()[0][0];
    }
    /**
     * Returns the rectangular grid of values for this range.
     *
     * Returns a two-dimensional array of values, indexed by row, then by column. The values may be of type Number,
     * Boolean, Date, or String, depending on the value of the cell. Empty cells are represented by an empty string
     * in the array. Remember that while a range index starts at 0, 0, same as the JavaScript array is indexed from [0][0].
     *
     * In web apps, a Date value isn't a legal parameter. getValues() fails to return data to a web app if the range
     * contains a cell with a Date value. Instead, transform all the values retrieved from the sheet to a supported
     * JavaScript primitive like a Number, Boolean, or String.
     *
     * @returns  A two-dimensional array of values.
     */
    getValues() {
      const { startRow, endRow, startColumn, endColumn } = this._range;
      const range = [];
      for (let r = startRow; r <= endRow; r++) {
        const row = [];
        for (let c = startColumn; c <= endColumn; c++) {
          row.push(this.getMatrix().getValue(r, c) || null);
        }
        range.push(row);
      }
      return range;
    }
    /**
     * get range matrix
     *
     * @returns range matrix
     */
    getMatrix() {
      const { startRow, endRow, startColumn, endColumn } = this._range;
      const sheetMatrix = this._worksheet.getCellMatrix();
      const rangeMatrix = new ObjectMatrix();
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startColumn; c <= endColumn; c++) {
          rangeMatrix.setValue(r, c, sheetMatrix.getValue(r, c) || null);
        }
      }
      return rangeMatrix;
    }
    /**
     * get range matrix object
     *
     * @returns range matrix object
     */
    getMatrixObject() {
      const { startRow, endRow, startColumn, endColumn } = this._range;
      const sheetMatrix = this._worksheet.getCellMatrix();
      const rangeMatrix = new ObjectMatrix();
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startColumn; c <= endColumn; c++) {
          rangeMatrix.setValue(r - startRow, c - startColumn, sheetMatrix.getValue(r, c) || {});
        }
      }
      return rangeMatrix;
    }
    /**
     * Returns a string description of the range, in A1 notation.
     *
     * @returns The string description of the range in A1 notation.
     */
    getA1Notation() {
      const { startRow, endRow, startColumn, endColumn } = this._range;
      let start;
      let end;
      if (startColumn < endColumn) {
        start = Tools.numToWord(startColumn + 1) + (startRow + 1);
        end = Tools.numToWord(endColumn + 1) + (endRow + 1);
      } else {
        start = Tools.numToWord(endColumn + 1) + (endRow + 1);
        end = Tools.numToWord(startColumn + 1) + (startRow + 1);
      }
      if (start === end)
        return `${start}`;
      return `${start}:${end}`;
    }
    /**
     * Returns the background color of the top-left cell in the range (for example, '#ffffff').
     *
     * @returns — The color code of the background.
     */
    getBackground() {
      return this.getBackgrounds()[0][0];
    }
    /**
     * Returns the background colors of the cells in the range (for example, '#ffffff').
     *
     * @returns  — A two-dimensional array of color codes of the backgrounds.
     */
    getBackgrounds() {
      const styles = this._deps.getStyles();
      return this.getValues().map(
        (row) => row.map((cell) => {
          var _a2;
          const rgbColor = styles.getStyleByCell(cell);
          return ((_a2 = rgbColor == null ? void 0 : rgbColor.bg) == null ? void 0 : _a2.rgb) || DEFAULT_STYLES.bg.rgb;
        })
      );
    }
    /**
     * Returns a given cell within a range.
     *
     * The row and column here are relative to the range
     * e.g. "B2:D4", getCell(0,0) in this code returns the cell at B2
     * @returns  — A range containing a single cell at the specified coordinates.
     */
    getCell(row, column) {
      const { startRow, endRow, startColumn, endColumn } = this._range;
      const cell = {
        startRow: startRow + row,
        endRow: startRow + row,
        startColumn: startColumn + column,
        endColumn: startColumn + column
      };
      return new _Range(this._worksheet, cell, this._deps);
    }
    /**
     * Returns the starting column position for this range
     *
     * @returns  — The range's starting column position in the spreadsheet.
     */
    getColumn() {
      return this._range.startColumn;
    }
    /**
     * Returns the data of the object structure, and can set whether to bring styles
     */
    getObjectValue(options = {}) {
      return this.getObjectValues(options)[0][0];
    }
    /**
     * Returns the data of the object structure, and can set whether to bring styles
     *
     * @param options set whether to include style
     * @returns Returns a value in object format
     */
    getObjectValues(options = {}) {
      var _a2;
      const { startRow, endRow, startColumn, endColumn } = this._range;
      const values = this._worksheet.getCellMatrix().getFragment(startRow, endRow, startColumn, endColumn).getData();
      if (options.isIncludeStyle) {
        const style = this._deps.getStyles();
        for (let r = 0; r <= endRow - startRow; r++) {
          for (let c = 0; c <= endColumn - startColumn; c++) {
            if (values == null || ((_a2 = values == null ? void 0 : values[r]) == null ? void 0 : _a2[c]) == null) {
              continue;
            }
            const s = values[r][c].s;
            if (s) {
              values[r][c].s = style.get(s);
            }
          }
        }
      }
      return values;
    }
    /**
     * Returns the font color of the cell in the top-left corner of the range, in CSS notation
     */
    getFontColor() {
      return this.getFontColors()[0][0];
    }
    /**
     * Returns the font colors of the cells in the range in CSS notation (such as '#ffffff' or 'white').
     */
    getFontColors() {
      const styles = this._deps.getStyles();
      return this.getValues().map(
        (row) => row.map((cell) => {
          var _a2;
          const cellStyle = styles.getStyleByCell(cell);
          return ((_a2 = cellStyle == null ? void 0 : cellStyle.cl) == null ? void 0 : _a2.rgb) || DEFAULT_STYLES.cl.rgb;
        })
      );
    }
    /**
     * Returns the font families of the cells in the range.
     */
    getFontFamilies() {
      return this._getStyles("ff");
    }
    /**
     * 	Returns the font family of the cell in the top-left corner of the range.
     */
    getFontFamily() {
      return this.getFontFamilies()[0][0];
    }
    /**
     * Returns the underlines of the cells in the range.
     */
    getUnderlines() {
      return this._getStyles("ul");
    }
    /**
     * Returns the underline of the cells in the range.
     */
    getUnderline() {
      var _a2, _b2;
      const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
      if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
        return isAllFormatInTextRuns("ul", p.body) === 1 /* TRUE */ ? {
          s: 1 /* TRUE */
        } : {
          s: 0 /* FALSE */
        };
      }
      return this.getUnderlines()[0][0];
    }
    /**
     * Returns the overlines of the cells in the range.
     */
    getOverlines() {
      return this._getStyles("ol");
    }
    /**
     * Returns the overline of the cells in the range.
     */
    getOverline() {
      return this.getOverlines()[0][0];
    }
    /**
     * Returns the strikeThrough of the cells in the range.
     */
    getStrikeThrough() {
      var _a2, _b2;
      const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
      if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
        return isAllFormatInTextRuns("st", p.body) === 1 /* TRUE */ ? {
          s: 1 /* TRUE */
        } : {
          s: 0 /* FALSE */
        };
      }
      return this.getStrikeThroughs()[0][0];
    }
    /**
     * Returns the strikeThroughs of the cells in the range.
     */
    getStrikeThroughs() {
      return this._getStyles("st");
    }
    /**
     * Returns the font size in point size of the cell in the top-left corner of the range.
     */
    getFontSize() {
      var _a2, _b2;
      const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
      if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
        if (p.body.textRuns.some((textRun) => {
          var _a3;
          return ((_a3 = textRun == null ? void 0 : textRun.ts) == null ? void 0 : _a3.fs) != null;
        })) {
          return Math.max(...p.body.textRuns.map((textRun) => {
            var _a3;
            return ((_a3 = textRun == null ? void 0 : textRun.ts) == null ? void 0 : _a3.fs) || 0;
          }));
        } else {
          return this.getFontSizes()[0][0];
        }
      }
      return this.getFontSizes()[0][0];
    }
    /**
     * Returns the font sizes of the cells in the range.
     */
    getFontSizes() {
      return this._getStyles("fs");
    }
    /**
     * Returns the border info of the cells in the range.
     */
    getBorder() {
      return this.getBorders()[0][0];
    }
    getBorders() {
      return this._getStyles("bd");
    }
    /**
     * Returns the font style ('italic' or 'normal') of the cell in the top-left corner of the range.
     */
    getFontStyle() {
      var _a2, _b2;
      const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
      if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
        return isAllFormatInTextRuns("it", p.body) === 1 /* TRUE */ ? 1 /* ITALIC */ : 0 /* NORMAL */;
      }
      return this._getFontStyles()[0][0];
    }
    /**
     * Returns the font styles of the cells in the range.
     */
    _getFontStyles() {
      return this._getStyles("it");
    }
    /**
     * Returns the font weight (normal/bold) of the cell in the top-left corner of the range.
     * If the cell has rich text, the return value according to the textRuns of the rich text,
     * when all styles of textRuns are bold, it will return FontWeight.BOLD,
     * otherwise return FontWeight.NORMAL.
     */
    getFontWeight() {
      var _a2, _b2;
      const { p } = (_a2 = this.getValue()) != null ? _a2 : {};
      if (p && Array.isArray((_b2 = p.body) == null ? void 0 : _b2.textRuns) && p.body.textRuns.length > 0) {
        return isAllFormatInTextRuns("bl", p.body) === 1 /* TRUE */ ? 1 /* BOLD */ : 0 /* NORMAL */;
      }
      return this._getFontWeights()[0][0];
    }
    /**
     * Returns the font weights of the cells in the range.
     */
    _getFontWeights() {
      return this._getStyles("bl");
    }
    /**
     * Returns the grid ID of the range's parent sheet.
     */
    getGridId() {
      return this._worksheet.getSheetId();
    }
    /**
     * Returns the height of the range.
     */
    getHeight() {
      const { _range: _rangeData, _worksheet } = this;
      const { startRow, endRow } = _rangeData;
      let h = 0;
      for (let i = 0; i <= endRow - startRow; i++) {
        const hh = _worksheet.getRowHeight(i);
        h += hh;
      }
      return h;
    }
    /**
     * 	Returns the horizontal alignment of the text (left/center/right) of the cell in the top-left corner of the range.
     */
    getHorizontalAlignment() {
      return this.getHorizontalAlignments()[0][0];
    }
    /**
     *Returns the horizontal alignments of the cells in the range.
     */
    getHorizontalAlignments() {
      return this._getStyles("ht");
    }
    /**
     * Returns the end column position.
     */
    getLastColumn() {
      return this._range.endColumn;
    }
    /**
     * 	Returns the end row position.
     */
    getLastRow() {
      return this._range.endRow;
    }
    /**
     * Returns the number of columns in this range.
     */
    getNumColumns() {
      const { startColumn, endColumn } = this._range;
      return endColumn - startColumn + 1;
    }
    /**
     * Returns the number of rows in this range.
     */
    getNumRows() {
      const { startRow, endRow } = this._range;
      return endRow - startRow + 1;
    }
    /**
     * Returns the Rich Text value for the top left cell of the range, or null if the cell value is not text.
     */
    getRichTextValue() {
      return this.getRichTextValues()[0][0];
    }
    /**
     * Returns the Rich Text values for the cells in the range.
     */
    getRichTextValues() {
      return this.getValues().map((row) => row.map((cell) => (cell == null ? void 0 : cell.p) || ""));
    }
    /**
     * Returns the row position for this range.
     */
    getRowIndex() {
      return this._range.startRow;
    }
    /**
     * Returns the sheet this range belongs to.
     */
    getSheet() {
      return this._worksheet;
    }
    /**
     * Returns the text direction for the top left cell of the range.
     */
    getTextDirection() {
      return this.getTextDirections()[0][0];
    }
    /**
     * Returns the text directions for the cells in the range.
     */
    getTextDirections() {
      return this._getStyles("td");
    }
    /**
     * Returns the text rotation settings for the top left cell of the range.
     */
    // getTextRotation(): number {
    getTextRotation() {
      return this.getTextRotations()[0][0];
    }
    /**
     * Returns the text rotation settings for the cells in the range.
     */
    // getTextRotations(): number[][] {
    getTextRotations() {
      return this._getStyles("tr");
    }
    /**
     * 	Returns the text style for the top left cell of the range.
     */
    getTextStyle() {
      return this.getTextStyles()[0][0];
    }
    /**
     * Returns the text styles for the cells in the range.
     */
    getTextStyles() {
      const styles = this._deps.getStyles();
      return this.getValues().map((row) => row.map((cell) => styles.getStyleByCell(cell)));
    }
    /**
     * Returns the vertical alignment (top/middle/bottom) of the cell in the top-left corner of the range.
     */
    getVerticalAlignment() {
      return this.getVerticalAlignments()[0][0];
    }
    /**
     * Returns the vertical alignments of the cells in the range.
     */
    getVerticalAlignments() {
      return this._getStyles("vt");
    }
    /**
     * Returns the width of the range in columns.
     */
    getWidth() {
      const { _range: _rangeData, _worksheet } = this;
      const { startColumn, endColumn } = _rangeData;
      let w = 0;
      for (let i = 0; i <= endColumn - startColumn; i++) {
        w += _worksheet.getColumnWidth(i);
      }
      return w;
    }
    /**
     * Returns whether the text in the cell wraps.
     */
    getWrap() {
      return this.getWraps()[0][0];
    }
    /**
     * Returns whether the text in the cells wrap.
     */
    getWraps() {
      return this._getStyles("tb");
    }
    /**
     * Returns the text wrapping strategies for the cells in the range.
     */
    getWrapStrategies() {
      return this._getStyles("tb");
    }
    /**
     * Returns the text wrapping strategy for the top left cell of the range.
     */
    getWrapStrategy() {
      return this.getWrapStrategies()[0][0];
    }
    forEach(action) {
      _Range.foreach(this._range, action);
    }
    /**
     *
     * @param arg Shorthand for the style that gets
     * @returns style value
     */
    _getStyles(styleKey) {
      const styles = this._deps.getStyles();
      return this.getValues().map(
        (row) => row.map((cell) => {
          const style = styles && styles.getStyleByCell(cell);
          return style && style[styleKey] || DEFAULT_STYLES[styleKey];
        })
      );
    }
  };

  // ../packages/core/src/docs/data-model/apply-utils/common.ts
  function normalizeTextRuns(textRuns) {
    const results = [];
    for (const textRun of textRuns) {
      const { st, ed, ts } = textRun;
      if (textRun.sId === void 0) {
        delete textRun.sId;
      }
      if (st === ed) {
        continue;
      }
      if (Tools.isEmptyObject(ts) && textRun.sId == null) {
        continue;
      }
      if (results.length === 0) {
        results.push(textRun);
        continue;
      }
      const peak = results.pop();
      if (isSameStyleTextRun(textRun, peak) && Tools.hasIntersectionBetweenTwoRanges(peak.st, peak.ed, textRun.st, textRun.ed)) {
        results.push({
          ...textRun,
          st: peak.st,
          ed
        });
      } else {
        results.push(peak, textRun);
      }
    }
    return results;
  }
  function insertTextRuns(body, insertBody, textLength, currentIndex) {
    var _a2;
    const { textRuns } = body;
    if (textRuns == null) {
      return;
    }
    const newTextRuns = [];
    const len = textRuns.length;
    let hasInserted = false;
    const insertTextRuns2 = (_a2 = insertBody.textRuns) != null ? _a2 : [];
    if (insertTextRuns2.length) {
      for (let i = 0, len2 = insertTextRuns2.length; i < len2; i++) {
        const insertTextRun = insertTextRuns2[i];
        insertTextRun.st += currentIndex;
        insertTextRun.ed += currentIndex;
      }
    }
    for (let i = 0; i < len; i++) {
      const textRun = textRuns[i];
      const { st, ed } = textRun;
      if (ed < currentIndex) {
        newTextRuns.push(textRun);
      } else if (currentIndex >= st && currentIndex <= ed) {
        if (!hasInserted) {
          hasInserted = true;
          textRun.ed += textLength;
          const pendingTextRuns = [];
          if (insertTextRuns2.length) {
            const startSplitTextRun = {
              ...textRun,
              st,
              ed: insertTextRuns2[0].st
            };
            pendingTextRuns.push(startSplitTextRun);
            pendingTextRuns.push(...insertTextRuns2);
            const lastInsertTextRuns = insertTextRuns2[insertTextRuns2.length - 1];
            const endSplitTextRun = {
              ...textRun,
              st: lastInsertTextRuns.ed,
              ed: ed + textLength
            };
            pendingTextRuns.push(endSplitTextRun);
          } else {
            pendingTextRuns.push(textRun);
          }
          newTextRuns.push(...pendingTextRuns);
        } else {
          textRun.st += textLength;
          textRun.ed += textLength;
          newTextRuns.push(textRun);
        }
      } else {
        textRun.st += textLength;
        textRun.ed += textLength;
        if (!hasInserted) {
          hasInserted = true;
          newTextRuns.push(...insertTextRuns2);
        }
        newTextRuns.push(textRun);
      }
    }
    if (!hasInserted) {
      hasInserted = true;
      newTextRuns.push(...insertTextRuns2);
    }
    body.textRuns = normalizeTextRuns(newTextRuns);
  }
  function insertParagraphs(body, insertBody, textLength, currentIndex) {
    const { paragraphs } = body;
    if (paragraphs == null) {
      return;
    }
    const { paragraphs: insertParagraphs2, dataStream: insertDataStream } = insertBody;
    const paragraphIndexList = [];
    let firstInsertParagraphNextIndex = -1;
    for (let i = 0, len = paragraphs.length; i < len; i++) {
      const paragraph = paragraphs[i];
      const { startIndex } = paragraph;
      if (startIndex >= currentIndex) {
        paragraph.startIndex += textLength;
      }
      if (firstInsertParagraphNextIndex === -1 && startIndex >= currentIndex) {
        firstInsertParagraphNextIndex = i;
      }
      paragraphIndexList.push(paragraph.startIndex);
    }
    let deleteReptIndex = -1;
    if (insertParagraphs2) {
      for (let i = 0, len = insertParagraphs2.length; i < len; i++) {
        const insertParagraph = insertParagraphs2[i];
        insertParagraph.startIndex += currentIndex;
        const insertIndex = insertParagraph.startIndex;
        deleteReptIndex = paragraphIndexList.indexOf(insertIndex);
      }
      if (insertDataStream === "\r" /* PARAGRAPH */ && insertParagraphs2.length === 1) {
        const nextParagraph = paragraphs[firstInsertParagraphNextIndex];
        const insertParagraph = insertParagraphs2[0];
        const nextParagraphStyle = nextParagraph.paragraphStyle;
        const nextBullet = nextParagraph.bullet;
        nextParagraph.paragraphStyle = insertParagraph.paragraphStyle;
        nextParagraph.bullet = insertParagraph.bullet;
        insertParagraph.paragraphStyle = nextParagraphStyle;
        insertParagraph.bullet = nextBullet;
      }
      if (deleteReptIndex !== -1) {
        paragraphs.splice(deleteReptIndex, 1);
      }
      paragraphs.push(...insertParagraphs2);
      paragraphs.sort(sortRulesFactory("startIndex"));
    }
  }
  function insertSectionBreaks(body, insertBody, textLength, currentIndex) {
    const { sectionBreaks } = body;
    if (sectionBreaks == null) {
      return;
    }
    for (let i = 0, len = sectionBreaks.length; i < len; i++) {
      const sectionBreak = sectionBreaks[i];
      const { startIndex } = sectionBreak;
      if (startIndex >= currentIndex) {
        sectionBreak.startIndex += textLength;
      }
    }
    const insertSectionBreaks2 = insertBody.sectionBreaks;
    if (insertSectionBreaks2) {
      for (let i = 0, len = insertSectionBreaks2.length; i < len; i++) {
        const sectionBreak = insertSectionBreaks2[i];
        sectionBreak.startIndex += currentIndex;
      }
      sectionBreaks.push(...insertSectionBreaks2);
      sectionBreaks.sort(sortRulesFactory("startIndex"));
    }
  }
  function insertCustomBlocks(body, insertBody, textLength, currentIndex) {
    const { customBlocks } = body;
    if (customBlocks == null) {
      return;
    }
    for (let i = 0, len = customBlocks.length; i < len; i++) {
      const customBlock = customBlocks[i];
      const { startIndex } = customBlock;
      if (startIndex >= currentIndex) {
        customBlock.startIndex += textLength;
      }
    }
    const insertCustomBlocks2 = insertBody.customBlocks;
    if (insertCustomBlocks2) {
      for (let i = 0, len = insertCustomBlocks2.length; i < len; i++) {
        const customBlock = insertCustomBlocks2[i];
        customBlock.startIndex += currentIndex;
      }
      customBlocks.push(...insertCustomBlocks2);
      customBlocks.sort(sortRulesFactory("startIndex"));
    }
  }
  function insertTables(body, insertBody, textLength, currentIndex) {
    const { tables } = body;
    if (tables == null) {
      return;
    }
    for (let i = 0, len = tables.length; i < len; i++) {
      const table = tables[i];
      const { startIndex, endIndex } = table;
      if (startIndex > currentIndex) {
        table.startIndex += textLength;
        table.endIndex += textLength;
      } else if (endIndex >= currentIndex - 1) {
        table.endIndex += textLength;
      }
    }
    const insertTables2 = insertBody.tables;
    if (insertTables2) {
      for (let i = 0, len = insertTables2.length; i < len; i++) {
        const table = insertTables2[i];
        table.startIndex += currentIndex;
        table.endIndex += currentIndex;
      }
      tables.push(...insertTables2);
      tables.sort(sortRulesFactory("startIndex"));
    }
  }
  function insertCustomRanges(body, insertBody, textLength, currentIndex) {
    const { customRanges } = body;
    if (customRanges == null) {
      return;
    }
    for (let i = 0, len = customRanges.length; i < len; i++) {
      const customRange = customRanges[i];
      const { startIndex, endIndex } = customRange;
      if (startIndex > currentIndex) {
        customRange.startIndex += textLength;
        customRange.endIndex += textLength;
      } else if (endIndex >= currentIndex - 1) {
        customRange.endIndex += textLength;
      }
    }
    const insertCustomRanges2 = insertBody.customRanges;
    if (insertCustomRanges2) {
      for (let i = 0, len = insertCustomRanges2.length; i < len; i++) {
        const customRange = insertCustomRanges2[i];
        customRange.startIndex += currentIndex;
        customRange.endIndex += currentIndex;
      }
      customRanges.push(...insertCustomRanges2);
      customRanges.sort(sortRulesFactory("startIndex"));
    }
  }
  function deleteTextRuns(body, textLength, currentIndex) {
    const { textRuns } = body;
    const startIndex = currentIndex;
    const endIndex = currentIndex + textLength;
    const removeTextRuns = [];
    if (textRuns) {
      const newTextRuns = [];
      for (let i = 0, len = textRuns.length; i < len; i++) {
        const textRun = textRuns[i];
        const { st, ed } = textRun;
        if (startIndex <= st && endIndex >= ed) {
          removeTextRuns.push({
            ...textRun,
            st: st - startIndex,
            ed: ed - startIndex
          });
          continue;
        } else if (st <= startIndex && ed >= endIndex) {
          removeTextRuns.push({
            ...textRun,
            st: startIndex - startIndex,
            ed: endIndex - startIndex
          });
          textRun.ed -= textLength;
        } else if (startIndex >= st && startIndex < ed) {
          removeTextRuns.push({
            ...textRun,
            st: startIndex - startIndex,
            ed: ed - startIndex
          });
          textRun.ed = startIndex;
        } else if (endIndex > st && endIndex <= ed) {
          removeTextRuns.push({
            ...textRun,
            st: st - startIndex,
            ed: endIndex - startIndex
          });
          textRun.st = endIndex - textLength;
          textRun.ed -= textLength;
        } else if (st >= endIndex) {
          textRun.st -= textLength;
          textRun.ed -= textLength;
        }
        newTextRuns.push(textRun);
      }
      body.textRuns = newTextRuns;
    }
    return removeTextRuns;
  }
  function deleteParagraphs(body, textLength, currentIndex) {
    const { paragraphs } = body;
    const startIndex = currentIndex;
    const endIndex = currentIndex + textLength;
    const removeParagraphs = [];
    let removeAfterFirstNew = null;
    let isRemove = false;
    if (paragraphs) {
      const newParagraphs = [];
      for (let i = 0, len = paragraphs.length; i < len; i++) {
        const paragraph = paragraphs[i];
        const { startIndex: index } = paragraph;
        if (index >= startIndex && index < endIndex) {
          removeParagraphs.push({
            ...paragraph,
            startIndex: index - currentIndex
          });
          isRemove = true;
          continue;
        } else if (index >= endIndex) {
          paragraph.startIndex -= textLength;
        }
        newParagraphs.push(paragraph);
        if (removeAfterFirstNew == null && isRemove) {
          removeAfterFirstNew = paragraph;
        }
      }
      body.paragraphs = newParagraphs;
    }
    return removeParagraphs;
  }
  function deleteSectionBreaks(body, textLength, currentIndex) {
    const { sectionBreaks } = body;
    const startIndex = currentIndex;
    const endIndex = currentIndex + textLength - 1;
    const removeSectionBreaks = [];
    if (sectionBreaks) {
      const newSectionBreaks = [];
      for (let i = 0, len = sectionBreaks.length; i < len; i++) {
        const sectionBreak = sectionBreaks[i];
        const { startIndex: index } = sectionBreak;
        if (index >= startIndex && index <= endIndex) {
          removeSectionBreaks.push({
            ...sectionBreak,
            startIndex: index - currentIndex
          });
          continue;
        } else if (index > endIndex) {
          sectionBreak.startIndex -= textLength;
        }
        newSectionBreaks.push(sectionBreak);
      }
      body.sectionBreaks = newSectionBreaks;
    }
    return removeSectionBreaks;
  }
  function deleteCustomBlocks(body, textLength, currentIndex) {
    const { customBlocks } = body;
    const startIndex = currentIndex;
    const endIndex = currentIndex + textLength - 1;
    const removeCustomBlocks = [];
    if (customBlocks) {
      const newCustomBlocks = [];
      for (let i = 0, len = customBlocks.length; i < len; i++) {
        const customBlock = customBlocks[i];
        const { startIndex: index } = customBlock;
        if (index >= startIndex && index <= endIndex) {
          removeCustomBlocks.push({
            ...customBlock,
            startIndex: index - currentIndex
          });
          continue;
        } else if (index > endIndex) {
          customBlock.startIndex -= textLength;
        }
        newCustomBlocks.push(customBlock);
      }
      body.customBlocks = newCustomBlocks;
    }
    return removeCustomBlocks;
  }
  function deleteTables(body, textLength, currentIndex) {
    const { tables } = body;
    const startIndex = currentIndex;
    const endIndex = currentIndex + textLength - 1;
    const removeTables = [];
    if (tables) {
      const newTables = [];
      for (let i = 0, len = tables.length; i < len; i++) {
        const table = tables[i];
        const { startIndex: st, endIndex: ed } = table;
        if (startIndex <= st && endIndex >= ed) {
          removeTables.push({
            ...table,
            startIndex: st - currentIndex,
            endIndex: ed - currentIndex
          });
          continue;
        } else if (st <= startIndex && ed >= endIndex) {
          const segments = horizontalLineSegmentsSubtraction(st, ed, startIndex, endIndex);
          table.startIndex = segments[0];
          table.endIndex = segments[1];
        } else if (endIndex < st) {
          table.startIndex -= textLength;
          table.endIndex -= textLength;
        }
        newTables.push(table);
      }
      body.tables = newTables;
    }
    return removeTables;
  }
  function deleteCustomRanges(body, textLength, currentIndex) {
    const { customRanges } = body;
    const startIndex = currentIndex;
    const endIndex = currentIndex + textLength - 1;
    const removeCustomRanges = [];
    if (customRanges) {
      const newCustomRanges = [];
      for (let i = 0, len = customRanges.length; i < len; i++) {
        const customRange = customRanges[i];
        const { startIndex: st, endIndex: ed } = customRange;
        if (startIndex <= st && endIndex >= ed) {
          removeCustomRanges.push({
            ...customRange,
            startIndex: st - currentIndex,
            endIndex: ed - currentIndex
          });
          continue;
        } else if (st <= startIndex && ed >= endIndex) {
          const segments = horizontalLineSegmentsSubtraction(st, ed, startIndex, endIndex);
          customRange.startIndex = segments[0];
          customRange.endIndex = segments[1];
        } else if (endIndex < st) {
          customRange.startIndex -= textLength;
          customRange.endIndex -= textLength;
        }
        newCustomRanges.push(customRange);
      }
      body.customRanges = newCustomRanges;
    }
    return removeCustomRanges;
  }

  // ../packages/core/src/docs/data-model/apply-utils/delete-apply.ts
  function updateAttributeByDelete(body, textLength, currentIndex) {
    const { dataStream } = body;
    const startIndex = currentIndex;
    const endIndex = currentIndex + textLength;
    const removeTextRuns = deleteTextRuns(body, textLength, currentIndex);
    const removeParagraphs = deleteParagraphs(body, textLength, currentIndex);
    const removeSectionBreaks = deleteSectionBreaks(body, textLength, currentIndex);
    const removeCustomBlocks = deleteCustomBlocks(body, textLength, currentIndex);
    const removeTables = deleteTables(body, textLength, currentIndex);
    const removeCustomRanges = deleteCustomRanges(body, textLength, currentIndex);
    let removeDataStream = "";
    if (dataStream) {
      body.dataStream = deleteContent(dataStream, startIndex, endIndex);
      removeDataStream = dataStream.slice(startIndex, endIndex);
    }
    return {
      dataStream: removeDataStream,
      textRuns: removeTextRuns,
      paragraphs: removeParagraphs,
      sectionBreaks: removeSectionBreaks,
      customBlocks: removeCustomBlocks,
      tables: removeTables,
      customRanges: removeCustomRanges
    };
  }

  // ../packages/core/src/docs/data-model/apply-utils/insert-apply.ts
  function updateAttributeByInsert(body, insertBody, textLength, currentIndex) {
    body.dataStream = insertTextToContent(body.dataStream, currentIndex, insertBody.dataStream);
    insertTextRuns(body, insertBody, textLength, currentIndex);
    insertParagraphs(body, insertBody, textLength, currentIndex);
    insertSectionBreaks(body, insertBody, textLength, currentIndex);
    insertCustomBlocks(body, insertBody, textLength, currentIndex);
    insertTables(body, insertBody, textLength, currentIndex);
    insertCustomRanges(body, insertBody, textLength, currentIndex);
  }

  // ../packages/core/src/docs/data-model/preset-list-type.ts
  var PRESET_LIST_TYPE = {
    ["BULLET_LIST" /* BULLET_LIST */]: {
      listType: "BULLET_LIST" /* BULLET_LIST */,
      nestingLevel: [
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %0",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphSymbol: "\u25CF",
          hanging: 21,
          indentStart: 21
        },
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphSymbol: "\u25A0",
          hanging: 21,
          indentStart: 42
        },
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphSymbol: "\u25C6",
          hanging: 21,
          indentStart: 63
        }
      ]
    },
    ["ORDER_LIST" /* ORDER_LIST */]: {
      listType: "ORDER_LIST" /* ORDER_LIST */,
      nestingLevel: [
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1.",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphType: 2 /* DECIMAL */,
          hanging: 21,
          indentStart: 21
        },
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1.%2)",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphType: 2 /* DECIMAL */,
          hanging: 21,
          indentStart: 42
        },
        {
          bulletAlignment: 1 /* START */,
          glyphFormat: " %1.%2.%3.",
          textStyle: {
            fs: 12
          },
          startNumber: 0,
          glyphType: 2 /* DECIMAL */,
          hanging: 21,
          indentStart: 63
        }
      ]
    }
  };

  // ../packages/core/src/docs/data-model/apply-utils/update-apply.ts
  function updateAttribute(body, updateBody, textLength, currentIndex, coverType) {
    const removeTextRuns = updateTextRuns(body, updateBody, textLength, currentIndex, coverType);
    const removeParagraphs = updateParagraphs(body, updateBody, textLength, currentIndex, coverType);
    const removeSectionBreaks = updateSectionBreaks(body, updateBody, textLength, currentIndex, coverType);
    const removeCustomBlocks = updateCustomBlocks(body, updateBody, textLength, currentIndex, coverType);
    const removeTables = updateTables(body, updateBody, textLength, currentIndex, coverType);
    const removeCustomRanges = updateCustomRanges(body, updateBody, textLength, currentIndex, coverType);
    return {
      dataStream: "",
      textRuns: removeTextRuns,
      paragraphs: removeParagraphs,
      sectionBreaks: removeSectionBreaks,
      customBlocks: removeCustomBlocks,
      tables: removeTables,
      customRanges: removeCustomRanges
    };
  }
  function updateTextRuns(body, updateBody, textLength, currentIndex, coverType) {
    const { textRuns } = body;
    const { textRuns: updateDataTextRuns } = updateBody;
    if (textRuns == null || updateDataTextRuns == null) {
      return;
    }
    const removeTextRuns = deleteTextRuns(body, textLength, currentIndex);
    if (coverType !== 1 /* REPLACE */) {
      const newUpdateTextRun = coverTextRuns(updateDataTextRuns, removeTextRuns, coverType);
      updateBody.textRuns = newUpdateTextRun;
    }
    insertTextRuns(body, updateBody, textLength, currentIndex);
    return removeTextRuns;
  }
  function coverTextRuns(updateDataTextRuns, removeTextRuns, coverType) {
    if (removeTextRuns.length === 0) {
      return updateDataTextRuns;
    }
    updateDataTextRuns = Tools.deepClone(updateDataTextRuns);
    removeTextRuns = Tools.deepClone(removeTextRuns);
    const newUpdateTextRun = [];
    const updateLength = updateDataTextRuns.length;
    const removeLength = removeTextRuns.length;
    let updateIndex = 0;
    let removeIndex = 0;
    let pending = null;
    function pushPendingAndReturnStatus() {
      if (pending) {
        newUpdateTextRun.push(pending);
        pending = null;
        return true;
      }
      return false;
    }
    while (updateIndex < updateLength && removeIndex < removeLength) {
      const { st: updateSt, ed: updateEd, ts: updateStyle } = updateDataTextRuns[updateIndex];
      const { st: removeSt, ed: removeEd, ts: removeStyle, sId } = removeTextRuns[removeIndex];
      let newTs;
      if (coverType === 0 /* COVER */) {
        newTs = { ...removeStyle, ...updateStyle };
      } else {
        newTs = { ...updateStyle, ...removeStyle };
      }
      if (updateEd < removeSt) {
        if (!pushPendingAndReturnStatus()) {
          newUpdateTextRun.push(updateDataTextRuns[updateIndex]);
        }
        updateIndex++;
      } else if (removeEd < updateSt) {
        if (!pushPendingAndReturnStatus()) {
          newUpdateTextRun.push(removeTextRuns[removeIndex]);
        }
        removeIndex++;
      } else {
        newUpdateTextRun.push({
          st: Math.min(updateSt, removeSt),
          ed: Math.max(updateSt, removeSt),
          ts: updateSt < removeSt ? { ...updateStyle } : { ...removeStyle },
          sId: updateSt < removeSt ? void 0 : sId
        });
        newUpdateTextRun.push({
          st: Math.max(updateSt, removeSt),
          ed: Math.min(updateEd, removeEd),
          ts: newTs,
          sId
        });
        if (updateEd < removeEd) {
          updateIndex++;
          removeTextRuns[removeIndex].st = updateEd;
        } else {
          removeIndex++;
          updateDataTextRuns[updateIndex].st = removeEd;
        }
        pending = {
          st: Math.min(updateEd, removeEd),
          ed: Math.max(updateEd, removeEd),
          ts: updateEd < removeEd ? { ...removeStyle } : { ...updateStyle },
          sId: updateEd < removeEd ? sId : void 0
        };
      }
    }
    pushPendingAndReturnStatus();
    const tempTopTextRun = newUpdateTextRun[newUpdateTextRun.length - 1];
    const updateLastTextRun = updateDataTextRuns[updateLength - 1];
    const removeLastTextRun = removeTextRuns[removeLength - 1];
    if (tempTopTextRun.ed !== Math.max(updateLastTextRun.ed, removeLastTextRun.ed)) {
      if (updateLastTextRun.ed > removeLastTextRun.ed) {
        newUpdateTextRun.push(updateLastTextRun);
      } else {
        newUpdateTextRun.push(removeLastTextRun);
      }
    }
    return normalizeTextRuns(newUpdateTextRun);
  }
  function updateParagraphs(body, updateBody, textLength, currentIndex, coverType) {
    const { paragraphs } = body;
    const { paragraphs: updateDataParagraphs } = updateBody;
    if (paragraphs == null || updateDataParagraphs == null) {
      return;
    }
    const removeParagraphs = deleteParagraphs(body, textLength, currentIndex);
    if (coverType !== 1 /* REPLACE */) {
      const newUpdateParagraphs = [];
      for (const updateParagraph of updateDataParagraphs) {
        const {
          startIndex: updateStartIndex,
          paragraphStyle: updateParagraphStyle,
          bullet: updateBullet
        } = updateParagraph;
        let splitUpdateParagraphs = [];
        for (const removeParagraph of removeParagraphs) {
          const {
            startIndex: removeStartIndex,
            paragraphStyle: removeParagraphStyle,
            bullet: removeBullet
          } = removeParagraph;
          let newParagraphStyle;
          let newBullet;
          if (coverType === 0 /* COVER */) {
            newParagraphStyle = { ...removeParagraphStyle, ...updateParagraphStyle };
            newBullet = {
              listId: "",
              listType: "BULLET_LIST" /* BULLET_LIST */,
              nestingLevel: 0,
              textStyle: {},
              ...removeBullet,
              ...updateBullet
            };
          } else {
            newParagraphStyle = { ...updateParagraphStyle, ...removeParagraphStyle };
            newBullet = {
              listId: "",
              listType: "BULLET_LIST" /* BULLET_LIST */,
              nestingLevel: 0,
              textStyle: {},
              ...updateBullet,
              ...removeBullet
            };
          }
          if (updateStartIndex === removeStartIndex) {
            splitUpdateParagraphs.push({
              startIndex: updateStartIndex,
              paragraphStyle: newParagraphStyle,
              bullet: newBullet
            });
            break;
          }
        }
        newUpdateParagraphs.push(...splitUpdateParagraphs);
        splitUpdateParagraphs = [];
      }
      updateBody.paragraphs = newUpdateParagraphs;
    }
    insertParagraphs(body, updateBody, textLength, currentIndex);
    return removeParagraphs;
  }
  function updateSectionBreaks(body, updateBody, textLength, currentIndex, coverType) {
    const { sectionBreaks } = body;
    const { sectionBreaks: updateDataSectionBreaks } = updateBody;
    if (sectionBreaks == null || updateDataSectionBreaks == null) {
      return;
    }
    const removeSectionBreaks = deleteSectionBreaks(body, textLength, currentIndex);
    if (coverType !== 1 /* REPLACE */) {
      const newUpdateSectionBreaks = [];
      for (const updateSectionBreak of updateDataSectionBreaks) {
        const { startIndex: updateStartIndex } = updateSectionBreak;
        let splitUpdateSectionBreaks = [];
        for (const removeSectionBreak of removeSectionBreaks) {
          const { startIndex: removeStartIndex } = removeSectionBreak;
          if (updateStartIndex === removeStartIndex) {
            if (coverType === 0 /* COVER */) {
              splitUpdateSectionBreaks.push({
                ...removeSectionBreak,
                ...updateSectionBreak
              });
            } else {
              splitUpdateSectionBreaks.push({
                ...updateSectionBreak,
                ...removeSectionBreak
              });
            }
            break;
          }
        }
        newUpdateSectionBreaks.push(...splitUpdateSectionBreaks);
        splitUpdateSectionBreaks = [];
      }
      updateBody.sectionBreaks = newUpdateSectionBreaks;
    }
    insertParagraphs(body, updateBody, textLength, currentIndex);
    return removeSectionBreaks;
  }
  function updateCustomBlocks(body, updateBody, textLength, currentIndex, coverType) {
    const { customBlocks } = body;
    const { customBlocks: updateDataCustomBlocks } = updateBody;
    if (customBlocks == null || updateDataCustomBlocks == null) {
      return;
    }
    const removeCustomBlocks = deleteCustomBlocks(body, textLength, currentIndex);
    if (coverType !== 1 /* REPLACE */) {
      const newUpdateCustomBlocks = [];
      for (const updateCustomBlock of updateDataCustomBlocks) {
        const { startIndex: updateStartIndex } = updateCustomBlock;
        let splitUpdateCustomBlocks = [];
        for (const removeCustomBlock of removeCustomBlocks) {
          const { startIndex: removeStartIndex } = removeCustomBlock;
          if (updateStartIndex === removeStartIndex) {
            if (coverType === 0 /* COVER */) {
              splitUpdateCustomBlocks.push({
                ...removeCustomBlock,
                ...updateCustomBlock
              });
            } else {
              splitUpdateCustomBlocks.push({
                ...updateCustomBlock,
                ...removeCustomBlock
              });
            }
            break;
          }
        }
        newUpdateCustomBlocks.push(...splitUpdateCustomBlocks);
        splitUpdateCustomBlocks = [];
      }
      updateBody.customBlocks = newUpdateCustomBlocks;
    }
    insertCustomBlocks(body, updateBody, textLength, currentIndex);
    return removeCustomBlocks;
  }
  function updateTables(body, updateBody, textLength, currentIndex, coverType) {
    const { tables } = body;
    const { tables: updateDataTables } = updateBody;
    if (tables == null || updateDataTables == null) {
      return;
    }
    const removeTables = deleteTables(body, textLength, currentIndex);
    if (coverType !== 1 /* REPLACE */) {
      const newUpdateTables = [];
      for (const updateTable of updateDataTables) {
        const { startIndex: updateStartIndex, endIndex: updateEndIndex } = updateTable;
        let splitUpdateTables = [];
        for (const removeTable of removeTables) {
          const { startIndex: removeStartIndex, endIndex: removeEndIndex } = removeTable;
          if (removeStartIndex >= updateStartIndex && removeEndIndex <= updateEndIndex) {
            if (coverType === 0 /* COVER */) {
              splitUpdateTables.push({
                ...removeTable,
                ...updateTable
              });
            } else {
              splitUpdateTables.push({
                ...updateTable,
                ...removeTable
              });
            }
            break;
          }
        }
        newUpdateTables.push(...splitUpdateTables);
        splitUpdateTables = [];
      }
      updateBody.tables = newUpdateTables;
    }
    insertTables(body, updateBody, textLength, currentIndex);
    return removeTables;
  }
  function updateCustomRanges(body, updateBody, textLength, currentIndex, coverType) {
    const { customRanges } = body;
    const { tables: updateDataCustomRanges } = updateBody;
    if (customRanges == null || updateDataCustomRanges == null) {
      return;
    }
    const removeCustomRanges = deleteCustomRanges(body, textLength, currentIndex);
    if (coverType !== 1 /* REPLACE */) {
      const newUpdateCustomRanges = [];
      for (const updateCustomRange of updateDataCustomRanges) {
        const { startIndex: updateStartIndex, endIndex: updateEndIndex } = updateCustomRange;
        let splitUpdateCustomRanges = [];
        for (const removeCustomRange of removeCustomRanges) {
          const { startIndex: removeStartIndex, endIndex: removeEndIndex } = removeCustomRange;
          if (removeStartIndex >= updateStartIndex && removeEndIndex <= updateEndIndex) {
            if (coverType === 0 /* COVER */) {
              splitUpdateCustomRanges.push({
                ...removeCustomRange,
                ...updateCustomRange
              });
            } else {
              splitUpdateCustomRanges.push({
                ...updateCustomRange,
                ...removeCustomRange
              });
            }
            break;
          }
        }
        newUpdateCustomRanges.push(...splitUpdateCustomRanges);
        splitUpdateCustomRanges = [];
      }
      updateBody.customRanges = newUpdateCustomRanges;
    }
    insertTables(body, updateBody, textLength, currentIndex);
    return removeCustomRanges;
  }

  // ../packages/core/src/docs/data-model/text-x/utils.ts
  function getBodySlice(body, startOffset, endOffset) {
    const { dataStream, textRuns = [], paragraphs = [] } = body;
    const docBody = {
      dataStream: dataStream.slice(startOffset, endOffset)
    };
    const newTextRuns = [];
    for (const textRun of textRuns) {
      const clonedTextRun = Tools.deepClone(textRun);
      const { st, ed } = clonedTextRun;
      if (Tools.hasIntersectionBetweenTwoRanges(st, ed, startOffset, endOffset)) {
        if (startOffset >= st && startOffset <= ed) {
          newTextRuns.push({
            ...clonedTextRun,
            st: startOffset,
            ed: Math.min(endOffset, ed)
          });
        } else if (endOffset >= st && endOffset <= ed) {
          newTextRuns.push({
            ...clonedTextRun,
            st: Math.max(startOffset, st),
            ed: endOffset
          });
        } else {
          newTextRuns.push(clonedTextRun);
        }
      }
    }
    if (newTextRuns.length) {
      docBody.textRuns = newTextRuns.map((tr) => {
        const { st, ed } = tr;
        return {
          ...tr,
          st: st - startOffset,
          ed: ed - startOffset
        };
      });
    }
    const newParagraphs = [];
    for (const paragraph of paragraphs) {
      const { startIndex } = paragraph;
      if (startIndex >= startOffset && startIndex <= endOffset) {
        newParagraphs.push(Tools.deepClone(paragraph));
      }
    }
    if (newParagraphs.length) {
      docBody.paragraphs = newParagraphs.map((p) => ({
        ...p,
        startIndex: p.startIndex - startOffset
      }));
    }
    return docBody;
  }

  // ../packages/core/src/docs/data-model/empty-snapshot.ts
  function getEmptySnapshot(unitID = Tools.generateRandomId(6), locale2 = "enUS" /* EN_US */, title = "") {
    const EMPTY_DOCUMENT_DATA = {
      id: unitID,
      locale: locale2,
      title,
      // title should get from request.
      body: {
        dataStream: "\r\n",
        textRuns: [],
        paragraphs: [
          {
            startIndex: 0,
            paragraphStyle: {
              spaceAbove: 5,
              lineSpacing: 1,
              spaceBelow: 0
            }
          }
        ],
        sectionBreaks: [
          {
            startIndex: 1
          }
        ]
      },
      documentStyle: {
        pageSize: {
          width: 595 / 0.75,
          height: 842 / 0.75
        },
        marginTop: 50,
        marginBottom: 50,
        marginRight: 40,
        marginLeft: 40,
        renderConfig: {
          vertexAngle: 0,
          centerAngle: 0
        }
      },
      settings: {}
    };
    return EMPTY_DOCUMENT_DATA;
  }

  // ../packages/core/src/docs/data-model/document-data-model.ts
  var DEFAULT_DOC = {
    id: "default_doc",
    documentStyle: {}
  };
  var DocumentDataModelSimple = class {
    constructor(snapshot) {
      __publicField(this, "snapshot");
      this.snapshot = { ...DEFAULT_DOC, ...snapshot };
    }
    get drawings() {
      return this.snapshot.drawings;
    }
    get documentStyle() {
      return this.snapshot.documentStyle;
    }
    get lists() {
      return this.snapshot.lists;
    }
    /**
     * @deprecated use getBody to instead.
     */
    get body() {
      return this.snapshot.body;
    }
    get zoomRatio() {
      var _a2;
      return ((_a2 = this.snapshot.settings) == null ? void 0 : _a2.zoomRatio) || 1;
    }
    getBody() {
      return this.snapshot.body;
    }
    getShouldRenderLoopImmediately() {
      const should = this.snapshot.shouldStartRenderingImmediately;
      return should !== false;
    }
    getContainer() {
      return this.snapshot.container;
    }
    getParentRenderUnitId() {
      return this.snapshot.parentRenderUnitId;
    }
    getSnapshot() {
      return this.snapshot;
    }
    updateDocumentId(unitId) {
      this.snapshot.id = unitId;
    }
    updateDocumentRenderConfig(config2) {
      const { documentStyle } = this.snapshot;
      if (documentStyle.renderConfig == null) {
        documentStyle.renderConfig = config2;
      } else {
        documentStyle.renderConfig = {
          ...documentStyle.renderConfig,
          ...config2
        };
      }
    }
    updateDocumentStyle(config2) {
      if (this.snapshot.documentStyle == null) {
        this.snapshot.documentStyle = config2;
      } else {
        this.snapshot.documentStyle = {
          ...this.snapshot.documentStyle,
          ...config2
        };
      }
    }
    updateDocumentDataMargin(data) {
      const { t, l, b, r } = data;
      const { documentStyle } = this.snapshot;
      if (t != null) {
        documentStyle.marginTop = t;
      }
      if (l != null) {
        documentStyle.marginLeft = l;
      }
      if (b != null) {
        documentStyle.marginBottom = b;
      }
      if (r != null) {
        documentStyle.marginRight = r;
      }
    }
    updateDocumentDataPageSize(width, height) {
      const { documentStyle } = this.snapshot;
      if (!documentStyle.pageSize) {
        width = width != null ? width : Number.POSITIVE_INFINITY;
        height = height != null ? height : Number.POSITIVE_INFINITY;
        documentStyle.pageSize = {
          width,
          height
        };
        return;
      }
      if (width !== void 0) {
        documentStyle.pageSize.width = width;
      }
      if (height !== void 0) {
        documentStyle.pageSize.height = height;
      }
    }
    updateDrawing(id, config2) {
      const { drawings } = this;
      const { width, height, left, top } = config2;
      const drawing = drawings == null ? void 0 : drawings[id];
      if (!drawing) {
        return;
      }
      const objectTransform = drawing.objectTransform;
      objectTransform.size.width = width;
      objectTransform.size.height = height;
      objectTransform.positionH.posOffset = left;
      objectTransform.positionV.posOffset = top;
    }
    setZoomRatio(zoomRatio = 1) {
      if (this.snapshot.settings == null) {
        this.snapshot.settings = {
          zoomRatio
        };
      } else {
        this.snapshot.settings.zoomRatio = 1;
      }
    }
  };
  var DocumentDataModel = class _DocumentDataModel extends DocumentDataModelSimple {
    constructor(snapshot) {
      var _a2;
      super(Tools.isEmptyObject(snapshot) ? getEmptySnapshot() : snapshot);
      __publicField(this, "_unitId");
      __publicField(this, "headerModelMap", /* @__PURE__ */ new Map());
      __publicField(this, "footerModelMap", /* @__PURE__ */ new Map());
      const UNIT_ID_LENGTH = 6;
      this._unitId = (_a2 = this.snapshot.id) != null ? _a2 : Tools.generateRandomId(UNIT_ID_LENGTH);
      this._initializeHeaderFooterModel();
    }
    dispose() {
      this.headerModelMap.forEach((header) => {
        header.dispose();
      });
      this.footerModelMap.forEach((footer) => {
        footer.dispose();
      });
    }
    getRev() {
      var _a2;
      return (_a2 = this.snapshot.rev) != null ? _a2 : 1;
    }
    incrementRev() {
      this.snapshot.rev = this.getRev() + 1;
    }
    getSettings() {
      return this.snapshot.settings;
    }
    // TODO: @JOCS do not use reset, please use apply to modify the snapshot.
    reset(snapshot) {
      if (snapshot.id && snapshot.id !== this._unitId) {
        throw new Error("Cannot reset a document model with a different unit id!");
      }
      this.snapshot = { ...DEFAULT_DOC, ...snapshot };
      this._initializeHeaderFooterModel();
    }
    getSelfOrHeaderFooterModel(segmentId) {
      if (segmentId != null) {
        if (this.headerModelMap.has(segmentId)) {
          return this.headerModelMap.get(segmentId);
        }
        if (this.footerModelMap.has(segmentId)) {
          return this.footerModelMap.get(segmentId);
        }
      }
      return this;
    }
    getUnitId() {
      return this._unitId;
    }
    apply(actions) {
      const undoMutations = [];
      const memoryCursor = new MemoryCursor();
      memoryCursor.reset();
      actions.forEach((action) => {
        action = Tools.deepClone(action);
        if (action.t === "r" /* RETAIN */) {
          const { coverType, body, len, segmentId } = action;
          if (body != null) {
            const documentBody = this._updateApply(body, len, memoryCursor.cursor, coverType, segmentId);
            undoMutations.push({
              ...action,
              t: "r" /* RETAIN */,
              coverType: 1 /* REPLACE */,
              body: documentBody
            });
          } else {
            undoMutations.push({
              ...action,
              t: "r" /* RETAIN */
            });
          }
          memoryCursor.moveCursor(len);
        } else if (action.t === "i" /* INSERT */) {
          const { body, len, segmentId, line } = action;
          this._insertApply(body, len, memoryCursor.cursor, segmentId);
          memoryCursor.moveCursor(len);
          undoMutations.push({
            t: "d" /* DELETE */,
            len,
            line,
            segmentId
          });
        } else if (action.t === "d" /* DELETE */) {
          const { len, segmentId } = action;
          const documentBody = this._deleteApply(len, memoryCursor.cursor, segmentId);
          undoMutations.push({
            ...action,
            t: "i" /* INSERT */,
            body: documentBody
          });
        } else {
          throw new Error(`Unknown action type for action: ${action}.`);
        }
      });
      return undoMutations;
    }
    sliceBody(startOffset, endOffset) {
      const body = this.getBody();
      if (body == null) {
        return;
      }
      return getBodySlice(body, startOffset, endOffset);
    }
    _updateApply(updateBody, textLength, currentIndex, coverType = 0 /* COVER */, segmentId) {
      if (updateBody == null) {
        throw new Error("updateBody is none");
      }
      const doc = this.snapshot;
      const body = getDocsUpdateBody(doc, segmentId);
      if (body == null) {
        throw new Error("no body has changed");
      }
      return updateAttribute(body, updateBody, textLength, currentIndex, coverType);
    }
    _deleteApply(textLength, currentIndex, segmentId) {
      const doc = this.snapshot;
      const body = getDocsUpdateBody(doc, segmentId);
      if (body == null) {
        throw new Error("no body has changed");
      }
      if (textLength <= 0) {
        return { dataStream: "" };
      }
      return updateAttributeByDelete(body, textLength, currentIndex);
    }
    _insertApply(insertBody, textLength, currentIndex, segmentId) {
      const doc = this.snapshot;
      const body = getDocsUpdateBody(doc, segmentId);
      if (textLength === 0) {
        return;
      }
      if (body == null) {
        throw new Error("no body has changed");
      }
      updateAttributeByInsert(body, insertBody, textLength, currentIndex);
    }
    _initializeHeaderFooterModel() {
      const { headers, footers } = this.getSnapshot();
      if (headers) {
        for (const headerId in headers) {
          const header = headers[headerId];
          this.headerModelMap.set(headerId, new _DocumentDataModel(header));
        }
      }
      if (footers) {
        for (const footerId in footers) {
          const footer = footers[footerId];
          this.footerModelMap.set(footerId, new _DocumentDataModel(footer));
        }
      }
    }
    updateDocumentId(unitId) {
      super.updateDocumentId(unitId);
      this._unitId = unitId;
    }
  };

  // ../packages/core/src/sheets/styles.ts
  var Styles = class {
    constructor(styles = {}) {
      __publicField(this, "_styles");
      __publicField(this, "_cacheMap", new LRUMap(1e5));
      this._styles = styles;
      this._generateCacheMap();
    }
    each(callback) {
      Object.entries(this._styles).forEach(callback);
      return this;
    }
    search(data, styleObject) {
      if (this._cacheMap.has(styleObject)) {
        return this._cacheMap.get(styleObject);
      }
      const existingId = this._getExistingStyleId(data);
      if (existingId) {
        return existingId;
      }
      return "-1";
    }
    get(id) {
      if (typeof id !== "string")
        return id;
      id = String(id);
      return this._styles[id];
    }
    add(data, styleObject) {
      const id = Tools.generateRandomId(6);
      this._styles[id] = data;
      this._cacheMap.set(styleObject, id);
      return id;
    }
    setValue(data) {
      if (data == null)
        return;
      const styleObject = JSON.stringify(data);
      const result = this.search(data, styleObject);
      if (result !== "-1") {
        return result;
      }
      return this.add(data, styleObject);
    }
    toJSON() {
      return this._styles;
    }
    getStyleByCell(cell) {
      let style;
      if (cell && Tools.isObject(cell.s)) {
        style = cell.s;
      } else {
        style = (cell == null ? void 0 : cell.s) && this.get(cell.s);
      }
      const interceptStyle = cell == null ? void 0 : cell.interceptorStyle;
      if (interceptStyle) {
        return {
          ...style,
          ...interceptStyle
        };
      }
      return style;
    }
    _generateCacheMap() {
      const { _styles, _cacheMap } = this;
      for (const id in _styles) {
        const styleObject = JSON.stringify(_styles[id]);
        _cacheMap.set(styleObject, id);
      }
    }
    _getExistingStyleId(data) {
      const { _styles } = this;
      for (const id in _styles) {
        if (Tools.diffValue(_styles[id], data)) {
          return id;
        }
      }
      return null;
    }
  };

  // ../node_modules/.pnpm/@univerjs+protocol@0.1.14_@grpc+grpc-js@1.10.4_rxjs@7.8.1/node_modules/@univerjs/protocol/lib/es/index.js
  var _ = /* @__PURE__ */ ((E) => (E[E.UNKNOWN = 0] = "UNKNOWN", E[E.STRING = 1] = "STRING", E[E.NUMBER = 2] = "NUMBER", E[E.BOOLEAN = 3] = "BOOLEAN", E[E.FORCE_STRING = 4] = "FORCE_STRING", E[E.UNRECOGNIZED = -1] = "UNRECOGNIZED", E))(_ || {});

  // ../packages/core/src/types/interfaces/i-cell-data.ts
  function isICellData(value) {
    return value && (value.s !== void 0 || value.p !== void 0 || value.v !== void 0 || value.t !== void 0 || value.f !== void 0 || value.si !== void 0);
  }
  function isNullCell(cell) {
    if (cell == null) {
      return true;
    }
    const { v, f, si, p, s } = cell;
    if (!(v == null || typeof v === "string" && v.length === 0)) {
      return false;
    }
    if (f != null && f.length > 0 || si != null && si.length > 0) {
      return false;
    }
    if (p != null) {
      return false;
    }
    return true;
  }

  // ../packages/core/src/sheets/column-manager.ts
  var ColumnManager = class {
    constructor(_config, data) {
      this._config = _config;
      __publicField(this, "_columnData", {});
      this._columnData = data;
    }
    /**
     * Get width and hidden status of columns in the sheet
     * @returns
     */
    getColumnData() {
      return this._columnData;
    }
    getColVisible(colPos) {
      const { _columnData } = this;
      const col = _columnData[colPos];
      if (!col) {
        return true;
      }
      return col.hd !== 1 /* TRUE */;
    }
    /**
     * Get all hidden columns
     * @param start Start index
     * @param end End index
     * @returns Hidden columns range list
     */
    getHiddenCols(start = 0, end = this.getSize() - 1) {
      const hiddenCols = [];
      let inHiddenRange = false;
      let startColumn = -1;
      for (let i = start; i <= end; i++) {
        const visible = this.getColVisible(i);
        if (inHiddenRange && visible) {
          inHiddenRange = false;
          hiddenCols.push({
            rangeType: 2 /* COLUMN */,
            startColumn,
            endColumn: i - 1,
            startRow: 0,
            endRow: 0
          });
        } else if (!inHiddenRange && !visible) {
          inHiddenRange = true;
          startColumn = i;
        }
      }
      if (inHiddenRange) {
        hiddenCols.push({
          startRow: 0,
          endRow: 0,
          startColumn,
          endColumn: end,
          rangeType: 2 /* COLUMN */
        });
      }
      return hiddenCols;
    }
    /**
     * Get all visible columns
     * @param start Start index
     * @param end End index
     * @returns Visible columns range list
     */
    getVisibleCols(start = 0, end = this.getSize() - 1) {
      const visibleCols = [];
      let inVisibleRange = false;
      let startColumn = -1;
      for (let i = start; i <= end; i++) {
        const visible = this.getColVisible(i);
        if (inVisibleRange && !visible) {
          inVisibleRange = false;
          visibleCols.push({
            rangeType: 2 /* COLUMN */,
            startColumn,
            endColumn: i - 1,
            startRow: 0,
            endRow: 0
          });
        } else if (!inVisibleRange && visible) {
          inVisibleRange = true;
          startColumn = i;
        }
      }
      if (inVisibleRange) {
        visibleCols.push({
          startRow: 0,
          endRow: 0,
          startColumn,
          endColumn: end,
          rangeType: 2 /* COLUMN */
        });
      }
      return visibleCols;
    }
    getColumnDatas(columnPos, numColumns) {
      const columnData = {};
      let index = 0;
      for (let i = columnPos; i < columnPos + numColumns; i++) {
        const data = this.getColumnOrCreate(i);
        columnData[index] = data;
        index++;
      }
      return columnData;
    }
    /**
     * Get count of column in the sheet
     * @returns
     */
    getSize() {
      return getArrayLength(this._columnData);
    }
    /**
     * Get the width of column
     * @param columnPos column index
     * @returns
     */
    getColumnWidth(columnPos) {
      const { _columnData } = this;
      const config2 = this._config;
      let width = 0;
      const column = _columnData[columnPos] || {
        hd: 0 /* FALSE */,
        w: config2.defaultColumnWidth
      };
      width = column.w || config2.defaultColumnWidth;
      return width;
    }
    /**
     * get given column data
     * @param columnPos column index
     * @returns
     */
    getColumn(columnPos) {
      const column = this._columnData[columnPos];
      if (column) {
        return column;
      }
    }
    /**
     * get given column data or create a column data when it's null
     * @param columnPos column index
     * @returns
     */
    getColumnOrCreate(columnPos) {
      const { _columnData } = this;
      const config2 = this._config;
      const column = _columnData[columnPos];
      if (column) {
        return column;
      }
      const create = {
        w: config2.defaultColumnWidth,
        hd: 0 /* FALSE */
      };
      this._columnData[columnPos] = create;
      return create;
    }
  };

  // ../packages/core/src/sheets/row-manager.ts
  var RowManager = class {
    constructor(_config, data) {
      this._config = _config;
      __publicField(this, "_rowData");
      this._rowData = data;
    }
    /**
     * Get height and hidden status of columns in the sheet
     * @returns
     */
    getRowData() {
      return this._rowData;
    }
    getRowDatas(rowPos, numRows) {
      const rowData = {};
      let index = 0;
      for (let i = rowPos; i < rowPos + numRows; i++) {
        const data = this.getRowOrCreate(i);
        rowData[index] = data;
        index++;
      }
      return rowData;
    }
    getRowHeight(rowPos, count = 1) {
      const { _rowData } = this;
      const config2 = this._config;
      let height = 0;
      for (let i = 0; i < count; i++) {
        const row = _rowData[i + rowPos] || {
          hd: 0 /* FALSE */,
          h: config2.defaultRowHeight
        };
        const { ia, ah, h = config2.defaultRowHeight } = row;
        height += (ia == null || ia === 1 /* TRUE */) && typeof ah === "number" ? ah : h;
      }
      return height;
    }
    /**
     * Get row data of given row
     * @param rowPos row index
     * @returns
     */
    getRow(rowPos) {
      return this._rowData[rowPos];
    }
    /**
     * Get given row data or create a row data when it's null
     * @param rowPos row index
     * @returns
     */
    getRowOrCreate(rowPos) {
      const { _rowData } = this;
      const row = _rowData[rowPos];
      if (row) {
        return row;
      }
      const config2 = this._config;
      const create = { hd: 0 /* FALSE */, h: config2.defaultRowHeight };
      _rowData[rowPos] = create;
      return create;
    }
    /**
     * Get all hidden rows
     * @param start Start index
     * @param end End index
     * @returns Hidden rows range list
     */
    getHiddenRows(start = 0, end = this.getSize() - 1) {
      const hiddenRows = [];
      let inHiddenRange = false;
      let startRow = -1;
      for (let i = start; i <= end; i++) {
        const visible = this.getRowVisible(i);
        if (inHiddenRange && visible) {
          inHiddenRange = false;
          hiddenRows.push({
            startRow,
            endRow: i - 1,
            startColumn: 0,
            endColumn: 0,
            rangeType: 1 /* ROW */
          });
        } else if (!inHiddenRange && !visible) {
          inHiddenRange = true;
          startRow = i;
        }
      }
      if (inHiddenRange) {
        hiddenRows.push({ startRow, endRow: end, startColumn: 0, endColumn: 0, rangeType: 1 /* ROW */ });
      }
      return hiddenRows;
    }
    /**
     * Get all visible rows
     * @param start Start index
     * @param end End index
     * @returns Visible rows range list
     */
    getVisibleRows(start = 0, end = this.getSize() - 1) {
      const visibleRows = [];
      let inVisibleRange = false;
      let startRow = -1;
      for (let i = start; i <= end; i++) {
        const visible = this.getRowVisible(i);
        if (inVisibleRange && !visible) {
          inVisibleRange = false;
          visibleRows.push({
            startRow,
            endRow: i - 1,
            startColumn: 0,
            endColumn: 0,
            rangeType: 1 /* ROW */
          });
        } else if (!inVisibleRange && visible) {
          inVisibleRange = true;
          startRow = i;
        }
      }
      if (inVisibleRange) {
        visibleRows.push({ startRow, endRow: end, startColumn: 0, endColumn: 0, rangeType: 1 /* ROW */ });
      }
      return visibleRows;
    }
    getRowVisible(rowPos) {
      const row = this.getRow(rowPos);
      if (!row) {
        return true;
      }
      return row.hd !== 1 /* TRUE */;
    }
    /**
     * Get count of row in the sheet
     * @returns
     */
    getSize() {
      return getArrayLength(this._rowData);
    }
  };

  // ../packages/core/src/sheets/sheet-snapshot-utils.ts
  var DEFAULT_WORKSHEET_ROW_COUNT = 1e3;
  var DEFAULT_WORKSHEET_COLUMN_COUNT = 20;
  var DEFAULT_WORKSHEET_ROW_HEIGHT = 19;
  var DEFAULT_WORKSHEET_COLUMN_WIDTH = 73;
  var DEFAULT_WORKSHEET_ROW_TITLE_WIDTH = 46;
  var DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT = 20;
  function mergeWorksheetSnapshotWithDefault(snapshot) {
    const defaultSnapshot = {
      name: "Sheet1",
      id: "sheet-01",
      tabColor: "",
      hidden: 0 /* FALSE */,
      rowCount: DEFAULT_WORKSHEET_ROW_COUNT,
      columnCount: DEFAULT_WORKSHEET_COLUMN_COUNT,
      zoomRatio: 1,
      freeze: {
        xSplit: 0,
        ySplit: 0,
        startRow: -1,
        startColumn: -1
      },
      scrollTop: 0,
      scrollLeft: 0,
      defaultColumnWidth: DEFAULT_WORKSHEET_COLUMN_WIDTH,
      defaultRowHeight: DEFAULT_WORKSHEET_ROW_HEIGHT,
      mergeData: [],
      cellData: {},
      rowData: {},
      columnData: {},
      showGridlines: 1 /* TRUE */,
      rowHeader: {
        width: DEFAULT_WORKSHEET_ROW_TITLE_WIDTH,
        hidden: 0 /* FALSE */
      },
      columnHeader: {
        height: DEFAULT_WORKSHEET_COLUMN_TITLE_HEIGHT,
        hidden: 0 /* FALSE */
      },
      selections: ["A1"],
      rightToLeft: 0 /* FALSE */
    };
    Object.keys(defaultSnapshot).forEach((_key) => {
      const key = _key;
      if (typeof snapshot[key] === "undefined") {
        snapshot[key] = defaultSnapshot[key];
      }
    });
    return snapshot;
  }

  // ../packages/core/src/sheets/view-model.ts
  var SheetViewModel = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_cellContentInterceptors", []);
      __publicField(this, "_rowFilteredInterceptors", []);
      __publicField(this, "_rowVisibleInterceptors", []);
      __publicField(this, "_colVisibleInterceptors", []);
    }
    dispose() {
      super.dispose();
      this._cellContentInterceptors.length = 0;
      this._rowFilteredInterceptors.length = 0;
      this._rowVisibleInterceptors.length = 0;
      this._colVisibleInterceptors.length = 0;
    }
    getCell(row, col) {
      for (const interceptor of this._cellContentInterceptors) {
        const result = interceptor.getCell(row, col);
        if (typeof result !== "undefined") {
          return result;
        }
      }
      return null;
    }
    registerCellContentInterceptor(interceptor) {
      if (this._cellContentInterceptors.includes(interceptor)) {
        throw new Error("[SheetViewModel]: Interceptor already registered.");
      }
      this._cellContentInterceptors.push(interceptor);
      return toDisposable(() => remove(this._cellContentInterceptors, interceptor));
    }
    registerRowFilteredInterceptor(interceptor) {
      if (this._rowFilteredInterceptors.includes(interceptor)) {
        throw new Error("[SheetViewModel]: Interceptor already registered.");
      }
      this._rowFilteredInterceptors.push(interceptor);
      return toDisposable(() => remove(this._rowFilteredInterceptors, interceptor));
    }
    registerRowVisibleInterceptor(interceptor) {
      if (this._rowVisibleInterceptors.includes(interceptor)) {
        throw new Error("[SheetViewModel]: Interceptor already registered.");
      }
      this._rowVisibleInterceptors.push(interceptor);
      return toDisposable(() => remove(this._rowVisibleInterceptors, interceptor));
    }
    registerColVisibleInterceptor(interceptor) {
      if (this._colVisibleInterceptors.includes(interceptor)) {
        throw new Error("[SheetViewModel]: Interceptor already registered.");
      }
      this._colVisibleInterceptors.push(interceptor);
      return toDisposable(() => remove(this._colVisibleInterceptors, interceptor));
    }
  };

  // ../packages/core/src/sheets/worksheet.ts
  var Worksheet = class _Worksheet {
    constructor(snapshot, _styles) {
      this._styles = _styles;
      __publicField(this, "_sheetId");
      __publicField(this, "_snapshot");
      __publicField(this, "_cellData");
      __publicField(this, "_rowManager");
      __publicField(this, "_columnManager");
      __publicField(this, "_viewModel");
      var _a2;
      this._snapshot = mergeWorksheetSnapshotWithDefault(snapshot);
      const { columnData, rowData, cellData } = this._snapshot;
      this._sheetId = (_a2 = this._snapshot.id) != null ? _a2 : Tools.generateRandomId(6);
      this._cellData = new ObjectMatrix(cellData);
      this._rowManager = new RowManager(this._snapshot, rowData);
      this._columnManager = new ColumnManager(this._snapshot, columnData);
      this._viewModel = new SheetViewModel();
    }
    /**
     * @internal
     * @param callback
     */
    __interceptViewModel(callback) {
      callback(this._viewModel);
    }
    getSnapshot() {
      return this._snapshot;
    }
    /**
     * Returns WorkSheet Cell Data Matrix
     * @returns
     */
    getCellMatrix() {
      return this._cellData;
    }
    /**
     * Get worksheet printable cell range.
     * @returns
     */
    getCellMatrixPrintRange() {
      const matrix = this.getCellMatrix();
      const mergedCells = this.getMergeData();
      let startRow = -1;
      let endRow = -1;
      let startColumn = -1;
      let endColumn = -1;
      let rowInitd = false;
      let columnInitd = false;
      matrix.forEach((rowIndex, row) => {
        Object.keys(row).forEach((colIndexStr) => {
          const colIndex = +colIndexStr;
          const cellValue = matrix.getValue(rowIndex, colIndex);
          const style = (cellValue == null ? void 0 : cellValue.s) ? this._styles.get(cellValue.s) : null;
          const isLegalBorder = (style == null ? void 0 : style.bd) && (style.bd.b || style.bd.l || style.bd.r || style.bd.t || style.bd.bc_tr || style.bd.bl_tr || style.bd.ml_tr || style.bd.tl_bc || style.bd.tl_br || style.bd.tl_mr);
          if (cellValue && (cellValue.v || cellValue.p) || (style == null ? void 0 : style.bg) || isLegalBorder) {
            if (rowInitd) {
              startRow = Math.min(startRow, rowIndex);
            } else {
              startRow = rowIndex;
              rowInitd = true;
            }
            endRow = Math.max(endRow, rowIndex);
            if (columnInitd) {
              startColumn = Math.min(startColumn, colIndex);
            } else {
              columnInitd = true;
              startColumn = colIndex;
            }
            endColumn = Math.max(endColumn, colIndex);
          }
        });
      });
      mergedCells.forEach((mergedCell) => {
        if (rowInitd) {
          startRow = Math.min(startRow, mergedCell.startRow);
        } else {
          startRow = mergedCell.startRow;
          rowInitd = true;
        }
        endRow = Math.max(endRow, mergedCell.endRow);
        if (columnInitd) {
          startColumn = Math.min(startColumn, mergedCell.startColumn);
        } else {
          startColumn = mergedCell.startColumn;
          rowInitd = true;
        }
        endColumn = Math.max(endColumn, mergedCell.endColumn);
      });
      if (!rowInitd || !columnInitd) {
        return null;
      }
      return {
        startColumn,
        startRow,
        endColumn,
        endRow
      };
    }
    /**
     * Returns Row Manager
     * @returns Row Manager
     */
    getRowManager() {
      return this._rowManager;
    }
    /**
     * Returns the ID of the sheet represented by this object.
     * @returns ID of the sheet
     */
    getSheetId() {
      return this._sheetId;
    }
    /**
     * Returns Column Manager
     * @returns Column Manager
     */
    getColumnManager() {
      return this._columnManager;
    }
    /**
     * Returns the name of the sheet.
     * @returns name of the sheet
     */
    getName() {
      return this._snapshot.name;
    }
    /**
     * Returns WorkSheet Clone Object
     * @returns WorkSheet Clone Object
     * @deprecated
     */
    clone() {
      const { _snapshot: _config } = this;
      const copy = Tools.deepClone(_config);
      return new _Worksheet(copy, this._styles);
    }
    getMergeData() {
      return this._snapshot.mergeData;
    }
    getMergedCell(row, col) {
      const rectangleList = this._snapshot.mergeData;
      for (let i = 0; i < rectangleList.length; i++) {
        const range = rectangleList[i];
        if (Rectangle.intersects(
          {
            startRow: row,
            startColumn: col,
            endRow: row,
            endColumn: col
          },
          range
        )) {
          return range;
        }
      }
      return null;
    }
    getCell(row, col) {
      if (row < 0 || col < 0) {
        return null;
      }
      return this._viewModel.getCell(row, col);
    }
    getCellRaw(row, col) {
      return this.getCellMatrix().getValue(row, col);
    }
    /**
     * Get cell matrix from a given range and pick out non-first cells of merged cells.
     *
     * Notice that `ICellData` here is not after copying. In another word, the object matrix here should be
     * considered as a slice of the original worksheet data matrix.
     */
    getMatrixWithMergedCells(row, col, endRow, endCol) {
      const matrix = this.getCellMatrix();
      const mergedCellsInRange = this._snapshot.mergeData.filter(
        (rect) => Rectangle.intersects({ startRow: row, startColumn: col, endRow, endColumn: endCol }, rect)
      );
      const ret = new ObjectMatrix();
      createRowColIter(row, endRow, col, endCol).forEach((row2, col2) => {
        const v = matrix.getValue(row2, col2);
        if (v) {
          ret.setValue(row2, col2, v);
        }
      });
      mergedCellsInRange.forEach((mergedCell) => {
        const { startColumn, startRow, endColumn, endRow: endRow2 } = mergedCell;
        createRowColIter(startRow, endRow2, startColumn, endColumn).forEach((row2, col2) => {
          if (row2 === startRow && col2 === startColumn) {
            ret.setValue(row2, col2, {
              ...matrix.getValue(row2, col2),
              rowSpan: endRow2 - startRow + 1,
              colSpan: endColumn - startColumn + 1
            });
          }
          if (row2 !== startRow || col2 !== startColumn) {
            ret.realDeleteValue(row2, col2);
          }
        });
      });
      return ret;
    }
    getRange(startRowOrRange, startColumn, endRow, endColumn) {
      if (typeof startRowOrRange === "object") {
        return new Range(this, startRowOrRange, {
          getStyles: () => this._styles
        });
      }
      return new Range(
        this,
        {
          startRow: startRowOrRange,
          startColumn,
          endColumn: endColumn || startColumn,
          endRow: endRow || startRowOrRange
        },
        {
          getStyles: () => this._styles
        }
      );
    }
    /**
     * Return WorkSheetZoomRatio
     * @return zoomRatio
     */
    getZoomRatio() {
      return this._snapshot.zoomRatio || 1;
    }
    /**
     * Returns WorkSheet Configures
     * @returns WorkSheet Configures
     */
    getConfig() {
      return this._snapshot;
    }
    /**
     * Returns  frozen.
     * @returns  frozen
     */
    getFreeze() {
      return this._snapshot.freeze;
    }
    /**
     * Returns the current number of columns in the sheet, regardless of content.
     * @returns the current number of columns in the sheet, regardless of content
     */
    getMaxColumns() {
      const { _snapshot: _config } = this;
      const { columnCount } = _config;
      return columnCount;
    }
    /**
     * Returns the current number of rows in the sheet, regardless of content.
     * @returns the current number of rows in the sheet, regardless of content
     */
    getMaxRows() {
      const { _snapshot: _config } = this;
      const { rowCount } = _config;
      return rowCount;
    }
    getRowCount() {
      return this._snapshot.rowCount;
    }
    setRowCount(count) {
      this._snapshot.rowCount = count;
    }
    getColumnCount() {
      return this._snapshot.columnCount;
    }
    setColumnCount(count) {
      this._snapshot.columnCount = count;
    }
    /**
     * isSheetHidden
     * @returns hidden status of sheet
     */
    isSheetHidden() {
      return this._snapshot.hidden;
    }
    /**
     * Returns true if the sheet's gridlines are hidden; otherwise returns false. Gridlines are visible by default.
     * @returns Gridlines Hidden Status
     */
    hasHiddenGridlines() {
      const { _snapshot: _config } = this;
      const { showGridlines } = _config;
      if (showGridlines === 0) {
        return true;
      }
      return false;
    }
    /**
     * Gets the sheet tab color, or null if the sheet tab has no color.
     * @returns the sheet tab color or null
     */
    getTabColor() {
      const { _snapshot: _config } = this;
      const { tabColor } = _config;
      return tabColor;
    }
    /**
     * Gets the width in pixels of the given column.
     * @param columnPosition column index
     * @returns Gets the width in pixels of the given column.
     */
    getColumnWidth(columnPosition) {
      return this.getColumnManager().getColumnWidth(columnPosition);
    }
    /**
     * Gets the height in pixels of the given row.
     * @param rowPosition row index
     * @returns Gets the height in pixels of the given row.
     */
    getRowHeight(rowPosition) {
      return this.getRowManager().getRowHeight(rowPosition);
    }
    getRowVisible(row) {
      return this.getRowManager().getRowVisible(row);
    }
    getHiddenRows(start, end) {
      const lastColumn = this.getMaxColumns() - 1;
      const ranges = this._rowManager.getHiddenRows(start, end);
      ranges.forEach((range) => range.endColumn = lastColumn);
      return ranges;
    }
    getColVisible(col) {
      return this._columnManager.getColVisible(col);
    }
    getHiddenCols(start, end) {
      const lastRow = this.getMaxRows() - 1;
      const ranges = this._columnManager.getHiddenCols(start, end);
      ranges.forEach((range) => range.endRow = lastRow);
      return ranges;
    }
    /**
     * Get all visible rows in the sheet.
     * @returns Visible rows range list
     */
    getVisibleRows() {
      const rowCount = this.getRowCount();
      return this._rowManager.getVisibleRows(0, rowCount - 1);
    }
    /**
     * Get all visible columns in the sheet.
     * @returns Visible columns range list
     */
    getVisibleCols() {
      const columnCount = this.getColumnCount();
      return this._columnManager.getVisibleCols(0, columnCount - 1);
    }
    /**
     * Returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
     * @returns true if this sheet layout is right-to-left. Returns false if the sheet uses the default left-to-right layout.
     */
    isRightToLeft() {
      const { _snapshot: _config } = this;
      const { rightToLeft } = _config;
      return rightToLeft;
    }
    /**
     * Returns the position of the last row that has content.
     * @returns the position of the last row that has content.
     */
    getLastRowWithContent() {
      return this._cellData.getLength() - 1;
    }
    /**
     * Returns the position of the last column that has content.
     * @returns the position of the last column that has content.
     */
    getLastColumnWithContent() {
      return this._cellData.getRange().endColumn;
    }
    cellHasValue(value) {
      return value && (value.v !== void 0 || value.f !== void 0 || value.p !== void 0);
    }
    // #region iterators
    // NOTE: performance intensive. Should keep an eye on methods in this region.
    /**
     * Iterate a range row by row.
     *
     * Performance intensive.
     */
    iterateByRow(range) {
      const { startRow, startColumn, endRow, endColumn } = range;
      const worksheet = this;
      let rowIndex = startRow;
      let columnIndex = startColumn;
      return {
        next() {
          while (true) {
            if (columnIndex > endColumn) {
              rowIndex += 1;
              columnIndex = startColumn;
            }
            if (rowIndex > endRow) {
              return { done: true, value: void 0 };
            }
            const cellValue = worksheet.getCell(rowIndex, columnIndex);
            const mergedCell = worksheet.getMergedCell(rowIndex, columnIndex);
            if (mergedCell && (!cellValue || rowIndex !== mergedCell.startRow || columnIndex !== mergedCell.startColumn)) {
              columnIndex = mergedCell.endColumn + 1;
            } else if (!cellValue) {
              columnIndex += 1;
            } else {
              const value = { row: rowIndex, col: columnIndex, value: cellValue };
              if (mergedCell) {
                value.colSpan = mergedCell.endColumn - mergedCell.startColumn + 1;
                value.rowSpan = mergedCell.endRow - mergedCell.startRow + 1;
              }
              columnIndex += 1;
              return { done: false, value };
            }
          }
        }
      };
    }
    /**
     * Iterate a range column by column. This is pretty similar to `iterateByRow` but with different order.
     *
     * Performance intensive.
     */
    iterateByColumn(range) {
      const { startRow, startColumn, endRow, endColumn } = range;
      const worksheet = this;
      let rowIndex = startRow;
      let columnIndex = startColumn;
      return {
        next() {
          while (true) {
            if (rowIndex > endRow) {
              columnIndex += 1;
              rowIndex = startRow;
            }
            if (columnIndex > endColumn) {
              return { done: true, value: void 0 };
            }
            const cellValue = worksheet.getCell(rowIndex, columnIndex);
            const mergedCell = worksheet.getMergedCell(rowIndex, columnIndex);
            if (mergedCell && (!cellValue || rowIndex !== mergedCell.startRow || columnIndex !== mergedCell.startColumn)) {
              rowIndex = mergedCell.endRow + 1;
            } else if (!cellValue) {
              rowIndex += 1;
            } else {
              const value = { row: rowIndex, col: columnIndex, value: cellValue };
              if (mergedCell) {
                value.colSpan = mergedCell.endColumn - mergedCell.startColumn + 1;
                value.rowSpan = mergedCell.endRow - mergedCell.startRow + 1;
              }
              rowIndex += 1;
              return { done: false, value };
            }
          }
        }
      };
    }
    // #endregion
  };
  function extractPureTextFromCell(cell) {
    var _a2, _b2;
    const richTextValue = (_b2 = (_a2 = cell.p) == null ? void 0 : _a2.body) == null ? void 0 : _b2.dataStream;
    if (richTextValue)
      return richTextValue;
    const rawValue = cell.v;
    if (typeof rawValue === "string") {
      if (cell.t === _.BOOLEAN)
        return rawValue.toUpperCase();
      return rawValue;
    }
    ;
    if (typeof rawValue === "number") {
      if (cell.t === _.BOOLEAN)
        return rawValue ? "TRUE" : "FALSE";
      return rawValue.toString();
    }
    ;
    if (typeof rawValue === "boolean")
      return rawValue ? "TRUE" : "FALSE";
    return "";
  }

  // ../packages/core/package.json
  var version = "0.1.5";

  // ../packages/core/src/sheets/empty-snapshot.ts
  function getEmptySnapshot2(unitID = "", locale2 = "zhCN" /* ZH_CN */, name = "") {
    const DEFAULT_WORKBOOK_DATA = {
      id: unitID,
      sheetOrder: [],
      name,
      appVersion: version,
      locale: locale2,
      styles: {},
      sheets: {},
      resources: []
    };
    return DEFAULT_WORKBOOK_DATA;
  }

  // ../packages/core/src/sheets/workbook.ts
  var Workbook = class extends Disposable {
    constructor(workbookData = {}, _logService) {
      super();
      this._logService = _logService;
      __publicField(this, "_sheetCreated$", new Subject());
      __publicField(this, "sheetCreated$", this._sheetCreated$.asObservable());
      __publicField(this, "_sheetDisposed$", new Subject());
      __publicField(this, "sheetDisposed$", this._sheetDisposed$.asObservable());
      __publicField(this, "_activeSheet$", new BehaviorSubject(null));
      __publicField(this, "activeSheet$", this._activeSheet$.asObservable());
      /**
       * sheets list
       * @private
       */
      __publicField(this, "_worksheets");
      /**
       * Common style
       * @private
       */
      __publicField(this, "_styles");
      /**
       * number format
       * @private
       */
      // private _formatManage: FormatManager;
      __publicField(this, "_snapshot");
      __publicField(this, "_unitId");
      __publicField(this, "_count");
      const DEFAULT_WORKBOOK = getEmptySnapshot2();
      if (Tools.isEmptyObject(workbookData)) {
        this._snapshot = DEFAULT_WORKBOOK;
      } else {
        this._snapshot = Tools.commonExtend(DEFAULT_WORKBOOK, workbookData);
      }
      const { styles } = this._snapshot;
      if (this._snapshot.id == null || this._snapshot.id.length === 0) {
        this._snapshot.id = Tools.generateRandomId(6);
      }
      this._unitId = this._snapshot.id;
      this._styles = new Styles(styles);
      this._count = 1;
      this._worksheets = /* @__PURE__ */ new Map();
      this._passWorksheetSnapshots();
    }
    get _activeSheet() {
      return this._activeSheet$.getValue();
    }
    get name() {
      return this._snapshot.name;
    }
    dispose() {
      super.dispose();
      this._sheetCreated$.complete();
      this._sheetDisposed$.complete();
      this._activeSheet$.complete();
    }
    save() {
      return Tools.deepClone(this._snapshot);
    }
    static isIRangeType(range) {
      return typeof range === "string" || "startRow" in range || "row" in range;
    }
    getSnapshot() {
      return this._snapshot;
    }
    getName() {
      return this._snapshot.name;
    }
    getUnitId() {
      return this._unitId;
    }
    getRev() {
      var _a2;
      return (_a2 = this._snapshot.rev) != null ? _a2 : 1;
    }
    incrementRev() {
      this._snapshot.rev = this.getRev() + 1;
    }
    getShouldRenderLoopImmediately() {
      const should = this._snapshot.shouldStartRenderingImmediately;
      return should !== false;
    }
    getContainer() {
      return this._snapshot.container;
    }
    /**
     * Add a Worksheet into Workbook.
     */
    addWorksheet(id, index, worksheetSnapshot) {
      const { sheets, sheetOrder } = this._snapshot;
      if (sheets[id]) {
        return false;
      }
      sheets[id] = worksheetSnapshot;
      sheetOrder.splice(index, 0, id);
      const worksheet = new Worksheet(worksheetSnapshot, this._styles);
      this._worksheets.set(id, worksheet);
      this._sheetCreated$.next(worksheet);
      return true;
    }
    getParentRenderUnitId() {
      return this._snapshot.parentRenderUnitId;
    }
    getSheetOrders() {
      return this._snapshot.sheetOrder;
    }
    getWorksheets() {
      return this._worksheets;
    }
    getActiveSpreadsheet() {
      return this;
    }
    getStyles() {
      return this._styles;
    }
    getConfig() {
      return this._snapshot;
    }
    getIndexBySheetId(sheetId) {
      const { sheetOrder } = this._snapshot;
      return sheetOrder.findIndex((id) => id === sheetId);
    }
    /**
     *
     * @returns
     */
    getRawActiveSheet() {
      return this._activeSheet;
    }
    /**
     * Get the active sheet. If there is no active sheet, the first sheet would
     * be set active.
     */
    getActiveSheet() {
      const currentActive = this.getRawActiveSheet();
      if (currentActive) {
        return currentActive;
      }
      const sheetOrder = this._snapshot.sheetOrder;
      for (let i = 0, len = sheetOrder.length; i < len; i++) {
        const worksheet2 = this._worksheets.get(sheetOrder[i]);
        if (worksheet2 && worksheet2.isSheetHidden() !== 1 /* TRUE */) {
          this.setActiveSheet(worksheet2);
          return worksheet2;
        }
      }
      const worksheet = this._worksheets.get(sheetOrder[0]);
      this.setActiveSheet(worksheet);
      return worksheet;
    }
    setActiveSheet(worksheet) {
      this._activeSheet$.next(worksheet);
    }
    removeSheet(sheetId) {
      var _a2;
      const sheetToRemove = this._worksheets.get(sheetId);
      if (!sheetToRemove) {
        return false;
      }
      if (((_a2 = this._activeSheet) == null ? void 0 : _a2.getSheetId()) === sheetId) {
        this.setActiveSheet(null);
      }
      this._worksheets.delete(sheetId);
      this._snapshot.sheetOrder.splice(this._snapshot.sheetOrder.indexOf(sheetId), 1);
      delete this._snapshot.sheets[sheetId];
      return true;
    }
    getActiveSheetIndex() {
      const { sheetOrder } = this._snapshot;
      return sheetOrder.findIndex((sheetId) => {
        const worksheet = this._worksheets.get(sheetId);
        return worksheet === this._activeSheet;
      });
    }
    getSheetSize() {
      return this._snapshot.sheetOrder.length;
    }
    getSheets() {
      const { sheetOrder } = this._snapshot;
      return sheetOrder.map((sheetId) => this._worksheets.get(sheetId));
    }
    getSheetsName() {
      const { sheetOrder } = this._snapshot;
      const names = [];
      sheetOrder.forEach((sheetId) => {
        const worksheet = this._worksheets.get(sheetId);
        if (worksheet) {
          names.push(worksheet.getName());
        }
      });
      return names;
    }
    getSheetIndex(sheet) {
      const { sheetOrder } = this._snapshot;
      return sheetOrder.findIndex((sheetId) => {
        if (sheet.getSheetId() === sheetId) {
          return true;
        }
        return false;
      });
    }
    getSheetBySheetName(name) {
      const { sheetOrder } = this._snapshot;
      const sheetId = sheetOrder.find((sheetId2) => {
        const worksheet = this._worksheets.get(sheetId2);
        return worksheet.getName() === name;
      });
      return this._worksheets.get(sheetId);
    }
    getSheetBySheetId(sheetId) {
      return this._worksheets.get(sheetId);
    }
    getSheetByIndex(index) {
      const { sheetOrder } = this._snapshot;
      return this._worksheets.get(sheetOrder[index]);
    }
    getHiddenWorksheets() {
      return this.getSheets().filter((s) => s.getConfig().hidden === 1 /* TRUE */).map((s) => s.getConfig().id);
    }
    /**
     * transform any range type to range data
     *
     * @remarks
     * e.g.,
     * "A1:B1", "Sheet2!A1:B1"
     *
     * or
     *
     * {
     *  row:[0,1],
     *  column:[0,1]
     * }
     *
     * or
     *
     * {
     *    startRow:0 ,
     *    startColumn:0,
     *    endRow:1,
     *    endColumn:1,
     * }
     *
     * to
     *
     * {
     *    startRow:0 ,
     *    startColumn:0,
     *    endRow:1,
     *    endColumn:1,
     * }
     *
     *   IRangeType[] is to prevent type detection
     *
     * @param range support all range types
     *
     * @returns range data
     */
    transformRangeType(range) {
      if (typeof range === "string") {
        const gridRange = this._getCellRange(range);
        return gridRange;
      }
      if (typeof range !== "string" && "row" in range) {
        const rangeArrayData = range;
        return {
          sheetId: "",
          range: {
            startRow: rangeArrayData.row[0],
            startColumn: rangeArrayData.column[0],
            endRow: rangeArrayData.row[1],
            endColumn: rangeArrayData.column[1]
          }
        };
      }
      if (typeof range !== "string" && "startRow" in range) {
        return { sheetId: "", range };
      }
      return DEFAULT_RANGE_ARRAY;
    }
    load(config2) {
      this._snapshot = config2;
    }
    /**
     * Check if sheet name is unique
     * @param name sheet name
     * @returns True if sheet name is unique
     */
    checkSheetName(name) {
      const sheetsName = this.getSheetsName();
      return sheetsName.includes(name);
    }
    /**
     *  Check whether the sheet name is unique and generate a new unique sheet name
     * @param name sheet name
     * @returns Unique sheet name
     */
    uniqueSheetName(name = "Sheet1") {
      let output = name;
      while (this.checkSheetName(output)) {
        output = name + this._count;
        this._count++;
      }
      return output;
    }
    /**
     * Automatically generate new sheet name
     * @param name sheet name
     * @returns New sheet name
     */
    generateNewSheetName(name) {
      let output = name + this._count;
      while (this.checkSheetName(output)) {
        output = name + this._count;
        this._count++;
      }
      return output;
    }
    /**
     * Get the range array based on the range string and sheet id
     *
     * @param txt - range string
     * @returns
     */
    _getCellRange(txt) {
      var _a2, _b2, _c, _d, _e;
      let sheetTxt = "";
      let rangeTxt = "";
      if (txt.indexOf("!") > -1) {
        const val = txt.split("!");
        sheetTxt = val[0];
        rangeTxt = val[1];
        sheetTxt = sheetTxt.replace(/\\'/g, "'").replace(/''/g, "'");
        if (sheetTxt.substring(0, 1) === "'" && sheetTxt.substring(sheetTxt.length - 1, 1) === "'") {
          sheetTxt = sheetTxt.substring(1, sheetTxt.length - 1);
        }
      } else {
        rangeTxt = txt;
      }
      if (rangeTxt.indexOf(":") === -1) {
        const row2 = Number.parseInt(rangeTxt.replace(/[^0-9]/g, ""), 10) - 1;
        const col2 = Tools.ABCatNum(rangeTxt.replace(/[^A-Za-z]/g, ""));
        if (!Number.isNaN(row2) && !Number.isNaN(col2)) {
          const item2 = {
            sheetId: sheetTxt,
            range: {
              startRow: row2,
              endRow: row2,
              startColumn: col2,
              endColumn: col2
            }
          };
          return item2;
        }
        return DEFAULT_RANGE_ARRAY;
      }
      rangeTxt = rangeTxt.split(":");
      const row = [0, 0];
      const col = [0, 0];
      const maxRow = ((_a2 = this.getSheetBySheetName(sheetTxt)) == null ? void 0 : _a2.getMaxRows()) || ((_b2 = this.getActiveSheet()) == null ? void 0 : _b2.getMaxRows());
      const maxCol = ((_c = this.getSheetBySheetName(sheetTxt)) == null ? void 0 : _c.getMaxColumns()) || ((_d = this.getActiveSheet()) == null ? void 0 : _d.getMaxColumns());
      row[0] = Number.parseInt(rangeTxt[0].replace(/[^0-9]/g, ""), 10) - 1;
      row[1] = Number.parseInt(rangeTxt[1].replace(/[^0-9]/g, ""), 10) - 1;
      if (Number.isNaN(row[0])) {
        row[0] = 0;
      }
      if (Number.isNaN(row[1])) {
        row[1] = maxRow;
      }
      if (row[0] > row[1]) {
        return DEFAULT_RANGE_ARRAY;
      }
      col[0] = Tools.ABCatNum(rangeTxt[0].replace(/[^A-Za-z]/g, ""));
      col[1] = Tools.ABCatNum(rangeTxt[1].replace(/[^A-Za-z]/g, ""));
      if (Number.isNaN(col[0])) {
        col[0] = 0;
      }
      if (Number.isNaN(col[1])) {
        col[1] = maxCol;
      }
      if (col[0] > col[1]) {
        return DEFAULT_RANGE_ARRAY;
      }
      const item = {
        sheetId: ((_e = this.getSheetBySheetName(sheetTxt)) == null ? void 0 : _e.getSheetId()) || "",
        range: {
          startRow: row[0],
          endRow: row[1],
          startColumn: col[0],
          endColumn: col[1]
        }
      };
      return item;
    }
    // FIXME: now we always create worksheet from DEFAULT_WORKSHEET?
    /**
     * Get Default Sheet
     */
    _passWorksheetSnapshots() {
      const { _snapshot, _worksheets } = this;
      const { sheets, sheetOrder } = _snapshot;
      if (Tools.isEmptyObject(sheets)) {
        const firstSheetId = Tools.generateRandomId();
        sheets[firstSheetId] = { id: firstSheetId };
      }
      for (const sheetId in sheets) {
        const worksheetSnapshot = sheets[sheetId];
        const { name } = worksheetSnapshot;
        worksheetSnapshot.name = this.uniqueSheetName(name);
        if (worksheetSnapshot.name !== name) {
          this._logService.debug("[Workbook]", `The worksheet name ${name} is duplicated, we changed it to ${worksheetSnapshot.name}. Please fix the problem in your snapshot.`);
        }
        const worksheet = new Worksheet(worksheetSnapshot, this._styles);
        _worksheets.set(sheetId, worksheet);
        if (!sheetOrder.includes(sheetId)) {
          sheetOrder.push(sheetId);
        }
      }
    }
  };
  Workbook = __decorateClass([
    __decorateParam(1, ILogService)
  ], Workbook);

  // ../packages/core/src/slides/domain/slide-model.ts
  var SlideDataModel = class {
    constructor(snapshot) {
      __publicField(this, "_snapshot");
      __publicField(this, "_unitId");
      var _a2;
      this._snapshot = { ...DEFAULT_SLIDE, ...snapshot };
      this._unitId = (_a2 = this._snapshot.id) != null ? _a2 : Tools.generateRandomId(6);
    }
    getContainer() {
      return this._snapshot.container;
    }
    getParentRenderUnitId() {
      return this._snapshot.parentRenderUnitId;
    }
    getSnapshot() {
      return this._snapshot;
    }
    getUnitId() {
      return this._unitId;
    }
    getPages() {
      var _a2;
      return (_a2 = this._snapshot.body) == null ? void 0 : _a2.pages;
    }
    getPageOrder() {
      var _a2;
      return (_a2 = this._snapshot.body) == null ? void 0 : _a2.pageOrder;
    }
    getPage(pageId) {
      const pages = this.getPages();
      return pages == null ? void 0 : pages[pageId];
    }
    getElementsByPage(pageId) {
      var _a2;
      return (_a2 = this.getPage(pageId)) == null ? void 0 : _a2.pageElements;
    }
    getElement(pageId, elementId) {
      var _a2;
      return (_a2 = this.getElementsByPage(pageId)) == null ? void 0 : _a2[elementId];
    }
    getPageSize() {
      return this._snapshot.pageSize;
    }
    addPage() {
      return {
        id: "cover_1",
        pageType: 0 /* SLIDE */,
        zIndex: 1,
        title: "cover",
        description: "this is first page, cover",
        pageBackgroundFill: {
          rgb: "rgb(255,255,255)"
        },
        pageElements: {}
      };
    }
  };

  // ../packages/core/src/services/context/context.ts
  var FOCUSING_SHEET = "FOCUSING_SHEET";
  var FOCUSING_DOC = "FOCUSING_DOC";
  var FOCUSING_SLIDE = "FOCUSING_SLIDE";
  var EDITOR_ACTIVATED = "EDITOR_ACTIVATED";
  var FOCUSING_FORMULA_EDITOR = "FOCUSING_FORMULA_EDITOR";

  // ../packages/core/src/services/instance/instance.service.ts
  var IUniverInstanceService = createIdentifier("univer.current");
  var UniverInstanceService = class extends Disposable {
    constructor(_handler, _contextService) {
      super();
      this._handler = _handler;
      this._contextService = _contextService;
      __publicField(this, "_focused", null);
      __publicField(this, "_focused$", new BehaviorSubject(null));
      __publicField(this, "focused$", this._focused$.asObservable());
      __publicField(this, "_currentSheet$", new BehaviorSubject(null));
      __publicField(this, "currentSheet$", this._currentSheet$.asObservable());
      __publicField(this, "_currentDoc$", new BehaviorSubject(null));
      __publicField(this, "currentDoc$", this._currentDoc$.asObservable());
      __publicField(this, "_currentSlide$", new BehaviorSubject(null));
      __publicField(this, "currentSlide$", this._currentSlide$.asObservable());
      __publicField(this, "_sheetAdded$", new Subject());
      __publicField(this, "sheetAdded$", this._sheetAdded$.asObservable());
      __publicField(this, "_docAdded$", new Subject());
      __publicField(this, "docAdded$", this._docAdded$.asObservable());
      __publicField(this, "_slideAdded$", new Subject());
      __publicField(this, "slideAdded$", this._slideAdded$.asObservable());
      __publicField(this, "_sheetDisposed$", new Subject());
      __publicField(this, "sheetDisposed$", this._sheetDisposed$.asObservable());
      __publicField(this, "_docDisposed$", new Subject());
      __publicField(this, "docDisposed$", this._docDisposed$.asObservable());
      __publicField(this, "_slideDisposed$", new Subject());
      __publicField(this, "slideDisposed$", this._slideDisposed$.asObservable());
      __publicField(this, "_sheets", []);
      __publicField(this, "_docs", []);
      __publicField(this, "_slides", []);
    }
    dispose() {
      super.dispose();
      this._focused$.complete();
      this._currentDoc$.complete();
      this._currentSheet$.complete();
      this._currentSlide$.complete();
      this._sheetAdded$.complete();
      this._docAdded$.complete();
      this._slideAdded$.complete();
      this._sheetDisposed$.complete();
      this._docDisposed$.complete();
      this._slideDisposed$.complete();
    }
    createDoc(data) {
      return this._handler.createUniverDoc(data);
    }
    createSheet(data) {
      return this._handler.createUniverSheet(data);
    }
    createSlide(data) {
      return this._handler.createUniverSlide(data);
    }
    addSheet(sheet) {
      this._sheets.push(sheet);
      this._sheetAdded$.next(sheet);
      this.setCurrentUniverSheetInstance(sheet.getUnitId());
    }
    changeDoc(unitId, doc) {
      const oldDoc = this._docs.find((doc2) => doc2.getUnitId() === unitId);
      if (oldDoc != null) {
        const index = this._docs.indexOf(oldDoc);
        this._docs.splice(index, 1);
      }
      this.addDoc(doc);
    }
    addDoc(doc) {
      this._docs.push(doc);
      this._docAdded$.next(doc);
      this.setCurrentUniverDocInstance(doc.getUnitId());
    }
    addSlide(slide) {
      this._slides.push(slide);
      this._slideAdded$.next(slide);
      this.setCurrentUniverSlideInstance(slide.getUnitId());
    }
    getUniverSheetInstance(id) {
      return this._sheets.find((sheet) => sheet.getUnitId() === id);
    }
    getUniverDocInstance(id) {
      return this._docs.find((doc) => doc.getUnitId() === id);
    }
    getUniverSlideInstance(id) {
      return this._slides.find((slide) => slide.getUnitId() === id);
    }
    getAllUniverSheetsInstance() {
      return this._sheets;
    }
    getAllUniverDocsInstance() {
      return this._docs;
    }
    getAllUniverSlidesInstance() {
      return this._slides;
    }
    setCurrentUniverSheetInstance(id) {
      this._currentSheet$.next(this.getUniverSheetInstance(id) || null);
    }
    setCurrentUniverSlideInstance(id) {
      this._currentSlide$.next(this.getUniverSlideInstance(id) || null);
    }
    setCurrentUniverDocInstance(id) {
      this._currentDoc$.next(this.getUniverDocInstance(id) || null);
    }
    getCurrentUniverSheetInstance() {
      const sheet = this._currentSheet$.getValue();
      if (!sheet) {
        throw new Error("No current sheet!");
      }
      return sheet;
    }
    getCurrentUniverDocInstance() {
      const doc = this._currentDoc$.getValue();
      if (!doc) {
        throw new Error("No current doc!");
      }
      return doc;
    }
    getCurrentUniverSlideInstance() {
      const slide = this._currentSlide$.getValue();
      if (!slide) {
        throw new Error("No current slide!");
      }
      return slide;
    }
    focusUniverInstance(id) {
      if (id) {
        this._focused = this.getUniverSheetInstance(id) || this.getUniverDocInstance(id) || this.getUniverSlideInstance(id) || null;
      }
      this._focused$.next(id);
      [FOCUSING_DOC, FOCUSING_SHEET, FOCUSING_SLIDE].forEach((k) => this._contextService.setContextValue(k, false));
      if (this._focused instanceof Workbook) {
        this._contextService.setContextValue(FOCUSING_SHEET, true);
      } else if (this._focused instanceof DocumentDataModel) {
        this._contextService.setContextValue(FOCUSING_DOC, true);
      } else if (this._focused instanceof SlideDataModel) {
        this._contextService.setContextValue(FOCUSING_SLIDE, true);
      }
    }
    getFocusedUniverInstance() {
      return this._focused;
    }
    getDocumentType(unitId) {
      if (this.getUniverDocInstance(unitId)) {
        return 1 /* DOC */;
      }
      if (this.getUniverSheetInstance(unitId)) {
        return 2 /* SHEET */;
      }
      if (this.getUniverSlideInstance(unitId)) {
        return 3 /* SLIDE */;
      }
      throw new Error(`[UniverInstanceService]: No document with unitId ${unitId}`);
    }
    disposeDocument(unitId) {
      const doc = this.getUniverDocInstance(unitId);
      if (doc) {
        const index = this._docs.indexOf(doc);
        this._docs.splice(index, 1);
        this._docDisposed$.next(doc);
        return true;
      }
      const sheet = this.getUniverSheetInstance(unitId);
      if (sheet) {
        const index = this._sheets.indexOf(sheet);
        this._sheets.splice(index, 1);
        this._sheetDisposed$.next(sheet);
        return true;
      }
      const slide = this.getUniverSlideInstance(unitId);
      if (slide) {
        const index = this._slides.indexOf(slide);
        this._slides.splice(index, 1);
        this._slideDisposed$.next(slide);
        return true;
      }
      return false;
    }
  };
  UniverInstanceService = __decorateClass([
    __decorateParam(1, IContextService)
  ], UniverInstanceService);

  // ../packages/core/src/services/lifecycle/lifecycle.ts
  var LifecycleNameMap = {
    [0 /* Starting */]: "Starting",
    [1 /* Ready */]: "Ready",
    [2 /* Rendered */]: "Rendered",
    [3 /* Steady */]: "Steady"
  };
  var LifecycleToModules = /* @__PURE__ */ new Map();
  function OnLifecycle(lifecycleStage, identifier) {
    const decorator = function decorator2(_820) {
      runOnLifecycle(lifecycleStage, identifier);
    };
    return decorator;
  }
  function runOnLifecycle(lifecycleStage, identifier) {
    if (!LifecycleToModules.has(lifecycleStage)) {
      LifecycleToModules.set(lifecycleStage, []);
    }
    LifecycleToModules.get(lifecycleStage).push(identifier);
  }

  // ../packages/core/src/services/lifecycle/lifecycle.service.ts
  var LifecycleService = class extends Disposable {
    constructor(_logService) {
      super();
      this._logService = _logService;
      __publicField(this, "_lifecycle$", new BehaviorSubject(0 /* Starting */));
      __publicField(this, "lifecycle$", this._lifecycle$.asObservable());
      this._reportProgress(0 /* Starting */);
    }
    get stage() {
      return this._lifecycle$.getValue();
    }
    set stage(stage) {
      if (stage < this.stage) {
        throw new Error("[LifecycleService]: lifecycle stage cannot go backward!");
      }
      if (stage === this.stage) {
        return;
      }
      this._reportProgress(stage);
      this._lifecycle$.next(stage);
    }
    dispose() {
      this._lifecycle$.complete();
      super.dispose();
    }
    /**
     * Subscribe to lifecycle changes and all previous stages and the current
     * stage will be emitted immediately.
     * @returns
     */
    subscribeWithPrevious() {
      return new Observable((subscriber) => {
        if (this.stage === 0 /* Starting */) {
        } else if (this.stage === 1 /* Ready */) {
          subscriber.next(0 /* Starting */);
        } else if (this.stage === 2 /* Rendered */) {
          subscriber.next(0 /* Starting */);
          subscriber.next(1 /* Ready */);
        } else {
          subscriber.next(0 /* Starting */);
          subscriber.next(1 /* Ready */);
          subscriber.next(2 /* Rendered */);
        }
        return this._lifecycle$.subscribe(subscriber);
      });
    }
    _reportProgress(stage) {
      this._logService.debug("[LifecycleService]", `lifecycle progressed to "${LifecycleNameMap[stage]}".`);
    }
  };
  LifecycleService = __decorateClass([
    __decorateParam(0, ILogService)
  ], LifecycleService);
  var LifecycleInitializerService = class extends Disposable {
    constructor(_lifecycleService, _injector) {
      super();
      this._lifecycleService = _lifecycleService;
      this._injector = _injector;
      __publicField(this, "_started", false);
    }
    start() {
      if (this._started) {
        return;
      }
      this._started = true;
      this.disposeWithMe(
        toDisposable(
          this._lifecycleService.subscribeWithPrevious().subscribe((stage) => this.initModulesOnStage(stage))
        )
      );
    }
    initModulesOnStage(stage) {
      const modules = LifecycleToModules.get(stage);
      modules == null ? void 0 : modules.forEach((m) => {
        if (this._injector.has(m)) {
          this._injector.get(m);
        }
      });
    }
  };
  LifecycleInitializerService = __decorateClass([
    __decorateParam(0, Inject(LifecycleService)),
    __decorateParam(1, Inject(Injector))
  ], LifecycleInitializerService);

  // ../packages/core/src/services/locale/locale.service.ts
  var LocaleService = class extends Disposable {
    constructor() {
      super();
      __publicField(this, "_currentLocale", "zhCN" /* ZH_CN */);
      __publicField(this, "_locales", null);
      __publicField(this, "localeChanged$", new Subject());
      /**
       * Translate a key to the current locale
       *
       * @param {string} key the key to translate
       * @param {string[]} args optional arguments to replace in the translated string
       * @returns {string} the translated string
       *
       * @example
       * const locales = {
       *   [LocaleType.EN_US]: {
       *     foo: {
       *       bar: 'Hello'
       *    }
       * }
       * t('foo.bar') => 'Hello'
       *
       * @example
       * const locales = {
       *   [LocaleType.EN_US]: {
       *     foo: {
       *       bar: 'Hello {0}'
       *    }
       * }
       * t('foo.bar', 'World') => 'Hello World'
       */
      __publicField(this, "t", (key, ...args) => {
        if (!this._locales)
          throw new Error("Locale not initialized");
        const keys = key.split(".");
        const resolvedValue = this.resolveKeyPath(this._locales[this._currentLocale], keys);
        if (typeof resolvedValue === "string") {
          let result = resolvedValue;
          args.forEach((arg, index) => {
            result = result.replace(`{${index}}`, arg);
          });
          return result;
        } else {
          return key;
        }
      });
      this.disposeWithMe(toDisposable(() => this.localeChanged$.complete()));
    }
    /**
     * Load more locales after init.
     *
     * @param locales - Locale object
     */
    load(locales) {
      var _a2;
      this._locales = Tools.deepMerge((_a2 = this._locales) != null ? _a2 : {}, locales);
    }
    setLocale(locale2) {
      this._currentLocale = locale2;
      this.localeChanged$.next();
    }
    getLocales() {
      var _a2;
      return (_a2 = this._locales) == null ? void 0 : _a2[this._currentLocale];
    }
    getCurrentLocale() {
      return this._currentLocale;
    }
    resolveKeyPath(obj, keys) {
      const currentKey = keys.shift();
      if (currentKey && obj && currentKey in obj) {
        const nextObj = obj[currentKey];
        if (keys.length > 0 && (typeof nextObj === "object" || Array.isArray(nextObj))) {
          return this.resolveKeyPath(nextObj, keys);
        } else {
          return nextObj;
        }
      }
      return null;
    }
  };

  // ../packages/core/src/services/resource-manager/type.ts
  var IResourceManagerService = createIdentifier("resource-manager-service");
  var ISnapshotPersistenceService = createIdentifier("ResourcePersistenceService");
  runOnLifecycle(1 /* Ready */, ISnapshotPersistenceService);

  // ../packages/core/src/services/permission/permission.service.ts
  var IPermissionService = createIdentifier("univer.permission-service");
  var resourceKey = "PERMISSION";
  var PermissionService = class extends Disposable {
    constructor(_resourceManagerService, _univerInstanceService) {
      super();
      this._resourceManagerService = _resourceManagerService;
      this._univerInstanceService = _univerInstanceService;
      __publicField(this, "_permissionPointMap", /* @__PURE__ */ new Map());
      __publicField(this, "deletePermissionPoint", (unitID, id) => {
        const permissionMap = this._permissionPointMap.get(unitID);
        if (permissionMap) {
          const subject = permissionMap.get(id);
          if (subject) {
            subject.complete();
            this._permissionPointMap.delete(id);
          }
        }
      });
      __publicField(this, "addPermissionPoint", (unitID, item) => {
        const permissionMap = this._permissionPointMap.get(unitID) || /* @__PURE__ */ new Map();
        if (!permissionMap.has(item.id)) {
          permissionMap.set(item.id, new BehaviorSubject(item));
          this._permissionPointMap.set(unitID, permissionMap);
          return true;
        }
        return false;
      });
      __publicField(this, "updatePermissionPoint", (unitID, permissionId, value) => {
        const permissionMap = this._permissionPointMap.get(unitID);
        if (!permissionMap) {
          return;
        }
        const permissionSubject = permissionMap.get(permissionId);
        if (permissionSubject) {
          const subject = permissionSubject.getValue();
          subject.value = value;
          subject.status = "done" /* DONE */;
          permissionSubject.next(subject);
        }
      });
      __publicField(this, "getPermissionPoint", (unitID, permissionId) => {
        const permissionMap = this._permissionPointMap.get(unitID);
        if (!permissionMap)
          return;
        const item = permissionMap.get(permissionId);
        if (item) {
          return item.getValue();
        }
      });
    }
    _init() {
      this.disposeWithMe(
        toDisposable(
          this._univerInstanceService.sheetAdded$.subscribe((workbook) => {
            this._resourceManagerService.registerPluginResource(workbook.getUnitId(), resourceKey, {
              onChange: (unitID, value) => {
                value.forEach((permissionPoint) => {
                  if (this.getPermissionPoint(unitID, permissionPoint.id)) {
                    this.updatePermissionPoint(unitID, permissionPoint.id, permissionPoint.value);
                  } else {
                    this.addPermissionPoint(unitID, permissionPoint);
                  }
                });
              },
              toJson: (unitID) => this._toJson(unitID),
              parseJson: (json) => this._parseJson(json)
            });
          })
        )
      );
      this.disposeWithMe(
        toDisposable(
          this._univerInstanceService.sheetDisposed$.subscribe((workbook) => {
            this._resourceManagerService.disposePluginResource(workbook.getUnitId(), resourceKey);
          })
        )
      );
    }
    _toJson(unitID) {
      const permissionMap = this._permissionPointMap.get(unitID);
      let list = [];
      if (permissionMap) {
        list = [...permissionMap.keys()].reduce((pre, key) => {
          const value = permissionMap.get(key);
          if (value) {
            pre.push(value.getValue());
          }
          return pre;
        }, []);
      }
      return JSON.stringify(list);
    }
    _parseJson(json) {
      return JSON.parse(json);
    }
    composePermission$(unitID, permissionIdList) {
      const permissionMap = this._permissionPointMap.get(unitID);
      const subjectList = permissionIdList.map((id) => {
        const subject = permissionMap == null ? void 0 : permissionMap.get(id);
        if (!subject) {
          throw new Error(`${id} permissionPoint is not exist`);
        }
        return subject.asObservable();
      });
      return combineLatest(subjectList).pipe(
        // Check that all permissions exist
        map((list) => {
          if (list.every((item) => this._permissionPointMap.get(item.id))) {
            return list;
          }
          return list;
        })
      );
    }
    composePermission(unitID, permissionIdList) {
      const permissionMap = this._permissionPointMap.get(unitID);
      const valueList = permissionIdList.map((id) => {
        const subject = permissionMap == null ? void 0 : permissionMap.get(id);
        if (!subject) {
          throw new Error(`${id} permissionPoint is not exist`);
        }
        return subject.getValue();
      });
      return valueList;
    }
  };
  PermissionService = __decorateClass([
    OnLifecycle(0 /* Starting */, PermissionService),
    __decorateParam(0, Inject(IResourceManagerService)),
    __decorateParam(1, Inject(IUniverInstanceService))
  ], PermissionService);

  // ../packages/core/src/services/permission/permission-point.ts
  var UniverEditablePermissionPoint = "univer.editable";
  var UniverEditablePermission = class extends PermissionPoint {
    constructor(unitID) {
      super();
      __publicField(this, "id", UniverEditablePermissionPoint);
      __publicField(this, "value", true);
      __publicField(this, "unitID");
      this.unitID = unitID;
    }
  };

  // ../packages/core/src/services/permission/univer.permission.service.ts
  var UniverPermissionService = class extends Disposable {
    constructor(_permissionService, _univerInstanceService) {
      super();
      this._permissionService = _permissionService;
      this._univerInstanceService = _univerInstanceService;
      this._init();
    }
    _init() {
      this._univerInstanceService.sheetAdded$.subscribe((workbook) => {
        const univerEditablePermission = new UniverEditablePermission(workbook.getUnitId());
        this._permissionService.addPermissionPoint(workbook.getUnitId(), univerEditablePermission);
      });
    }
    getEditable(unitID) {
      let unitId = unitID;
      if (!unitId) {
        unitId = this._univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      }
      const univerEditablePermission = new UniverEditablePermission(unitId);
      const permission = this._permissionService.getPermissionPoint(unitId, univerEditablePermission.id);
      return permission == null ? void 0 : permission.value;
    }
    setEditable(unitID, v) {
      const univerEditablePermission = new UniverEditablePermission(unitID);
      this._permissionService.updatePermissionPoint(unitID, univerEditablePermission.id, v);
    }
  };
  UniverPermissionService = __decorateClass([
    OnLifecycle(0 /* Starting */, UniverPermissionService),
    __decorateParam(0, Inject(IPermissionService)),
    __decorateParam(1, Inject(IUniverInstanceService))
  ], UniverPermissionService);

  // ../packages/core/src/services/resource-manager/resource-manager.service.ts
  var ResourceManagerService = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_resourceMap", /* @__PURE__ */ new Map());
      __publicField(this, "_register$", new Subject());
      __publicField(this, "register$", this._register$.asObservable());
    }
    getAllResource(unitID) {
      const resourceMap = this._resourceMap.get(unitID);
      if (resourceMap) {
        return [...resourceMap.keys()].reduce(
          (list, resourceName) => {
            const hook = resourceMap.get(resourceName);
            if (hook) {
              list.push({
                unitID,
                resourceName,
                hook
              });
            }
            return list;
          },
          []
        );
      }
      return [];
    }
    /**
     * the pluginName is map to resourceId which is created by serve.
     * @param {string} pluginName
     * @param {ResourceHook<T>} hook
     */
    registerPluginResource(unitID, resourceName, hook) {
      const resourceMap = this._resourceMap.get(unitID) || /* @__PURE__ */ new Map();
      if (resourceMap.has(resourceName)) {
        throw new Error(`the pluginName is registered {${resourceName}}`);
      }
      resourceMap.set(resourceName, hook);
      this._resourceMap.set(unitID, resourceMap);
      this._register$.next({ unitID, resourceName, hook });
      return toDisposable(() => resourceMap.delete(resourceName));
    }
    disposePluginResource(unitID, pluginName) {
      const resourceMap = this._resourceMap.get(unitID);
      resourceMap == null ? void 0 : resourceMap.delete(pluginName);
    }
    dispose() {
      this._register$.complete();
      this._resourceMap.clear();
    }
  };

  // ../packages/core/src/services/theme/theme.service.ts
  var ThemeService = class extends Disposable {
    constructor() {
      super();
      __publicField(this, "_currentTheme");
      __publicField(this, "_currentTheme$", new BehaviorSubject({}));
      __publicField(this, "currentTheme$", this._currentTheme$.asObservable());
      this.disposeWithMe(toDisposable(() => this._currentTheme$.complete()));
    }
    getCurrentTheme() {
      if (!this._currentTheme) {
        throw new Error("[ThemeService]: current theme is not set!");
      }
      return this._currentTheme;
    }
    setTheme(theme) {
      this._currentTheme = theme;
      this._currentTheme$.next(theme);
    }
  };

  // ../packages/core/src/common/const.ts
  var DOCS_NORMAL_EDITOR_UNIT_ID_KEY = "__defaultDocumentNormalEditorSpecialUnitId_20231006__";
  var DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY = "__defaultDocumentFormulaBarEditorSpecialUnitId_20231012__";
  var DEFAULT_EMPTY_DOCUMENT_VALUE = "\r\n";

  // ../packages/core/src/services/undoredo/undoredo.service.ts
  var IUndoRedoService = createIdentifier("univer.undo-redo.service");
  var STACK_CAPACITY = 20;
  var MultiImplementationCommand = class {
    dispose() {
    }
    async dispatchToHandlers() {
      return false;
    }
  };
  var RedoCommandId = "univer.command.redo";
  var UndoCommandId = "univer.command.undo";
  var UndoCommand = new class extends MultiImplementationCommand {
    constructor() {
      super(...arguments);
      __publicField(this, "type", 0 /* COMMAND */);
      __publicField(this, "id", UndoCommandId);
    }
    async handler(accessor) {
      const undoRedoService = accessor.get(IUndoRedoService);
      const element = undoRedoService.pitchTopUndoElement();
      if (!element) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const result = sequenceExecute(element.undoMutations, commandService);
      if (result) {
        undoRedoService.popUndoToRedo();
        return true;
      }
      return false;
    }
  }();
  var RedoCommand = new class extends MultiImplementationCommand {
    constructor() {
      super(...arguments);
      __publicField(this, "type", 0 /* COMMAND */);
      __publicField(this, "id", RedoCommandId);
    }
    async handler(accessor) {
      const undoRedoService = accessor.get(IUndoRedoService);
      const element = undoRedoService.pitchTopRedoElement();
      if (!element) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const result = sequenceExecute(element.redoMutations, commandService);
      if (result) {
        undoRedoService.popRedoToUndo();
        return true;
      }
      return false;
    }
  }();
  var LocalUndoRedoService = class extends Disposable {
    constructor(_univerInstanceService, _commandService, _contextService) {
      super();
      this._univerInstanceService = _univerInstanceService;
      this._commandService = _commandService;
      this._contextService = _contextService;
      __publicField(this, "undoRedoStatus$");
      __publicField(this, "_undoRedoStatus$", new BehaviorSubject({ undos: 0, redos: 0 }));
      // Undo and redo stacks are per unit.
      __publicField(this, "_undoStacks", /* @__PURE__ */ new Map());
      __publicField(this, "_redoStacks", /* @__PURE__ */ new Map());
      __publicField(this, "_batchingStatus", /* @__PURE__ */ new Map());
      this.undoRedoStatus$ = this._undoRedoStatus$.asObservable();
      this.disposeWithMe(this._commandService.registerCommand(UndoCommand));
      this.disposeWithMe(this._commandService.registerCommand(RedoCommand));
      this.disposeWithMe(toDisposable(() => this._undoRedoStatus$.complete()));
      this.disposeWithMe(toDisposable(this._univerInstanceService.focused$.subscribe(() => this._updateStatus())));
    }
    pushUndoRedo(item) {
      const { unitID } = item;
      const redoStack = this._getRedoStack(unitID, true);
      const undoStack = this._getUndoStack(unitID, true);
      redoStack.length = 0;
      if (this._batchingStatus.has(item.unitID)) {
        const batchingStatus = this._batchingStatus.get(item.unitID);
        const lastItem = this._pitchUndoElement(item.unitID);
        if (batchingStatus === 0 /* WAITING */ || !lastItem) {
          appendNewItem(item);
          this._batchingStatus.set(item.unitID, 1 /* CREATED */);
        } else {
          this._tryBatchingElements(lastItem, item);
        }
      } else {
        appendNewItem(item);
      }
      function appendNewItem(item2) {
        undoStack.push(item2);
        if (undoStack.length > STACK_CAPACITY) {
          undoStack.splice(0, 1);
        }
      }
      this._updateStatus();
    }
    clearUndoRedo(unitID) {
      const redoStack = this._getRedoStack(unitID);
      if (redoStack) {
        redoStack.length = 0;
      }
      const undoStack = this._getUndoStack(unitID);
      if (undoStack) {
        undoStack.length = 0;
      }
      this._updateStatus();
    }
    pitchTopUndoElement() {
      const unitID = this._getFocusedUniverInstanceId();
      return this._pitchUndoElement(unitID);
    }
    pitchTopRedoElement() {
      const unitID = this._getFocusedUniverInstanceId();
      return this._pitchRedoElement(unitID);
    }
    _pitchUndoElement(unitId) {
      const stack = this._getUndoStack(unitId);
      return (stack == null ? void 0 : stack.length) ? stack[stack.length - 1] : null;
    }
    _pitchRedoElement(unitId) {
      const stack = this._getRedoStack(unitId);
      return (stack == null ? void 0 : stack.length) ? stack[stack.length - 1] : null;
    }
    popUndoToRedo() {
      const undoStack = this._getUndoStackForFocused();
      const element = undoStack.pop();
      if (element) {
        const redoStack = this._getRedoStackForFocused();
        redoStack.push(element);
        this._updateStatus();
      }
    }
    popRedoToUndo() {
      const redoStack = this._getRedoStackForFocused();
      const element = redoStack.pop();
      if (element) {
        const undoStack = this._getUndoStackForFocused();
        undoStack.push(element);
        this._updateStatus();
      }
    }
    __tempBatchingUndoRedo(unitId) {
      if (this._batchingStatus.has(unitId)) {
        throw new Error("[LocalUndoRedoService]: cannot batching undo redo twice at the same time!");
      }
      this._batchingStatus.set(unitId, 0 /* WAITING */);
      return toDisposable(() => this._batchingStatus.delete(unitId));
    }
    _updateStatus() {
      var _a2, _b2;
      const unitID = this._getFocusedUniverInstanceId();
      const undos = unitID && ((_a2 = this._undoStacks.get(unitID)) == null ? void 0 : _a2.length) || 0;
      const redos = unitID && ((_b2 = this._redoStacks.get(unitID)) == null ? void 0 : _b2.length) || 0;
      this._undoRedoStatus$.next({
        undos,
        redos
      });
    }
    _getUndoStack(unitId, createAsNeeded = false) {
      let stack = this._undoStacks.get(unitId);
      if (!stack && createAsNeeded) {
        stack = [];
        this._undoStacks.set(unitId, stack);
      }
      return stack || null;
    }
    _getRedoStack(unitId, createAsNeeded = false) {
      let stack = this._redoStacks.get(unitId);
      if (!stack && createAsNeeded) {
        stack = [];
        this._redoStacks.set(unitId, stack);
      }
      return stack || null;
    }
    _getUndoStackForFocused() {
      const unitID = this._getFocusedUniverInstanceId();
      if (!unitID) {
        throw new Error("No focused univer instance!");
      }
      return this._getUndoStack(unitID, true);
    }
    _getRedoStackForFocused() {
      const unitID = this._getFocusedUniverInstanceId();
      if (!unitID) {
        throw new Error("No focused univer instance!");
      }
      return this._getRedoStack(unitID, true);
    }
    _tryBatchingElements(item, newItem) {
      item.redoMutations.push(...newItem.redoMutations);
      item.undoMutations.push(...newItem.undoMutations);
    }
    _getFocusedUniverInstanceId() {
      var _a2, _b2, _c, _d;
      let unitID = "";
      const isFocusSheet = this._contextService.getContextValue(FOCUSING_SHEET);
      const isFocusFormulaEditor = this._contextService.getContextValue(FOCUSING_FORMULA_EDITOR);
      const isFocusEditor = this._contextService.getContextValue(EDITOR_ACTIVATED);
      if (isFocusSheet) {
        if (isFocusFormulaEditor) {
          unitID = DOCS_FORMULA_BAR_EDITOR_UNIT_ID_KEY;
        } else if (isFocusEditor) {
          unitID = DOCS_NORMAL_EDITOR_UNIT_ID_KEY;
        } else {
          unitID = (_b2 = (_a2 = this._univerInstanceService.getFocusedUniverInstance()) == null ? void 0 : _a2.getUnitId()) != null ? _b2 : "";
        }
      } else {
        unitID = (_d = (_c = this._univerInstanceService.getFocusedUniverInstance()) == null ? void 0 : _c.getUnitId()) != null ? _d : "";
      }
      return unitID;
    }
  };
  LocalUndoRedoService = __decorateClass([
    __decorateParam(0, IUniverInstanceService),
    __decorateParam(1, ICommandService),
    __decorateParam(2, IContextService)
  ], LocalUndoRedoService);

  // ../packages/core/src/basics/plugin-holder.ts
  var PluginHolder = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_started", false);
    }
    addPlugins(plugins) {
      if (!this._started) {
        const pluginInstances = plugins.map(([plugin, options]) => this._initPlugin(plugin, options));
        this._takePluginsThroughLifecycle(pluginInstances);
        this._started = true;
      } else {
        const lazyPlugins = plugins.map(([plugin, options]) => this._initPlugin(plugin, options));
        this._pluginsRunLifecycle(lazyPlugins, 0 /* Starting */);
        setTimeout(() => this._takePluginsThroughLifecycle(lazyPlugins, true));
      }
    }
    _takePluginsThroughLifecycle(plugins, skipStarting = false) {
      this.disposeWithMe(
        toDisposable(
          this._lifecycleService.subscribeWithPrevious().subscribe((stage) => {
            if (skipStarting && stage === 0 /* Starting */) {
              return;
            }
            this._pluginsRunLifecycle(plugins, stage);
          })
        )
      );
    }
    _pluginsRunLifecycle(plugins, lifecycle) {
      plugins.forEach((p) => {
        switch (lifecycle) {
          case 0 /* Starting */:
            p.onStarting(this._injector);
            break;
          case 1 /* Ready */:
            p.onReady();
            break;
          case 2 /* Rendered */:
            p.onRendered();
            break;
          case 3 /* Steady */:
            p.onSteady();
            break;
        }
      });
      this._lifecycleInitializerService.initModulesOnStage(lifecycle);
    }
    _initPlugin(plugin, options) {
      const pluginInstance = this._injector.createInstance(plugin, options);
      return pluginInstance;
    }
  };

  // ../packages/core/src/basics/univer-doc.ts
  var UniverDoc = class extends PluginHolder {
    constructor(_injector, _lifecycleService, _lifecycleInitializerService) {
      super();
      this._injector = _injector;
      this._lifecycleService = _lifecycleService;
      this._lifecycleInitializerService = _lifecycleInitializerService;
    }
    createDoc(docData) {
      return this._injector.createInstance(DocumentDataModel, docData);
    }
  };
  UniverDoc = __decorateClass([
    __decorateParam(0, Inject(Injector)),
    __decorateParam(1, Inject(LifecycleService)),
    __decorateParam(2, Inject(LifecycleInitializerService))
  ], UniverDoc);

  // ../packages/core/src/basics/univer-sheet.ts
  var UniverSheet = class extends PluginHolder {
    constructor(_injector, _lifecycleService, _lifecycleInitializerService) {
      super();
      this._injector = _injector;
      this._lifecycleService = _lifecycleService;
      this._lifecycleInitializerService = _lifecycleInitializerService;
    }
    createSheet(workbookConfig) {
      const workbook = this._injector.createInstance(Workbook, workbookConfig);
      return workbook;
    }
  };
  UniverSheet = __decorateClass([
    __decorateParam(0, Inject(Injector)),
    __decorateParam(1, Inject(LifecycleService)),
    __decorateParam(2, Inject(LifecycleInitializerService))
  ], UniverSheet);

  // ../packages/core/src/basics/univer-slide.ts
  var UniverSlide = class extends PluginHolder {
    constructor(_injector, _lifecycleService, _lifecycleInitializerService) {
      super();
      this._injector = _injector;
      this._lifecycleService = _lifecycleService;
      this._lifecycleInitializerService = _lifecycleInitializerService;
    }
    createSlide(data) {
      const slide = this._injector.createInstance(SlideDataModel, data);
      return slide;
    }
  };
  UniverSlide = __decorateClass([
    __decorateParam(0, Inject(Injector)),
    __decorateParam(1, Inject(LifecycleService)),
    __decorateParam(2, Inject(LifecycleInitializerService))
  ], UniverSlide);

  // ../packages/core/src/basics/univer.ts
  var INIT_LAZY_PLUGINS_TIMEOUT = 200;
  var Univer = class extends PluginHolder {
    constructor(univerData = {}) {
      super();
      __publicField(this, "_injector");
      __publicField(this, "_univerPluginStore", new PluginStore());
      __publicField(this, "_univerPluginRegistry", new PluginRegistry());
      __publicField(this, "_univerSheet", null);
      __publicField(this, "_univerDoc", null);
      __publicField(this, "_univerSlide", null);
      __publicField(this, "_initLazyPluginsTimer");
      this._injector = this._initDependencies();
      const { theme, locale: locale2, locales, logLevel } = univerData;
      theme && this._injector.get(ThemeService).setTheme(theme);
      locales && this._injector.get(LocaleService).load(locales);
      locale2 && this._injector.get(LocaleService).setLocale(locale2);
      logLevel && this._injector.get(ILogService).setLogLevel(logLevel);
    }
    get _univerInstanceService() {
      return this._injector.get(IUniverInstanceService);
    }
    get _lifecycleService() {
      return this._injector.get(LifecycleService);
    }
    get _lifecycleInitializerService() {
      return this._injector.get(LifecycleInitializerService);
    }
    __getInjector() {
      return this._injector;
    }
    dispose() {
      this._injector.dispose();
      super.dispose();
    }
    setLocale(locale2) {
      this._injector.get(LocaleService).setLocale(locale2);
    }
    /**
     * Create a univer sheet instance with internal dependency injection.
     */
    createUniverSheet(config2) {
      let workbook;
      const addSheet = () => {
        workbook = this._univerSheet.createSheet(config2);
        this._univerInstanceService.addSheet(workbook);
      };
      if (!this._univerSheet) {
        this._tryProgressToStart();
        const univerSheet = this._univerSheet = this._injector.createInstance(UniverSheet);
        const sheetPlugins = this._univerPluginRegistry.getRegisterPlugins(2 /* Sheet */).map((p) => [p.plugin, p.options]);
        this._univerPluginRegistry.clearPluginsOfType(2 /* Sheet */);
        univerSheet.addPlugins(sheetPlugins);
        addSheet();
        this._tryProgressToReady();
      } else {
        addSheet();
      }
      return workbook;
    }
    createUniverDoc(config2) {
      let doc;
      const addDoc = () => {
        doc = this._univerDoc.createDoc(config2);
        this._univerInstanceService.addDoc(doc);
      };
      if (!this._univerDoc) {
        this._tryProgressToStart();
        const univerDoc = this._univerDoc = this._injector.createInstance(UniverDoc);
        const docPlugins = this._univerPluginRegistry.getRegisterPlugins(1 /* Doc */).map((p) => [p.plugin, p.options]);
        this._univerPluginRegistry.clearPluginsOfType(1 /* Doc */);
        univerDoc.addPlugins(docPlugins);
        addDoc();
        this._tryProgressToReady();
      } else {
        addDoc();
      }
      return doc;
    }
    createUniverSlide(config2) {
      let slide;
      const addSlide = () => {
        slide = this._univerSlide.createSlide(config2);
        this._univerInstanceService.addSlide(slide);
      };
      if (!this._univerSlide) {
        this._tryProgressToStart();
        const univerSlide = this._univerSlide = this._injector.createInstance(UniverSlide);
        const slidePlugins = this._univerPluginRegistry.getRegisterPlugins(3 /* Slide */).map((p) => [p.plugin, p.options]);
        this._univerPluginRegistry.clearPluginsOfType(3 /* Slide */);
        univerSlide.addPlugins(slidePlugins);
        addSlide();
        this._tryProgressToReady();
      } else {
        addSlide();
      }
      return slide;
    }
    _initDependencies() {
      return new Injector([
        [
          IUniverInstanceService,
          {
            useFactory: (contextService) => new UniverInstanceService(
              {
                createUniverDoc: (data) => this.createUniverDoc(data),
                createUniverSheet: (data) => this.createUniverSheet(data),
                createUniverSlide: (data) => this.createUniverSlide(data)
              },
              contextService
            ),
            deps: [IContextService]
          }
        ],
        [ErrorService],
        [LocaleService],
        [ThemeService],
        [LifecycleService],
        [LifecycleInitializerService],
        [IPermissionService, { useClass: PermissionService }],
        [UniverPermissionService],
        [ILogService, { useClass: DesktopLogService, lazy: true }],
        [ICommandService, { useClass: CommandService, lazy: true }],
        [IUndoRedoService, { useClass: LocalUndoRedoService, lazy: true }],
        [IConfigService, { useClass: ConfigService }],
        [IContextService, { useClass: ContextService }],
        [IFloatingObjectManagerService, { useClass: FloatingObjectManagerService, lazy: true }],
        [IResourceManagerService, { useClass: ResourceManagerService, lazy: true }]
      ]);
    }
    /**
     * Initialize modules provided by Univer-type plugins.
     */
    _tryProgressToStart() {
      if (this._started) {
        return;
      }
      this._injector.get(LifecycleInitializerService).start();
      this._started = true;
    }
    _tryProgressToReady() {
      const lifecycleService = this._injector.get(LifecycleService);
      if (lifecycleService.stage < 1 /* Ready */) {
        this._injector.get(LifecycleService).stage = 1 /* Ready */;
        this._univerPluginStore.forEachPlugin((p) => p.onReady());
      }
    }
    // #region register plugins
    /** Register a plugin into univer. */
    registerPlugin(plugin, config2) {
      if (plugin.type === 0 /* Univer */) {
        this._registerUniverPlugin(plugin, config2);
      } else if (plugin.type === 2 /* Sheet */) {
        this._registerSheetsPlugin(plugin, config2);
      } else if (plugin.type === 1 /* Doc */) {
        this._registerDocsPlugin(plugin, config2);
      } else if (plugin.type === 3 /* Slide */) {
        this._registerSlidesPlugin(plugin, config2);
      } else {
        throw new Error(`Unimplemented plugin system for business: "${plugin.type}".`);
      }
      if (this._started) {
        return this._scheduleInitPluginAfterStarted();
      }
    }
    _scheduleInitPluginAfterStarted() {
      if (this._initLazyPluginsTimer === void 0) {
        this._initLazyPluginsTimer = setTimeout(
          () => this._flushLazyPlugins(),
          INIT_LAZY_PLUGINS_TIMEOUT
        );
      }
    }
    _flushLazyPlugins() {
      this._initLazyPluginsTimer = void 0;
      const univerLazyPlugins = this._univerPluginRegistry.getRegisterPlugins(0 /* Univer */);
      if (univerLazyPlugins.length) {
        this._univerPluginRegistry.clearPluginsOfType(0 /* Univer */);
        const pluginInstances = univerLazyPlugins.map((p) => this._injector.createInstance(p.plugin, p.options));
        this._takePluginsThroughLifecycle(pluginInstances);
      }
      if (this._univerSheet) {
        const sheetPlugins = this._univerPluginRegistry.getRegisterPlugins(2 /* Sheet */).map((p) => [p.plugin, p.options]);
        if (sheetPlugins.length) {
          this._univerSheet.addPlugins(sheetPlugins);
          this._univerPluginRegistry.clearPluginsOfType(2 /* Sheet */);
        }
      }
      if (this._univerDoc) {
        const docPlugins = this._univerPluginRegistry.getRegisterPlugins(1 /* Doc */).map((p) => [p.plugin, p.options]);
        if (docPlugins.length) {
          this._univerDoc.addPlugins(docPlugins);
          this._univerPluginRegistry.clearPluginsOfType(1 /* Doc */);
        }
      }
      if (this._univerSlide) {
        const slidePlugins = this._univerPluginRegistry.getRegisterPlugins(3 /* Slide */).map((p) => [p.plugin, p.options]);
        if (slidePlugins.length) {
          this._univerSlide.addPlugins(slidePlugins);
          this._univerPluginRegistry.clearPluginsOfType(3 /* Slide */);
        }
      }
    }
    _registerUniverPlugin(pluginCtor, options) {
      if (this._started) {
        this._univerPluginRegistry.registerPlugin(pluginCtor, options);
      } else {
        const pluginInstance = this._injector.createInstance(pluginCtor, options);
        pluginInstance.onStarting(this._injector);
        this._univerPluginStore.addPlugin(pluginInstance);
      }
    }
    _registerSheetsPlugin(pluginCtor, options) {
      this._univerPluginRegistry.registerPlugin(pluginCtor, options);
    }
    _registerDocsPlugin(pluginCtor, options) {
      this._univerPluginRegistry.registerPlugin(pluginCtor, options);
    }
    _registerSlidesPlugin(pluginCtor, options) {
      this._univerPluginRegistry.registerPlugin(pluginCtor, options);
    }
    // #endregion
  };

  // ../packages/core/src/common/request-immediate-macro-task.ts
  function requestImmediateMacroTask(callback) {
    const channel = new MessageChannel();
    let cancelled = false;
    channel.port1.onmessage = () => {
      if (!cancelled) {
        callback();
      }
    };
    channel.port2.postMessage(null);
    return () => {
      cancelled = true;
    };
  }

  // ../packages/core/src/services/local-storage/local-storage.service.ts
  var ILocalStorageService = createIdentifier("ILocalStorageService");

  // ../packages/core/src/common/interceptor.ts
  var createInterceptorKey = (key) => {
    const symbol = `sheet_interceptor_${key}`;
    return symbol;
  };
  var composeInterceptors = (interceptors) => function(initialValue, context2) {
    let index = -1;
    function passThrough(i, v) {
      if (i <= index) {
        throw new Error("[SheetInterceptorService]: next() called multiple times!");
      }
      index = i;
      if (i === interceptors.length) {
        return v;
      }
      const interceptor = interceptors[i];
      return interceptor.handler(v, context2, passThrough.bind(null, i + 1));
    }
    return passThrough(0, initialValue);
  };
  var InterceptorManager = class {
    constructor(interceptorPoints) {
      __publicField(this, "_interceptorsByName", /* @__PURE__ */ new Map());
      __publicField(this, "_interceptorPoints");
      this._interceptorPoints = interceptorPoints;
    }
    fetchThroughInterceptors(name) {
      const key = name;
      const interceptors = this._interceptorsByName.get(key);
      return composeInterceptors(interceptors || []);
    }
    intercept(name, interceptor) {
      const key = name;
      if (!this._interceptorsByName.has(key)) {
        this._interceptorsByName.set(key, []);
      }
      const interceptors = this._interceptorsByName.get(key);
      interceptors.push(interceptor);
      this._interceptorsByName.set(
        key,
        interceptors.sort((a, b) => {
          var _a2, _b2;
          return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a.priority) != null ? _b2 : 0);
        })
        // from large to small
      );
      return () => remove(this._interceptorsByName.get(key), interceptor);
    }
    getInterceptPoints() {
      return this._interceptorPoints;
    }
  };

  // ../packages/core/src/services/snapshot/snapshot-server.service.ts
  var ISnapshotServerService = createIdentifier(
    "univer.snapshot-server-service"
  );

  // ../packages/core/src/services/snapshot/snapshot-utils.ts
  var textEncoder = new TextEncoder();
  var textDecoder = new TextDecoder();

  // ../packages/core/src/index.ts
  installShims();

  // ../packages/engine-formula/src/basics/dirty.ts
  function isInDirtyRange(dirtyRanges, unitId, sheetId, row, column) {
    for (let i = 0, len = dirtyRanges.length; i < len; i++) {
      const dirtyRange = dirtyRanges[i];
      if (unitId !== dirtyRange.unitId) {
        continue;
      }
      if (sheetId !== dirtyRange.sheetId) {
        continue;
      }
      const { startRow, startColumn, endRow, endColumn } = dirtyRange.range;
      if (row >= startRow && row <= endRow && column >= startColumn && column <= endColumn) {
        return true;
      }
    }
    return false;
  }

  // ../packages/engine-formula/src/basics/error-type.ts
  var ErrorType = /* @__PURE__ */ ((ErrorType2) => {
    ErrorType2["DIV_BY_ZERO"] = "#DIV/0!";
    ErrorType2["NAME"] = "#NAME?";
    ErrorType2["VALUE"] = "#VALUE!";
    ErrorType2["NUM"] = "#NUM!";
    ErrorType2["NA"] = "#N/A";
    ErrorType2["CYCLE"] = "#CYCLE!";
    ErrorType2["REF"] = "#REF!";
    ErrorType2["SPILL"] = "#SPILL!";
    ErrorType2["CALC"] = "#CALC!";
    ErrorType2["ERROR"] = "#ERROR!";
    ErrorType2["CONNECT"] = "#GETTING_DATA";
    ErrorType2["NULL"] = "#NULL!";
    return ErrorType2;
  })(ErrorType || {});
  var ERROR_TYPE_SET = new Set(Object.values(ErrorType));

  // ../packages/engine-formula/src/basics/token.ts
  var operatorToken = /* @__PURE__ */ ((operatorToken2) => {
    operatorToken2["PLUS"] = "+";
    operatorToken2["MINUS"] = "-";
    operatorToken2["MULTIPLY"] = "*";
    operatorToken2["DIVIDED"] = "/";
    operatorToken2["CONCATENATE"] = "&";
    operatorToken2["POWER"] = "^";
    operatorToken2["EQUALS"] = "=";
    operatorToken2["NOT_EQUAL"] = "<>";
    operatorToken2["GREATER_THAN"] = ">";
    operatorToken2["GREATER_THAN_OR_EQUAL"] = ">=";
    operatorToken2["LESS_THAN"] = "<";
    operatorToken2["LESS_THAN_OR_EQUAL"] = "<=";
    return operatorToken2;
  })(operatorToken || {});
  var compareToken = /* @__PURE__ */ ((compareToken2) => {
    compareToken2["EQUALS"] = "=";
    compareToken2["NOT_EQUAL"] = "<>";
    compareToken2["GREATER_THAN"] = ">";
    compareToken2["GREATER_THAN_OR_EQUAL"] = ">=";
    compareToken2["LESS_THAN"] = "<";
    compareToken2["LESS_THAN_OR_EQUAL"] = "<=";
    return compareToken2;
  })(compareToken || {});
  var OPERATOR_TOKEN_PRIORITY = /* @__PURE__ */ new Map([
    ["<>" /* NOT_EQUAL */, 3],
    ["<" /* LESS_THAN */, 3],
    [">=" /* GREATER_THAN_OR_EQUAL */, 3],
    ["=" /* EQUALS */, 3],
    [">" /* GREATER_THAN */, 3],
    ["<=" /* LESS_THAN_OR_EQUAL */, 3],
    ["&" /* CONCATENATE */, 2],
    ["+" /* PLUS */, 2],
    ["-" /* MINUS */, 2],
    ["/" /* DIVIDED */, 1],
    ["*" /* MULTIPLY */, 1],
    ["^" /* POWER */, 0]
  ]);
  var OPERATOR_TOKEN_SET = new Set(OPERATOR_TOKEN_PRIORITY.keys());
  var OPERATOR_TOKEN_COMPARE_SET = /* @__PURE__ */ new Set([
    "=" /* EQUALS */,
    "<>" /* NOT_EQUAL */,
    ">" /* GREATER_THAN */,
    ">=" /* GREATER_THAN_OR_EQUAL */,
    "<" /* LESS_THAN */,
    "<=" /* LESS_THAN_OR_EQUAL */
  ]);
  var matchToken = /* @__PURE__ */ ((matchToken2) => {
    matchToken2["OPEN_BRACKET"] = "(";
    matchToken2["CLOSE_BRACKET"] = ")";
    matchToken2["COMMA"] = ",";
    matchToken2["SINGLE_QUOTATION"] = "'";
    matchToken2["DOUBLE_QUOTATION"] = '"';
    matchToken2["OPEN_BRACES"] = "{";
    matchToken2["CLOSE_BRACES"] = "}";
    matchToken2["COLON"] = ":";
    matchToken2["OPEN_SQUARE_BRACKET"] = "[";
    matchToken2["CLOSE_SQUARE_BRACKET"] = "]";
    return matchToken2;
  })(matchToken || {});
  var suffixToken = /* @__PURE__ */ ((suffixToken2) => {
    suffixToken2["PERCENTAGE"] = "%";
    suffixToken2["POUND"] = "#";
    return suffixToken2;
  })(suffixToken || {});
  var SUFFIX_TOKEN_SET = /* @__PURE__ */ new Set(["%" /* PERCENTAGE */, "#" /* POUND */]);
  var prefixToken = /* @__PURE__ */ ((prefixToken2) => {
    prefixToken2["AT"] = "@";
    prefixToken2["MINUS"] = "-";
    return prefixToken2;
  })(prefixToken || {});
  var SPACE_TOKEN = " ";

  // ../packages/engine-formula/src/basics/match-token.ts
  var FORMULA_LEXER_TOKENS = [
    ...Object.values(compareToken),
    ...Object.values(operatorToken),
    ...Object.values(matchToken),
    ...Object.values(suffixToken),
    ...Object.values(prefixToken)
  ];
  function isFormulaLexerToken(str) {
    return FORMULA_LEXER_TOKENS.includes(str);
  }
  function includeFormulaLexerToken(str) {
    for (const token of FORMULA_LEXER_TOKENS) {
      if (str.indexOf(token) > -1) {
        return true;
      }
    }
    return false;
  }

  // ../packages/engine-formula/src/basics/runtime.ts
  function convertUnitDataToRuntime(unitData) {
    const arrayFormulaCellData = {};
    Object.keys(unitData).forEach((unitId) => {
      const sheetData = unitData[unitId];
      if (sheetData == null) {
        return true;
      }
      if (arrayFormulaCellData[unitId] == null) {
        arrayFormulaCellData[unitId] = {};
      }
      Object.keys(sheetData).forEach((sheetId) => {
        const cellData = sheetData[sheetId];
        arrayFormulaCellData[unitId][sheetId] = new ObjectMatrix(cellData);
      });
    });
    return arrayFormulaCellData;
  }
  function convertRuntimeToUnitData(unitData) {
    const unitPrimitiveData = {};
    Object.keys(unitData).forEach((unitId) => {
      const sheetData = unitData[unitId];
      if (sheetData == null) {
        return true;
      }
      if (unitPrimitiveData[unitId] == null) {
        unitPrimitiveData[unitId] = {};
      }
      Object.keys(sheetData).forEach((sheetId) => {
        const cellData = sheetData[sheetId];
        unitPrimitiveData[unitId][sheetId] = cellData.getData();
      });
    });
    return unitPrimitiveData;
  }

  // ../packages/engine-formula/src/commands/mutations/register-function.mutation.ts
  var RegisterFunctionMutation = {
    id: "formula.mutation.register-function",
    type: 2 /* MUTATION */,
    handler: () => true
  };

  // ../packages/engine-formula/src/basics/cache-lru.ts
  var FormulaAstLRU = class {
    constructor(cacheCount) {
      __publicField(this, "_cache");
      this._cache = new LRUMap(cacheCount);
    }
    set(formulaString, node) {
      const hash = this._hash(formulaString);
      this._cache.set(hash, node);
    }
    get(formulaString) {
      const hash = this._hash(formulaString);
      return this._cache.get(hash);
    }
    clear() {
      this._cache.clear();
    }
    _hash(formulaString) {
      return hashAlgorithm(formulaString);
    }
  };

  // ../packages/engine-formula/src/basics/regex.ts
  var UNIT_NAME_REGEX = '\\[([^\\[\\]\\/?:"<>|*\\\\]+)\\]';
  var SHEET_NAME_REGEX = "((?![\\[\\]\\/?*\\\\]).)*!";
  var ABSOLUTE_SYMBOL = "$";
  var RANGE_SYMBOL = "\\s*?:\\s*?";
  var UNIT_NAME_SHEET_NAME_REGEX = `'?(${UNIT_NAME_REGEX})?(${SHEET_NAME_REGEX})?'?`;
  var SIMPLE_SINGLE_RANGE_REGEX = `\\${ABSOLUTE_SYMBOL}?[A-Za-z]+\\${ABSOLUTE_SYMBOL}?[0-9]+`;
  var REFERENCE_MULTIPLE_RANGE_REGEX = `^(${"@" /* AT */})?${UNIT_NAME_SHEET_NAME_REGEX}${SIMPLE_SINGLE_RANGE_REGEX}${RANGE_SYMBOL}${SIMPLE_SINGLE_RANGE_REGEX}$`;
  var REFERENCE_SINGLE_RANGE_REGEX = `^${UNIT_NAME_SHEET_NAME_REGEX}\\s*?${SIMPLE_SINGLE_RANGE_REGEX}(${"#" /* POUND */})?$`;
  var REFERENCE_REGEX_ROW = `^${UNIT_NAME_SHEET_NAME_REGEX}\\${ABSOLUTE_SYMBOL}?[0-9]+${RANGE_SYMBOL}\\${ABSOLUTE_SYMBOL}?[0-9]+$`;
  var REFERENCE_REGEX_COLUMN = `^${UNIT_NAME_SHEET_NAME_REGEX}\\${ABSOLUTE_SYMBOL}?[A-Za-z]+${RANGE_SYMBOL}\\${ABSOLUTE_SYMBOL}?[A-Za-z]+$`;
  var REFERENCE_REGEX_SINGLE_ROW = `^${UNIT_NAME_SHEET_NAME_REGEX}\\s*?\\${ABSOLUTE_SYMBOL}?[0-9]+$`;
  var REFERENCE_REGEX_SINGLE_COLUMN = `^${UNIT_NAME_SHEET_NAME_REGEX}\\s*?\\${ABSOLUTE_SYMBOL}?[A-Za-z]+$`;
  var TABLE_NAME_REGEX = "((?![~!@#$%^&*()_+<>?:,./;\u2019\uFF0C\u3002\u3001\u2018\uFF1A\u201C\u300A\u300B\uFF1F~\uFF01@#\uFFE5%\u2026\u2026\uFF08\uFF09\u3010\u3011\\[\\]\\/\\\\]).)+";
  var TABLE_TITLE_REGEX = "\\[#.+\\]\\s*?,\\s*?";
  var TABLE_CONTENT_REGEX = "\\[((?<!#).)*\\]";
  var TABLE_MULTIPLE_COLUMN_REGEX = `${TABLE_CONTENT_REGEX}${RANGE_SYMBOL}${TABLE_CONTENT_REGEX}`;
  var REFERENCE_TABLE_ALL_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}$`;
  var REFERENCE_TABLE_SINGLE_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}(${TABLE_CONTENT_REGEX}|\\[${TABLE_TITLE_REGEX}${TABLE_CONTENT_REGEX}\\])+$`;
  var REFERENCE_TABLE_MULTIPLE_COLUMN_REGEX = `^(${UNIT_NAME_REGEX})?${TABLE_NAME_REGEX}(\\[${TABLE_MULTIPLE_COLUMN_REGEX}\\])?$|^${TABLE_NAME_REGEX}(\\[${TABLE_TITLE_REGEX}${TABLE_MULTIPLE_COLUMN_REGEX}\\])?$`;
  var $SUPER_TABLE_COLUMN_REGEX = "[.*?]";
  var $ARRAY_VALUE_REGEX = "{.*?}";
  function isReferenceString(refString) {
    return new RegExp(REFERENCE_SINGLE_RANGE_REGEX).test(refString) || new RegExp(REFERENCE_MULTIPLE_RANGE_REGEX).test(refString) || new RegExp(REFERENCE_REGEX_ROW).test(refString) || new RegExp(REFERENCE_REGEX_COLUMN).test(refString);
  }

  // ../packages/engine-formula/src/basics/token-type.ts
  var DEFAULT_TOKEN_TYPE_PARAMETER = "P_1";
  var DEFAULT_TOKEN_TYPE_ROOT = "R_1";
  var DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER = "L_1";
  var DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER = "LR_1";
  var DEFAULT_TOKEN_TYPE_LAMBDA_OMIT_PARAMETER = "LO_1";
  var DEFAULT_TOKEN_LET_FUNCTION_NAME = "LET";
  var DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME = "LAMBDA";
  var DEFAULT_TOKEN_CUBE_FUNCTION_NAME = "CUBE";

  // ../packages/engine-formula/src/engine/utils/reference.ts
  var $ROW_REGEX = /[^0-9]/g;
  var $COLUMN_REGEX = /[^A-Za-z]/g;
  function getAbsoluteRefTypeWithSingleString(singleRefString) {
    const isColumnAbsolute = singleRefString[0] === "$";
    const remainChar = singleRefString.substring(1);
    const isRowAbsolute = remainChar.indexOf("$") > -1;
    if (isColumnAbsolute && isRowAbsolute) {
      return 3 /* ALL */;
    }
    if (isColumnAbsolute) {
      return 2 /* COLUMN */;
    }
    if (isRowAbsolute) {
      return 1 /* ROW */;
    }
    return 0 /* NONE */;
  }
  function _getAbsoluteToken(absoluteRefType = 0 /* NONE */) {
    let rowAbsoluteString = "";
    let columnAbsoluteString = "";
    if (absoluteRefType === 1 /* ROW */) {
      rowAbsoluteString = "$";
    } else if (absoluteRefType === 2 /* COLUMN */) {
      columnAbsoluteString = "$";
    } else if (absoluteRefType === 3 /* ALL */) {
      rowAbsoluteString = "$";
      columnAbsoluteString = "$";
    }
    return {
      rowAbsoluteString,
      columnAbsoluteString
    };
  }
  function serializeRange(range) {
    const {
      startColumn,
      startRow,
      endColumn,
      endRow,
      startAbsoluteRefType,
      endAbsoluteRefType,
      rangeType = 0 /* NORMAL */
    } = range;
    const start = _getAbsoluteToken(startAbsoluteRefType);
    const end = _getAbsoluteToken(endAbsoluteRefType);
    if (rangeType === 1 /* ROW */ || rangeType === 3 /* ALL */) {
      const startStr2 = `${start.rowAbsoluteString}${startRow + 1}`;
      const endStr2 = `${end.rowAbsoluteString}${endRow + 1}`;
      return `${startStr2}:${endStr2}`;
    }
    if (rangeType === 2 /* COLUMN */) {
      const startStr2 = `${start.columnAbsoluteString}${Tools.chatAtABC(startColumn)}`;
      const endStr2 = `${end.columnAbsoluteString}${Tools.chatAtABC(endColumn)}`;
      return `${startStr2}:${endStr2}`;
    }
    const startStr = `${start.columnAbsoluteString}${Tools.chatAtABC(startColumn)}${start.rowAbsoluteString}${startRow + 1}`;
    const endStr = `${end.columnAbsoluteString}${Tools.chatAtABC(endColumn)}${end.rowAbsoluteString}${endRow + 1}`;
    if (startStr === endStr) {
      return startStr;
    }
    return `${startStr}:${endStr}`;
  }
  function serializeRangeWithSheet(sheetName, range) {
    if (needsQuoting(sheetName)) {
      return `'${sheetName}'!${serializeRange(range)}`;
    }
    return `${sheetName}!${serializeRange(range)}`;
  }
  function serializeRangeWithSpreadsheet(unit, sheetName, range) {
    if (needsQuoting(unit) || needsQuoting(sheetName)) {
      return `'[${unit}]${sheetName}'!${serializeRange(range)}`;
    }
    return `[${unit}]${sheetName}!${serializeRange(range)}`;
  }
  function serializeRangeToRefString(gridRangeName) {
    const { unitId, sheetName, range } = gridRangeName;
    if (unitId != null && unitId.length > 0 && sheetName != null && sheetName.length > 0) {
      return serializeRangeWithSpreadsheet(unitId, sheetName, range);
    }
    if (sheetName != null && sheetName.length > 0) {
      return serializeRangeWithSheet(sheetName, range);
    }
    return serializeRange(range);
  }
  function singleReferenceToGrid(refBody) {
    const row = Number.parseInt(refBody.replace($ROW_REGEX, "")) - 1;
    const column = Tools.ABCatNum(refBody.replace($COLUMN_REGEX, ""));
    const absoluteRefType = getAbsoluteRefTypeWithSingleString(refBody);
    return {
      row,
      column,
      absoluteRefType
    };
  }
  function handleRefStringInfo(refString) {
    const unitIdMatch = new RegExp(UNIT_NAME_REGEX).exec(refString);
    let unitId = "";
    if (unitIdMatch != null) {
      unitId = unitIdMatch[0].trim();
      unitId = unitId.slice(1, unitId.length - 1);
      refString = refString.replace(new RegExp(UNIT_NAME_REGEX), "");
    }
    const sheetNameIndex = refString.indexOf("!");
    let sheetName = "";
    let refBody = "";
    if (sheetNameIndex > -1) {
      sheetName = refString.substring(0, sheetNameIndex);
      if (sheetName[0] === "'" && sheetName[sheetName.length - 1] === "'") {
        sheetName = sheetName.substring(1, sheetName.length - 1);
      }
      refBody = refString.substring(sheetNameIndex);
    } else {
      refBody = refString;
    }
    return {
      refBody,
      sheetName,
      unitId
    };
  }
  function deserializeRangeWithSheet(refString) {
    const { refBody, sheetName, unitId } = handleRefStringInfo(refString);
    const colonIndex = refBody.indexOf(":");
    if (colonIndex === -1) {
      const grid = singleReferenceToGrid(refBody);
      const row = grid.row;
      const column = grid.column;
      const absoluteRefType = grid.absoluteRefType;
      const range = {
        startRow: row,
        startColumn: column,
        endRow: row,
        endColumn: column,
        startAbsoluteRefType: absoluteRefType,
        endAbsoluteRefType: absoluteRefType
      };
      return {
        unitId,
        sheetName,
        range
      };
    }
    const refStartString = refBody.substring(0, colonIndex);
    const refEndString = refBody.substring(colonIndex + 1);
    const startGrid = singleReferenceToGrid(refStartString);
    const endGrid = singleReferenceToGrid(refEndString);
    const startRow = startGrid.row;
    const startColumn = startGrid.column;
    const endRow = endGrid.row;
    const endColumn = endGrid.column;
    let rangeType = 0 /* NORMAL */;
    if (Number.isNaN(startRow) && Number.isNaN(endRow)) {
      rangeType = 2 /* COLUMN */;
    } else if (Number.isNaN(startColumn) && Number.isNaN(endColumn)) {
      rangeType = 1 /* ROW */;
    }
    return {
      unitId,
      sheetName,
      range: {
        startRow,
        startColumn,
        endRow,
        endColumn,
        startAbsoluteRefType: startGrid.absoluteRefType,
        endAbsoluteRefType: endGrid.absoluteRefType,
        rangeType
      }
    };
  }
  function needsQuoting(name) {
    if (name.length === 0) {
      return false;
    }
    if (includeFormulaLexerToken(name)) {
      return true;
    }
    if (isA1Notation(name) || isR1C1Notation(name)) {
      return true;
    }
    if (startsWithNonAlphabetic(name)) {
      return true;
    }
    if (/[\s!$%^&*()+\-=\[\]{};':"\\|,.<>\/?]/.test(name)) {
      return true;
    }
    return false;
  }
  function isA1Notation(name) {
    const match = name.match(/[1-9][0-9]{0,6}/);
    return /^[A-Z]+[1-9][0-9]{0,6}$/.test(name) && match !== null;
  }
  function isR1C1Notation(name) {
    return /^(R(-?[0-9]+)?C(-?[0-9]+)?|C(-?[0-9]+)?|R(-?[0-9]+)?)$/.test(name);
  }
  function startsWithNonAlphabetic(name) {
    return !new RegExp("^\\p{Letter}", "u").test(name.charAt(0));
  }

  // ../packages/engine-formula/src/engine/utils/sequence.ts
  function generateStringWithSequence(newSequenceNodes) {
    let sequenceString = "";
    for (const node of newSequenceNodes) {
      if (typeof node === "string") {
        sequenceString += node;
      } else {
        sequenceString += node.token;
      }
    }
    return sequenceString;
  }

  // ../packages/engine-formula/src/engine/analysis/lexer-node.ts
  var LexerNode = class _LexerNode {
    constructor() {
      __publicField(this, "_parent");
      __publicField(this, "_token", DEFAULT_TOKEN_TYPE_ROOT);
      __publicField(this, "_children", []);
      __publicField(this, "_lambdaId");
      __publicField(this, "_functionDefinitionPrivacyVar");
      __publicField(this, "_lambdaParameter", "");
      __publicField(this, "_startIndex", -1);
      __publicField(this, "_endIndex", -1);
    }
    dispose() {
      var _a2;
      this._children.forEach((node) => {
        if (!(typeof node === "string")) {
          node.dispose();
        }
      });
      (_a2 = this._functionDefinitionPrivacyVar) == null ? void 0 : _a2.clear();
      this._parent = null;
    }
    getStartIndex() {
      return this._startIndex;
    }
    getLambdaId() {
      return this._lambdaId;
    }
    setLambdaId(lambdaId) {
      this._lambdaId = lambdaId;
    }
    getFunctionDefinitionPrivacyVar() {
      return this._functionDefinitionPrivacyVar;
    }
    setLambdaPrivacyVar(lambdaPrivacyVar) {
      this._functionDefinitionPrivacyVar = lambdaPrivacyVar;
    }
    getLambdaParameter() {
      return this._lambdaParameter;
    }
    setLambdaParameter(lambdaParameter) {
      this._lambdaParameter = lambdaParameter;
    }
    getParent() {
      return this._parent;
    }
    setParent(lexerNode) {
      this._parent = lexerNode;
    }
    getChildren() {
      return this._children;
    }
    setChildren(children) {
      this._children = children;
    }
    addChildren(children) {
      this._children.push(children);
    }
    addChildrenFirst(children) {
      this._children.unshift(children);
    }
    getToken() {
      return this._token;
    }
    setToken(token) {
      this._token = token;
    }
    setIndex(st, ed) {
      this._startIndex = st;
      this._endIndex = ed;
    }
    replaceChild(lexerNode, newLexerNode) {
      const i = this._getIndexInParent(lexerNode);
      if (i == null) {
        return;
      }
      this.getChildren().splice(i, 1, newLexerNode);
      newLexerNode.setParent(this);
    }
    changeToParent(newParentLexerNode) {
      const parentNode = this.getParent();
      if (parentNode) {
        parentNode.removeChild(this);
      }
      this.setParent(newParentLexerNode);
      const childrenNode = newParentLexerNode.getChildren();
      childrenNode.push(this);
    }
    removeChild(lexerNode) {
      const i = this._getIndexInParent(lexerNode);
      if (i == null) {
        return;
      }
      this.getChildren().splice(i, 1);
    }
    serialize() {
      const token = this.getToken();
      const children = this.getChildren();
      const childrenSerialization = [];
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        if (item instanceof _LexerNode) {
          childrenSerialization.push(item.serialize());
        } else {
          childrenSerialization.push(item);
        }
      }
      return {
        token,
        st: this._startIndex,
        ed: this._endIndex,
        children: childrenSerialization
      };
    }
    _getIndexInParent(lexerNode) {
      const childrenNode = this.getChildren();
      const childrenCount = childrenNode.length;
      for (let i = 0; i < childrenCount; i++) {
        const child = childrenNode[i];
        if (child === lexerNode) {
          return i;
        }
      }
    }
  };

  // ../packages/engine-formula/src/engine/analysis/lexer-tree-builder.ts
  var FORMULA_CACHE_LRU_COUNT = 1e5;
  var FormulaLexerNodeCache = new FormulaAstLRU(FORMULA_CACHE_LRU_COUNT);
  var FormulaSequenceNodeCache = new FormulaAstLRU(FORMULA_CACHE_LRU_COUNT);
  var LexerTreeBuilder = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_currentLexerNode", new LexerNode());
      __publicField(this, "_upLevel", 0);
      __publicField(this, "_segment", "");
      __publicField(this, "_bracketState", []);
      // ()
      __publicField(this, "_squareBracketState", 0);
      __publicField(this, "_bracesState", 0);
      // {}
      __publicField(this, "_singleQuotationState", 0);
      // ''
      __publicField(this, "_doubleQuotationState", 0);
      // ""
      __publicField(this, "_lambdaState", false);
      // Lambda
      __publicField(this, "_colonState", false);
      // :
      __publicField(this, "_tableBracketState", false);
    }
    // Table3[[#All],[Column1]:[Column2]]
    dispose() {
      this._resetTemp();
      this._currentLexerNode.dispose();
      FormulaLexerNodeCache.clear();
      FormulaSequenceNodeCache.clear();
    }
    getUpLevel() {
      return this._upLevel;
    }
    isColonClose() {
      return this._colonState === false;
    }
    isColonOpen() {
      return this._colonState === true;
    }
    isDoubleQuotationClose() {
      return this._doubleQuotationState === 0;
    }
    isLambdaOpen() {
      return this._lambdaState === true;
    }
    isLambdaClose() {
      return this._lambdaState === false;
    }
    isSingleQuotationClose() {
      return this._singleQuotationState === 0;
    }
    isBracesClose() {
      return this._bracesState === 0;
    }
    isBracketClose() {
      return this._bracketState.length === 0;
    }
    isSquareBracketClose() {
      return this._squareBracketState === 0;
    }
    getCurrentLexerNode() {
      return this._currentLexerNode;
    }
    getFunctionAndParameter(formulaString, strIndex) {
      const current = this._getCurrentParamIndex(formulaString, strIndex);
      if (current == null || current === "#VALUE!" /* VALUE */) {
        return;
      }
      const lexerNode = current[0];
      if (typeof lexerNode === "string") {
        return;
      }
      let parent = lexerNode.getParent();
      let children = lexerNode;
      while (parent) {
        const token = parent.getToken();
        if (token !== DEFAULT_TOKEN_TYPE_PARAMETER && !isFormulaLexerToken(token) && parent.getStartIndex() !== -1) {
          const paramIndex = parent.getChildren().indexOf(children);
          return {
            functionName: token,
            paramIndex
          };
        }
        children = parent;
        parent = parent.getParent();
      }
    }
    moveFormulaRefOffset(formulaString, refOffsetX, refOffsetY) {
      const sequenceNodes = this.sequenceNodesBuilder(formulaString);
      if (sequenceNodes == null) {
        return formulaString;
      }
      const newSequenceNodes = [];
      for (let i = 0, len = sequenceNodes.length; i < len; i++) {
        const node = sequenceNodes[i];
        if (typeof node === "string" || node.nodeType !== 4 /* REFERENCE */) {
          newSequenceNodes.push(node);
          continue;
        }
        const { token } = node;
        const sequenceGrid = deserializeRangeWithSheet(token);
        const { range, sheetName, unitId: sequenceUnitId } = sequenceGrid;
        const newRange = Rectangle.moveOffset(range, refOffsetX, refOffsetY);
        let newToken = "";
        if (isValidRange(newRange)) {
          newToken = serializeRangeToRefString({
            range: newRange,
            unitId: sequenceUnitId,
            sheetName
          });
        } else {
          newToken = "#REF!" /* REF */;
        }
        newSequenceNodes.push({
          ...node,
          token: newToken
        });
      }
      return `=${generateStringWithSequence(newSequenceNodes)}`;
    }
    /**
     * Estimate the number of right brackets that need to be automatically added to the end of the formula.
     * @param formulaString
     */
    checkIfAddBracket(formulaString) {
      let lastBracketCount = 0;
      let lastIndex = formulaString.length - 1;
      let lastString = formulaString[lastIndex];
      while ((lastString === ")" /* CLOSE_BRACKET */ || lastString === " ") && lastIndex >= 0) {
        if (lastString === ")" /* CLOSE_BRACKET */) {
          lastBracketCount++;
        }
        lastString = formulaString[--lastIndex];
      }
      const current = this._getCurrentParamIndex(formulaString, formulaString.length - 2);
      if (current == null || current === "#VALUE!" /* VALUE */) {
        return 0;
      }
      const lexerNode = current[0];
      if (typeof lexerNode === "string") {
        return 0;
      }
      let parent = lexerNode.getParent();
      let bracketCount = 0;
      if (current[1] === "(" /* OPEN_BRACKET */) {
        bracketCount++;
      }
      while (parent) {
        const token = parent.getToken();
        if (token !== DEFAULT_TOKEN_TYPE_PARAMETER && token !== ":" /* COLON */ && parent.getStartIndex() !== -1 && token.toUpperCase() !== DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME) {
          if (lastBracketCount === 0) {
            bracketCount += 1;
          } else {
            lastBracketCount--;
          }
        }
        parent = parent.getParent();
      }
      return bracketCount;
    }
    sequenceNodesBuilder(formulaString) {
      const sequenceNodesCache = FormulaSequenceNodeCache.get(formulaString);
      if (sequenceNodesCache) {
        return [...sequenceNodesCache];
      }
      const sequenceArray = this._getSequenceArray(formulaString);
      if (sequenceArray.length === 0) {
        return;
      }
      const newSequenceNodes = this.getSequenceNode(sequenceArray);
      FormulaSequenceNodeCache.set(formulaString, [...newSequenceNodes]);
      return newSequenceNodes;
    }
    getSequenceNode(sequenceArray) {
      const sequenceNodes = [];
      let maybeString = false;
      for (let i = 0, len = sequenceArray.length; i < len; i++) {
        const item = sequenceArray[i];
        const preItem = sequenceArray[i - 1];
        const { segment, currentString } = item;
        if (currentString === '"' /* DOUBLE_QUOTATION */) {
          maybeString = true;
        }
        if ((segment !== "" || i === 0) && i !== len - 1) {
          sequenceNodes.push(currentString);
          continue;
        }
        let preSegment = (preItem == null ? void 0 : preItem.segment) || "";
        let startIndex = i - preSegment.length;
        let endIndex = i - 1;
        let deleteEndIndex = i - 1;
        if (i === len - 1 && this._isLastMergeString(currentString)) {
          preSegment += currentString;
          endIndex += 1;
        }
        if (preSegment === "" || OPERATOR_TOKEN_PRIORITY.has(preSegment)) {
          sequenceNodes.push(currentString);
          continue;
        }
        const preSegmentTrim = preSegment.trim();
        const preSegmentNotPrefixToken = this._replacePrefixString(preSegmentTrim);
        if (maybeString === true && preSegmentTrim[preSegmentTrim.length - 1] === '"' /* DOUBLE_QUOTATION */) {
          maybeString = false;
          this._pushSequenceNode(
            sequenceNodes,
            {
              nodeType: 2 /* STRING */,
              token: preSegment,
              startIndex,
              endIndex
            },
            deleteEndIndex
          );
        } else if (new RegExp(REFERENCE_SINGLE_RANGE_REGEX).test(preSegmentNotPrefixToken)) {
          if (preSegmentNotPrefixToken.length !== preSegmentTrim.length) {
            const minusCount = preSegmentTrim.length - preSegmentNotPrefixToken.length;
            deleteEndIndex += minusCount;
            startIndex += minusCount;
            preSegment = this._replacePrefixString(preSegment);
          }
          this._pushSequenceNode(
            sequenceNodes,
            {
              nodeType: 4 /* REFERENCE */,
              token: preSegment,
              startIndex,
              endIndex
            },
            deleteEndIndex
          );
        } else if (Tools.isStringNumber(preSegmentTrim)) {
          this._pushSequenceNode(
            sequenceNodes,
            {
              nodeType: 1 /* NUMBER */,
              token: preSegment,
              startIndex,
              endIndex
            },
            deleteEndIndex
          );
        } else if (preSegmentTrim.length > 0) {
          this._pushSequenceNode(
            sequenceNodes,
            {
              nodeType: 3 /* FUNCTION */,
              token: preSegment,
              startIndex,
              endIndex
            },
            deleteEndIndex
          );
        }
        if (i !== len - 1 || !this._isLastMergeString(currentString)) {
          sequenceNodes.push(currentString);
        }
      }
      return this._mergeSequenceNodeReference(sequenceNodes);
    }
    _getCurrentParamIndex(formulaString, index) {
      return this._nodeMaker(formulaString, void 0, index);
    }
    _isLastMergeString(str) {
      return str === '"' /* DOUBLE_QUOTATION */ || Tools.isStringNumber(str) || !isFormulaLexerToken(str);
    }
    /**
     * Merge array and handle ref operations
     *
     */
    _mergeSequenceNodeReference(sequenceNodes) {
      const newSequenceNodes = [];
      const sequenceNodesCount = sequenceNodes.length;
      let i = 0;
      while (i < sequenceNodesCount) {
        const node = sequenceNodes[i];
        if (typeof node === "string") {
          const preNode = sequenceNodes[i - 1];
          if (node.trim() === "}" /* CLOSE_BRACES */ && preNode != null && typeof preNode !== "string" && preNode.nodeType === 3 /* FUNCTION */) {
            const firstChar = preNode.token.trim().substring(0, 1);
            if (firstChar === "{" /* OPEN_BRACES */) {
              preNode.nodeType = 5 /* ARRAY */;
              preNode.token += node;
              preNode.endIndex += node.length;
              i++;
              continue;
            }
          }
          newSequenceNodes.push(node);
        } else {
          const nextOneNode = sequenceNodes[i + 1];
          const nextTwoNode = sequenceNodes[i + 2];
          if (nextOneNode === ":" /* COLON */ && typeof node !== "string" && nextTwoNode != null && typeof nextTwoNode !== "string" && isReferenceString((node.token + nextOneNode + nextTwoNode.token).trim())) {
            node.nodeType = 4 /* REFERENCE */;
            node.token += nextOneNode + nextTwoNode.token;
            node.endIndex = nextTwoNode.endIndex;
            i += 2;
          }
          newSequenceNodes.push(node);
        }
        i++;
      }
      return newSequenceNodes;
    }
    _pushSequenceNode(sequenceNodes, node, deleteEndIndex) {
      const segmentCount = deleteEndIndex - node.startIndex + 1;
      sequenceNodes.splice(sequenceNodes.length - segmentCount, segmentCount, node);
    }
    _replacePrefixString(token) {
      const tokenArray = [];
      let isNotPreFix = false;
      for (let i = 0, len = token.length; i < len; i++) {
        const char = token[i];
        if (char === SPACE_TOKEN && !isNotPreFix) {
          tokenArray.push(char);
        } else if (!isNotPreFix && (char === "@" /* AT */ || char === "-" /* MINUS */)) {
          continue;
        } else {
          tokenArray.push(char);
          isNotPreFix = true;
        }
      }
      return tokenArray.join("");
    }
    nodeMakerTest(formulaString) {
      return this._nodeMaker(formulaString);
    }
    treeBuilder(formulaString, transformSuffix = true, injectDefinedName) {
      if (transformSuffix === true) {
        const lexerNode = FormulaLexerNodeCache.get(formulaString);
        if (lexerNode) {
          return lexerNode;
        }
      }
      this._resetCurrentLexerNode();
      this._currentLexerNode.setToken(DEFAULT_TOKEN_TYPE_ROOT);
      const sequenceArray = [];
      let state = this._nodeMaker(formulaString, sequenceArray);
      if (state === "#VALUE!" /* VALUE */ || sequenceArray.length === 0) {
        return state;
      }
      let currentHasDefinedName = false;
      let currentSequenceString = "";
      if (injectDefinedName) {
        const { hasDefinedName, sequenceString } = injectDefinedName(sequenceArray);
        currentHasDefinedName = hasDefinedName;
        currentSequenceString = sequenceString;
      }
      if (currentHasDefinedName) {
        this._resetCurrentLexerNode();
        this._currentLexerNode.setToken(DEFAULT_TOKEN_TYPE_ROOT);
        state = this._nodeMaker(`=${currentSequenceString}`);
        if (state === "#VALUE!" /* VALUE */) {
          return state;
        }
      }
      const node = this._getTopNode(this._currentLexerNode);
      if (node) {
        this._currentLexerNode = node;
      }
      if (transformSuffix) {
        const isValid = this._suffixExpressionHandler(this._currentLexerNode);
        if (!isValid) {
          return "#VALUE!" /* VALUE */;
        }
        FormulaLexerNodeCache.set(formulaString, this._currentLexerNode);
      }
      return this._currentLexerNode;
    }
    _suffixExpressionHandler(lexerNode) {
      var _a2, _b2;
      const children = lexerNode.getChildren();
      if (!children) {
        return false;
      }
      const childrenCount = children.length;
      const baseStack = [];
      const symbolStack = [];
      for (let i = 0; i < childrenCount; i++) {
        const node = children[i];
        if (!(node instanceof LexerNode)) {
          const char = node.trim();
          if (char === "") {
            continue;
          }
          if (OPERATOR_TOKEN_SET.has(char)) {
            if (char === "+" /* PLUS */ && this._deletePlusForPreNode(children[i - 1])) {
              continue;
            }
            if (char !== "+" /* PLUS */ && char !== "-" /* MINUS */ && this._deletePlusForPreNode(children[i - 1])) {
              return false;
            }
            while (symbolStack.length > 0) {
              const lastSymbol = (_a2 = symbolStack[symbolStack.length - 1]) == null ? void 0 : _a2.trim();
              if (!lastSymbol || lastSymbol === "(" /* OPEN_BRACKET */) {
                break;
              }
              const lastSymbolPriority = OPERATOR_TOKEN_PRIORITY.get(lastSymbol);
              const charPriority = OPERATOR_TOKEN_PRIORITY.get(char);
              if (!lastSymbolPriority || !charPriority) {
                break;
              }
              if (charPriority >= lastSymbolPriority) {
                baseStack.push(symbolStack.pop());
              } else {
                break;
              }
            }
            symbolStack.push(node);
          } else if (char === "(" /* OPEN_BRACKET */) {
            symbolStack.push(node);
          } else if (char === ")" /* CLOSE_BRACKET */) {
            if (this._checkOpenBracket(children[i - 1])) {
              return false;
            }
            if (this._checkOperator(children[i - 1])) {
              return false;
            }
            while (symbolStack.length > 0) {
              const lastSymbol = (_b2 = symbolStack[symbolStack.length - 1]) == null ? void 0 : _b2.trim();
              if (!lastSymbol) {
                break;
              }
              if (lastSymbol === "(" /* OPEN_BRACKET */) {
                symbolStack.pop();
                break;
              }
              baseStack.push(symbolStack.pop());
            }
          } else {
            if (this._checkCloseBracket(children[i - 1])) {
              return false;
            }
            baseStack.push(node);
          }
        } else {
          this._suffixExpressionHandler(node);
          baseStack.push(node);
        }
      }
      while (symbolStack.length > 0) {
        const symbol = symbolStack.pop();
        if (symbol === "(" /* OPEN_BRACKET */ || symbol === ")" /* CLOSE_BRACKET */) {
          return false;
        }
        baseStack.push(symbol);
      }
      lexerNode.setChildren(baseStack);
      return true;
    }
    _checkCloseBracket(node) {
      return node === ")" /* CLOSE_BRACKET */;
    }
    _checkOpenBracket(node) {
      return node === "(" /* OPEN_BRACKET */;
    }
    _checkOperator(node) {
      if (node == null) {
        return false;
      }
      if (node instanceof LexerNode) {
        return false;
      }
      return OPERATOR_TOKEN_SET.has(node);
    }
    _deletePlusForPreNode(preNode) {
      if (preNode == null) {
        return true;
      }
      if (!(preNode instanceof LexerNode)) {
        const preChar = preNode.trim();
        if (OPERATOR_TOKEN_SET.has(preChar) || preChar === "(" /* OPEN_BRACKET */) {
          return true;
        }
      }
      return false;
    }
    _resetCurrentLexerNode() {
      this._currentLexerNode = new LexerNode();
    }
    _resetSegment() {
      this._segment = "";
    }
    _openBracket(type = 0 /* NORMAL */) {
      this._bracketState.push(type);
    }
    _closeBracket() {
      this._bracketState.pop();
    }
    _openSquareBracket() {
      this._squareBracketState += 1;
    }
    _closeSquareBracket() {
      this._squareBracketState -= 1;
    }
    _getCurrentBracket() {
      const bracketState = this._bracketState;
      return bracketState[bracketState.length - 1];
    }
    _changeCurrentBracket(type) {
      const bracketState = this._bracketState;
      bracketState[bracketState.length - 1] = type;
    }
    _openBraces() {
      this._bracesState += 1;
    }
    _closeBraces() {
      this._bracesState -= 1;
    }
    _openSingleQuotation() {
      this._singleQuotationState += 1;
    }
    _closeSingleQuotation() {
      this._singleQuotationState -= 1;
    }
    _openDoubleQuotation() {
      this._doubleQuotationState += 1;
    }
    _closeDoubleQuotation() {
      this._doubleQuotationState -= 1;
    }
    _openLambda() {
      this._lambdaState = true;
    }
    _closeLambda() {
      this._lambdaState = false;
    }
    _openColon(upLevel) {
      this._upLevel = upLevel;
      this._colonState = true;
    }
    _closeColon() {
      this._upLevel = 0;
      this._colonState = false;
    }
    _isTableBracket() {
      return this._tableBracketState;
    }
    _openTableBracket() {
      this._tableBracketState = true;
    }
    _closeTableBracket() {
      this._tableBracketState = false;
    }
    _getLastChildCurrentLexerNode() {
      const children = this._currentLexerNode.getChildren();
      if (children && children.length > 0) {
        const lastNode = children[children.length - 1];
        if (lastNode instanceof LexerNode) {
          return lastNode;
        }
      }
      return false;
    }
    _getLastChildCurrent() {
      const children = this._currentLexerNode.getChildren();
      if (children && children.length > 0) {
        const lastNode = children[children.length - 1];
        return lastNode;
      }
      return false;
    }
    _setParentCurrentLexerNode() {
      const parent = this._currentLexerNode.getParent();
      if (parent) {
        this._currentLexerNode = parent;
        return true;
      }
      return false;
    }
    _setAncestorCurrentLexerNode() {
      var _a2, _b2, _c, _d, _e, _f;
      const parent = (_a2 = this._currentLexerNode) == null ? void 0 : _a2.getParent();
      let state = false;
      if (parent && parent.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
        if ((_b2 = parent == null ? void 0 : parent.getParent()) == null ? void 0 : _b2.getParent()) {
          const node = (_d = (_c = this._currentLexerNode.getParent()) == null ? void 0 : _c.getParent()) == null ? void 0 : _d.getParent();
          if (node) {
            this._currentLexerNode = node;
          }
          state = true;
        }
      } else {
        if (parent == null ? void 0 : parent.getParent()) {
          const node = (_e = this._currentLexerNode.getParent()) == null ? void 0 : _e.getParent();
          if (node) {
            this._currentLexerNode = node;
          }
          state = true;
        }
      }
      for (let i = 0; i < this._upLevel; i++) {
        const node = (_f = this._currentLexerNode) == null ? void 0 : _f.getParent();
        if (node) {
          this._currentLexerNode = node;
        }
        if (this._currentLexerNode) {
          state = true;
        } else {
          state = false;
        }
      }
      return state;
    }
    _segmentCount() {
      return this._segment.trim().length;
    }
    _pushSegment(value) {
      this._segment += value;
    }
    _pushNodeToChildren(value, isUnshift = false) {
      if (value !== "") {
        const children = this._currentLexerNode.getChildren();
        if (!(value instanceof LexerNode) && this.isColonOpen()) {
          const subLexerNode_ref = new LexerNode();
          subLexerNode_ref.setToken(value);
          subLexerNode_ref.setParent(this._currentLexerNode);
          value = subLexerNode_ref;
        }
        if (isUnshift) {
          children.unshift(value);
        } else {
          children.push(value);
        }
      }
      if (this.isColonOpen()) {
        this._setAncestorCurrentLexerNode();
        this._closeColon();
      }
    }
    _setCurrentLexerNode(subLexerNode, isUnshift = false) {
      this._pushNodeToChildren(subLexerNode, isUnshift);
      subLexerNode.setParent(this._currentLexerNode);
      this._currentLexerNode = subLexerNode;
    }
    _newAndPushCurrentLexerNode(token, current, isUnshift = false) {
      const subLexerNode = new LexerNode();
      subLexerNode.setToken(token);
      subLexerNode.setIndex(current - token.length, current - 1);
      this._setCurrentLexerNode(subLexerNode, isUnshift);
    }
    _getTopNode(lexerNode) {
      let parentNode = lexerNode;
      while (parentNode == null ? void 0 : parentNode.getParent()) {
        parentNode = parentNode.getParent();
      }
      return parentNode;
    }
    _removeLastChild() {
      const children = this._currentLexerNode.getChildren();
      children.splice(-1);
    }
    _findPreviousToken(data, index) {
      while (index >= 0) {
        const token = data[index];
        if (token !== " ") {
          return token;
        }
        index--;
      }
    }
    _negativeCondition(prevString) {
      if (OPERATOR_TOKEN_SET.has(prevString) || prevString === "(" /* OPEN_BRACKET */ || prevString === "," /* COMMA */ || prevString === "") {
        return true;
      }
      return false;
    }
    _getSequenceArray(formulaString) {
      const sequenceArray = [];
      this._nodeMaker(formulaString, sequenceArray);
      return sequenceArray;
    }
    _resetTemp() {
      this._currentLexerNode = new LexerNode();
      this._upLevel = 0;
      this._segment = "";
      this._bracketState = [];
      this._bracesState = 0;
      this._singleQuotationState = 0;
      this._doubleQuotationState = 0;
      this._lambdaState = false;
      this._colonState = false;
    }
    _checkSimilarErrorToken(currentString, cur, formulaStringArray) {
      if (currentString !== "#" /* POUND */) {
        return true;
      }
      let currentText = formulaStringArray[++cur];
      while (currentText === " ") {
        currentText = formulaStringArray[++cur];
      }
      if (isFormulaLexerToken(currentText)) {
        return true;
      }
      return false;
    }
    _nodeMaker(formulaString, sequenceArray, matchCurrentNodeIndex) {
      if (formulaString.substring(0, 1) === "=" /* EQUALS */) {
        formulaString = formulaString.substring(1);
      }
      let isZeroAdded = false;
      if (formulaString.substring(0, 1) === "-" /* MINUS */) {
        formulaString = `0${formulaString}`;
        isZeroAdded = true;
      }
      const formulaStringArray = formulaString.split("");
      const formulaStringArrayCount = formulaStringArray.length;
      let cur = 0;
      this._resetTemp();
      while (cur < formulaStringArrayCount) {
        const currentString = formulaStringArray[cur];
        if (matchCurrentNodeIndex === cur) {
          return [this._currentLexerNode, currentString];
        }
        if (currentString === "(" /* OPEN_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          if (this._segmentCount() > 0 || this.isLambdaOpen()) {
            if (this.isLambdaClose()) {
              this._newAndPushCurrentLexerNode(this._segment, cur);
              this._resetSegment();
            }
            this._openBracket(1 /* FUNCTION */);
            this._closeLambda();
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && nextCurrentString === ")" /* CLOSE_BRACKET */) {
              if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
                return "#VALUE!" /* VALUE */;
              }
              cur++;
            } else if (nextCurrentString) {
              this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_PARAMETER, cur);
            }
          } else {
            this._pushNodeToChildren(currentString);
            this._openBracket(0 /* NORMAL */);
          }
        } else if (currentString === ")" /* CLOSE_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          this._pushNodeToChildren(this._segment);
          this._resetSegment();
          const currentBracket = this._getCurrentBracket();
          if (currentBracket === 0 /* NORMAL */) {
            this._pushNodeToChildren(currentString);
          } else if (currentBracket === 1 /* FUNCTION */) {
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && nextCurrentString === "(" /* OPEN_BRACKET */) {
              if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
                return "#VALUE!" /* VALUE */;
              }
              this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER, cur, true);
              this._openLambda();
            } else {
              if (!this._setAncestorCurrentLexerNode() && cur !== formulaStringArrayCount - 1) {
                return "#VALUE!" /* VALUE */;
              }
            }
          } else {
            return "#VALUE!" /* VALUE */;
          }
          this._closeBracket();
        } else if (currentString === "{" /* OPEN_BRACES */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          this._pushSegment(currentString);
          this._openBraces();
        } else if (currentString === "}" /* CLOSE_BRACES */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          this._pushSegment(currentString);
          this._pushNodeToChildren(this._segment);
          this._resetSegment();
          this._closeBraces();
        } else if (currentString === "[" /* OPEN_SQUARE_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          if (this._segment.length > 0) {
            this._openTableBracket();
          }
          this._pushSegment(currentString);
          this._openSquareBracket();
        } else if (currentString === "]" /* CLOSE_SQUARE_BRACKET */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose()) {
          this._closeSquareBracket();
          if (this.isSquareBracketClose()) {
            this._pushSegment(currentString);
            if (this._isTableBracket()) {
              this._pushNodeToChildren(this._segment);
              this._resetSegment();
            }
            this._closeTableBracket();
          } else {
            this._pushSegment(currentString);
          }
        } else if (currentString === '"' /* DOUBLE_QUOTATION */ && this.isSingleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
          if (this.isDoubleQuotationClose()) {
            this._openDoubleQuotation();
          } else {
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && nextCurrentString === '"' /* DOUBLE_QUOTATION */) {
              cur++;
            } else {
              this._closeDoubleQuotation();
            }
          }
          this._pushSegment(currentString);
        } else if (currentString === "'" /* SINGLE_QUOTATION */ && this.isDoubleQuotationClose()) {
          if (this.isSingleQuotationClose()) {
            this._openSingleQuotation();
          } else {
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && nextCurrentString === "'" /* SINGLE_QUOTATION */) {
              cur++;
            } else {
              this._closeSingleQuotation();
            }
          }
          this._pushSegment(currentString);
        } else if (currentString === "," /* COMMA */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
          const currentBracket = this._getCurrentBracket();
          if (currentBracket === 1 /* FUNCTION */ || currentBracket == null) {
            this._pushNodeToChildren(this._segment);
            this._resetSegment();
            if (!this._setParentCurrentLexerNode() && cur !== formulaStringArrayCount - 1 && currentBracket != null) {
              return "#VALUE!" /* VALUE */;
            }
            this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_PARAMETER, cur);
          } else {
            const cubeNode = new LexerNode();
            cubeNode.setToken(DEFAULT_TOKEN_CUBE_FUNCTION_NAME);
            const cubeParamNode = new LexerNode();
            cubeParamNode.setToken(DEFAULT_TOKEN_TYPE_PARAMETER);
            cubeParamNode.changeToParent(cubeNode);
            const colonNode = this._currentLexerNode.getParent();
            if (colonNode && colonNode.getToken() === ":" /* COLON */) {
              const colonNodeParent = colonNode.getParent();
              if (!colonNodeParent) {
                return "#VALUE!" /* VALUE */;
              }
              colonNode.changeToParent(cubeParamNode);
              colonNodeParent.setChildren([]);
              cubeNode.changeToParent(colonNodeParent);
            } else {
              return "#VALUE!" /* VALUE */;
            }
            this._changeCurrentBracket(1 /* FUNCTION */);
            this._pushNodeToChildren(this._segment);
            this._resetSegment();
            this._currentLexerNode = cubeNode;
            this._newAndPushCurrentLexerNode(DEFAULT_TOKEN_TYPE_PARAMETER, cur);
          }
        } else if (currentString === ":" /* COLON */ && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isBracesClose() && this.isSquareBracketClose()) {
          const subLexerNode_op = new LexerNode();
          subLexerNode_op.setToken(currentString);
          const subLexerNode_left = new LexerNode();
          subLexerNode_left.setToken(DEFAULT_TOKEN_TYPE_PARAMETER);
          subLexerNode_left.setParent(subLexerNode_op);
          const subLexerNode_right = new LexerNode();
          subLexerNode_right.setToken(DEFAULT_TOKEN_TYPE_PARAMETER);
          subLexerNode_right.setParent(subLexerNode_op);
          subLexerNode_op.getChildren().push(subLexerNode_left, subLexerNode_right);
          let subLexerNode_main = subLexerNode_op;
          let upLevel = 0;
          if (this._segmentCount() > 0) {
            let subLexerNode_minus;
            let subLexerNode_at;
            let sliceLength = 0;
            const segmentTrim = this._segment.trim();
            const lastString = segmentTrim[0];
            const twoLastString = segmentTrim[1];
            if (lastString === "-" /* MINUS */) {
              subLexerNode_minus = new LexerNode();
              subLexerNode_minus.setToken("-" /* MINUS */);
              sliceLength++;
            }
            if (lastString === "@" /* AT */ || twoLastString === "@" /* AT */) {
              subLexerNode_at = new LexerNode();
              subLexerNode_at.setToken("@" /* AT */);
              if (subLexerNode_minus) {
                subLexerNode_minus.addChildren(subLexerNode_at);
                subLexerNode_at.setParent(subLexerNode_minus);
              }
              sliceLength++;
            }
            if (sliceLength > 0) {
              this._segment = segmentTrim.slice(sliceLength);
            }
            upLevel = sliceLength;
            if (subLexerNode_at) {
              subLexerNode_at.addChildren(subLexerNode_op);
              subLexerNode_op.setParent(subLexerNode_at);
              if (subLexerNode_at.getParent()) {
                const node = subLexerNode_at.getParent();
                if (node) {
                  subLexerNode_main = node;
                }
              } else {
                subLexerNode_main = subLexerNode_at;
              }
            } else if (subLexerNode_minus) {
              subLexerNode_main = subLexerNode_minus;
              subLexerNode_minus.addChildren(subLexerNode_op);
              subLexerNode_op.setParent(subLexerNode_minus);
            }
            const subLexerNode_ref = new LexerNode();
            subLexerNode_ref.setToken(this._segment);
            subLexerNode_ref.setParent(subLexerNode_left);
            subLexerNode_left.getChildren().push(subLexerNode_ref);
            this._resetSegment();
          } else {
            const lastChildNode = this._getLastChildCurrentLexerNode();
            if (lastChildNode) {
              lastChildNode.changeToParent(subLexerNode_left);
            }
          }
          this._setCurrentLexerNode(subLexerNode_main);
          this._currentLexerNode = subLexerNode_right;
          this._openColon(upLevel);
        } else if (SUFFIX_TOKEN_SET.has(currentString) && this._checkSimilarErrorToken(currentString, cur, formulaStringArray) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose()) {
          this._pushNodeToChildren(this._segment);
          const subLexerNode = new LexerNode();
          subLexerNode.setToken(currentString);
          const lastChildNode = this._getLastChildCurrent();
          if (lastChildNode instanceof LexerNode) {
            lastChildNode.changeToParent(subLexerNode);
          } else if (lastChildNode !== false) {
            subLexerNode.getChildren().push(lastChildNode);
            this._removeLastChild();
          }
          this._pushNodeToChildren(subLexerNode);
          subLexerNode.setParent(this._currentLexerNode);
          this._resetSegment();
        } else if (OPERATOR_TOKEN_SET.has(currentString) && this.isSingleQuotationClose() && this.isDoubleQuotationClose() && this.isSquareBracketClose()) {
          let trimSegment = this._segment.trim();
          if (currentString === "-" /* MINUS */ && trimSegment === "") {
            const prevString = this._findPreviousToken(formulaStringArray, cur - 1) || "";
            if (this._negativeCondition(prevString)) {
              this._pushSegment("-" /* MINUS */);
              if (!(isZeroAdded && cur === 0)) {
                sequenceArray == null ? void 0 : sequenceArray.push({
                  segment: this._segment,
                  currentString,
                  cur,
                  currentLexerNode: this._currentLexerNode
                });
              }
              cur++;
              continue;
            }
          } else if (this._segment.length > 0 && formulaStringArray[cur - 1] && formulaStringArray[cur - 1].toUpperCase() === "E" && (currentString === "-" /* MINUS */ || currentString === "+" /* PLUS */)) {
            this._pushSegment(currentString);
            if (!(isZeroAdded && cur === 0)) {
              sequenceArray == null ? void 0 : sequenceArray.push({
                segment: this._segment,
                currentString,
                cur,
                currentLexerNode: this._currentLexerNode
              });
            }
            cur++;
            continue;
          } else if (this._segment.length > 0 && trimSegment === "") {
            trimSegment = this._segment;
          } else {
            this._pushNodeToChildren(this._segment);
            trimSegment = "";
          }
          if (currentString === "<" /* LESS_THAN */ || currentString === ">" /* GREATER_THAN */) {
            const nextCurrentString = formulaStringArray[cur + 1];
            if (nextCurrentString && OPERATOR_TOKEN_SET.has(currentString + nextCurrentString)) {
              this._pushNodeToChildren(trimSegment + currentString + nextCurrentString);
              cur++;
            } else {
              this._pushNodeToChildren(trimSegment + currentString);
            }
          } else {
            this._pushNodeToChildren(trimSegment + currentString);
          }
          this._resetSegment();
        } else {
          this._pushSegment(currentString);
        }
        if (!(isZeroAdded && cur === 0)) {
          sequenceArray == null ? void 0 : sequenceArray.push({
            segment: this._segment,
            currentString,
            cur,
            currentLexerNode: this._currentLexerNode
          });
        }
        cur++;
      }
      this._pushNodeToChildren(this._segment);
    }
  };

  // ../packages/engine-formula/src/models/formula-data.model.ts
  var FormulaDataModel = class extends Disposable {
    constructor(_currentUniverService, _lexerTreeBuilder) {
      super();
      this._currentUniverService = _currentUniverService;
      this._lexerTreeBuilder = _lexerTreeBuilder;
      __publicField(this, "_formulaData", {});
      __publicField(this, "_arrayFormulaRange", {});
      __publicField(this, "_arrayFormulaCellData", {});
      // TODO@Dushusir: Determine the node.js environment and synchronize to the resource plugin when SSC is used
      __publicField(this, "_numfmtItemMap", {});
    }
    clearPreviousArrayFormulaCellData(clearArrayFormulaCellData) {
      Object.keys(clearArrayFormulaCellData).forEach((unitId) => {
        const clearSheetData = clearArrayFormulaCellData[unitId];
        if (clearSheetData == null) {
          return true;
        }
        Object.keys(clearSheetData).forEach((sheetId) => {
          var _a2, _b2, _c, _d;
          const clearCellMatrixData = clearSheetData[sheetId];
          const rangeMatrix = (_b2 = (_a2 = this._arrayFormulaRange) == null ? void 0 : _a2[unitId]) == null ? void 0 : _b2[sheetId];
          if (rangeMatrix == null) {
            return true;
          }
          let arrayFormulaCellMatrixData = new ObjectMatrix();
          if (((_c = this._arrayFormulaCellData[unitId]) == null ? void 0 : _c[sheetId]) != null) {
            arrayFormulaCellMatrixData = new ObjectMatrix(
              (_d = this._arrayFormulaCellData[unitId]) == null ? void 0 : _d[sheetId]
            );
          }
          clearCellMatrixData.forValue((row, column) => {
            var _a3;
            const range = (_a3 = rangeMatrix == null ? void 0 : rangeMatrix[row]) == null ? void 0 : _a3[column];
            if (range == null) {
              return true;
            }
            const { startRow, startColumn, endRow, endColumn } = range;
            for (let r = startRow; r <= endRow; r++) {
              for (let c = startColumn; c <= endColumn; c++) {
                arrayFormulaCellMatrixData.setValue(r, c, null);
              }
            }
          });
          if (this._arrayFormulaCellData[unitId]) {
            this._arrayFormulaCellData[unitId][sheetId] = arrayFormulaCellMatrixData.getData();
          }
        });
      });
    }
    mergeArrayFormulaCellData(unitData) {
      Object.keys(unitData).forEach((unitId) => {
        const sheetData = unitData[unitId];
        if (sheetData == null) {
          return true;
        }
        if (this._arrayFormulaRange[unitId] == null) {
          this._arrayFormulaRange[unitId] = {};
        }
        if (this._arrayFormulaCellData[unitId] == null) {
          this._arrayFormulaCellData[unitId] = {};
        }
        Object.keys(sheetData).forEach((sheetId) => {
          var _a2, _b2, _c, _d;
          const cellMatrixData = sheetData[sheetId];
          let arrayFormulaRangeMatrix = new ObjectMatrix();
          let arrayFormulaCellMatrixData = new ObjectMatrix();
          if (((_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId]) != null) {
            arrayFormulaRangeMatrix = new ObjectMatrix((_b2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _b2[sheetId]);
          }
          if (((_c = this._arrayFormulaCellData[unitId]) == null ? void 0 : _c[sheetId]) != null) {
            arrayFormulaCellMatrixData = new ObjectMatrix(
              (_d = this._arrayFormulaCellData[unitId]) == null ? void 0 : _d[sheetId]
            );
          }
          cellMatrixData.forValue((row, column) => {
            const arrayFormulaRange = arrayFormulaRangeMatrix == null ? void 0 : arrayFormulaRangeMatrix.getValue(row, column);
            if (arrayFormulaRange == null) {
              return true;
            }
            const { startRow, startColumn, endRow, endColumn } = arrayFormulaRange;
            for (let r = startRow; r <= endRow; r++) {
              for (let c = startColumn; c <= endColumn; c++) {
                arrayFormulaCellMatrixData.setValue(r, c, null);
              }
            }
          });
          cellMatrixData.forValue((row, column, cellData) => {
            arrayFormulaCellMatrixData.setValue(row, column, cellData);
          });
          if (this._arrayFormulaCellData[unitId]) {
            this._arrayFormulaCellData[unitId][sheetId] = arrayFormulaCellMatrixData.getData();
          }
        });
      });
    }
    getFormulaData() {
      return this._formulaData;
    }
    setFormulaData(value) {
      this._formulaData = value;
    }
    getArrayFormulaRange() {
      return this._arrayFormulaRange;
    }
    setArrayFormulaRange(value) {
      this._arrayFormulaRange = value;
    }
    getArrayFormulaCellData() {
      return this._arrayFormulaCellData;
    }
    setArrayFormulaCellData(value) {
      this._arrayFormulaCellData = value;
    }
    getNumfmtItemMap() {
      return this._numfmtItemMap;
    }
    getNumfmtValue(unitId, sheetId, row, column) {
      var _a2, _b2, _c;
      return (_c = (_b2 = (_a2 = this._numfmtItemMap[unitId]) == null ? void 0 : _a2[sheetId]) == null ? void 0 : _b2[row]) == null ? void 0 : _c[column];
    }
    setNumfmtItemMap(value) {
      this._numfmtItemMap = value;
    }
    updateNumfmtItemMap(value) {
      Object.keys(value).forEach((unitId) => {
        const sheetData = value[unitId];
        if (sheetData == null) {
          return true;
        }
        if (this._numfmtItemMap[unitId] == null) {
          this._numfmtItemMap[unitId] = {};
        }
        Object.keys(sheetData).forEach((sheetId) => {
          const numfmtItemMap = sheetData[sheetId];
          const numfmtItemMatrix = new ObjectMatrix(numfmtItemMap);
          if (this._numfmtItemMap[unitId][sheetId] == null) {
            this._numfmtItemMap[unitId][sheetId] = {};
          }
          numfmtItemMatrix.forValue((r, c, numfmtItem) => {
            if (this._numfmtItemMap[unitId][sheetId][r] == null) {
              this._numfmtItemMap[unitId][sheetId][r] = {};
            }
            this._numfmtItemMap[unitId][sheetId][r][c] = numfmtItem;
          });
        });
      });
    }
    mergeArrayFormulaRange(formulaData) {
      Object.keys(formulaData).forEach((unitId) => {
        const sheetData = formulaData[unitId];
        if (sheetData == null) {
          return true;
        }
        if (!this._arrayFormulaRange[unitId]) {
          this._arrayFormulaRange[unitId] = {};
        }
        Object.keys(sheetData).forEach((sheetId) => {
          var _a2, _b2;
          const arrayFormula = new ObjectMatrix(sheetData[sheetId]);
          let rangeMatrix = new ObjectMatrix();
          if ((_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId]) {
            rangeMatrix = new ObjectMatrix((_b2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _b2[sheetId]);
          }
          arrayFormula.forValue((r, c, v) => {
            rangeMatrix.setValue(r, c, v);
          });
          if (this._arrayFormulaRange[unitId]) {
            this._arrayFormulaRange[unitId][sheetId] = rangeMatrix.getData();
          }
        });
      });
    }
    deleteArrayFormulaRange(unitId, sheetId, row, column) {
      var _a2;
      const cellMatrixData = (_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId];
      if (cellMatrixData == null) {
        return;
      }
      const rangeMatrixData = new ObjectMatrix(cellMatrixData);
      if (rangeMatrixData.getValue(row, column)) {
        rangeMatrixData.realDeleteValue(row, column);
        if (this._arrayFormulaRange[unitId]) {
          this._arrayFormulaRange[unitId][sheetId] = rangeMatrixData.getData();
        }
      }
    }
    initFormulaData() {
      const unitFile = this._currentUniverService.getAllUniverSheetsInstance();
      if (unitFile.length === 0) {
        return;
      }
      const workbook = this._currentUniverService.getCurrentUniverSheetInstance();
      const unitId = workbook.getUnitId();
      this._formulaData[unitId] = {};
      const worksheets = workbook.getSheets();
      worksheets.forEach((worksheet) => {
        const cellMatrix = worksheet.getCellMatrix();
        const sheetId = worksheet.getSheetId();
        initSheetFormulaData(this._formulaData, unitId, sheetId, cellMatrix);
      });
    }
    getCalculateData() {
      const unitAllSheet = this._currentUniverService.getAllUniverSheetsInstance();
      const allUnitData = {};
      const unitSheetNameMap = {};
      for (const workbook of unitAllSheet) {
        const unitId = workbook.getUnitId();
        const sheets = workbook.getSheets();
        const sheetData = {};
        const sheetNameMap = {};
        for (const sheet of sheets) {
          const sheetId = sheet.getSheetId();
          const sheetConfig = sheet.getConfig();
          sheetData[sheetId] = {
            cellData: new ObjectMatrix(sheetConfig.cellData),
            rowCount: sheetConfig.rowCount,
            columnCount: sheetConfig.columnCount,
            rowData: sheetConfig.rowData,
            columnData: sheetConfig.columnData
          };
          sheetNameMap[sheet.getName()] = sheet.getSheetId();
        }
        allUnitData[unitId] = sheetData;
        unitSheetNameMap[unitId] = sheetNameMap;
      }
      return {
        allUnitData,
        unitSheetNameMap
      };
    }
    updateFormulaData(unitId, sheetId, cellValue) {
      const cellMatrix = new ObjectMatrix(cellValue);
      const formulaIdMap = this.getFormulaIdMap(unitId, sheetId);
      const deleteFormulaIdMap = /* @__PURE__ */ new Map();
      const formulaData = this._formulaData;
      if (formulaData[unitId] == null) {
        formulaData[unitId] = {};
      }
      const workbookFormulaData = formulaData[unitId];
      if (workbookFormulaData[sheetId] == null) {
        workbookFormulaData[sheetId] = {};
      }
      const sheetFormulaDataMatrix = new ObjectMatrix(workbookFormulaData[sheetId]);
      cellMatrix.forValue((r, c, cell) => {
        const formulaString = (cell == null ? void 0 : cell.f) || "";
        const formulaId = (cell == null ? void 0 : cell.si) || "";
        const checkFormulaString = isFormulaString(formulaString);
        const checkFormulaId = isFormulaId(formulaId);
        if (checkFormulaString && checkFormulaId) {
          sheetFormulaDataMatrix.setValue(r, c, {
            f: formulaString,
            si: formulaId
          });
          formulaIdMap.set(formulaId, { f: formulaString, r, c });
        } else if (checkFormulaString && !checkFormulaId) {
          sheetFormulaDataMatrix.setValue(r, c, {
            f: formulaString
          });
        } else if (!checkFormulaString && checkFormulaId) {
          sheetFormulaDataMatrix.setValue(r, c, {
            f: "",
            si: formulaId
          });
        } else if (!checkFormulaString && !checkFormulaId && sheetFormulaDataMatrix.getValue(r, c)) {
          const currentFormulaInfo = sheetFormulaDataMatrix.getValue(r, c);
          const f = (currentFormulaInfo == null ? void 0 : currentFormulaInfo.f) || "";
          const si = (currentFormulaInfo == null ? void 0 : currentFormulaInfo.si) || "";
          if (isFormulaString(f) && isFormulaId(si)) {
            deleteFormulaIdMap.set(si, f);
          }
          sheetFormulaDataMatrix.realDeleteValue(r, c);
        }
      });
      sheetFormulaDataMatrix.forValue((r, c, cell) => {
        const formulaString = (cell == null ? void 0 : cell.f) || "";
        const formulaId = (cell == null ? void 0 : cell.si) || "";
        if (isFormulaId(formulaId)) {
          const formulaInfo = formulaIdMap.get(formulaId);
          const deleteFormula = deleteFormulaIdMap.get(formulaId);
          if (formulaInfo && !isFormulaString(formulaString)) {
            const f = formulaInfo.f;
            const x = c - formulaInfo.c;
            const y = r - formulaInfo.r;
            sheetFormulaDataMatrix.setValue(r, c, { f, si: formulaId, x, y });
          } else if (typeof deleteFormula === "string") {
            const x = cell.x || 0;
            const y = cell.y || 0;
            const offsetFormula = this._lexerTreeBuilder.moveFormulaRefOffset(deleteFormula, x, y);
            deleteFormulaIdMap.set(formulaId, {
              r,
              c,
              f: offsetFormula
            });
            sheetFormulaDataMatrix.setValue(r, c, { f: offsetFormula, si: formulaId });
          } else if (typeof deleteFormula === "object") {
            const x = c - deleteFormula.c;
            const y = r - deleteFormula.r;
            sheetFormulaDataMatrix.setValue(r, c, {
              f: deleteFormula.f,
              si: formulaId,
              x,
              y
            });
          }
        }
      });
    }
    updateArrayFormulaRange(unitId, sheetId, cellValue) {
      var _a2;
      const arrayFormulaRange = (_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId];
      if (!arrayFormulaRange)
        return;
      const arrayFormulaRangeMatrix = new ObjectMatrix(arrayFormulaRange);
      const cellMatrix = new ObjectMatrix(cellValue);
      cellMatrix.forValue((r, c, cell) => {
        const arrayFormulaRangeValue = arrayFormulaRangeMatrix == null ? void 0 : arrayFormulaRangeMatrix.getValue(r, c);
        if (arrayFormulaRangeValue == null) {
          return true;
        }
        const formulaString = (cell == null ? void 0 : cell.f) || "";
        const formulaId = (cell == null ? void 0 : cell.si) || "";
        const checkFormulaString = isFormulaString(formulaString);
        const checkFormulaId = isFormulaId(formulaId);
        if (!checkFormulaString && !checkFormulaId) {
          arrayFormulaRangeMatrix.realDeleteValue(r, c);
        }
      });
    }
    updateArrayFormulaCellData(unitId, sheetId, cellValue) {
      var _a2, _b2;
      const arrayFormulaRange = (_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId];
      if (!arrayFormulaRange)
        return;
      const arrayFormulaRangeMatrix = new ObjectMatrix(arrayFormulaRange);
      const arrayFormulaCellData = (_b2 = this._arrayFormulaCellData[unitId]) == null ? void 0 : _b2[sheetId];
      if (!arrayFormulaCellData)
        return;
      const arrayFormulaCellDataMatrix = new ObjectMatrix(arrayFormulaCellData);
      const cellMatrix = new ObjectMatrix(cellValue);
      cellMatrix.forValue((r, c, cell) => {
        const arrayFormulaRangeValue = arrayFormulaRangeMatrix == null ? void 0 : arrayFormulaRangeMatrix.getValue(r, c);
        if (arrayFormulaRangeValue == null) {
          return true;
        }
        const formulaString = (cell == null ? void 0 : cell.f) || "";
        const formulaId = (cell == null ? void 0 : cell.si) || "";
        const checkFormulaString = isFormulaString(formulaString);
        const checkFormulaId = isFormulaId(formulaId);
        if (!checkFormulaString && !checkFormulaId) {
          const { startRow, startColumn, endRow, endColumn } = arrayFormulaRangeValue;
          for (let r2 = startRow; r2 <= endRow; r2++) {
            for (let c2 = startColumn; c2 <= endColumn; c2++) {
              arrayFormulaCellDataMatrix.realDeleteValue(r2, c2);
            }
          }
        }
      });
    }
    updateNumfmtData(unitId, sheetId, cellValue) {
      var _a2, _b2;
      const arrayFormulaRange = (_a2 = this._arrayFormulaRange[unitId]) == null ? void 0 : _a2[sheetId];
      const arrayFormulaRangeMatrix = new ObjectMatrix(arrayFormulaRange);
      const numfmtData = (_b2 = this._numfmtItemMap[unitId]) == null ? void 0 : _b2[sheetId];
      if (!numfmtData)
        return;
      const numfmtDataMatrix = new ObjectMatrix(numfmtData);
      const cellMatrix = new ObjectMatrix(cellValue);
      cellMatrix.forValue((r, c, cell) => {
        const formulaString = (cell == null ? void 0 : cell.f) || "";
        const formulaId = (cell == null ? void 0 : cell.si) || "";
        const checkFormulaString = isFormulaString(formulaString);
        const checkFormulaId = isFormulaId(formulaId);
        if (!checkFormulaString && !checkFormulaId) {
          numfmtDataMatrix.setValue(r, c, null);
          const arrayFormulaRangeValue = arrayFormulaRangeMatrix.getValue(r, c);
          if (arrayFormulaRangeValue) {
            const { startRow, startColumn, endRow, endColumn } = arrayFormulaRangeValue;
            for (let row = startRow; row <= endRow; row++) {
              for (let column = startColumn; column <= endColumn; column++) {
                numfmtDataMatrix.setValue(row, column, null);
              }
            }
          }
        }
      });
    }
    getFormulaItemBySId(sId, sheetId, unitId) {
      const formulaData = this._formulaData;
      if (formulaData[unitId] == null) {
        return null;
      }
      const workbookFormulaData = formulaData[unitId];
      if ((workbookFormulaData == null ? void 0 : workbookFormulaData[sheetId]) == null) {
        return null;
      }
      const cellMatrix = new ObjectMatrix(workbookFormulaData[sheetId]);
      let formulaDataItem = null;
      cellMatrix.forValue((row, column, item) => {
        const { f, si, x = 0, y = 0 } = item;
        if (si === sId && f.length > 0 && x === 0 && y === 0) {
          formulaDataItem = item;
          return false;
        }
      });
      return formulaDataItem;
    }
    getFormulaDataItem(row, column, sheetId, unitId) {
      var _a2, _b2, _c, _d;
      return (_d = (_c = (_b2 = (_a2 = this._formulaData) == null ? void 0 : _a2[unitId]) == null ? void 0 : _b2[sheetId]) == null ? void 0 : _c[row]) == null ? void 0 : _d[column];
    }
    getFormulaIdMap(unitId, sheetId) {
      const formulaIdMap = /* @__PURE__ */ new Map();
      const formulaData = this._formulaData;
      if (formulaData[unitId] == null) {
        return formulaIdMap;
      }
      const workbookFormulaData = formulaData[unitId];
      if ((workbookFormulaData == null ? void 0 : workbookFormulaData[sheetId]) == null) {
        return formulaIdMap;
      }
      const sheetFormulaDataMatrix = new ObjectMatrix(workbookFormulaData[sheetId]);
      sheetFormulaDataMatrix.forValue((r, c, cell) => {
        const formulaString = (cell == null ? void 0 : cell.f) || "";
        const formulaId = (cell == null ? void 0 : cell.si) || "";
        const x = (cell == null ? void 0 : cell.x) || 0;
        const y = (cell == null ? void 0 : cell.y) || 0;
        if (isFormulaString(formulaString) && isFormulaId(formulaId) && x === 0 && y === 0) {
          formulaIdMap.set(formulaId, { f: formulaString, r, c });
        }
      });
      return formulaIdMap;
    }
  };
  FormulaDataModel = __decorateClass([
    __decorateParam(0, IUniverInstanceService),
    __decorateParam(1, Inject(LexerTreeBuilder))
  ], FormulaDataModel);
  function initSheetFormulaData(formulaData, unitId, sheetId, cellMatrix) {
    const formulaIdMap = /* @__PURE__ */ new Map();
    const sheetFormulaDataMatrix = new ObjectMatrix();
    cellMatrix.forValue((r, c, cell) => {
      const formulaString = (cell == null ? void 0 : cell.f) || "";
      const formulaId = (cell == null ? void 0 : cell.si) || "";
      const checkFormulaString = isFormulaString(formulaString);
      const checkFormulaId = isFormulaId(formulaId);
      if (checkFormulaString && checkFormulaId) {
        sheetFormulaDataMatrix.setValue(r, c, {
          f: formulaString,
          si: formulaId
        });
        formulaIdMap.set(formulaId, { f: formulaString, r, c });
      } else if (checkFormulaString && !checkFormulaId) {
        sheetFormulaDataMatrix.setValue(r, c, {
          f: formulaString
        });
      } else if (!checkFormulaString && checkFormulaId) {
        sheetFormulaDataMatrix.setValue(r, c, {
          f: "",
          si: formulaId
        });
      }
    });
    sheetFormulaDataMatrix.forValue((r, c, cell) => {
      const formulaString = (cell == null ? void 0 : cell.f) || "";
      const formulaId = (cell == null ? void 0 : cell.si) || "";
      if (isFormulaId(formulaId) && !isFormulaString(formulaString)) {
        const formulaInfo = formulaIdMap.get(formulaId);
        if (formulaInfo) {
          const f = formulaInfo.f;
          const x = c - formulaInfo.c;
          const y = r - formulaInfo.r;
          sheetFormulaDataMatrix.setValue(r, c, { f, si: formulaId, x, y });
        }
      }
    });
    if (formulaData[unitId]) {
      formulaData[unitId][sheetId] = sheetFormulaDataMatrix.getData();
    }
  }

  // ../packages/engine-formula/src/commands/mutations/set-array-formula-data.mutation.ts
  var SetArrayFormulaDataMutation = {
    id: "formula.mutation.set-array-formula-data",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const formulaDataModel = accessor.get(FormulaDataModel);
      formulaDataModel.setArrayFormulaRange(params.arrayFormulaRange);
      formulaDataModel.setArrayFormulaCellData(params.arrayFormulaCellData);
      return true;
    }
  };

  // ../packages/engine-formula/src/commands/mutations/set-defined-name.mutation.ts
  var SetDefinedNameMutation = {
    id: "formula.mutation.set-defined-name",
    type: 2 /* MUTATION */,
    handler: () => true
  };
  var RemoveDefinedNameMutation = {
    id: "formula.mutation.remove-defined-name",
    type: 2 /* MUTATION */,
    handler: () => true
  };

  // ../packages/engine-formula/src/commands/mutations/set-feature-calculation.mutation.ts
  var SetFeatureCalculationMutation = {
    id: "formula.mutation.set-feature-calculation",
    type: 2 /* MUTATION */,
    handler: () => true
  };
  var RemoveFeatureCalculationMutation = {
    id: "formula.mutation.remove-feature-calculation",
    type: 2 /* MUTATION */,
    handler: () => true
  };

  // ../packages/engine-formula/src/commands/mutations/set-formula-calculation.mutation.ts
  var SetFormulaCalculationStartMutation = {
    id: "formula.mutation.set-formula-calculation-start",
    type: 2 /* MUTATION */,
    handler: () => true
  };
  var SetFormulaCalculationStopMutation = {
    id: "formula.mutation.set-formula-calculation-stop",
    type: 2 /* MUTATION */,
    handler: () => true
  };
  var SetFormulaCalculationNotificationMutation = {
    id: "formula.mutation.set-formula-calculation-notification",
    type: 2 /* MUTATION */,
    handler: () => true
  };
  var SetFormulaCalculationResultMutation = {
    id: "formula.mutation.set-formula-calculation-result",
    type: 2 /* MUTATION */,
    handler: () => true
  };

  // ../packages/engine-formula/src/commands/mutations/set-formula-data.mutation.ts
  var SetFormulaDataMutation = {
    id: "formula.mutation.set-formula-data",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const formulaDataModel = accessor.get(FormulaDataModel);
      formulaDataModel.setFormulaData(params.formulaData);
      return true;
    }
  };

  // ../packages/engine-formula/src/commands/mutations/set-other-formula.mutation.ts
  var SetOtherFormulaMutation = {
    id: "formula.mutation.set-other-formula",
    type: 2 /* MUTATION */,
    handler: () => true
  };
  var RemoveOtherFormulaMutation = {
    id: "formula.mutation.remove-other-formula",
    type: 2 /* MUTATION */,
    handler: () => true
  };

  // ../packages/engine-formula/src/commands/mutations/set-super-table.mutation.ts
  var SetSuperTableMutation = {
    id: "formula.mutation.set-super-table",
    type: 2 /* MUTATION */,
    handler: () => true
  };
  var RemoveSuperTableMutation = {
    id: "formula.mutation.remove-super-table",
    type: 2 /* MUTATION */,
    handler: () => true
  };
  var SetSuperTableOptionMutation = {
    id: "formula.mutation.set-super-table-option",
    type: 2 /* MUTATION */,
    handler: () => true
  };

  // ../packages/engine-formula/src/commands/mutations/unregister-function.mutation.ts
  var UnregisterFunctionMutation = {
    id: "formula.mutation.unregister-function",
    type: 2 /* MUTATION */,
    handler: () => true
  };

  // ../packages/engine-formula/src/basics/object-class-type.ts
  var ObjectClassType = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "pattern", "");
    }
    getPattern() {
      return this.pattern;
    }
    /**
     * Only used in NumberValueObject
     * @param pattern
     */
    setPattern(pattern) {
      this.pattern = pattern;
    }
    isError() {
      return false;
    }
    isAsyncObject() {
      return false;
    }
    isAsyncArrayObject() {
      return false;
    }
    isReferenceObject() {
      return false;
    }
    isArray() {
      return false;
    }
    isValueObject() {
      return false;
    }
    isEqualType(object) {
      return false;
    }
  };

  // ../packages/engine-formula/src/basics/inverted-index-cache.ts
  var InvertedIndexCache = class {
    constructor() {
      /**
       * {
       *    unitId:{
       *       sheetId:{
       *          'columnIndex': {
       *              10:[1,3,4,5],
       *              5:[2,6,11,22]
       *          }
       *       }
       *    }
       * }
       */
      __publicField(this, "_cache", /* @__PURE__ */ new Map());
      __publicField(this, "_continueBuildingCache", /* @__PURE__ */ new Map());
    }
    set(unitId, sheetId, column, value, row) {
      if (!this.shouldContinueBuildingCache(unitId, sheetId, column, row)) {
        return;
      }
      let unitMap = this._cache.get(unitId);
      if (unitMap == null) {
        unitMap = /* @__PURE__ */ new Map();
        this._cache.set(unitId, unitMap);
      }
      let sheetMap = unitMap.get(sheetId);
      if (sheetMap == null) {
        sheetMap = /* @__PURE__ */ new Map();
        unitMap.set(sheetId, sheetMap);
      }
      let columnMap = sheetMap.get(column);
      if (columnMap == null) {
        columnMap = /* @__PURE__ */ new Map();
        sheetMap.set(column, columnMap);
      }
      let cellList = columnMap.get(value);
      if (cellList == null) {
        cellList = /* @__PURE__ */ new Set();
        columnMap.set(value, cellList);
      }
      cellList.add(row);
    }
    getCellValuePositions(unitId, sheetId, column) {
      var _a2, _b2;
      return (_b2 = (_a2 = this._cache.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(column);
    }
    getCellPositions(unitId, sheetId, column, value) {
      var _a2, _b2, _c;
      return (_c = (_b2 = (_a2 = this._cache.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(column)) == null ? void 0 : _c.get(value);
    }
    getCellPosition(unitId, sheetId, column, value, startRow, endRow) {
      const rows = this.getCellPositions(unitId, sheetId, column, value);
      if (rows == null) {
        return;
      }
      for (const row of rows) {
        if (row >= startRow && row <= endRow) {
          return row;
        }
      }
    }
    setContinueBuildingCache(unitId, sheetId, column, startRow, endRow) {
      let unitMap = this._continueBuildingCache.get(unitId);
      if (unitMap == null) {
        unitMap = /* @__PURE__ */ new Map();
        this._continueBuildingCache.set(unitId, unitMap);
      }
      let sheetMap = unitMap.get(sheetId);
      if (sheetMap == null) {
        sheetMap = /* @__PURE__ */ new Map();
        unitMap.set(sheetId, sheetMap);
      }
      let columnMap = sheetMap.get(column);
      if (columnMap == null) {
        columnMap = { startRow, endRow };
        sheetMap.set(column, columnMap);
        return;
      }
      columnMap.startRow = Math.min(columnMap.startRow, startRow);
      columnMap.endRow = Math.max(columnMap.endRow, endRow);
    }
    shouldContinueBuildingCache(unitId, sheetId, column, row) {
      var _a2, _b2;
      const rowRange = (_b2 = (_a2 = this._continueBuildingCache.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(column);
      if (rowRange == null) {
        return true;
      }
      const { startRow, endRow } = rowRange;
      if (row >= startRow && row <= endRow) {
        return false;
      }
      return true;
    }
    canUseCache(unitId, sheetId, column, rangeStartRow, rangeEndRow) {
      var _a2, _b2;
      if (column === -1 || rangeStartRow === -1 || rangeEndRow === -1) {
        return false;
      }
      const rowRange = (_b2 = (_a2 = this._continueBuildingCache.get(unitId)) == null ? void 0 : _a2.get(sheetId)) == null ? void 0 : _b2.get(column);
      if (rowRange == null) {
        return false;
      }
      const { startRow, endRow } = rowRange;
      if (!(rangeStartRow > endRow || rangeEndRow < startRow)) {
        return true;
      }
      return false;
    }
    clear() {
      this._cache.clear();
      this._continueBuildingCache.clear();
    }
  };
  var CELL_INVERTED_INDEX_CACHE = new InvertedIndexCache();

  // ../packages/engine-formula/src/engine/utils/compare.ts
  function getCompare() {
    if (Intl && Intl.Collator) {
      return new Intl.Collator(void 0, { numeric: false }).compare;
    }
    return (a, b) => {
      return a.localeCompare(b);
    };
  }
  function isWildcard(str) {
    return str.indexOf("*") > -1 || str.indexOf("?") > -1;
  }
  function isMatchWildcard(currentValue, value) {
    const pattern = escapeRegExp(value).replace(/~?[*?]/g, (match) => {
      if (match.startsWith("~")) {
        return `\\${match.substring(1)}`;
      }
      if (match === "*") {
        return ".*";
      }
      if (match === "?") {
        return ".";
      }
      return match;
    });
    const regex = new RegExp(`^${pattern}$`);
    return regex.test(currentValue);
  }
  function replaceWildcard(value) {
    return value.replace(/~?[*?]/g, (match) => {
      if (match.startsWith("~")) {
        return match.substring(1);
      }
      return " ";
    });
  }
  function compareWithWildcard(currentValue, value, operator) {
    let result = false;
    switch (operator) {
      case "=" /* EQUALS */:
        result = isMatchWildcard(currentValue, value);
        break;
      case ">" /* GREATER_THAN */:
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        result = isMatchWildcard(currentValue, value) || currentValue > replaceWildcard(value);
        break;
      case "<" /* LESS_THAN */:
      case "<=" /* LESS_THAN_OR_EQUAL */:
        result = currentValue < replaceWildcard(value);
        break;
      default:
        break;
    }
    return result;
  }
  function escapeRegExp(str) {
    return str.replace(/[.+^${}()|[\]\\]/g, "\\$&");
  }

  // ../packages/engine-formula/src/engine/value-object/base-value-object.ts
  var BaseValueObject = class extends ObjectClassType {
    constructor(_rawValue) {
      super();
      this._rawValue = _rawValue;
    }
    isValueObject() {
      return true;
    }
    toUnitRange() {
      return {
        range: {
          startColumn: -1,
          startRow: -1,
          endRow: -1,
          endColumn: -1
        },
        sheetId: "",
        unitId: ""
      };
    }
    getValue() {
      return 0;
    }
    getArrayValue() {
      return [];
    }
    setValue(value) {
    }
    setArrayValue(value) {
    }
    isCube() {
      return false;
    }
    isString() {
      return false;
    }
    isNumber() {
      return false;
    }
    isBoolean() {
      return false;
    }
    isLambda() {
      return false;
    }
    isError() {
      return false;
    }
    isNull() {
      return false;
    }
    sum() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    max() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    min() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    count() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    countA() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    countBlank() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    getNegative() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    getReciprocal() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    plus(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    minus(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    multiply(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    divided(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    mod(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    /**
     * return every value in the array after the callback function, excluding the error value
     * @param callbackFn
     * @returns
     */
    map(callbackFn) {
      return ErrorValueObject.create("#NAME?" /* NAME */);
    }
    /**
     * return every value in the array after the callback function
     * @param callbackFn
     * @returns
     */
    mapValue(callbackFn) {
      return ErrorValueObject.create("#NAME?" /* NAME */);
    }
    compare(valueObject, operator) {
      return ErrorValueObject.create("#NAME?" /* NAME */);
    }
    isEqual(valueObject) {
      return this.compare(valueObject, "=" /* EQUALS */);
    }
    isNotEqual(valueObject) {
      return this.compare(valueObject, "<>" /* NOT_EQUAL */);
    }
    isGreaterThanOrEqual(valueObject) {
      return this.compare(valueObject, ">=" /* GREATER_THAN_OR_EQUAL */);
    }
    isLessThanOrEqual(valueObject) {
      return this.compare(valueObject, "<=" /* LESS_THAN_OR_EQUAL */);
    }
    isLessThan(valueObject) {
      return this.compare(valueObject, "<" /* LESS_THAN */);
    }
    isGreaterThan(valueObject) {
      return this.compare(valueObject, ">" /* GREATER_THAN */);
    }
    concatenateFront(valueObject) {
      return ErrorValueObject.create("#NAME?" /* NAME */);
    }
    concatenateBack(valueObject) {
      return ErrorValueObject.create("#NAME?" /* NAME */);
    }
    plusBy(value) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    minusBy(value) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    multiplyBy(value) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    dividedBy(value) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    modInverse(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    compareBy(value, operator) {
      return ErrorValueObject.create("#NAME?" /* NAME */);
    }
    concatenate(value, concatenateType = 0 /* FRONT */) {
      let currentValue = this.getValue().toString();
      if (typeof value === "string") {
        if (concatenateType === 0 /* FRONT */) {
          currentValue = value + currentValue;
        } else {
          currentValue += value;
        }
      } else if (typeof value === "number") {
        if (concatenateType === 0 /* FRONT */) {
          currentValue = value.toString() + currentValue;
        } else {
          currentValue += value.toString();
        }
      } else if (typeof value === "boolean") {
        const booleanString = value ? "TRUE" : "FALSE";
        if (concatenateType === 0 /* FRONT */) {
          currentValue = booleanString + currentValue;
        } else {
          currentValue += booleanString;
        }
      }
      return currentValue;
    }
    pow(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    powInverse(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    sqrt() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    cbrt() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    cos() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    acos() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    acosh() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    sin() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    asin() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    asinh() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    tan() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    tanh() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    atan() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    atan2(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    atan2Inverse(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    atanh() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    /**
     * Calculate the mean of the entire array.
     *
     * reference https://numpy.org/doc/stable/reference/generated/numpy.mean.html#numpy.mean
     *
     */
    mean() {
      return this;
    }
    /**
     * Calculate the median of the entire array.
     *
     * reference https://numpy.org/doc/stable/reference/generated/numpy.median.html
     *
     */
    median() {
      return this;
    }
    /**
     * Calculate the variance of the entire array.
     *
     * reference https://numpy.org/doc/stable/reference/generated/numpy.var.html
     */
    var() {
      return this;
    }
    /**
     * Calculate the standard deviation of the entire array.
     *
     * reference https://numpy.org/doc/stable/reference/generated/numpy.std.html
     */
    std() {
      return this;
    }
    log() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    log10() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    exp() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    abs() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    round(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    roundInverse(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    floor(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    floorInverse(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    ceil(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    ceilInverse(valueObject) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    convertToNumberObjectValue() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    convertToBooleanObjectValue() {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };
  var Error_CACHE_LRU_COUNT = 1e3;
  var ErrorValueObjectCache = new FormulaAstLRU(Error_CACHE_LRU_COUNT);
  var ErrorValueObject = class _ErrorValueObject extends BaseValueObject {
    constructor(_errorType, _errorContent = "") {
      super(_errorType);
      this._errorType = _errorType;
      this._errorContent = _errorContent;
    }
    static create(errorType, errorContent = "") {
      const key = `${errorType}-${errorContent}`;
      const cached = ErrorValueObjectCache.get(key);
      if (cached) {
        return cached;
      }
      const instance = new _ErrorValueObject(errorType, errorContent);
      ErrorValueObjectCache.set(key, instance);
      return instance;
    }
    getValue() {
      return this._errorType;
    }
    getErrorType() {
      return this._errorType;
    }
    getErrorContent() {
      return this._errorContent;
    }
    isEqualType(object) {
      if (object.getErrorType() === this.getErrorType()) {
        return true;
      }
      return false;
    }
    isError() {
      return true;
    }
  };

  // ../node_modules/.pnpm/big.js@6.2.1/node_modules/big.js/big.mjs
  var DP = 20;
  var RM = 1;
  var MAX_DP = 1e6;
  var MAX_POWER = 1e6;
  var NE = -7;
  var PE = 21;
  var STRICT = false;
  var NAME = "[big.js] ";
  var INVALID = NAME + "Invalid ";
  var INVALID_DP = INVALID + "decimal places";
  var INVALID_RM = INVALID + "rounding mode";
  var DIV_BY_ZERO = NAME + "Division by zero";
  var P = {};
  var UNDEFINED = void 0;
  var NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  function _Big_() {
    function Big2(n) {
      var x = this;
      if (!(x instanceof Big2))
        return n === UNDEFINED ? _Big_() : new Big2(n);
      if (n instanceof Big2) {
        x.s = n.s;
        x.e = n.e;
        x.c = n.c.slice();
      } else {
        if (typeof n !== "string") {
          if (Big2.strict === true && typeof n !== "bigint") {
            throw TypeError(INVALID + "value");
          }
          n = n === 0 && 1 / n < 0 ? "-0" : String(n);
        }
        parse(x, n);
      }
      x.constructor = Big2;
    }
    Big2.prototype = P;
    Big2.DP = DP;
    Big2.RM = RM;
    Big2.NE = NE;
    Big2.PE = PE;
    Big2.strict = STRICT;
    Big2.roundDown = 0;
    Big2.roundHalfUp = 1;
    Big2.roundHalfEven = 2;
    Big2.roundUp = 3;
    return Big2;
  }
  function parse(x, n) {
    var e, i, nl;
    if (!NUMERIC.test(n)) {
      throw Error(INVALID + "number");
    }
    x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
    if ((e = n.indexOf(".")) > -1)
      n = n.replace(".", "");
    if ((i = n.search(/e/i)) > 0) {
      if (e < 0)
        e = i;
      e += +n.slice(i + 1);
      n = n.substring(0, i);
    } else if (e < 0) {
      e = n.length;
    }
    nl = n.length;
    for (i = 0; i < nl && n.charAt(i) == "0"; )
      ++i;
    if (i == nl) {
      x.c = [x.e = 0];
    } else {
      for (; nl > 0 && n.charAt(--nl) == "0"; )
        ;
      x.e = e - i - 1;
      x.c = [];
      for (e = 0; i <= nl; )
        x.c[e++] = +n.charAt(i++);
    }
    return x;
  }
  function round(x, sd, rm, more) {
    var xc = x.c;
    if (rm === UNDEFINED)
      rm = x.constructor.RM;
    if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
      throw Error(INVALID_RM);
    }
    if (sd < 1) {
      more = rm === 3 && (more || !!xc[0]) || sd === 0 && (rm === 1 && xc[0] >= 5 || rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED)));
      xc.length = 1;
      if (more) {
        x.e = x.e - sd + 1;
        xc[0] = 1;
      } else {
        xc[0] = x.e = 0;
      }
    } else if (sd < xc.length) {
      more = rm === 1 && xc[sd] >= 5 || rm === 2 && (xc[sd] > 5 || xc[sd] === 5 && (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) || rm === 3 && (more || !!xc[0]);
      xc.length = sd;
      if (more) {
        for (; ++xc[--sd] > 9; ) {
          xc[sd] = 0;
          if (sd === 0) {
            ++x.e;
            xc.unshift(1);
            break;
          }
        }
      }
      for (sd = xc.length; !xc[--sd]; )
        xc.pop();
    }
    return x;
  }
  function stringify(x, doExponential, isNonzero) {
    var e = x.e, s = x.c.join(""), n = s.length;
    if (doExponential) {
      s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
    } else if (e < 0) {
      for (; ++e; )
        s = "0" + s;
      s = "0." + s;
    } else if (e > 0) {
      if (++e > n) {
        for (e -= n; e--; )
          s += "0";
      } else if (e < n) {
        s = s.slice(0, e) + "." + s.slice(e);
      }
    } else if (n > 1) {
      s = s.charAt(0) + "." + s.slice(1);
    }
    return x.s < 0 && isNonzero ? "-" + s : s;
  }
  P.abs = function() {
    var x = new this.constructor(this);
    x.s = 1;
    return x;
  };
  P.cmp = function(y) {
    var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
    if (!xc[0] || !yc[0])
      return !xc[0] ? !yc[0] ? 0 : -j : i;
    if (i != j)
      return i;
    isneg = i < 0;
    if (k != l)
      return k > l ^ isneg ? 1 : -1;
    j = (k = xc.length) < (l = yc.length) ? k : l;
    for (i = -1; ++i < j; ) {
      if (xc[i] != yc[i])
        return xc[i] > yc[i] ^ isneg ? 1 : -1;
    }
    return k == l ? 0 : k > l ^ isneg ? 1 : -1;
  };
  P.div = function(y) {
    var x = this, Big2 = x.constructor, a = x.c, b = (y = new Big2(y)).c, k = x.s == y.s ? 1 : -1, dp = Big2.DP;
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    if (!b[0]) {
      throw Error(DIV_BY_ZERO);
    }
    if (!a[0]) {
      y.s = k;
      y.c = [y.e = 0];
      return y;
    }
    var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, p = dp + (q.e = x.e - y.e) + 1;
    q.s = k;
    k = p < 0 ? 0 : p;
    bz.unshift(0);
    for (; rl++ < bl; )
      r.push(0);
    do {
      for (n = 0; n < 10; n++) {
        if (bl != (rl = r.length)) {
          cmp = bl > rl ? 1 : -1;
        } else {
          for (ri = -1, cmp = 0; ++ri < bl; ) {
            if (b[ri] != r[ri]) {
              cmp = b[ri] > r[ri] ? 1 : -1;
              break;
            }
          }
        }
        if (cmp < 0) {
          for (bt = rl == bl ? b : bz; rl; ) {
            if (r[--rl] < bt[rl]) {
              ri = rl;
              for (; ri && !r[--ri]; )
                r[ri] = 9;
              --r[ri];
              r[rl] += 10;
            }
            r[rl] -= bt[rl];
          }
          for (; !r[0]; )
            r.shift();
        } else {
          break;
        }
      }
      qc[qi++] = cmp ? n : ++n;
      if (r[0] && cmp)
        r[rl] = a[ai] || 0;
      else
        r = [a[ai]];
    } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
    if (!qc[0] && qi != 1) {
      qc.shift();
      q.e--;
      p--;
    }
    if (qi > p)
      round(q, p, Big2.RM, r[0] !== UNDEFINED);
    return q;
  };
  P.eq = function(y) {
    return this.cmp(y) === 0;
  };
  P.gt = function(y) {
    return this.cmp(y) > 0;
  };
  P.gte = function(y) {
    return this.cmp(y) > -1;
  };
  P.lt = function(y) {
    return this.cmp(y) < 0;
  };
  P.lte = function(y) {
    return this.cmp(y) < 1;
  };
  P.minus = P.sub = function(y) {
    var i, j, t, xlty, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
    if (a != b) {
      y.s = -b;
      return x.plus(y);
    }
    var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
    if (!xc[0] || !yc[0]) {
      if (yc[0]) {
        y.s = -b;
      } else if (xc[0]) {
        y = new Big2(x);
      } else {
        y.s = 1;
      }
      return y;
    }
    if (a = xe - ye) {
      if (xlty = a < 0) {
        a = -a;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b = a; b--; )
        t.push(0);
      t.reverse();
    } else {
      j = ((xlty = xc.length < yc.length) ? xc : yc).length;
      for (a = b = 0; b < j; b++) {
        if (xc[b] != yc[b]) {
          xlty = xc[b] < yc[b];
          break;
        }
      }
    }
    if (xlty) {
      t = xc;
      xc = yc;
      yc = t;
      y.s = -y.s;
    }
    if ((b = (j = yc.length) - (i = xc.length)) > 0)
      for (; b--; )
        xc[i++] = 0;
    for (b = i; j > a; ) {
      if (xc[--j] < yc[j]) {
        for (i = j; i && !xc[--i]; )
          xc[i] = 9;
        --xc[i];
        xc[j] += 10;
      }
      xc[j] -= yc[j];
    }
    for (; xc[--b] === 0; )
      xc.pop();
    for (; xc[0] === 0; ) {
      xc.shift();
      --ye;
    }
    if (!xc[0]) {
      y.s = 1;
      xc = [ye = 0];
    }
    y.c = xc;
    y.e = ye;
    return y;
  };
  P.mod = function(y) {
    var ygtx, x = this, Big2 = x.constructor, a = x.s, b = (y = new Big2(y)).s;
    if (!y.c[0]) {
      throw Error(DIV_BY_ZERO);
    }
    x.s = y.s = 1;
    ygtx = y.cmp(x) == 1;
    x.s = a;
    y.s = b;
    if (ygtx)
      return new Big2(x);
    a = Big2.DP;
    b = Big2.RM;
    Big2.DP = Big2.RM = 0;
    x = x.div(y);
    Big2.DP = a;
    Big2.RM = b;
    return this.minus(x.times(y));
  };
  P.neg = function() {
    var x = new this.constructor(this);
    x.s = -x.s;
    return x;
  };
  P.plus = P.add = function(y) {
    var e, k, t, x = this, Big2 = x.constructor;
    y = new Big2(y);
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }
    var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
    if (!xc[0] || !yc[0]) {
      if (!yc[0]) {
        if (xc[0]) {
          y = new Big2(x);
        } else {
          y.s = x.s;
        }
      }
      return y;
    }
    xc = xc.slice();
    if (e = xe - ye) {
      if (e > 0) {
        ye = xe;
        t = yc;
      } else {
        e = -e;
        t = xc;
      }
      t.reverse();
      for (; e--; )
        t.push(0);
      t.reverse();
    }
    if (xc.length - yc.length < 0) {
      t = yc;
      yc = xc;
      xc = t;
    }
    e = yc.length;
    for (k = 0; e; xc[e] %= 10)
      k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;
    if (k) {
      xc.unshift(k);
      ++ye;
    }
    for (e = xc.length; xc[--e] === 0; )
      xc.pop();
    y.c = xc;
    y.e = ye;
    return y;
  };
  P.pow = function(n) {
    var x = this, one = new x.constructor("1"), y = one, isneg = n < 0;
    if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
      throw Error(INVALID + "exponent");
    }
    if (isneg)
      n = -n;
    for (; ; ) {
      if (n & 1)
        y = y.times(x);
      n >>= 1;
      if (!n)
        break;
      x = x.times(x);
    }
    return isneg ? one.div(y) : y;
  };
  P.prec = function(sd, rm) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + "precision");
    }
    return round(new this.constructor(this), sd, rm);
  };
  P.round = function(dp, rm) {
    if (dp === UNDEFINED)
      dp = 0;
    else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    return round(new this.constructor(this), dp + this.e + 1, rm);
  };
  P.sqrt = function() {
    var r, c, t, x = this, Big2 = x.constructor, s = x.s, e = x.e, half = new Big2("0.5");
    if (!x.c[0])
      return new Big2(x);
    if (s < 0) {
      throw Error(NAME + "No square root");
    }
    s = Math.sqrt(x + "");
    if (s === 0 || s === 1 / 0) {
      c = x.c.join("");
      if (!(c.length + e & 1))
        c += "0";
      s = Math.sqrt(c);
      e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
      r = new Big2((s == 1 / 0 ? "5e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
    } else {
      r = new Big2(s + "");
    }
    e = r.e + (Big2.DP += 4);
    do {
      t = r;
      r = half.times(t.plus(x.div(t)));
    } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
    return round(r, (Big2.DP -= 4) + r.e + 1, Big2.RM);
  };
  P.times = P.mul = function(y) {
    var c, x = this, Big2 = x.constructor, xc = x.c, yc = (y = new Big2(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
    y.s = x.s == y.s ? 1 : -1;
    if (!xc[0] || !yc[0]) {
      y.c = [y.e = 0];
      return y;
    }
    y.e = i + j;
    if (a < b) {
      c = xc;
      xc = yc;
      yc = c;
      j = a;
      a = b;
      b = j;
    }
    for (c = new Array(j = a + b); j--; )
      c[j] = 0;
    for (i = b; i--; ) {
      b = 0;
      for (j = a + i; j > i; ) {
        b = c[j] + yc[i] * xc[j - i - 1] + b;
        c[j--] = b % 10;
        b = b / 10 | 0;
      }
      c[j] = b;
    }
    if (b)
      ++y.e;
    else
      c.shift();
    for (i = c.length; !c[--i]; )
      c.pop();
    y.c = c;
    return y;
  };
  P.toExponential = function(dp, rm) {
    var x = this, n = x.c[0];
    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x = round(new x.constructor(x), ++dp, rm);
      for (; x.c.length < dp; )
        x.c.push(0);
    }
    return stringify(x, true, !!n);
  };
  P.toFixed = function(dp, rm) {
    var x = this, n = x.c[0];
    if (dp !== UNDEFINED) {
      if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
        throw Error(INVALID_DP);
      }
      x = round(new x.constructor(x), dp + x.e + 1, rm);
      for (dp = dp + x.e + 1; x.c.length < dp; )
        x.c.push(0);
    }
    return stringify(x, false, !!n);
  };
  P[Symbol.for("nodejs.util.inspect.custom")] = P.toJSON = P.toString = function() {
    var x = this, Big2 = x.constructor;
    return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, !!x.c[0]);
  };
  P.toNumber = function() {
    var n = Number(stringify(this, true, true));
    if (this.constructor.strict === true && !this.eq(n.toString())) {
      throw Error(NAME + "Imprecise conversion");
    }
    return n;
  };
  P.toPrecision = function(sd, rm) {
    var x = this, Big2 = x.constructor, n = x.c[0];
    if (sd !== UNDEFINED) {
      if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
        throw Error(INVALID + "precision");
      }
      x = round(new Big2(x), sd, rm);
      for (; x.c.length < sd; )
        x.c.push(0);
    }
    return stringify(x, sd <= x.e || x.e <= Big2.NE || x.e >= Big2.PE, !!n);
  };
  P.valueOf = function() {
    var x = this, Big2 = x.constructor;
    if (Big2.strict === true) {
      throw Error(NAME + "valueOf disallowed");
    }
    return stringify(x, x.e <= Big2.NE || x.e >= Big2.PE, true);
  };
  var Big = _Big_();
  var big_default = Big;

  // ../packages/engine-formula/src/basics/calculate.ts
  function reverseCompareOperator(operator) {
    let result;
    switch (operator) {
      case "=" /* EQUALS */:
        result = "=" /* EQUALS */;
        break;
      case ">" /* GREATER_THAN */:
        result = "<" /* LESS_THAN */;
        break;
      case ">=" /* GREATER_THAN_OR_EQUAL */:
        result = "<=" /* LESS_THAN_OR_EQUAL */;
        break;
      case "<" /* LESS_THAN */:
        result = ">" /* GREATER_THAN */;
        break;
      case "<=" /* LESS_THAN_OR_EQUAL */:
        result = ">=" /* GREATER_THAN_OR_EQUAL */;
        break;
      case "<>" /* NOT_EQUAL */:
        result = "<>" /* NOT_EQUAL */;
        break;
    }
    return result;
  }

  // ../packages/engine-formula/src/engine/utils/math-kit.ts
  function multiply(a, b) {
    return big_default(a).times(b).toNumber();
  }
  function round2(base, precision) {
    const factor = 10 ** Math.floor(precision);
    return Math.round(multiply(base, factor)) / factor;
  }
  function floor(base, precision) {
    const factor = 10 ** Math.floor(precision);
    return Math.floor(multiply(base, factor)) / factor;
  }
  function ceil(base, precision) {
    const factor = 10 ** Math.floor(precision);
    return Math.ceil(multiply(base, factor)) / factor;
  }
  function mod(base, divisor) {
    const bigNumber = new big_default(base);
    const bigDivisor = new big_default(divisor);
    const quotient = Math.floor(base / divisor);
    const result = bigNumber.minus(bigDivisor.times(quotient));
    return result.toNumber();
  }
  function pow(base, exponent) {
    return base ** exponent;
  }

  // ../packages/engine-formula/src/engine/value-object/primitive-object.ts
  var _NullValueObject = class _NullValueObject extends BaseValueObject {
    static create() {
      this._instance = this._instance || new _NullValueObject(0);
      return this._instance;
    }
    isNull() {
      return true;
    }
    plus(valueObject) {
      return NumberValueObject.create(0).plus(valueObject);
    }
    minus(valueObject) {
      return NumberValueObject.create(0).minus(valueObject);
    }
    multiply(valueObject) {
      return NumberValueObject.create(0).multiply(valueObject);
    }
    divided(valueObject) {
      return NumberValueObject.create(0).divided(valueObject);
    }
    mod(valueObject) {
      return NumberValueObject.create(0).mod(valueObject);
    }
    compare(valueObject, operator) {
      if (valueObject.isString()) {
        return StringValueObject.create("").compare(valueObject, operator);
      }
      if (valueObject.isBoolean()) {
        return BooleanValueObject.create(false).compare(valueObject, operator);
      }
      return NumberValueObject.create(0).compare(valueObject, operator);
    }
    concatenateFront(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateBack(StringValueObject.create(""));
      }
      return StringValueObject.create(this.concatenate(valueObject.getValue(), 0 /* FRONT */));
    }
    concatenateBack(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateFront(StringValueObject.create(""));
      }
      return StringValueObject.create(this.concatenate(valueObject.getValue(), 1 /* BACK */));
    }
    plusBy(value) {
      return NumberValueObject.create(0).plusBy(value);
    }
    minusBy(value) {
      return NumberValueObject.create(0).minusBy(value);
    }
    multiplyBy(value) {
      return NumberValueObject.create(0).multiplyBy(value);
    }
    dividedBy(value) {
      return NumberValueObject.create(0).dividedBy(value);
    }
    compareBy(value, operator) {
      if (typeof value === "string") {
        return StringValueObject.create("").compareBy(value, operator);
      }
      if (typeof value === "boolean") {
        return BooleanValueObject.create(false).compareBy(value, operator);
      }
      return NumberValueObject.create(0).compareBy(value, operator);
    }
    pow(valueObject) {
      return NumberValueObject.create(0).pow(valueObject);
    }
    sqrt() {
      return NumberValueObject.create(0).sqrt();
    }
    cbrt() {
      return NumberValueObject.create(0).cbrt();
    }
    cos() {
      return NumberValueObject.create(0).cos();
    }
    acos() {
      return NumberValueObject.create(0).acos();
    }
    acosh() {
      return NumberValueObject.create(0).acosh();
    }
    sin() {
      return NumberValueObject.create(0).sin();
    }
    asin() {
      return NumberValueObject.create(0).asin();
    }
    asinh() {
      return NumberValueObject.create(0).asinh();
    }
    tan() {
      return NumberValueObject.create(0).tan();
    }
    tanh() {
      return NumberValueObject.create(0).tanh();
    }
    atan() {
      return NumberValueObject.create(0).atan();
    }
    atan2(valueObject) {
      return NumberValueObject.create(0).atan2(valueObject);
    }
    atanh() {
      return NumberValueObject.create(0).atanh();
    }
    log() {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    log10() {
      return ErrorValueObject.create("#NUM!" /* NUM */);
    }
    exp() {
      return NumberValueObject.create(0).exp();
    }
    abs() {
      return NumberValueObject.create(0).abs();
    }
    round(valueObject) {
      return NumberValueObject.create(0).round(valueObject);
    }
    floor(valueObject) {
      return NumberValueObject.create(0).floor(valueObject);
    }
    ceil(valueObject) {
      return NumberValueObject.create(0).ceil(valueObject);
    }
    convertToNumberObjectValue() {
      return NumberValueObject.create(0);
    }
    convertToBooleanObjectValue() {
      return BooleanValueObject.create(false);
    }
  };
  __publicField(_NullValueObject, "_instance");
  var NullValueObject = _NullValueObject;
  var _BooleanValueObject = class _BooleanValueObject extends BaseValueObject {
    constructor(rawValue) {
      super(rawValue);
      __publicField(this, "_value", false);
      this._value = rawValue;
    }
    static create(value) {
      if (value) {
        this._instanceTrue = this._instanceTrue || new _BooleanValueObject(true);
        return this._instanceTrue;
      }
      this._instanceFalse = this._instanceFalse || new _BooleanValueObject(false);
      return this._instanceFalse;
    }
    getValue() {
      return this._value;
    }
    isBoolean() {
      return true;
    }
    getNegative() {
      const currentValue = this.getValue();
      let result = 0;
      if (currentValue) {
        result = 1;
      }
      return NumberValueObject.create(-result);
    }
    getReciprocal() {
      const currentValue = this.getValue();
      if (currentValue) {
        return NumberValueObject.create(1);
      }
      return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
    }
    plus(valueObject) {
      return this._convertTonNumber().plus(valueObject);
    }
    minus(valueObject) {
      return this._convertTonNumber().minus(valueObject);
    }
    multiply(valueObject) {
      return this._convertTonNumber().multiply(valueObject);
    }
    divided(valueObject) {
      return this._convertTonNumber().divided(valueObject);
    }
    mod(valueObject) {
      return this._convertTonNumber().mod(valueObject);
    }
    compare(valueObject, operator) {
      return this._convertTonNumber().compare(valueObject, operator);
    }
    concatenateFront(valueObject) {
      return this._convertTonNumber().concatenateFront(valueObject);
    }
    concatenateBack(valueObject) {
      return this._convertTonNumber().concatenateBack(valueObject);
    }
    _convertTonNumber() {
      const currentValue = this.getValue();
      let result = 0;
      if (currentValue) {
        result = 1;
      }
      return NumberValueObject.create(result);
    }
    pow(valueObject) {
      return this._convertTonNumber().pow(valueObject);
    }
    sqrt() {
      return this._convertTonNumber().sqrt();
    }
    cbrt() {
      return this._convertTonNumber().cbrt();
    }
    cos() {
      return this._convertTonNumber().cos();
    }
    acos() {
      return this._convertTonNumber().acos();
    }
    acosh() {
      return this._convertTonNumber().acosh();
    }
    sin() {
      return this._convertTonNumber().sin();
    }
    asin() {
      return this._convertTonNumber().asin();
    }
    asinh() {
      return this._convertTonNumber().asinh();
    }
    tan() {
      return this._convertTonNumber().tan();
    }
    tanh() {
      return this._convertTonNumber().tanh();
    }
    atan() {
      return this._convertTonNumber().atan();
    }
    atan2(valueObject) {
      return this._convertTonNumber().atan2(valueObject);
    }
    atanh() {
      return this._convertTonNumber().atanh();
    }
    log() {
      return this._convertTonNumber().log();
    }
    log10() {
      return this._convertTonNumber().log10();
    }
    exp() {
      return this._convertTonNumber().exp();
    }
    abs() {
      return this._convertTonNumber().abs();
    }
    round(valueObject) {
      return this._convertTonNumber().round(valueObject);
    }
    floor(valueObject) {
      return this._convertTonNumber().floor(valueObject);
    }
    ceil(valueObject) {
      return this._convertTonNumber().ceil(valueObject);
    }
    convertToNumberObjectValue() {
      return createNumberValueObjectByRawValue(this.getValue());
    }
    convertToBooleanObjectValue() {
      return this;
    }
  };
  __publicField(_BooleanValueObject, "_instanceTrue");
  __publicField(_BooleanValueObject, "_instanceFalse");
  var BooleanValueObject = _BooleanValueObject;
  var NUMBER_CACHE_LRU_COUNT = 2e5;
  var NumberValueObjectCache = new FormulaAstLRU(NUMBER_CACHE_LRU_COUNT);
  var NumberValueObject = class _NumberValueObject extends BaseValueObject {
    constructor(rawValue) {
      super(rawValue);
      __publicField(this, "_value", 0);
      this._value = Number(rawValue);
    }
    static create(value, pattern = "") {
      const key = `${value}-${pattern}`;
      const cached = NumberValueObjectCache.get(key);
      if (cached) {
        return cached;
      }
      const instance = new _NumberValueObject(value);
      instance.setPattern(pattern);
      NumberValueObjectCache.set(key, instance);
      return instance;
    }
    getValue() {
      return this._value;
    }
    setValue(value) {
      this._value = value;
    }
    isNumber() {
      return true;
    }
    getNegative() {
      return _NumberValueObject.create(0).minus(this);
    }
    getReciprocal() {
      return _NumberValueObject.create(1).divided(this);
    }
    plus(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.plus(this);
      }
      const object = this.plusBy(valueObject.getValue());
      if (object.isError()) {
        return object;
      }
      object.setPattern(this.getPattern() || valueObject.getPattern());
      return object;
    }
    equalZero() {
      return this._value === 0;
    }
    minus(valueObject) {
      if (valueObject.isArray()) {
        const o = valueObject.getNegative();
        if (o.isError()) {
          return o;
        }
        return o.plus(this);
      }
      const object = this.minusBy(valueObject.getValue());
      if (object.isError()) {
        return object;
      }
      object.setPattern(this.getPattern() || valueObject.getPattern());
      return object;
    }
    multiply(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.multiply(this);
      }
      const object = this.multiplyBy(valueObject.getValue());
      if (object.isError()) {
        return object;
      }
      object.setPattern(this.getPattern() || valueObject.getPattern());
      return object;
    }
    divided(valueObject) {
      if (valueObject.isArray()) {
        const o = valueObject.getReciprocal();
        if (o.isError()) {
          return o;
        }
        return o.multiply(this);
      }
      const object = this.dividedBy(valueObject.getValue());
      if (object.isError()) {
        return object;
      }
      object.setPattern(this.getPattern() || valueObject.getPattern());
      return object;
    }
    mod(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.modInverse(this);
      }
      const currentValue = this.getValue();
      const value = valueObject.getValue();
      if (valueObject.isNull()) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (value === 0) {
          return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
        }
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = mod(currentValue, value);
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        const booleanValue = value ? 1 : 0;
        if (booleanValue === 0) {
          return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
        }
        return _NumberValueObject.create(mod(currentValue, booleanValue));
      }
      return this;
    }
    concatenateFront(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateBack(this);
      }
      return StringValueObject.create(this.concatenate(valueObject.getValue(), 0 /* FRONT */));
    }
    concatenateBack(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateFront(this);
      }
      return StringValueObject.create(this.concatenate(valueObject.getValue(), 1 /* BACK */));
    }
    compare(valueObject, operator) {
      if (valueObject.isArray()) {
        return valueObject.compare(this, reverseCompareOperator(operator));
      }
      return this.compareBy(valueObject.getValue(), operator);
    }
    plusBy(value) {
      const currentValue = this.getValue();
      if (typeof value === "string") {
        if (ERROR_TYPE_SET.has(value)) {
          return ErrorValueObject.create(value);
        }
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = big_default(currentValue).plus(value).toNumber();
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        return _NumberValueObject.create(
          big_default(currentValue).plus(value ? 1 : 0).toNumber()
        );
      }
      return this;
    }
    minusBy(value) {
      const currentValue = this.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = big_default(currentValue).minus(value).toNumber();
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        return _NumberValueObject.create(
          big_default(currentValue).minus(value ? 1 : 0).toNumber()
        );
      }
      return this;
    }
    multiplyBy(value) {
      const currentValue = this.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = big_default(currentValue).times(value).toNumber();
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        return _NumberValueObject.create(
          big_default(currentValue).times(value ? 1 : 0).toNumber()
        );
      }
      return this;
    }
    dividedBy(value) {
      const currentValue = this.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (value === 0) {
          return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
        }
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = big_default(currentValue).div(value).toNumber();
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        if (value === false) {
          return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
        }
        return _NumberValueObject.create(big_default(currentValue).div(1).toNumber());
      }
      return this;
    }
    compareBy(value, operator) {
      const currentValue = this.getValue();
      let result = false;
      if (typeof value === "string") {
        switch (operator) {
          case "=" /* EQUALS */:
          case ">" /* GREATER_THAN */:
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = false;
            break;
          case "<" /* LESS_THAN */:
          case "<=" /* LESS_THAN_OR_EQUAL */:
          case "<>" /* NOT_EQUAL */:
            result = true;
            break;
        }
      } else if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          result = this._compareInfinity(currentValue, value, operator);
        } else {
          switch (operator) {
            case "=" /* EQUALS */:
              result = big_default(currentValue).eq(value);
              break;
            case ">" /* GREATER_THAN */:
              result = big_default(currentValue).gt(value);
              break;
            case ">=" /* GREATER_THAN_OR_EQUAL */:
              result = big_default(currentValue).gte(value);
              break;
            case "<" /* LESS_THAN */:
              result = big_default(currentValue).lt(value);
              break;
            case "<=" /* LESS_THAN_OR_EQUAL */:
              result = big_default(currentValue).lte(value);
              break;
            case "<>" /* NOT_EQUAL */:
              result = !big_default(currentValue).eq(value);
              break;
          }
        }
      } else if (typeof value === "boolean") {
        switch (operator) {
          case "=" /* EQUALS */:
          case ">" /* GREATER_THAN */:
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = false;
            break;
          case "<" /* LESS_THAN */:
          case "<=" /* LESS_THAN_OR_EQUAL */:
          case "<>" /* NOT_EQUAL */:
            result = true;
            break;
        }
      }
      return BooleanValueObject.create(result);
    }
    pow(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.powInverse(this);
      }
      const currentValue = this.getValue();
      const value = valueObject.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = pow(currentValue, value);
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        return _NumberValueObject.create(pow(currentValue, value ? 1 : 0));
      }
      return this;
    }
    sqrt() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = big_default(currentValue).sqrt().toNumber();
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    cbrt() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.cbrt(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    cos() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.cos(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    acos() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.acos(currentValue);
      if (Number.isNaN(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    acosh() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.acosh(currentValue);
      if (Number.isNaN(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    sin() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.sin(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    asin() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.asin(currentValue);
      if (Number.isNaN(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    asinh() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.asinh(currentValue);
      if (Number.isNaN(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    tan() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.tan(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    tanh() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.tanh(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    atan() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.atan(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    atan2(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.atan2Inverse(this);
      }
      const currentValue = this.getValue();
      const value = valueObject.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = Math.atan2(currentValue, value);
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        return _NumberValueObject.create(Math.atan2(currentValue, value ? 1 : 0));
      }
      return this;
    }
    atanh() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.atanh(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    log() {
      const currentValue = this.getValue();
      if (typeof currentValue === "number" && currentValue <= 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.log(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    log10() {
      const currentValue = this.getValue();
      if (typeof currentValue === "number" && currentValue <= 0) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.log10(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    exp() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.exp(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    abs() {
      const currentValue = this.getValue();
      if (!Number.isFinite(currentValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      const result = Math.abs(currentValue);
      if (!Number.isFinite(result)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return _NumberValueObject.create(result);
    }
    round(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.roundInverse(this);
      }
      const currentValue = this.getValue();
      const value = valueObject.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = round2(currentValue, value);
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        return _NumberValueObject.create(round2(currentValue, value ? 1 : 0));
      }
      return this;
    }
    floor(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.floorInverse(this);
      }
      const currentValue = this.getValue();
      const value = valueObject.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = floor(currentValue, value);
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        return _NumberValueObject.create(floor(currentValue, value ? 1 : 0));
      }
      return this;
    }
    ceil(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.ceilInverse(this);
      }
      const currentValue = this.getValue();
      const value = valueObject.getValue();
      if (typeof value === "string") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (typeof value === "number") {
        if (!Number.isFinite(currentValue) || !Number.isFinite(value)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const result = ceil(currentValue, value);
        if (!Number.isFinite(result)) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        return _NumberValueObject.create(result);
      }
      if (typeof value === "boolean") {
        return _NumberValueObject.create(ceil(currentValue, value ? 1 : 0));
      }
      return this;
    }
    convertToNumberObjectValue() {
      return this;
    }
    convertToBooleanObjectValue() {
      return createBooleanValueObjectByRawValue(true);
    }
    _compareInfinity(currentValue, value, operator) {
      let result = false;
      switch (operator) {
        case "=" /* EQUALS */:
          result = currentValue === value;
          break;
        case ">" /* GREATER_THAN */:
          result = currentValue > value;
          break;
        case ">=" /* GREATER_THAN_OR_EQUAL */:
          result = currentValue >= value;
          break;
        case "<" /* LESS_THAN */:
          result = currentValue < value;
          break;
        case "<=" /* LESS_THAN_OR_EQUAL */:
          result = currentValue <= value;
          break;
        case "<>" /* NOT_EQUAL */:
          result = currentValue !== value;
          break;
      }
      return result;
    }
  };
  var STRING_CACHE_LRU_COUNT = 2e5;
  var StringValueObjectCache = new FormulaAstLRU(STRING_CACHE_LRU_COUNT);
  var StringValueObject = class _StringValueObject extends BaseValueObject {
    constructor(rawValue) {
      super(rawValue);
      __publicField(this, "_value");
      this._value = rawValue;
    }
    static create(value) {
      const cached = StringValueObjectCache.get(value);
      if (cached) {
        return cached;
      }
      const instance = new _StringValueObject(value);
      StringValueObjectCache.set(value, instance);
      return instance;
    }
    getValue() {
      return this._value;
    }
    isString() {
      return true;
    }
    concatenateFront(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateBack(this);
      }
      return _StringValueObject.create(this.concatenate(valueObject.getValue(), 0 /* FRONT */));
    }
    concatenateBack(valueObject) {
      if (valueObject.isArray()) {
        return valueObject.concatenateFront(this);
      }
      return _StringValueObject.create(this.concatenate(valueObject.getValue(), 1 /* BACK */));
    }
    compare(valueObject, operator) {
      if (valueObject.isArray()) {
        return valueObject.compare(this, reverseCompareOperator(operator));
      }
      return this.compareBy(valueObject.getValue(), operator);
    }
    compareBy(value, operator) {
      const currentValue = this.getValue();
      let result = false;
      if (typeof value === "string") {
        if (isWildcard(value)) {
          return this._checkWildcard(value, operator);
        }
        switch (operator) {
          case "=" /* EQUALS */:
            result = currentValue === value;
            break;
          case ">" /* GREATER_THAN */:
            result = currentValue > value;
            break;
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = currentValue >= value;
            break;
          case "<" /* LESS_THAN */:
            result = currentValue < value;
            break;
          case "<=" /* LESS_THAN_OR_EQUAL */:
            result = currentValue <= value;
            break;
          case "<>" /* NOT_EQUAL */:
            result = currentValue !== value;
            break;
        }
      } else if (typeof value === "number") {
        switch (operator) {
          case "<>" /* NOT_EQUAL */:
          case ">" /* GREATER_THAN */:
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = true;
            break;
          case "=" /* EQUALS */:
          case "<" /* LESS_THAN */:
          case "<=" /* LESS_THAN_OR_EQUAL */:
            result = false;
            break;
        }
      } else if (typeof value === "boolean") {
        switch (operator) {
          case "=" /* EQUALS */:
          case ">" /* GREATER_THAN */:
          case ">=" /* GREATER_THAN_OR_EQUAL */:
            result = false;
            break;
          case "<" /* LESS_THAN */:
          case "<=" /* LESS_THAN_OR_EQUAL */:
          case "<>" /* NOT_EQUAL */:
            result = true;
            break;
        }
      }
      return BooleanValueObject.create(result);
    }
    convertToNumberObjectValue() {
      return createNumberValueObjectByRawValue(this.getValue());
    }
    convertToBooleanObjectValue() {
      return BooleanValueObject.create(true);
    }
    _checkWildcard(value, operator) {
      const currentValue = this.getValue().toLocaleLowerCase();
      const result = compareWithWildcard(currentValue, value, operator);
      return BooleanValueObject.create(result);
    }
  };
  function createBooleanValueObjectByRawValue(rawValue) {
    if (typeof rawValue === "boolean") {
      return BooleanValueObject.create(rawValue);
    }
    let value = false;
    if (typeof rawValue === "string") {
      const rawValueUpper = rawValue.toLocaleUpperCase();
      if (rawValueUpper === "TRUE" /* TRUE */) {
        value = true;
      } else if (rawValueUpper === "FALSE" /* FALSE */) {
        value = false;
      }
    } else {
      if (rawValue === 1) {
        value = true;
      } else {
        value = false;
      }
    }
    return BooleanValueObject.create(value);
  }
  function createStringValueObjectByRawValue(rawValue) {
    let value = rawValue.toString();
    if (value.charAt(0) === '"' && value.charAt(value.length - 1) === '"') {
      value = value.slice(1, -1);
      value = value.replace(/""/g, '"');
    }
    return StringValueObject.create(value);
  }
  function createNumberValueObjectByRawValue(rawValue) {
    if (typeof rawValue === "boolean") {
      let result = 0;
      if (rawValue) {
        result = 1;
      }
      return NumberValueObject.create(result);
    } else if (typeof rawValue === "number") {
      if (!Number.isFinite(rawValue)) {
        return ErrorValueObject.create("#NUM!" /* NUM */);
      }
      return NumberValueObject.create(rawValue);
    } else if (isRealNum(rawValue)) {
      return NumberValueObject.create(Number(rawValue));
    }
    return ErrorValueObject.create("#VALUE!" /* VALUE */);
  }

  // ../packages/engine-formula/src/engine/value-object/array-value-object.ts
  function fromObjectToString(array) {
    return "";
  }
  function transformToValueObject(array = []) {
    const arrayValueList = [];
    for (let r = 0; r < array.length; r++) {
      const row = array[r];
      if (arrayValueList[r] == null) {
        arrayValueList[r] = [];
      }
      for (let c = 0; c < row.length; c++) {
        const cell = row[c];
        arrayValueList[r][c] = ValueObjectFactory.create(cell);
      }
    }
    return arrayValueList;
  }
  function transformToValue(array = []) {
    const arrayValueList = [];
    for (let r = 0; r < array.length; r++) {
      const row = array[r];
      if (arrayValueList[r] == null) {
        arrayValueList[r] = [];
      }
      for (let c = 0; c < row.length; c++) {
        const cell = row[c];
        if (cell == null) {
          arrayValueList[r][c] = null;
        } else if (cell.isError()) {
          arrayValueList[r][c] = cell.getErrorType();
        } else {
          arrayValueList[r][c] = cell.getValue();
        }
      }
    }
    return arrayValueList;
  }
  var ArrayValueObject = class _ArrayValueObject extends BaseValueObject {
    constructor(rawValue) {
      super(typeof rawValue === "string" ? rawValue : fromObjectToString(rawValue));
      __publicField(this, "_values", []);
      __publicField(this, "_rowCount", -1);
      __publicField(this, "_columnCount", -1);
      __publicField(this, "_unitId", "");
      __publicField(this, "_sheetId", "");
      __publicField(this, "_currentRow", -1);
      __publicField(this, "_currentColumn", -1);
      __publicField(this, "_sliceCache", /* @__PURE__ */ new Map());
      __publicField(this, "_flattenCache");
      __publicField(this, "_flattenPosition");
      this._values = this._formatValue(rawValue);
    }
    static create(rawValue) {
      return new _ArrayValueObject(rawValue);
    }
    dispose() {
      this._values.forEach((cells) => {
        cells.forEach((cell) => {
          cell == null ? void 0 : cell.dispose();
        });
      });
      this._values = [];
      this._clearCache();
    }
    clone() {
      return this.map((o) => {
        return o;
      });
    }
    getRowCount() {
      return this._rowCount;
    }
    setRowCount(rowCount) {
      this._rowCount = rowCount;
    }
    getColumnCount() {
      return this._columnCount;
    }
    setColumnCount(columnCount) {
      this._columnCount = columnCount;
    }
    setCurrent(row, column) {
      this._currentRow = row;
      this._currentColumn = column;
    }
    setUnitId(unitId) {
      this._unitId = unitId;
    }
    getUnitId() {
      return this._unitId;
    }
    setSheetId(sheetId) {
      this._sheetId = sheetId;
    }
    getSheetId() {
      return this._sheetId;
    }
    getCurrentRow() {
      return this._currentRow;
    }
    getCurrentColumn() {
      return this._currentColumn;
    }
    getArrayValue() {
      return this._values;
    }
    setArrayValue(value) {
      this._clearCache();
      this._values = value;
    }
    isArray() {
      return true;
    }
    get(row, column) {
      const rowValues = this._values[row];
      if (rowValues == null) {
        return null;
      }
      const v = rowValues[column];
      if (v == null) {
        return null;
      }
      return v;
    }
    getRealValue(row, column) {
      const rowValues = this._values[row];
      if (rowValues == null) {
        return null;
      }
      const v = rowValues[column];
      if (v == null) {
        return null;
      }
      return v;
    }
    set(row, column, value) {
      if (row >= this._rowCount || column >= this._columnCount) {
        throw new Error("Exceeding array bounds.");
      }
      this._clearCache();
      this._values[row][column] = value;
    }
    getRangePosition() {
      const startRow = 0;
      const rowCount = this.getRowCount();
      const startColumn = 0;
      const columnCount = this.getColumnCount();
      return {
        startRow,
        endRow: rowCount - 1,
        startColumn,
        endColumn: columnCount - 1
      };
    }
    iterator(callback) {
      var _a2;
      const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
      const valueList = this.getArrayValue();
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startColumn; c <= endColumn; c++) {
          if (callback((_a2 = valueList[r]) == null ? void 0 : _a2[c], r, c) === false) {
            return;
          }
        }
      }
    }
    iteratorReverse(callback) {
      const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
      const valueList = this.getArrayValue();
      for (let r = endRow; r >= startRow; r--) {
        for (let c = endColumn; c >= startColumn; c--) {
          if (callback(valueList[r][c], r, c) === false) {
            return;
          }
        }
      }
    }
    getLastTruePosition() {
      let rangeSingle;
      this.iteratorReverse((value, rowIndex, columnIndex) => {
        if ((value == null ? void 0 : value.isBoolean()) && value.getValue() === true) {
          rangeSingle = {
            row: rowIndex,
            column: columnIndex
          };
          return false;
        }
      });
      return rangeSingle;
    }
    getFirstTruePosition() {
      let rangeSingle;
      this.iterator((value, rowIndex, columnIndex) => {
        if ((value == null ? void 0 : value.isBoolean()) && value.getValue() === true) {
          rangeSingle = {
            row: rowIndex,
            column: columnIndex
          };
          return false;
        }
      });
      return rangeSingle;
    }
    getFirstCell() {
      const { startRow, startColumn } = this.getRangePosition();
      return this.get(startRow, startColumn) || NullValueObject.create();
    }
    getLastCell() {
      const { endRow, endColumn } = this.getRangePosition();
      return this.get(endRow, endColumn) || NullValueObject.create();
    }
    /**
     * Referring to matrix calculations,
     * extract the matching values from a true/false matrix based on parameters and store them in a two-dimensional array.
     * implement x[x<10]
     * https://numpy.org/doc/stable/user/basics.indexing.html
     * @param takeArray
     */
    pick(takeArray) {
      const takeArrayRowCount = takeArray.getRowCount();
      const takeArrayColumnCount = takeArray.getColumnCount();
      if (takeArrayRowCount !== this._rowCount || takeArrayColumnCount !== this._columnCount) {
        return this._createNewArray([[NullValueObject.create()]], 1, 1);
      }
      const newValue = [];
      newValue[0] = [];
      for (let r = 0; r < takeArrayRowCount; r++) {
        for (let c = 0; c < takeArrayColumnCount; c++) {
          const takeCell = takeArray.get(r, c);
          const value = this.get(r, c);
          if (takeCell == null || takeCell.isError()) {
            continue;
          }
          if (takeCell.getValue() === true) {
            newValue[0].push(value);
          }
        }
      }
      return this._createNewArray(newValue, 1, newValue[0].length);
    }
    /**
     * Flatten a 2D array.
     * https://numpy.org/doc/stable/reference/generated/numpy.chararray.flatten.html#numpy.chararray.flatten
     */
    flatten() {
      if (this._flattenCache != null) {
        return this._flattenCache;
      }
      const newValue = [];
      newValue[0] = [];
      for (let r = 0; r < this._rowCount; r++) {
        for (let c = 0; c < this._columnCount; c++) {
          const value = this.get(r, c);
          newValue[0].push(value);
        }
      }
      const arrayV = this._createNewArray(newValue, 1, newValue[0].length);
      this._flattenCache = arrayV;
      return arrayV;
    }
    /**
     * Flatten a 2D array.
     * In Excel, errors and blank cells are ignored, which results in a binary search that cannot strictly adhere to the number of cells.
     */
    flattenPosition() {
      if (this._flattenPosition != null) {
        return this._flattenPosition;
      }
      const stringValue = [];
      const numberValue = [];
      const stringPosition = [];
      const numberPosition = [];
      let index = 0;
      for (let r = 0; r < this._rowCount; r++) {
        for (let c = 0; c < this._columnCount; c++) {
          const value = this.get(r, c);
          if (value == null || value.isError() || value.isNull()) {
            index++;
            continue;
          }
          if (value.isString()) {
            stringValue.push(value);
            stringPosition.push(index++);
          } else {
            numberValue.push(value);
            numberPosition.push(index++);
          }
        }
      }
      const result = {
        stringArray: stringValue,
        numberArray: numberValue,
        stringPosition,
        numberPosition
      };
      this._flattenPosition = result;
      return result;
    }
    /**
     * I'm looking to perform slicing operations on 2D arrays, similar to the functionality provided by NumPy.
     * https://numpy.org/doc/stable/user/basics.indexing.html
     * @rowParam start:stop:step
     * @columnParam start:stop:step
     * @param takeArray
     */
    slice(rowParam, columnParam) {
      let rowStart = 0;
      let rowStop = this._rowCount;
      let rowStep = 1;
      let columnStart = 0;
      let columnStop = this._columnCount;
      let columnStep = 1;
      if (rowParam != null) {
        rowStart = rowParam[0] || 0;
        rowStop = rowParam[1] || this._rowCount;
        rowStep = rowParam[2] || 1;
      }
      if (columnParam != null) {
        columnStart = columnParam[0] || 0;
        columnStop = columnParam[1] || this._columnCount;
        columnStep = columnParam[2] || 1;
      }
      if (rowStart >= this._rowCount || columnStart >= this._columnCount) {
        return;
      }
      const cacheKey = `${rowStart}_${rowStop}_${rowStep}_${columnStart}_${columnStop}_${columnStep}`;
      const cache = this._sliceCache.get(cacheKey);
      if (cache != null) {
        return cache;
      }
      const result = [];
      const array = this._values;
      let result_row_index = 0;
      let result_column_index = 0;
      for (let r = rowStart; r < rowStop; r += rowStep) {
        result_column_index = 0;
        if (result[result_row_index] == null) {
          result[result_row_index] = [];
        }
        for (let c = columnStart; c < columnStop; c += columnStep) {
          if (!array[r]) {
            return;
          }
          ;
          let cell = array[r][c];
          if (cell == null) {
            cell = NullValueObject.create();
          }
          result[result_row_index][result_column_index] = cell;
          result_column_index++;
        }
        result_row_index++;
      }
      if (result.length === 0 || result[0].length === 0) {
        return;
      }
      const startRow = rowStep > 1 ? -1 : rowStart + this._currentRow;
      const startColumn = columnStep > 1 ? -1 : columnStart + this._currentColumn;
      const newResultArray = this._createNewArray(result, result.length, result[0].length, startRow, startColumn);
      this._sliceCache.set(cacheKey, newResultArray);
      return newResultArray;
    }
    sortByRow(index) {
      const result = this._transposeArray(this._values);
      result.sort(this._sort(index));
      this._clearCache();
      this._values = this._transposeArray(result);
    }
    sortByColumn(index) {
      this._clearCache();
      this._values.sort(this._sort(index));
    }
    transpose() {
      const transposeArray = this._transposeArray(this._values);
      const rowCount = this._rowCount;
      const columnCount = this._columnCount;
      return this._createNewArray(transposeArray, columnCount, rowCount);
    }
    /**
     * Due to the inability to effectively utilize the cache,
     * the sequential matching approach is only used for special matches in XLOOKUP and XMATCH.
     * For example, when match_mode is set to 1 and -1 for an exact match. If not found, it returns the next smaller item.
     */
    orderSearch(valueObject, searchType = 1 /* MIN */, isDesc = false, isFuzzyMatching = false) {
      let result;
      let maxOrMin;
      let resultPosition;
      let maxOrMinPosition;
      const _handleMatch = (itemValue, row, column) => {
        if (itemValue == null) {
          return true;
        }
        let matchObject;
        if (isFuzzyMatching === true) {
          matchObject = itemValue.compare(valueObject, "=" /* EQUALS */);
        } else {
          matchObject = itemValue.isEqual(valueObject);
        }
        if ((matchObject == null ? void 0 : matchObject.getValue()) === true) {
          result = itemValue;
          resultPosition = { row, column };
          return false;
        }
        if (searchType === 2 /* MAX */) {
          if (itemValue.isGreaterThan(valueObject).getValue() === true) {
            if (maxOrMin == null || itemValue.minus(valueObject).abs().isLessThanOrEqual(maxOrMin.minus(valueObject).abs()).getValue() === true) {
              maxOrMin = itemValue;
              maxOrMinPosition = { row, column };
            }
          }
        } else if (searchType === 1 /* MIN */) {
          if (itemValue.isLessThan(valueObject).getValue() === true) {
            if (maxOrMin == null || itemValue.minus(valueObject).abs().isLessThanOrEqual(maxOrMin.minus(valueObject).abs()).getValue() === true) {
              maxOrMin = itemValue;
              maxOrMinPosition = { row, column };
            }
          }
        }
      };
      if (isDesc) {
        const rowCount = this._values.length;
        if (this._values[0] == null) {
          return;
        }
        const columnCount = this._values[0].length;
        for (let r = rowCount - 1; r >= 0; r--) {
          for (let c = columnCount - 1; c >= 0; c--) {
            const itemValue = this._values[r][c];
            _handleMatch(itemValue, r, c);
          }
        }
      } else {
        this.iterator((itemValue, r, c) => {
          _handleMatch(itemValue, r, c);
        });
      }
      if (result != null) {
        return resultPosition;
      }
      if (maxOrMin != null) {
        return maxOrMinPosition;
      }
    }
    binarySearch(valueObject, searchType = 0 /* MIN */) {
      if (valueObject.isError()) {
        return;
      }
      const { stringArray, stringPosition, numberArray, numberPosition } = this.flattenPosition();
      if (valueObject.isString()) {
        return this._binarySearch(valueObject, stringArray, stringPosition, searchType);
      }
      const result = this._binarySearch(valueObject, numberArray, numberPosition, searchType);
      return result;
    }
    _binarySearch(valueObject, searchArray2, positionArray, searchType = 0 /* MIN */) {
      const compareFunc = getCompare();
      const value = valueObject.getValue().toString();
      let start = 0;
      let end = searchArray2.length - 1;
      let lastValue = null;
      while (start <= end) {
        const middle = Math.floor((start + end) / 2);
        const compareTo = searchArray2[middle];
        let compare2 = 0;
        if (compareTo.isNull()) {
          compare2 = 1;
        } else {
          const compareToValue = compareTo.getValue();
          compare2 = compareFunc(compareToValue.toString(), value);
        }
        if (compare2 === 0) {
          return positionArray[middle];
        }
        if (compare2 === -1) {
          start = middle + 1;
          if (searchType === 0 /* MIN */) {
            lastValue = middle;
          }
        } else {
          end = middle - 1;
          if (searchType === 1 /* MAX */) {
            lastValue = middle;
          }
        }
      }
      if (lastValue == null) {
        return;
      }
      return positionArray[lastValue];
    }
    sum() {
      let accumulatorAll = NumberValueObject.create(0);
      this.iterator((valueObject) => {
        if (valueObject == null || valueObject.isString() || valueObject.isBoolean() || valueObject.isNull()) {
          return true;
        }
        if (valueObject.isError()) {
          accumulatorAll = valueObject;
          return false;
        }
        accumulatorAll = accumulatorAll.plus(
          valueObject
        );
      });
      return accumulatorAll;
    }
    max() {
      let accumulatorAll = NumberValueObject.create(Number.NEGATIVE_INFINITY);
      this.iterator((valueObject) => {
        if (valueObject == null) {
          return true;
        }
        if (valueObject.isError()) {
          accumulatorAll = valueObject;
          return false;
        }
        if (valueObject.isString() || valueObject.isNull() || valueObject.isBoolean()) {
          return true;
        }
        const result = accumulatorAll.isLessThan(valueObject);
        if (result.getValue()) {
          accumulatorAll = valueObject;
        }
      });
      return accumulatorAll;
    }
    min() {
      let accumulatorAll = NumberValueObject.create(Number.POSITIVE_INFINITY);
      this.iterator((valueObject) => {
        if (valueObject == null) {
          return true;
        }
        if (valueObject.isError()) {
          accumulatorAll = valueObject;
          return false;
        }
        if (valueObject.isString() || valueObject.isNull() || valueObject.isBoolean()) {
          return true;
        }
        const result = accumulatorAll.isGreaterThan(valueObject);
        if (result.getValue()) {
          accumulatorAll = valueObject;
        }
      });
      return accumulatorAll;
    }
    count() {
      let accumulatorAll = NumberValueObject.create(0);
      this.iterator((valueObject) => {
        if (valueObject == null || valueObject.isError() || valueObject.isString() || valueObject.isNull() || valueObject.isBoolean()) {
          return true;
        }
        accumulatorAll = accumulatorAll.plusBy(1);
      });
      return accumulatorAll;
    }
    countA() {
      let accumulatorAll = NumberValueObject.create(0);
      this.iterator((valueObject) => {
        if (valueObject == null || valueObject.isNull()) {
          return true;
        }
        accumulatorAll = accumulatorAll.plusBy(1);
      });
      return accumulatorAll;
    }
    countBlank() {
      let accumulatorAll = NumberValueObject.create(0);
      this.iterator((valueObject) => {
        if (valueObject != null && !valueObject.isNull()) {
          return true;
        }
        accumulatorAll = accumulatorAll.plusBy(1);
      });
      return accumulatorAll;
    }
    getNegative() {
      const arrayValueObject = _ArrayValueObject.create("{0}");
      return arrayValueObject.minus(this);
    }
    getReciprocal() {
      const arrayValueObject = _ArrayValueObject.create("{1}");
      return arrayValueObject.divided(this);
    }
    plus(valueObject) {
      return this._batchOperator(valueObject, 1 /* PLUS */);
    }
    minus(valueObject) {
      return this._batchOperator(valueObject, 0 /* MINUS */);
    }
    multiply(valueObject) {
      return this._batchOperator(valueObject, 2 /* MULTIPLY */);
    }
    divided(valueObject) {
      return this._batchOperator(valueObject, 3 /* DIVIDED */);
    }
    mod(valueObject) {
      return this._batchOperator(valueObject, 4 /* MOD */);
    }
    modInverse(valueObject) {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return valueObject.mod(currentValue);
      });
    }
    compare(valueObject, operator) {
      return this._batchOperator(valueObject, 5 /* COMPARE */, operator);
    }
    concatenateFront(valueObject) {
      return this._batchOperator(valueObject, 6 /* CONCATENATE_FRONT */);
    }
    concatenateBack(valueObject) {
      return this._batchOperator(valueObject, 7 /* CONCATENATE_BACK */);
    }
    map(callbackFn) {
      const wrappedCallbackFn = (currentValue, r, c) => {
        if (currentValue == null) {
          return NullValueObject.create();
        }
        if (currentValue.isError()) {
          return currentValue;
        } else {
          return callbackFn(currentValue, r, c);
        }
      };
      return this.mapValue(wrappedCallbackFn);
    }
    mapValue(callbackFn) {
      var _a2;
      const rowCount = this._rowCount;
      const columnCount = this._columnCount;
      const result = [];
      for (let r = 0; r < rowCount; r++) {
        const rowList = [];
        for (let c = 0; c < columnCount; c++) {
          const row = (_a2 = this._values) == null ? void 0 : _a2[r];
          if (row == null) {
            rowList[c] = ErrorValueObject.create("#VALUE!" /* VALUE */);
          } else {
            const currentValue = row[c];
            if (currentValue) {
              rowList[c] = callbackFn(currentValue, r, c);
            } else {
              rowList[c] = NullValueObject.create();
            }
          }
        }
        result.push(rowList);
      }
      return this._createNewArray(result, rowCount, columnCount);
    }
    pow(valueObject) {
      return this._batchOperator(valueObject, 8 /* POW */);
    }
    /**
     *
     * @param valueObject In the case of an inverse, it is certainly not an array.
     * @returns
     */
    powInverse(valueObject) {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return valueObject.pow(currentValue);
      });
    }
    sqrt() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.sqrt();
      });
    }
    cbrt() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.cbrt();
      });
    }
    cos() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.cos();
      });
    }
    acos() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.acos();
      });
    }
    acosh() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.acosh();
      });
    }
    sin() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.sin();
      });
    }
    asin() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.asin();
      });
    }
    asinh() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.asinh();
      });
    }
    tan() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.tan();
      });
    }
    tanh() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.tanh();
      });
    }
    atan() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.atan();
      });
    }
    atanh() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.atanh();
      });
    }
    atan2(valueObject) {
      return this._batchOperator(valueObject, 12 /* ATAN2 */);
    }
    atan2Inverse(valueObject) {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return valueObject.atan2(currentValue);
      });
    }
    mean(ddof = 0) {
      const sum = this.sum();
      const count = this.count();
      return sum.divided(ddof === 0 ? count : count.minusBy(1));
    }
    median() {
      const numberArray = this.flattenPosition().numberArray;
      const allValue = this._createNewArray([numberArray], 1, numberArray.length);
      const count = allValue.getColumnCount();
      if (count <= 1) {
        return allValue.get(0, 0) || NullValueObject.create();
      }
      allValue.sortByRow(0);
      if (count % 2 === 0) {
        const medianRight = allValue.get(0, count / 2) || NullValueObject.create();
        const medianLeft = allValue.get(0, count / 2 - 1) || NullValueObject.create();
        return medianRight.plus(medianLeft).divided(NumberValueObject.create(2));
      }
      return allValue.get(0, (count - 1) / 2) || NullValueObject.create();
    }
    /**
     * ┌──────────────┬────────────────────────────────┬───────────────────┐
     * │ Function     │ Ignore logical values and text │ Type              │
     * ├──────────────┼────────────────────────────────┼───────────────────┤
     * │ VAR.S (VAR)  │ TRUE                           │ sample            │
     * │ VAR.P (VARP) │ TRUE                           │ entire population │
     * │ VARA         │ FALSE                          │ sample            │
     * │ VARPA        │ FALSE                          │ entire population │
     * └──────────────┴────────────────────────────────┴───────────────────┘
     *
     * for VARPA and VARA, strings and FALSE are counted as 0, TRUE is counted as 1
     * for VAR.S/VAR, or VAR.P/VARP, strings,TRUE and FALSE are ignored
     * Since sum ignores strings and booleans, they are ignored here too, and VAR.S and VAR.P are used more
     *
     * VAR.S assumes that its arguments are a sample of the population, like numpy.var(data, ddof=1)
     * VAR.P assumes that its arguments are the entire population, like numpy.var(data, ddof=0)
     * numpy.var uses ddof=0 (Delta Degrees of Freedom) by default, so we use ddof=0 here
     *
     */
    var(ddof = 0) {
      const mean = this.mean();
      const squaredDifferences = [[]];
      this.iterator((valueObject) => {
        if (valueObject == null || valueObject.isError() || valueObject.isString() || valueObject.isBoolean() || valueObject.isNull()) {
          return;
        }
        const baseValueObject = valueObject.minus(mean).pow(NumberValueObject.create(2));
        if (baseValueObject.isError()) {
          return;
        }
        squaredDifferences[0].push(baseValueObject);
      });
      const { _unitId, _sheetId, _currentRow, _currentColumn } = this;
      const squaredDifferencesArrayObject = _ArrayValueObject.create({
        calculateValueList: squaredDifferences,
        rowCount: 1,
        columnCount: squaredDifferences[0].length,
        unitId: _unitId,
        sheetId: _sheetId,
        row: _currentRow,
        column: _currentColumn
      });
      return squaredDifferencesArrayObject.mean(ddof);
    }
    /**
     * STDEV.P (STDEVP): ddof=0, ignore strings and booleans
     * STDEV.S (STDEV): ddof=1, ignore strings and booleans
     *
     * STDEVPA: ddof=0,
     * STDEVA: ddof=1,
     * @returns
     */
    std(ddof = 0) {
      const variance = this.var(ddof);
      if (variance.isError()) {
        return variance;
      }
      return variance.sqrt();
    }
    log() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.log();
      });
    }
    log10() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.log10();
      });
    }
    exp() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.exp();
      });
    }
    abs() {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return currentValue.abs();
      });
    }
    round(valueObject) {
      return this._batchOperator(valueObject, 9 /* ROUND */);
    }
    roundInverse(valueObject) {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return valueObject.round(currentValue);
      });
    }
    floor(valueObject) {
      return this._batchOperator(valueObject, 10 /* FLOOR */);
    }
    floorInverse(valueObject) {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return valueObject.floor(currentValue);
      });
    }
    ceil(valueObject) {
      return this._batchOperator(valueObject, 11 /* CEIL */);
    }
    ceilInverse(valueObject) {
      return this.map((currentValue) => {
        if (currentValue.isError()) {
          return currentValue;
        }
        return valueObject.ceil(currentValue);
      });
    }
    toValue() {
      return transformToValue(this._values);
    }
    _clearCache() {
      this._flattenCache = null;
      this._sliceCache.clear();
    }
    _sort(index) {
      const compare2 = getCompare();
      return (a, b) => {
        const columnA = a[index];
        const columnB = b[index];
        if (columnA == null) {
          return 1;
        }
        if (columnB == null) {
          return -1;
        }
        if (columnA.isError() && columnA.isError()) {
          return 0;
        }
        if (columnA.isError()) {
          return 1;
        }
        if (columnB.isError()) {
          return -1;
        }
        return compare2(
          columnA.getValue(),
          columnB.getValue()
        );
      };
    }
    _transposeArray(array) {
      const rows = array.length;
      const cols = array[0].length;
      const transposedArray = [];
      for (let col = 0; col < cols; col++) {
        transposedArray[col] = [];
        for (let row = 0; row < rows; row++) {
          transposedArray[col][row] = array[row][col];
        }
      }
      return transposedArray;
    }
    _batchOperator(valueObject, batchOperatorType, operator) {
      const valueList = [];
      let rowCount = this._rowCount;
      let columnCount = this._columnCount;
      if (valueObject.isArray()) {
        const valueRowCount = valueObject.getRowCount();
        const valueColumnCount = valueObject.getColumnCount();
        rowCount = Math.max(valueRowCount, rowCount);
        columnCount = Math.max(valueColumnCount, columnCount);
        if (valueRowCount === 1 && valueColumnCount === 1) {
          const v = valueObject.getFirstCell();
          for (let c = 0; c < columnCount; c++) {
            valueList.push(v);
          }
        } else if (valueRowCount === 1 && this._columnCount > 1) {
          const list = valueObject.getArrayValue();
          for (let c = 0; c < columnCount; c++) {
            valueList.push(list[0][c]);
          }
        } else {
          return this._batchOperatorArray(valueObject, batchOperatorType, operator);
        }
      } else {
        for (let c = 0; c < columnCount; c++) {
          valueList.push(valueObject);
        }
      }
      const result = [];
      for (let c = 0; c < columnCount; c++) {
        const value = valueList[c];
        this._batchOperatorValue(value, c, result, batchOperatorType, operator);
      }
      return this._createNewArray(result, rowCount, columnCount);
    }
    _batchOperatorValue(valueObject, column, result, batchOperatorType, operator) {
      var _a2, _b2;
      const rowCount = this._rowCount;
      let canUseCache = false;
      const unitId = this.getUnitId();
      const sheetId = this.getSheetId();
      const startRow = this.getCurrentRow();
      const startColumn = this.getCurrentColumn();
      if (batchOperatorType === 5 /* COMPARE */) {
        canUseCache = CELL_INVERTED_INDEX_CACHE.canUseCache(
          unitId,
          sheetId,
          column + startColumn,
          startRow,
          startRow + rowCount - 1
        );
        if (canUseCache === true) {
          if (operator === "=" /* EQUALS */) {
            const rowPositions = CELL_INVERTED_INDEX_CACHE.getCellPositions(
              unitId,
              sheetId,
              column + startColumn,
              valueObject.getValue()
            );
            if (rowPositions != null) {
              rowPositions.forEach((row) => {
                const r = row - startRow;
                if (result[r] == null) {
                  result[r] = [];
                }
                result[r][column] = BooleanValueObject.create(true);
              });
            }
          } else {
            const rowValuePositions = CELL_INVERTED_INDEX_CACHE.getCellValuePositions(
              unitId,
              sheetId,
              column + startColumn
            );
            if (rowValuePositions != null) {
              rowValuePositions.forEach((rowPositions, rowValue) => {
                let currentValue = NullValueObject.create();
                if (typeof rowValue === "string") {
                  currentValue = StringValueObject.create(rowValue);
                } else if (typeof rowValue === "number") {
                  currentValue = NumberValueObject.create(rowValue);
                } else if (typeof rowValue === "boolean") {
                  currentValue = BooleanValueObject.create(rowValue);
                }
                const matchResult = currentValue.compare(valueObject, operator);
                if (matchResult.getValue() === true) {
                  rowPositions.forEach((index) => {
                    if (index >= startRow && index <= startRow + rowCount - 1) {
                      if (result[index - startRow] == null) {
                        result[index - startRow] = [];
                      }
                      result[index - startRow][column] = BooleanValueObject.create(true);
                    }
                  });
                }
              });
            }
          }
          return;
        }
      }
      for (let r = 0; r < rowCount; r++) {
        const currentValue = (_b2 = (_a2 = this._values) == null ? void 0 : _a2[r]) == null ? void 0 : _b2[column];
        if (result[r] == null) {
          result[r] = [];
        }
        if (currentValue && valueObject) {
          if (currentValue.isError()) {
            result[r][column] = currentValue;
          } else if (valueObject.isError()) {
            result[r][column] = valueObject;
          } else {
            switch (batchOperatorType) {
              case 1 /* PLUS */:
                result[r][column] = currentValue.plus(valueObject);
                break;
              case 0 /* MINUS */:
                result[r][column] = currentValue.minus(valueObject);
                break;
              case 2 /* MULTIPLY */:
                result[r][column] = currentValue.multiply(valueObject);
                break;
              case 3 /* DIVIDED */:
                result[r][column] = currentValue.divided(valueObject);
                break;
              case 4 /* MOD */:
                result[r][column] = currentValue.mod(valueObject);
                break;
              case 5 /* COMPARE */:
                if (!operator) {
                  result[r][column] = ErrorValueObject.create("#VALUE!" /* VALUE */);
                } else {
                  result[r][column] = currentValue.compare(valueObject, operator);
                }
                break;
              case 6 /* CONCATENATE_FRONT */:
                result[r][column] = currentValue.concatenateFront(valueObject);
                break;
              case 7 /* CONCATENATE_BACK */:
                result[r][column] = currentValue.concatenateBack(valueObject);
                break;
              case 8 /* POW */:
                result[r][column] = currentValue.pow(valueObject);
                break;
              case 9 /* ROUND */:
                result[r][column] = currentValue.round(valueObject);
                break;
              case 10 /* FLOOR */:
                result[r][column] = currentValue.floor(valueObject);
                break;
              case 12 /* ATAN2 */:
                result[r][column] = currentValue.atan2(valueObject);
                break;
              case 11 /* CEIL */:
                result[r][column] = currentValue.ceil(valueObject);
                break;
            }
          }
        } else {
          result[r][column] = ErrorValueObject.create("#N/A" /* NA */);
        }
        if (currentValue == null) {
          continue;
        }
        if (currentValue.isError()) {
          CELL_INVERTED_INDEX_CACHE.set(
            unitId,
            sheetId,
            column + startColumn,
            currentValue.getErrorType(),
            r + startRow
          );
        } else if (currentValue.isNull()) {
          CELL_INVERTED_INDEX_CACHE.set(unitId, sheetId, column + startColumn, null, r + startRow);
        } else {
          CELL_INVERTED_INDEX_CACHE.set(
            unitId,
            sheetId,
            column + startColumn,
            currentValue.getValue(),
            r + startRow
          );
        }
      }
      CELL_INVERTED_INDEX_CACHE.setContinueBuildingCache(
        unitId,
        sheetId,
        column + startColumn,
        startRow,
        startRow + rowCount - 1
      );
    }
    _batchOperatorArray(valueObject, batchOperatorType, operator) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      let rowCount = valueObject.getRowCount();
      let columnCount = valueObject.getColumnCount();
      if (rowCount < this._rowCount) {
        rowCount = this._rowCount;
      }
      if (columnCount < this._columnCount) {
        columnCount = this._columnCount;
      }
      const result = [];
      const valueObjectList = valueObject.getArrayValue();
      const currentCalculateType = this._checkArrayCalculateType(this);
      const opCalculateType = this._checkArrayCalculateType(valueObject);
      for (let r = 0; r < rowCount; r++) {
        const rowList = [];
        for (let c = 0; c < columnCount; c++) {
          let currentValue;
          if (currentCalculateType === 3 /* SINGLE */) {
            currentValue = (_b2 = (_a2 = this._values) == null ? void 0 : _a2[0]) == null ? void 0 : _b2[0];
          } else if (currentCalculateType === 1 /* ROW */) {
            currentValue = (_d = (_c = this._values) == null ? void 0 : _c[0]) == null ? void 0 : _d[c];
          } else if (currentCalculateType === 2 /* COLUMN */) {
            currentValue = (_f = (_e = this._values) == null ? void 0 : _e[r]) == null ? void 0 : _f[0];
          } else {
            currentValue = (_h = (_g = this._values) == null ? void 0 : _g[r]) == null ? void 0 : _h[c];
          }
          let opValue;
          if (opCalculateType === 3 /* SINGLE */) {
            opValue = (_i = valueObjectList == null ? void 0 : valueObjectList[0]) == null ? void 0 : _i[0];
          } else if (opCalculateType === 1 /* ROW */) {
            opValue = (_j = valueObjectList == null ? void 0 : valueObjectList[0]) == null ? void 0 : _j[c];
          } else if (opCalculateType === 2 /* COLUMN */) {
            opValue = (_k = valueObjectList == null ? void 0 : valueObjectList[r]) == null ? void 0 : _k[0];
          } else {
            opValue = (_l = valueObjectList == null ? void 0 : valueObjectList[r]) == null ? void 0 : _l[c];
          }
          if (currentValue && opValue) {
            if (currentValue.isError()) {
              rowList[c] = currentValue;
            } else if (opValue.isError()) {
              rowList[c] = opValue;
            } else {
              switch (batchOperatorType) {
                case 1 /* PLUS */:
                  rowList[c] = currentValue.plus(opValue);
                  break;
                case 0 /* MINUS */:
                  rowList[c] = currentValue.minus(opValue);
                  break;
                case 2 /* MULTIPLY */:
                  rowList[c] = currentValue.multiply(opValue);
                  break;
                case 3 /* DIVIDED */:
                  rowList[c] = currentValue.divided(opValue);
                  break;
                case 4 /* MOD */:
                  rowList[c] = currentValue.mod(opValue);
                  break;
                case 5 /* COMPARE */:
                  if (!operator) {
                    rowList[c] = ErrorValueObject.create("#VALUE!" /* VALUE */);
                  } else {
                    rowList[c] = currentValue.compare(opValue, operator);
                  }
                  break;
                case 6 /* CONCATENATE_FRONT */:
                  rowList[c] = currentValue.concatenateFront(opValue);
                  break;
                case 7 /* CONCATENATE_BACK */:
                  rowList[c] = currentValue.concatenateBack(opValue);
                  break;
                case 8 /* POW */:
                  rowList[c] = currentValue.pow(opValue);
                  break;
                case 9 /* ROUND */:
                  rowList[c] = currentValue.round(opValue);
                  break;
                case 12 /* ATAN2 */:
                  rowList[c] = currentValue.atan2(opValue);
                  break;
                case 10 /* FLOOR */:
                  rowList[c] = currentValue.floor(opValue);
                  break;
                case 11 /* CEIL */:
                  rowList[c] = currentValue.ceil(opValue);
                  break;
              }
            }
          } else {
            rowList[c] = ErrorValueObject.create("#N/A" /* NA */);
          }
        }
        result.push(rowList);
      }
      return this._createNewArray(result, rowCount, columnCount);
    }
    _checkArrayCalculateType(valueObject) {
      if (valueObject.getRowCount() === 1 && valueObject.getColumnCount() === 1) {
        return 3 /* SINGLE */;
      }
      if (valueObject.getRowCount() === 1) {
        return 1 /* ROW */;
      }
      if (valueObject.getColumnCount() === 1) {
        return 2 /* COLUMN */;
      }
      return 0 /* PRODUCT */;
    }
    _formatValue(rawValue) {
      if (typeof rawValue !== "string") {
        rawValue = rawValue;
        this._rowCount = rawValue.rowCount;
        this._columnCount = rawValue.columnCount;
        this._unitId = rawValue.unitId;
        this._sheetId = rawValue.sheetId;
        this._currentRow = rawValue.row;
        this._currentColumn = rawValue.column;
        return rawValue.calculateValueList;
      }
      rawValue = rawValue.slice(1, -1);
      const rowArray = rawValue.split(";");
      const rowArrayCount = rowArray.length;
      const result = [];
      let maxColumnCount = 0;
      for (let r = 0; r < rowArrayCount; r++) {
        const columnRaw = rowArray[r];
        const columnArray = columnRaw.split(",");
        const columnArrayCount = columnArray.length;
        if (maxColumnCount < columnArrayCount) {
          maxColumnCount = columnArrayCount;
        }
        const row = [];
        for (let c = 0; c < columnArrayCount; c++) {
          const cellRaw = columnArray[c].trim();
          row.push(ValueObjectFactory.create(cellRaw));
        }
        result.push(row);
      }
      this._rowCount = rowArrayCount;
      this._columnCount = maxColumnCount;
      return result;
    }
    _createNewArray(result, rowCount, columnCount, row = -1, column = -1) {
      if (this._currentColumn === -1 || this._currentRow === -1) {
        row = -1;
        column = -1;
      }
      const arrayValueObjectData = {
        calculateValueList: result,
        rowCount,
        columnCount,
        unitId: this.getUnitId(),
        sheetId: this.getSheetId(),
        row,
        column
      };
      return _ArrayValueObject.create(arrayValueObjectData);
    }
  };
  var ValueObjectFactory = class {
    static create(rawValue) {
      if (rawValue == null) {
        return NullValueObject.create();
      }
      if (typeof rawValue === "boolean") {
        return BooleanValueObject.create(rawValue);
      }
      if (typeof rawValue === "string") {
        const rawValueUpper = rawValue.toLocaleUpperCase().trim();
        if (ERROR_TYPE_SET.has(rawValueUpper)) {
          return ErrorValueObject.create(rawValueUpper);
        }
        if (rawValueUpper === "TRUE" /* TRUE */ || rawValueUpper === "FALSE" /* FALSE */) {
          return createBooleanValueObjectByRawValue(rawValue);
        }
        if (isRealNum(rawValue)) {
          return NumberValueObject.create(Number(rawValue));
        }
        if (new RegExp($ARRAY_VALUE_REGEX, "g").test(rawValue.replace(/\n/g, "").replace(/\r/g, ""))) {
          return ArrayValueObject.create(rawValue.replace(/\n/g, "").replace(/\r/g, ""));
        }
        return createStringValueObjectByRawValue(rawValue);
      }
      if (typeof rawValue === "number") {
        return createNumberValueObjectByRawValue(rawValue);
      }
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };

  // ../packages/engine-formula/src/engine/utils/cell.ts
  function getCellValue(cell) {
    if (cell === null) {
      return 0;
    }
    if (cell == null ? void 0 : cell.p) {
      const body = cell == null ? void 0 : cell.p.body;
      if (body == null) {
        return 0;
      }
      const data = body.dataStream;
      const lastString = data.substring(data.length - 2, data.length);
      const newDataStream = lastString === DEFAULT_EMPTY_DOCUMENT_VALUE ? data.substring(0, data.length - 2) : data;
      return newDataStream;
    }
    return (cell == null ? void 0 : cell.v) || 0;
  }

  // ../packages/engine-formula/src/engine/reference-object/base-reference-object.ts
  var FORMULA_CACHE_LRU_COUNT2 = 1e5;
  var FORMULA_REF_TO_ARRAY_CACHE = new FormulaAstLRU(FORMULA_CACHE_LRU_COUNT2);
  var BaseReferenceObject = class extends ObjectClassType {
    constructor(_token) {
      super();
      this._token = _token;
      __publicField(this, "_forcedSheetId", "");
      __publicField(this, "_forcedSheetName", "");
      __publicField(this, "_defaultSheetId", "");
      __publicField(this, "_rangeData", {
        startColumn: -1,
        startRow: -1,
        endRow: -1,
        endColumn: -1
      });
      __publicField(this, "_unitData", {});
      __publicField(this, "_defaultUnitId", "");
      __publicField(this, "_forcedUnitId", "");
      __publicField(this, "_runtimeData", {});
      __publicField(this, "_arrayFormulaCellData", {});
      __publicField(this, "_runtimeArrayFormulaCellData", {});
      __publicField(this, "_runtimeFeatureCellData", {});
      __publicField(this, "_numfmtItemData", {});
      __publicField(this, "_refOffsetX", 0);
      __publicField(this, "_refOffsetY", 0);
    }
    dispose() {
      this._unitData = {};
      this._runtimeData = {};
    }
    getToken() {
      return this._token;
    }
    setToken(token) {
      this._token = token;
    }
    isExceedRange() {
      const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
      if (startRow < 0 || startColumn < 0 || endRow >= this.getActiveSheetRowCount() || endColumn >= this.getActiveSheetColumnCount()) {
        return true;
      }
      return false;
    }
    setRefOffset(x = 0, y = 0) {
      this._refOffsetX = x;
      this._refOffsetY = y;
    }
    getRefOffset() {
      return {
        x: this._refOffsetX,
        y: this._refOffsetY
      };
    }
    getRangePosition() {
      let startRow = this._rangeData.startRow + this._refOffsetY;
      let endRow = this._rangeData.endRow + this._refOffsetY;
      let startColumn = this._rangeData.startColumn + this._refOffsetX;
      let endColumn = this._rangeData.endColumn + this._refOffsetX;
      if (Number.isNaN(startRow)) {
        startRow = 0;
      }
      if (Number.isNaN(startColumn)) {
        startColumn = 0;
      }
      if (Number.isNaN(endRow)) {
        endRow = this.getActiveSheetRowCount() - 1;
      }
      if (Number.isNaN(endColumn)) {
        endColumn = this.getActiveSheetColumnCount() - 1;
      }
      return {
        startRow,
        endRow,
        startColumn,
        endColumn
      };
    }
    isReferenceObject() {
      return true;
    }
    iterator(callback) {
      var _a2, _b2, _c;
      const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
      if (this._checkIfWorksheetMiss()) {
        return callback(ErrorValueObject.create("#VALUE!" /* VALUE */), startRow, startColumn);
      }
      const unitId = this._forcedUnitId || this._defaultUnitId;
      const sheetId = this._forcedSheetId || this._defaultSheetId;
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startColumn; c <= endColumn; c++) {
          if (r < 0 || c < 0) {
            return callback(ErrorValueObject.create("#REF!" /* REF */), r, c);
          }
          const cell = this.getCellData(r, c);
          let result = false;
          if (cell == null || isNullCell(cell)) {
            result = callback(null, r, c);
            continue;
          }
          const resultObjectValue = this.getCellValueObject(cell);
          const isNumber = resultObjectValue.isNumber();
          const pattern = (_c = (_b2 = (_a2 = this._numfmtItemData[unitId]) == null ? void 0 : _a2[sheetId]) == null ? void 0 : _b2[r]) == null ? void 0 : _c[c];
          pattern && isNumber && resultObjectValue.setPattern(pattern);
          result = callback(resultObjectValue, r, c);
          if (result === false) {
            return;
          }
        }
      }
    }
    getFirstCell() {
      var _a2, _b2, _c;
      const { startRow, startColumn } = this.getRangePosition();
      const cell = this.getCellData(startRow, startColumn);
      if (!cell) {
        return NumberValueObject.create(0);
      }
      const cellValueObject = this.getCellValueObject(cell);
      const isNumber = cellValueObject.isNumber();
      const unitId = this._forcedUnitId || this._defaultUnitId;
      const sheetId = this._forcedSheetId || this._defaultSheetId;
      const numfmtItem = (_c = (_b2 = (_a2 = this._numfmtItemData[unitId]) == null ? void 0 : _a2[sheetId]) == null ? void 0 : _b2[startRow]) == null ? void 0 : _c[startColumn];
      numfmtItem && isNumber && cellValueObject.setPattern(numfmtItem);
      return cellValueObject;
    }
    getRangeData() {
      return this._rangeData;
    }
    setRangeData(range) {
      this._rangeData = range;
    }
    getUnitId() {
      if (this._forcedUnitId && this._forcedUnitId.length > 0) {
        return this._forcedUnitId;
      }
      return this._defaultUnitId;
    }
    getSheetId() {
      if (this._forcedSheetId && this._forcedSheetId.length > 0) {
        return this._forcedSheetId;
      }
      return this._defaultSheetId;
    }
    setForcedUnitIdDirect(unitId) {
      if (unitId.length > 0) {
        this._forcedUnitId = unitId;
      }
    }
    getForcedUnitId() {
      return this._forcedUnitId;
    }
    setForcedSheetId(sheetNameMap) {
      var _a2;
      this._forcedSheetId = (_a2 = sheetNameMap[this.getUnitId()]) == null ? void 0 : _a2[this._forcedSheetName];
    }
    setForcedSheetIdDirect(sheetId) {
      this._forcedSheetId = sheetId;
    }
    getForcedSheetId() {
      return this._forcedSheetId;
    }
    setForcedSheetName(sheetName) {
      if (sheetName.length > 0) {
        this._forcedSheetName = sheetName;
      }
    }
    getForcedSheetName() {
      return this._forcedSheetName;
    }
    setDefaultSheetId(sheetId) {
      this._defaultSheetId = sheetId;
    }
    getDefaultSheetId() {
      return this._defaultSheetId;
    }
    setDefaultUnitId(unitId) {
      this._defaultUnitId = unitId;
    }
    getDefaultUnitId() {
      return this._defaultUnitId;
    }
    getUnitData() {
      return this._unitData;
    }
    setUnitData(unitData) {
      this._unitData = unitData;
    }
    getRuntimeData() {
      return this._runtimeData;
    }
    setRuntimeData(runtimeData) {
      this._runtimeData = runtimeData;
    }
    getArrayFormulaCellData() {
      return this._arrayFormulaCellData;
    }
    setArrayFormulaCellData(unitData) {
      this._arrayFormulaCellData = unitData;
    }
    getRuntimeArrayFormulaCellData() {
      return this._runtimeArrayFormulaCellData;
    }
    setRuntimeArrayFormulaCellData(unitData) {
      this._runtimeArrayFormulaCellData = unitData;
    }
    getRuntimeFeatureCellData() {
      return this._runtimeFeatureCellData;
    }
    setRuntimeFeatureCellData(unitData) {
      this._runtimeFeatureCellData = unitData;
    }
    getNumfmtItemData() {
      return this._numfmtItemData;
    }
    setNumfmtItemData(numfmtItemData) {
      this._numfmtItemData = numfmtItemData;
    }
    getActiveSheetRowCount() {
      return this.getCurrentActiveSheetData().rowCount;
    }
    getActiveSheetColumnCount() {
      return this.getCurrentActiveSheetData().columnCount;
    }
    getRowCount() {
      return this._rangeData.endRow - this._rangeData.startRow + 1;
    }
    getColumnCount() {
      return this._rangeData.endColumn - this._rangeData.startColumn + 1;
    }
    getRowData() {
      return this.getCurrentActiveSheetData().rowData;
    }
    getColumnData() {
      return this.getCurrentActiveSheetData().columnData;
    }
    isCell() {
      return false;
    }
    isColumn() {
      return false;
    }
    isRow() {
      return false;
    }
    isRange() {
      return false;
    }
    isTable() {
      return false;
    }
    unionBy(referenceObject) {
      return ErrorValueObject.create("#REF!" /* REF */);
    }
    unionRange(rangeData1, rangeData2) {
      return {
        startRow: -1,
        startColumn: -1,
        endRow: -1,
        endColumn: -1
      };
    }
    getCellValueObject(cell) {
      const value = getCellValue(cell);
      if (ERROR_TYPE_SET.has(value)) {
        return ErrorValueObject.create(value);
      }
      if (cell.t === 2 /* NUMBER */) {
        return createNumberValueObjectByRawValue(value);
      }
      if (cell.t === 1 /* STRING */ || cell.t === 4 /* FORCE_STRING */) {
        return createStringValueObjectByRawValue(value);
      }
      if (cell.t === 3 /* BOOLEAN */) {
        return createBooleanValueObjectByRawValue(value);
      }
      return ValueObjectFactory.create(value);
    }
    getCellByRow(row) {
      return this.getCellByPosition(row);
    }
    getCellByColumn(column) {
      return this.getCellByPosition(void 0, column);
    }
    getCurrentActiveSheetData() {
      return this._unitData[this.getUnitId()][this.getSheetId()];
    }
    getCurrentRuntimeSheetData() {
      var _a2, _b2;
      return (_b2 = (_a2 = this._runtimeData) == null ? void 0 : _a2[this.getUnitId()]) == null ? void 0 : _b2[this.getSheetId()];
    }
    getCurrentActiveArrayFormulaCellData() {
      var _a2, _b2;
      return (_b2 = (_a2 = this._arrayFormulaCellData) == null ? void 0 : _a2[this.getUnitId()]) == null ? void 0 : _b2[this.getSheetId()];
    }
    getCurrentRuntimeActiveArrayFormulaCellData() {
      var _a2, _b2;
      return (_b2 = (_a2 = this._runtimeArrayFormulaCellData) == null ? void 0 : _a2[this.getUnitId()]) == null ? void 0 : _b2[this.getSheetId()];
    }
    getCellData(row, column) {
      const activeSheetData = this.getCurrentActiveSheetData();
      const activeRuntimeData = this.getCurrentRuntimeSheetData();
      const activeArrayFormulaCellData = this.getCurrentActiveArrayFormulaCellData();
      const activeRuntimeArrayFormulaCellData = this.getCurrentRuntimeActiveArrayFormulaCellData();
      return (activeRuntimeData == null ? void 0 : activeRuntimeData.getValue(row, column)) || (activeRuntimeArrayFormulaCellData == null ? void 0 : activeRuntimeArrayFormulaCellData.getValue(row, column)) || this.getRuntimeFeatureCellValue(row, column) || (activeArrayFormulaCellData == null ? void 0 : activeArrayFormulaCellData.getValue(row, column)) || (activeSheetData == null ? void 0 : activeSheetData.cellData.getValue(row, column));
    }
    getRuntimeFeatureCellValue(row, column) {
      var _a2;
      const featureKeys = Object.keys(this._runtimeFeatureCellData);
      for (const featureId of featureKeys) {
        const data = this._runtimeFeatureCellData[featureId];
        const runtimeFeatureCellData = (_a2 = data == null ? void 0 : data[this.getUnitId()]) == null ? void 0 : _a2[this.getSheetId()];
        if (runtimeFeatureCellData == null) {
          continue;
        }
        const value = runtimeFeatureCellData.getValue(row, column);
        if (value == null) {
          continue;
        }
        return value;
      }
    }
    getCellByPosition(row, column) {
      if (!row) {
        row = this._rangeData.startRow;
      }
      if (!column) {
        column = this._rangeData.startColumn;
      }
      const cell = this.getCellData(row, column);
      if (!cell) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return this.getCellValueObject(cell);
    }
    toArrayValueObject(useCache = true) {
      var _a2;
      const { startRow, endRow, startColumn, endColumn } = this.getRangePosition();
      const key = `${this.getUnitId()}_${this.getSheetId()}_${startRow}_${endRow}_${startColumn}_${endColumn}`;
      const array = FORMULA_REF_TO_ARRAY_CACHE.get(key);
      if (array && useCache) {
        return array;
      }
      const rowSize = endRow - startRow + 1;
      const columnSize = endColumn - startColumn + 1;
      if (rowSize < 0 || columnSize < 0) {
        return this._getBlankArrayValueObject();
      }
      const arrayValueList = new Array(rowSize);
      this.iterator((valueObject, rowIndex, columnIndex) => {
        const row = rowIndex - startRow;
        const column = columnIndex - startColumn;
        if (!arrayValueList[row]) {
          arrayValueList[row] = new Array(columnSize);
        }
        if (valueObject == null) {
          valueObject = NullValueObject.create();
        }
        arrayValueList[row][column] = valueObject;
      });
      const arrayValueObjectData = {
        calculateValueList: arrayValueList,
        rowCount: arrayValueList.length,
        columnCount: ((_a2 = arrayValueList[0]) == null ? void 0 : _a2.length) || 0,
        unitId: this.getUnitId(),
        sheetId: this.getSheetId(),
        row: startRow,
        column: startColumn
      };
      const arrayValueObject = ArrayValueObject.create(arrayValueObjectData);
      useCache && FORMULA_REF_TO_ARRAY_CACHE.set(key, arrayValueObject);
      return arrayValueObject;
    }
    toUnitRange() {
      return {
        range: this.getRangePosition(),
        sheetId: this.getSheetId(),
        unitId: this.getUnitId()
      };
    }
    _checkIfWorksheetMiss() {
      if ((this._forcedSheetId == null || this._forcedSheetId.length === 0) && this._forcedSheetName.length > 0) {
        return true;
      }
      return false;
    }
    _getBlankArrayValueObject() {
      const arrayValueObjectData = {
        calculateValueList: [],
        rowCount: 0,
        columnCount: 0,
        unitId: this.getUnitId(),
        sheetId: this.getSheetId(),
        row: 0,
        column: 0
      };
      return ArrayValueObject.create(arrayValueObjectData);
    }
  };
  var AsyncObject = class extends ObjectClassType {
    constructor(_promise) {
      super();
      this._promise = _promise;
    }
    isAsyncObject() {
      return true;
    }
    async getValue() {
      return this._promise;
    }
  };
  var AsyncArrayObject = class extends ObjectClassType {
    constructor(_promiseList) {
      super();
      this._promiseList = _promiseList;
    }
    isAsyncArrayObject() {
      return true;
    }
    async getValue() {
      var _a2;
      const variants = [];
      for (let r = 0; r < this._promiseList.length; r++) {
        const promiseCells = this._promiseList[r];
        if (variants[r] == null) {
          variants[r] = [];
        }
        for (let c = 0; c < promiseCells.length; c++) {
          const promiseCell = promiseCells[c];
          if (promiseCell.isAsyncObject()) {
            variants[r][c] = await promiseCell.getValue();
          } else {
            variants[r][c] = promiseCell;
          }
        }
      }
      const arrayValueObjectData = {
        calculateValueList: variants,
        rowCount: variants.length,
        columnCount: ((_a2 = variants[0]) == null ? void 0 : _a2.length) || 0,
        unitId: "",
        sheetId: "",
        row: 0,
        column: 0
      };
      return ArrayValueObject.create(arrayValueObjectData);
    }
  };

  // ../packages/engine-formula/src/engine/reference-object/range-reference-object.ts
  var RangeReferenceObject = class extends BaseReferenceObject {
    constructor(range, forcedSheetId, forcedUnitId) {
      super("");
      this.setRangeData(range);
      if (forcedSheetId) {
        this.setForcedSheetIdDirect(forcedSheetId);
      }
      if (forcedUnitId) {
        this.setForcedUnitIdDirect(forcedUnitId);
      }
    }
    isRange() {
      return true;
    }
  };

  // ../packages/engine-formula/src/engine/utils/r1c1-reference.ts
  var $relativeRegex = /[\[\]]/g;
  function handleR1C1(rowOrColumnString, current) {
    if ($relativeRegex.test(rowOrColumnString)) {
      const index = Number(rowOrColumnString.replace($relativeRegex, ""));
      return current + index;
    }
    return Number(rowOrColumnString) - 1;
  }
  function singleReference(refBody, currentRow = 0, currentColumn = 0) {
    refBody = refBody.toLocaleUpperCase();
    const refBodyArray = refBody.split(/[RC]/);
    const rowString = refBodyArray[1];
    const columnString = refBodyArray[2];
    const row = handleR1C1(rowString, currentRow);
    const column = handleR1C1(columnString, currentColumn);
    return {
      row,
      column,
      absoluteRefType: 0 /* NONE */
    };
  }
  function deserializeRangeForR1C1(refString, currentRow = 0, currentColumn = 0) {
    const { refBody, sheetName, unitId } = handleRefStringInfo(refString);
    const colonIndex = refBody.indexOf(":");
    if (colonIndex === -1) {
      const grid = singleReference(refBody, currentRow, currentColumn);
      const row = grid.row;
      const column = grid.column;
      const absoluteRefType = grid.absoluteRefType;
      const range = {
        startRow: row,
        startColumn: column,
        endRow: row,
        endColumn: column,
        startAbsoluteRefType: absoluteRefType,
        endAbsoluteRefType: absoluteRefType
      };
      return {
        unitId,
        sheetName,
        range
      };
    }
    const refStartString = refBody.substring(0, colonIndex);
    const refEndString = refBody.substring(colonIndex + 1);
    const startGrid = singleReference(refStartString, currentRow, currentColumn);
    const endGrid = singleReference(refEndString, currentRow, currentColumn);
    const startRow = startGrid.row;
    const startColumn = startGrid.column;
    const endRow = endGrid.row;
    const endColumn = endGrid.column;
    return {
      unitId,
      sheetName,
      range: {
        startRow,
        startColumn,
        endRow,
        endColumn,
        startAbsoluteRefType: startGrid.absoluteRefType,
        endAbsoluteRefType: endGrid.absoluteRefType
      }
    };
  }
  function serializeRangeToR1C1(range) {
    const startRowRef = getR1C1Ref(range.startRow, range.startAbsoluteRefType, true);
    const startColumnRef = getR1C1Ref(range.startColumn, range.startAbsoluteRefType, false);
    const endRowRef = getR1C1Ref(range.endRow, range.endAbsoluteRefType, true);
    const endColumnRef = getR1C1Ref(range.endColumn, range.endAbsoluteRefType, false);
    if (startRowRef === endRowRef && startColumnRef === endColumnRef) {
      return `R${startRowRef}C${startColumnRef}`;
    }
    return `R${startRowRef}C${startColumnRef}:R${endRowRef}C${endColumnRef}`;
  }
  function getR1C1Ref(index, absoluteRefType = 3 /* ALL */, isRow) {
    index += 1;
    switch (absoluteRefType) {
      case 3 /* ALL */:
        return `${index}`;
      case 1 /* ROW */:
        return isRow ? `${index}` : `[${index}]`;
      case 2 /* COLUMN */:
        return isRow ? `[${index}]` : `${index}`;
      case 0 /* NONE */:
        return `[${index}]`;
    }
  }

  // ../packages/engine-formula/src/functions/array/function-map.ts
  var functionArray = [];

  // ../packages/engine-formula/src/engine/utils/value-object.ts
  function convertTonNumber(valueObject) {
    const currentValue = valueObject.getValue();
    let result = 0;
    if (currentValue) {
      result = 1;
    }
    return NumberValueObject.create(result);
  }
  function isSingleValueObject(valueObject) {
    if (valueObject.isArray() && valueObject.getRowCount() === 1 && valueObject.getColumnCount() === 1) {
      return true;
    }
    if (valueObject.isReferenceObject()) {
      if (valueObject.isCell()) {
        return true;
      }
      if (valueObject.getRowCount() === 1 && valueObject.getColumnCount() === 1) {
        return true;
      }
      return false;
    }
    valueObject = valueObject;
    if (valueObject.isString() || valueObject.isNumber() || valueObject.isBoolean() || valueObject.isError() || valueObject.isNull()) {
      return true;
    }
    return false;
  }

  // ../packages/engine-formula/src/engine/utils/array-object.ts
  function expandArrayValueObject(rowCount, columnCount, valueObject, defaultValue) {
    const result = [];
    if (valueObject.isArray()) {
      const valueRowCount = valueObject.getRowCount();
      const valueColumnCount = valueObject.getColumnCount();
      if (valueRowCount === 1 && valueColumnCount === 1) {
        const v = valueObject.getFirstCell();
        for (let r = 0; r < rowCount; r++) {
          const row = [];
          for (let c = 0; c < columnCount; c++) {
            row.push(v);
          }
          result.push(row);
        }
      } else if (valueRowCount === 1 && valueColumnCount > 1) {
        for (let r = 0; r < rowCount; r++) {
          const row = [];
          for (let c = 0; c < columnCount; c++) {
            const v = valueObject.getRealValue(0, c) || (defaultValue != null ? defaultValue : NullValueObject.create());
            row.push(v);
          }
          result.push(row);
        }
      } else if (valueColumnCount === 1 && valueRowCount > 1) {
        for (let r = 0; r < rowCount; r++) {
          const row = [];
          for (let c = 0; c < columnCount; c++) {
            const v = valueObject.getRealValue(r, 0) || (defaultValue != null ? defaultValue : NullValueObject.create());
            row.push(v);
          }
          result.push(row);
        }
      } else {
        for (let r = 0; r < rowCount; r++) {
          const row = [];
          for (let c = 0; c < columnCount; c++) {
            const v = valueObject.getRealValue(r, c) || (defaultValue != null ? defaultValue : NullValueObject.create());
            row.push(v);
          }
          result.push(row);
        }
      }
    } else {
      for (let r = 0; r < rowCount; r++) {
        const row = [];
        for (let c = 0; c < columnCount; c++) {
          row.push(valueObject);
        }
        result.push(row);
      }
    }
    return createNewArray(result, rowCount, columnCount);
  }
  function createNewArray(result, rowCount, columnCount, unitId = "", sheetId = "") {
    const arrayValueObjectData = {
      calculateValueList: result,
      rowCount,
      columnCount,
      unitId,
      sheetId,
      row: -1,
      column: -1
    };
    return ArrayValueObject.create(arrayValueObjectData);
  }

  // ../packages/engine-formula/src/engine/reference-object/cell-reference-object.ts
  var CellReferenceObject = class extends BaseReferenceObject {
    constructor(token) {
      super(token);
      const grid = deserializeRangeWithSheet(token);
      this.setForcedUnitIdDirect(grid.unitId);
      this.setForcedSheetName(grid.sheetName);
      this.setRangeData(grid.range);
    }
    isCell() {
      return true;
    }
    unionBy(referenceObject) {
      if (!referenceObject.isCell()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const cellReferenceObject = referenceObject;
      const newRangeData = this.unionRange(this.getRangeData(), cellReferenceObject.getRangeData());
      return this._createRange(newRangeData);
    }
    unionRange(rangeData1, rangeData2) {
      const startRow1 = rangeData1.startRow;
      const startColumn1 = rangeData1.startColumn;
      const startRow2 = rangeData2.startRow;
      const startColumn2 = rangeData2.startColumn;
      const range = {
        startRow: -1,
        startColumn: -1,
        endRow: -1,
        endColumn: -1
      };
      if (startRow1 > startRow2) {
        range.startRow = startRow2;
        range.endRow = startRow1;
      } else {
        range.startRow = startRow1;
        range.endRow = startRow2;
      }
      if (startColumn1 > startColumn2) {
        range.startColumn = startColumn2;
        range.endColumn = startColumn1;
      } else {
        range.startColumn = startColumn1;
        range.endColumn = startColumn2;
      }
      return range;
    }
    _createRange(newRangeData) {
      const rangeReferenceObject = new RangeReferenceObject(
        newRangeData,
        this.getForcedSheetId(),
        this.getForcedUnitId()
      );
      rangeReferenceObject.setUnitData(this.getUnitData());
      rangeReferenceObject.setDefaultSheetId(this.getDefaultSheetId());
      rangeReferenceObject.setDefaultUnitId(this.getDefaultUnitId());
      rangeReferenceObject.setRuntimeData(this.getRuntimeData());
      rangeReferenceObject.setNumfmtItemData(this.getNumfmtItemData());
      rangeReferenceObject.setArrayFormulaCellData(this.getArrayFormulaCellData());
      rangeReferenceObject.setRuntimeArrayFormulaCellData(this.getRuntimeArrayFormulaCellData());
      rangeReferenceObject.setRuntimeFeatureCellData(this.getRuntimeFeatureCellData());
      const { x, y } = this.getRefOffset();
      rangeReferenceObject.setRefOffset(x, y);
      const forceSheetId = this.getForcedSheetId();
      rangeReferenceObject.setForcedSheetName(this.getForcedSheetName());
      if (forceSheetId != null) {
        rangeReferenceObject.setForcedSheetIdDirect(forceSheetId);
      }
      const forcedUnitId = this.getForcedUnitId();
      if (forcedUnitId) {
        rangeReferenceObject.setForcedUnitIdDirect(forcedUnitId);
      }
      return rangeReferenceObject;
    }
  };

  // ../packages/engine-formula/src/engine/reference-object/row-reference-object.ts
  var RowReferenceObject = class extends BaseReferenceObject {
    constructor(token) {
      super(token);
      const grid = deserializeRangeWithSheet(token);
      this.setForcedUnitIdDirect(grid.unitId);
      this.setForcedSheetName(grid.sheetName);
      const range = {
        startColumn: Number.NaN,
        startRow: grid.range.startRow,
        endColumn: Number.NaN,
        endRow: -1
      };
      this.setRangeData(range);
    }
    isRow() {
      return true;
    }
    unionBy(referenceObject) {
      if (!referenceObject.isRow()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const rowReferenceObject = referenceObject;
      if (rowReferenceObject.getForcedSheetName() !== void 0 && rowReferenceObject.getForcedSheetName() !== "") {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const currentRangeData = this.getRangeData();
      const newRow = rowReferenceObject.getRangeData().startRow;
      const row = currentRangeData.startRow;
      if (newRow > row) {
        currentRangeData.endRow = newRow;
      } else {
        currentRangeData.startRow = newRow;
        currentRangeData.endRow = row;
      }
      this.setToken(`${this.getToken()}${":" /* COLON */}${rowReferenceObject.getToken()}`);
      return this;
    }
  };

  // ../packages/engine-formula/src/engine/reference-object/column-reference-object.ts
  var ColumnReferenceObject = class extends BaseReferenceObject {
    constructor(token) {
      super(token);
      const grid = deserializeRangeWithSheet(token);
      this.setForcedUnitIdDirect(grid.unitId);
      this.setForcedSheetName(grid.sheetName);
      const range = {
        startColumn: grid.range.startColumn,
        startRow: Number.NaN,
        endColumn: -1,
        endRow: Number.NaN
      };
      this.setRangeData(range);
    }
    isColumn() {
      return true;
    }
    unionBy(referenceObject) {
      if (!referenceObject.isColumn()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const columnReferenceObject = referenceObject;
      if (columnReferenceObject.getForcedSheetName() !== void 0 && columnReferenceObject.getForcedSheetName() !== "") {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const currentRangeData = this.getRangeData();
      const newColumn = columnReferenceObject.getRangeData().startColumn;
      const column = currentRangeData.startColumn;
      if (newColumn > column) {
        currentRangeData.endColumn = newColumn;
      } else {
        currentRangeData.startColumn = newColumn;
        currentRangeData.endColumn = column;
      }
      this.setToken(`${this.getToken()}${":" /* COLON */}${columnReferenceObject.getToken()}`);
      return this;
    }
  };

  // ../packages/engine-formula/src/functions/base-function.ts
  var BaseFunction = class extends Disposable {
    constructor(_name) {
      super();
      this._name = _name;
      __publicField(this, "_unitId");
      __publicField(this, "_subUnitId");
      __publicField(this, "_row", -1);
      __publicField(this, "_column", -1);
      /**
       * Whether the function needs to expand the parameters
       */
      __publicField(this, "needsExpandParams", false);
      /**
       * Whether the function needs to pass in reference object
       */
      __publicField(this, "needsReferenceObject", false);
    }
    get name() {
      return this._name;
    }
    get unitId() {
      return this._unitId;
    }
    get subUnitId() {
      return this._subUnitId;
    }
    get row() {
      return this._row;
    }
    get column() {
      return this._column;
    }
    isAsync() {
      return false;
    }
    isAddress() {
      return false;
    }
    isCustom() {
      return false;
    }
    setRefInfo(unitId, subUnitId, row, column) {
      this._unitId = unitId;
      this._subUnitId = subUnitId;
      this._row = row;
      this._column = column;
    }
    calculateCustom(...arg) {
      return null;
    }
    calculate(...arg) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    checkArrayType(variant) {
      return variant.isReferenceObject() || variant.isValueObject() && variant.isArray();
    }
    /**
     * Starting with 1
     * For instance, The column number (starting with 1 for the left-most column of table_array) that contains the return value.
     * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
     * @param indexNum
     */
    getIndexNumValue(indexNum, defaultValue = 1) {
      if (indexNum.isArray()) {
        indexNum = indexNum.getFirstCell();
      }
      if (indexNum.isBoolean()) {
        const colIndexNumV = indexNum.getValue();
        if (colIndexNumV === false) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        return defaultValue;
      }
      if (indexNum.isString()) {
        const colIndexNumV = Number(indexNum.getValue());
        if (Number.isNaN(colIndexNumV)) {
          return ErrorValueObject.create("#REF!" /* REF */);
        }
        return colIndexNumV;
      } else if (indexNum.isNumber()) {
        const colIndexNumV = indexNum.getValue();
        return colIndexNumV;
      }
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    /**
     * A logical value that specifies 1/TRUE , 0/FALSE, default 1
     * For instance range_lookup, A logical value that specifies whether you want VLOOKUP to find an approximate or an exact match
     * Approximate match - 1/TRUE
     * Exact match - 0/FALSE
     * https://support.microsoft.com/en-us/office/vlookup-function-0bbc8083-26fe-4963-8ab8-93a18ad188a1
     * For instance A1, A logical value that specifies what type of reference is contained in the cell ref_text.
     * If a1 is TRUE or omitted, ref_text is interpreted as an A1-style reference.
     * If a1 is FALSE, ref_text is interpreted as an R1C1-style reference.
     * https://support.microsoft.com/zh-cn/office/indirect-%E5%87%BD%E6%95%B0-474b3a3a-8a26-4f44-b491-92b6306fa261
     * @param logicValueObject
     */
    getZeroOrOneByOneDefault(logicValueObject) {
      if (logicValueObject == null) {
        return 1;
      }
      let logicValue = 1;
      if (logicValueObject.isArray()) {
        logicValueObject = logicValueObject.getFirstCell();
      }
      if (logicValueObject.isBoolean()) {
        const logicV = logicValueObject.getValue();
        if (logicV === false) {
          logicValue = 0;
        }
      } else if (logicValueObject.isString()) {
        return;
      } else if (logicValueObject.isNumber()) {
        const logicV = logicValueObject.getValue();
        if (logicV === 0) {
          logicValue = 0;
        }
      }
      return logicValue;
    }
    /**
     * A logical value that specifies 1/TRUE , 0/FALSE, -1, default 1.
     * The difference from getZeroOrOneByOneDefault is that we need to get -1
     * @param logicValueObject
     */
    getMatchTypeValue(logicValueObject) {
      if (logicValueObject == null) {
        return 1;
      }
      let logicValue = 1;
      if (logicValueObject.isArray()) {
        logicValueObject = logicValueObject.getFirstCell();
      }
      if (logicValueObject.isBoolean()) {
        const logicV = logicValueObject.getValue();
        if (logicV === false) {
          logicValue = 0;
        }
      } else if (logicValueObject.isString()) {
        return;
      } else if (logicValueObject.isNumber()) {
        const logicV = logicValueObject.getValue();
        if (logicV <= 0) {
          logicValue = logicV;
        }
      }
      return logicValue;
    }
    binarySearch(value, searchArray2, resultArray, searchType) {
      const rowOrColumn = searchArray2.binarySearch(value, searchType);
      if (rowOrColumn == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let resultValue;
      if (resultArray.getRowCount() === 1) {
        resultValue = resultArray.get(0, rowOrColumn) || NullValueObject.create();
      } else {
        resultValue = resultArray.get(rowOrColumn, 0) || NullValueObject.create();
      }
      if (resultValue.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return resultValue;
    }
    equalSearch(value, searchArray2, resultArray, isFirst = true) {
      const resultArrayValue = resultArray.pick(searchArray2.isEqual(value));
      let resultValue;
      if (isFirst) {
        resultValue = resultArrayValue.getFirstCell();
      } else {
        resultValue = resultArrayValue.getLastCell();
      }
      if (resultValue.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return resultValue;
    }
    fuzzySearch(value, searchArray2, resultArray, isFirst = true) {
      const resultArrayValue = resultArray.pick(searchArray2.compare(value, "=" /* EQUALS */));
      let resultValue;
      if (isFirst) {
        resultValue = resultArrayValue.getFirstCell();
      } else {
        resultValue = resultArrayValue.getLastCell();
      }
      if (resultValue.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return resultValue;
    }
    orderSearch(value, searchArray2, resultArray, searchType = 1 /* MIN */, isDesc = false) {
      const position = searchArray2.orderSearch(value, searchType, isDesc);
      if (position == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const resultValue = resultArray.get(position.row, position.column) || NullValueObject.create();
      if (resultValue.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return resultValue;
    }
    binarySearchExpand(value, searchArray2, resultArray, axis = 0, searchType) {
      const rowOrColumn = searchArray2.binarySearch(value, searchType);
      if (rowOrColumn == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (axis === 0) {
        return resultArray.slice([rowOrColumn, rowOrColumn + 1]);
      }
      return resultArray.slice(void 0, [rowOrColumn, rowOrColumn + 1]);
    }
    equalSearchExpand(value, searchArray2, resultArray, isFirst = true, axis = 0) {
      const matchObject = searchArray2.isEqual(value);
      let position;
      if (isFirst) {
        position = matchObject.getFirstTruePosition();
      } else {
        position = matchObject.getLastTruePosition();
      }
      if (position == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (axis === 0) {
        return resultArray.slice([position.row, position.row + 1]);
      }
      return resultArray.slice(void 0, [position.column, position.column + 1]);
    }
    fuzzySearchExpand(value, searchArray2, resultArray, isFirst = true, axis = 0) {
      const matchObject = searchArray2.compare(value, "=" /* EQUALS */);
      let position;
      if (isFirst) {
        position = matchObject.getFirstTruePosition();
      } else {
        position = matchObject.getLastTruePosition();
      }
      if (position == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (axis === 0) {
        return resultArray.slice([position.row, position.row + 1]);
      }
      return resultArray.slice(void 0, [position.column, position.column + 1]);
    }
    orderSearchExpand(value, searchArray2, resultArray, searchType = 1 /* MIN */, isDesc = false, axis = 0) {
      const position = searchArray2.orderSearch(value, searchType, isDesc);
      if (position == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (axis === 0) {
        return resultArray.slice([position.row, position.row + 1]);
      }
      return resultArray.slice(void 0, [position.column, position.column + 1]);
    }
    flattenArray(variants, ignoreLogicalValuesAndText = true) {
      const flattenValues = [];
      flattenValues[0] = [];
      for (let i = 0; i < variants.length; i++) {
        let variant = variants[i];
        if (variant.isString() || variant.isBoolean() || variant.isNull()) {
          variant = variant.convertToNumberObjectValue();
        }
        if (variant.isError()) {
          return variant;
        }
        if (variant.isArray()) {
          let errorValue;
          variant.iterator((valueObject) => {
            if (valueObject == null || valueObject.isNull()) {
              return true;
            }
            if (ignoreLogicalValuesAndText && (valueObject.isString() || valueObject.isBoolean())) {
              return true;
            }
            valueObject = this._includingLogicalValuesAndText(valueObject);
            if (valueObject.isError()) {
              errorValue = valueObject;
              return false;
            }
            flattenValues[0].push(valueObject);
          });
          if (errorValue == null ? void 0 : errorValue.isError()) {
            return errorValue;
          }
        } else {
          flattenValues[0].push(variant);
        }
      }
      return createNewArray(flattenValues, 1, flattenValues[0].length);
    }
    _includingLogicalValuesAndText(valueObject) {
      if (valueObject.isBoolean()) {
        valueObject = convertTonNumber(valueObject);
      }
      if (valueObject.isString()) {
        const value = Number(valueObject.getValue());
        valueObject = NumberValueObject.create(Number.isNaN(value) ? 0 : value);
      }
      return valueObject;
    }
    createReferenceObject(reference, range) {
      const unitId = reference.getForcedUnitId();
      const sheetId = reference.getForcedSheetId() || "";
      const sheetName = reference.getForcedSheetName();
      const gridRangeName = {
        unitId,
        sheetName,
        range
      };
      const token = serializeRangeToRefString(gridRangeName);
      let referenceObject;
      if (new RegExp(REFERENCE_SINGLE_RANGE_REGEX).test(token)) {
        referenceObject = new CellReferenceObject(token);
      } else if (new RegExp(REFERENCE_REGEX_SINGLE_ROW).test(token)) {
        referenceObject = new RowReferenceObject(token);
      } else if (new RegExp(REFERENCE_REGEX_SINGLE_COLUMN).test(token)) {
        referenceObject = new ColumnReferenceObject(token);
      } else {
        referenceObject = new RangeReferenceObject(range, sheetId, unitId);
      }
      return this._setReferenceDefault(reference, referenceObject);
      ;
    }
    _setReferenceDefault(reference, object) {
      if (this.unitId == null || this.subUnitId == null) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      object.setDefaultUnitId(this.unitId);
      object.setDefaultSheetId(this.subUnitId);
      object.setUnitData(reference.getUnitData());
      object.setRuntimeData(reference.getRuntimeData());
      object.setArrayFormulaCellData(reference.getArrayFormulaCellData());
      object.setRuntimeArrayFormulaCellData(reference.getRuntimeArrayFormulaCellData());
      return object;
    }
  };

  // ../packages/engine-formula/src/functions/statistical/stdev-p/index.ts
  var StdevP = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const flattenArray = this.flattenArray(variants);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.std();
    }
  };

  // ../packages/engine-formula/src/functions/statistical/stdev-s/index.ts
  var StdevS = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const flattenArray = this.flattenArray(variants);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.std(1);
    }
  };

  // ../packages/engine-formula/src/functions/statistical/var-p/index.ts
  var VarP = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const flattenArray = this.flattenArray(variants);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.var();
    }
  };

  // ../packages/engine-formula/src/functions/statistical/var-s/index.ts
  var VarS = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const flattenArray = this.flattenArray(variants);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.var(1);
    }
  };

  // ../packages/engine-formula/src/functions/compatibility/function-map.ts
  var functionCompatibility = [
    [StdevS, "STDEV" /* STDEV */],
    [StdevP, "STDEVP" /* STDEVP */],
    [VarS, "VAR" /* VAR */],
    [VarP, "VARP" /* VARP */]
  ];

  // ../packages/engine-formula/src/functions/cube/function-map.ts
  var functionCube = [];

  // ../packages/engine-formula/src/functions/database/function-map.ts
  var functionDatabase = [];

  // ../packages/engine-formula/src/basics/date.ts
  var DEFAULT_DATE_FORMAT = "yyyy/mm/dd;@";
  function excelDateSerial(date) {
    const baseDate = new Date(Date.UTC(1900, 0, 1));
    const leapDayDate = new Date(Date.UTC(1900, 1, 28));
    const dateInUTC = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate());
    let dayDifference = (dateInUTC - baseDate.getTime()) / (1e3 * 3600 * 24);
    if (dateInUTC > leapDayDate.getTime()) {
      dayDifference += 1;
    }
    return Math.floor(dayDifference) + 1;
  }
  function excelSerialToDate(serial) {
    const baseDate = new Date(Date.UTC(1900, 0, 1));
    const leapDayDate = new Date(Date.UTC(1900, 1, 28));
    let dayDifference = Math.floor(serial) - 1;
    if (dayDifference > (leapDayDate.getTime() - baseDate.getTime()) / (1e3 * 3600 * 24)) {
      dayDifference -= 1;
    }
    const resultDate = new Date(baseDate.getTime() + dayDifference * (1e3 * 3600 * 24));
    return resultDate;
  }
  function isValidDateStr(dateStr) {
    const regex = /^\d{4}[-/](0?[1-9]|1[012])[-/](0?[1-9]|[12][0-9]|3[01])$/;
    if (!regex.test(dateStr)) {
      return false;
    }
    const normalizedDateStr = dateStr.replace(/-/g, "/").replace(/T.+/, "");
    const dateWithTime = /* @__PURE__ */ new Date(`${normalizedDateStr}`);
    if (Number.isNaN(dateWithTime.getTime())) {
      return false;
    }
    const year = dateWithTime.getFullYear();
    const month = (dateWithTime.getMonth() + 1).toString().padStart(2, "0");
    const day = dateWithTime.getDate().toString().padStart(2, "0");
    const reconstructedDateStr = `${year}-${month}-${day}`;
    const dateStrPad = dateStr.replace(/\//g, "-").split("-").map((v) => v.padStart(2, "0")).join("-");
    return dateStrPad === reconstructedDateStr;
  }

  // ../packages/engine-formula/src/functions/date/date/index.ts
  var DateFunction = class extends BaseFunction {
    calculate(year, month, day) {
      if (year == null || month == null || day == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (year.isError()) {
        return year;
      }
      if (month.isError()) {
        return month;
      }
      if (day.isError()) {
        return day;
      }
      const maxRowLength = Math.max(
        year.isArray() ? year.getRowCount() : 1,
        month.isArray() ? month.getRowCount() : 1,
        day.isArray() ? day.getRowCount() : 1
      );
      const maxColumnLength = Math.max(
        year.isArray() ? year.getColumnCount() : 1,
        month.isArray() ? month.getColumnCount() : 1,
        day.isArray() ? day.getColumnCount() : 1
      );
      const yearArray = expandArrayValueObject(maxRowLength, maxColumnLength, year);
      const monthArray = expandArrayValueObject(maxRowLength, maxColumnLength, month);
      const dayArray = expandArrayValueObject(maxRowLength, maxColumnLength, day);
      return yearArray.map((yearValueObject, rowIndex, columnIndex) => {
        const monthValueObject = monthArray.get(rowIndex, columnIndex) || NullValueObject.create();
        const dayValueObject = dayArray.get(rowIndex, columnIndex) || NullValueObject.create();
        if (yearValueObject.isError()) {
          return yearValueObject;
        }
        if (monthValueObject.isError()) {
          return monthValueObject;
        }
        if (dayValueObject.isError()) {
          return dayValueObject;
        }
        if (yearValueObject.isString() || monthValueObject.isString() || dayValueObject.isString()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        let yearValue = +yearValueObject.getValue();
        const monthValue = Math.floor(+monthValueObject.getValue());
        const dayValue = +dayValueObject.getValue();
        if (yearValue < 0 || yearValue > 9999) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        if (yearValue >= 0 && yearValue < 1899) {
          yearValue += 1900;
        }
        const date = new Date(yearValue, monthValue - 1, dayValue);
        const currentSerial = excelDateSerial(date);
        if (currentSerial < 0) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const valueObject = NumberValueObject.create(currentSerial);
        valueObject.setPattern(DEFAULT_DATE_FORMAT);
        return valueObject;
      });
    }
  };

  // ../packages/engine-formula/src/functions/date/day/index.ts
  var Day = class extends BaseFunction {
    calculate(serialNumber) {
      if (serialNumber == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (serialNumber.isArray()) {
        return serialNumber.map((serialNumberObject) => this._handleSingleObject(serialNumberObject));
      }
      return this._handleSingleObject(serialNumber);
    }
    _handleSingleObject(serialNumberObject) {
      if (serialNumberObject.isError()) {
        return serialNumberObject;
      }
      let date;
      const dateValue = serialNumberObject.getValue();
      if (serialNumberObject.isString()) {
        if (!isValidDateStr(`${dateValue}`)) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        date = /* @__PURE__ */ new Date(`${dateValue}`);
      } else {
        const dateSerial = +serialNumberObject.getValue();
        if (dateSerial < 0) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        if (dateSerial === 0) {
          return NumberValueObject.create(0);
        }
        date = excelSerialToDate(dateSerial);
      }
      const month = date.getDate();
      const valueObject = NumberValueObject.create(month);
      return valueObject;
    }
  };

  // ../packages/engine-formula/src/functions/date/edate/index.ts
  var Edate = class extends BaseFunction {
    calculate(startDate, months) {
      if (startDate == null || months == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (startDate.isError()) {
        return startDate;
      }
      if (months.isError()) {
        return months;
      }
      const maxRowLength = Math.max(
        startDate.isArray() ? startDate.getRowCount() : 1,
        months.isArray() ? months.getRowCount() : 1
      );
      const maxColumnLength = Math.max(
        startDate.isArray() ? startDate.getColumnCount() : 1,
        months.isArray() ? months.getColumnCount() : 1
      );
      const startDateArray = expandArrayValueObject(maxRowLength, maxColumnLength, startDate);
      const monthsArray = expandArrayValueObject(maxRowLength, maxColumnLength, months);
      return startDateArray.map((startDateObject, rowIndex, columnIndex) => {
        const monthsValueObject = monthsArray.get(rowIndex, columnIndex) || NullValueObject.create();
        if (startDateObject.isError()) {
          return startDateObject;
        }
        if (monthsValueObject.isError()) {
          return monthsValueObject;
        }
        if (startDateObject.isString() || startDateObject.isBoolean() || monthsValueObject.isString() || monthsValueObject.isBoolean()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        const startDateSerial = +startDateObject.getValue();
        if (startDateSerial < 0) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        const monthsValue = Math.floor(+monthsValueObject.getValue());
        const startDate2 = excelSerialToDate(startDateSerial);
        const year = startDate2.getUTCFullYear();
        const month = startDate2.getUTCMonth() + monthsValue;
        const day = startDate2.getUTCDate();
        const resultDate = new Date(Date.UTC(year, month, day));
        const currentSerial = excelDateSerial(resultDate);
        const valueObject = NumberValueObject.create(currentSerial);
        valueObject.setPattern(DEFAULT_DATE_FORMAT);
        return valueObject;
      });
    }
  };

  // ../packages/engine-formula/src/functions/date/month/index.ts
  var Month = class extends BaseFunction {
    calculate(serialNumber) {
      if (serialNumber == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (serialNumber.isArray()) {
        return serialNumber.map((serialNumberObject) => this._handleSingleObject(serialNumberObject));
      }
      return this._handleSingleObject(serialNumber);
    }
    _handleSingleObject(serialNumberObject) {
      if (serialNumberObject.isError()) {
        return serialNumberObject;
      }
      let date;
      const dateValue = serialNumberObject.getValue();
      if (serialNumberObject.isString()) {
        if (!isValidDateStr(`${dateValue}`)) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        date = /* @__PURE__ */ new Date(`${dateValue}`);
      } else {
        const dateSerial = +serialNumberObject.getValue();
        if (dateSerial < 0) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        if (dateSerial === 0) {
          return NumberValueObject.create(1);
        }
        date = excelSerialToDate(dateSerial);
      }
      const month = date.getUTCMonth() + 1;
      const valueObject = NumberValueObject.create(month);
      return valueObject;
    }
  };

  // ../packages/engine-formula/src/functions/date/today/index.ts
  var Today = class extends BaseFunction {
    calculate(value) {
      if (value) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const currentSerial = excelDateSerial(/* @__PURE__ */ new Date());
      const valueObject = NumberValueObject.create(currentSerial);
      valueObject.setPattern(DEFAULT_DATE_FORMAT);
      return valueObject;
    }
  };

  // ../packages/engine-formula/src/functions/date/year/index.ts
  var Year = class extends BaseFunction {
    calculate(serialNumber) {
      if (serialNumber == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (serialNumber.isArray()) {
        return serialNumber.map((serialNumberObject) => this._handleSingleObject(serialNumberObject));
      }
      return this._handleSingleObject(serialNumber);
    }
    _handleSingleObject(serialNumberObject) {
      if (serialNumberObject.isError()) {
        return serialNumberObject;
      }
      let date;
      const dateValue = serialNumberObject.getValue();
      if (serialNumberObject.isString()) {
        if (!isValidDateStr(`${dateValue}`)) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        date = /* @__PURE__ */ new Date(`${dateValue}`);
      } else {
        const dateSerial = +dateValue;
        if (dateSerial < 0) {
          return ErrorValueObject.create("#NUM!" /* NUM */);
        }
        if (dateSerial === 0) {
          return NumberValueObject.create(1900);
        }
        date = excelSerialToDate(dateSerial);
      }
      const year = date.getUTCFullYear();
      const valueObject = NumberValueObject.create(year);
      return valueObject;
    }
  };

  // ../packages/engine-formula/src/functions/date/function-map.ts
  var functionDate = [
    [DateFunction, "DATE" /* DATE */],
    [Day, "DAY" /* DAY */],
    [Edate, "EDATE" /* EDATE */],
    [Month, "MONTH" /* MONTH */],
    [Today, "TODAY" /* TODAY */],
    [Year, "YEAR" /* YEAR */]
  ];

  // ../packages/engine-formula/src/functions/engineering/function-map.ts
  var functionEngineering = [];

  // ../packages/engine-formula/src/functions/financial/function-map.ts
  var functionFinancial = [];

  // ../packages/engine-formula/src/functions/information/isblank/index.ts
  var Isblank = class extends BaseFunction {
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.isNull()) {
        return BooleanValueObject.create(true);
      } else if (value.isArray()) {
        return value.mapValue((valueObject) => {
          if (valueObject.isNull()) {
            return BooleanValueObject.create(true);
          }
          return BooleanValueObject.create(false);
        });
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/iserr/index.ts
  var Iserr = class extends BaseFunction {
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.getValue() === "#N/A" /* NA */) {
        return BooleanValueObject.create(false);
      }
      if (value.isError()) {
        return BooleanValueObject.create(true);
      } else if (value.isArray()) {
        return value.mapValue((valueObject) => {
          if (valueObject.getValue() === "#N/A" /* NA */) {
            return BooleanValueObject.create(false);
          }
          if (valueObject.isError()) {
            return BooleanValueObject.create(true);
          }
          return BooleanValueObject.create(false);
        });
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/iserror/index.ts
  var Iserror = class extends BaseFunction {
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.isError()) {
        return BooleanValueObject.create(true);
      } else if (value.isArray()) {
        return value.mapValue((valueObject) => {
          if (valueObject.isError()) {
            return BooleanValueObject.create(true);
          }
          return BooleanValueObject.create(false);
        });
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/islogical/index.ts
  var Islogical = class extends BaseFunction {
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.isBoolean()) {
        return BooleanValueObject.create(true);
      } else if (value.isArray()) {
        return value.mapValue((valueObject) => {
          if (valueObject.isBoolean()) {
            return BooleanValueObject.create(true);
          }
          return BooleanValueObject.create(false);
        });
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/isna/index.ts
  var Isna = class extends BaseFunction {
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.getValue() === "#N/A" /* NA */) {
        return BooleanValueObject.create(true);
      } else if (value.isArray()) {
        return value.mapValue((valueObject) => {
          if (valueObject.getValue() === "#N/A" /* NA */) {
            return BooleanValueObject.create(true);
          }
          return BooleanValueObject.create(false);
        });
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/isnontext/index.ts
  var Isnontext = class extends BaseFunction {
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (!value.isArray() && !value.isString()) {
        return BooleanValueObject.create(true);
      } else if (value.isArray()) {
        return value.mapValue((valueObject) => {
          if (!valueObject.isString()) {
            return BooleanValueObject.create(true);
          }
          return BooleanValueObject.create(false);
        });
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/isnumber/index.ts
  var Isnumber = class extends BaseFunction {
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.isNumber()) {
        return BooleanValueObject.create(true);
      } else if (value.isArray()) {
        return value.mapValue((valueObject) => {
          if (valueObject.isNumber()) {
            return BooleanValueObject.create(true);
          }
          return BooleanValueObject.create(false);
        });
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/isref/index.ts
  var Isref = class extends BaseFunction {
    constructor() {
      super(...arguments);
      __publicField(this, "needsReferenceObject", true);
    }
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.isReferenceObject()) {
        return BooleanValueObject.create(true);
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/istext/index.ts
  var Istext = class extends BaseFunction {
    calculate(value) {
      if (value == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.isString()) {
        return BooleanValueObject.create(true);
      } else if (value.isArray()) {
        return value.mapValue((valueObject) => {
          if (valueObject.isString()) {
            return BooleanValueObject.create(true);
          }
          return BooleanValueObject.create(false);
        });
      }
      return BooleanValueObject.create(false);
    }
  };

  // ../packages/engine-formula/src/functions/information/function-map.ts
  var functionInformation = [
    [Isblank, "ISBLANK" /* ISBLANK */],
    [Iserr, "ISERR" /* ISERR */],
    [Iserror, "ISERROR" /* ISERROR */],
    [Islogical, "ISLOGICAL" /* ISLOGICAL */],
    [Isna, "ISNA" /* ISNA */],
    [Isnontext, "ISNONTEXT" /* ISNONTEXT */],
    [Isnumber, "ISNUMBER" /* ISNUMBER */],
    [Isref, "ISREF" /* ISREF */],
    [Istext, "ISTEXT" /* ISTEXT */]
  ];

  // ../packages/engine-formula/src/functions/logical/and/index.ts
  var And = class extends BaseFunction {
    calculate(...logicalValues) {
      if (logicalValues.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let result = true;
      let noBoolean = true;
      let errorValue = null;
      for (const logicalValue of logicalValues) {
        if (logicalValue.isError()) {
          return logicalValue;
        }
        if (logicalValue.isArray()) {
          logicalValue.iterator((value) => {
            if (value == null ? void 0 : value.isError()) {
              errorValue = value;
              return false;
            } else if ((value == null ? void 0 : value.isBoolean()) || (value == null ? void 0 : value.isNumber())) {
              result = result && !!value.getValue();
              noBoolean = false;
            }
          });
          if (errorValue) {
            return errorValue;
          }
        } else if (logicalValue.isBoolean() || logicalValue.isNumber()) {
          result = result && !!logicalValue.getValue();
          noBoolean = false;
        }
      }
      return noBoolean ? ErrorValueObject.create("#VALUE!" /* VALUE */) : BooleanValueObject.create(result);
    }
  };

  // ../packages/engine-formula/src/functions/logical/if/index.ts
  var If = class extends BaseFunction {
    calculate(logicalTest, valueIfTrue, valueIfFalse = BooleanValueObject.create(false)) {
      if (logicalTest == null || valueIfTrue == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (logicalTest.isError()) {
        return logicalTest;
      }
      if (valueIfTrue.isError()) {
        return valueIfTrue;
      }
      logicalTest = this._getSingleValueObject(logicalTest);
      if (!logicalTest.isArray()) {
        return logicalTest.getValue() ? valueIfTrue : valueIfFalse;
      }
      const maxRowLength = Math.max(
        logicalTest.isArray() ? logicalTest.getRowCount() : 1,
        valueIfTrue.isArray() ? valueIfTrue.getRowCount() : 1,
        valueIfFalse.isArray() ? valueIfFalse.getRowCount() : 1
      );
      const maxColumnLength = Math.max(
        logicalTest.isArray() ? logicalTest.getColumnCount() : 1,
        valueIfTrue.isArray() ? valueIfTrue.getColumnCount() : 1,
        valueIfFalse.isArray() ? valueIfFalse.getColumnCount() : 1
      );
      const logicalTestArray = expandArrayValueObject(maxRowLength, maxColumnLength, logicalTest);
      const valueIfTrueArray = expandArrayValueObject(maxRowLength, maxColumnLength, valueIfTrue, ErrorValueObject.create("#N/A" /* NA */));
      const valueIfFalseArray = expandArrayValueObject(maxRowLength, maxColumnLength, valueIfFalse, ErrorValueObject.create("#N/A" /* NA */));
      return logicalTestArray.map((logicalTestValue, rowIndex, columnIndex) => {
        if (logicalTestValue.isNull()) {
          return ErrorValueObject.create("#N/A" /* NA */);
        } else {
          const valueIfTrueValue = valueIfTrueArray.get(rowIndex, columnIndex) || NullValueObject.create();
          const valueIfFalseValue = valueIfFalseArray.get(rowIndex, columnIndex) || NullValueObject.create();
          return this._calculateSingleCell(logicalTestValue, valueIfTrueValue, valueIfFalseValue);
        }
      });
    }
    _getSingleValueObject(valueObject) {
      if (valueObject.isArray() && valueObject.getRowCount() === 1 && valueObject.getColumnCount() === 1) {
        return valueObject.getFirstCell();
      }
      return valueObject;
    }
    _calculateSingleCell(logicalTest, valueIfTrue, valueIfFalse) {
      if (logicalTest.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const logicalTestValue = logicalTest.getValue();
      if (logicalTestValue) {
        if (valueIfTrue.isNull()) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
        return valueIfTrue;
      }
      if (valueIfFalse.isNull()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return valueIfFalse;
    }
  };

  // ../packages/engine-formula/src/functions/logical/iferror/index.ts
  var Iferror = class extends BaseFunction {
    calculate(value, valueIfError) {
      if (value == null || valueIfError == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (value.isError()) {
        return value;
      }
      if (valueIfError.isError()) {
        return valueIfError;
      }
      if (!value.isArray()) {
        return value.isError() ? valueIfError : value;
      }
      const maxRowLength = Math.max(
        value.isArray() ? value.getRowCount() : 1,
        valueIfError.isArray() ? valueIfError.getRowCount() : 1
      );
      const maxColumnLength = Math.max(
        value.isArray() ? value.getColumnCount() : 1,
        valueIfError.isArray() ? valueIfError.getColumnCount() : 1
      );
      const valueArray = expandArrayValueObject(maxRowLength, maxColumnLength, value);
      const valueIfErrorArray = expandArrayValueObject(maxRowLength, maxColumnLength, valueIfError);
      valueArray.iterator((value2, rowIndex, columnIndex) => {
        if (value2 == null ? void 0 : value2.isError()) {
          valueArray.set(rowIndex, columnIndex, valueIfErrorArray.get(rowIndex, columnIndex));
        }
      });
      return valueArray;
    }
  };

  // ../packages/engine-formula/src/functions/logical/lambda/index.ts
  var Lambda = class extends BaseFunction {
    calculate(...variants) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };

  // ../packages/engine-formula/src/functions/logical/makearray/index.ts
  var Makearray = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length !== 3) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const row = this.getIndexNumValue(variants[0]);
      if (typeof row !== "number") {
        return row;
      }
      const column = this.getIndexNumValue(variants[1]);
      if (typeof column !== "number") {
        return column;
      }
      if (!(variants[2].isValueObject() && variants[2].isLambda())) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const lambda = variants[2];
      const result = [];
      for (let r = 0; r < row; r++) {
        if (result[r] == null) {
          result[r] = [];
        }
        for (let c = 0; c < column; c++) {
          const value = lambda.execute(NumberValueObject.create(r + 1), NumberValueObject.create(c + 1));
          result[r][c] = value;
        }
      }
      return new AsyncArrayObject(result);
    }
    isAsync() {
      return true;
    }
  };

  // ../packages/engine-formula/src/functions/logical/or/index.ts
  var Or = class extends BaseFunction {
    calculate(...logicalValues) {
      if (logicalValues.length === 0) {
        return new ErrorValueObject("#N/A" /* NA */);
      }
      let result = false;
      let noBoolean = true;
      let errorValue = null;
      for (const logicalValue of logicalValues) {
        if (logicalValue.isError()) {
          return logicalValue;
        }
        if (logicalValue.isArray()) {
          logicalValue.iterator((value) => {
            if (value == null ? void 0 : value.isError()) {
              errorValue = value;
              return false;
            } else if ((value == null ? void 0 : value.isBoolean()) || (value == null ? void 0 : value.isNumber())) {
              result = result || !!value.getValue();
              noBoolean = false;
            }
          });
          if (errorValue) {
            return errorValue;
          }
        } else if (logicalValue.isBoolean() || logicalValue.isNumber()) {
          result = result || !!logicalValue.getValue();
          noBoolean = false;
        }
      }
      return noBoolean ? new ErrorValueObject("#VALUE!" /* VALUE */) : new BooleanValueObject(result);
    }
  };

  // ../packages/engine-formula/src/functions/logical/function-map.ts
  var functionLogical = [
    [And, "AND" /* AND */],
    [If, "IF" /* IF */],
    [Lambda, "LAMBDA" /* LAMBDA */],
    [Makearray, "MAKEARRAY" /* MAKEARRAY */],
    [Or, "OR" /* OR */],
    [Iferror, "IFERROR" /* IFERROR */]
  ];

  // ../packages/engine-formula/src/functions/lookup/address/index.ts
  var Address = class extends BaseFunction {
    calculate(rowNumber, columnNumber, absNumber, a1, sheetText) {
      if (rowNumber == null || columnNumber == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (rowNumber.isError()) {
        return rowNumber;
      }
      if (columnNumber.isError()) {
        return columnNumber;
      }
      if (absNumber == null ? void 0 : absNumber.isError()) {
        return absNumber;
      }
      if (a1 == null ? void 0 : a1.isError()) {
        return a1;
      }
      if (sheetText == null ? void 0 : sheetText.isError()) {
        return sheetText;
      }
      const row = Number(rowNumber.getValue()) - 1;
      const column = Number(columnNumber.getValue()) - 1;
      if (Number.isNaN(row) || Number.isNaN(column)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const absType = absNumber ? transformAbsoluteRefType(absNumber.getValue()) : 3 /* ALL */;
      const a1Value = this.getZeroOrOneByOneDefault(a1);
      const sheetTextValue = sheetText ? `${sheetText.getValue()}` : "";
      const sheetName = needsQuoting(sheetTextValue) ? `'${sheetTextValue}'` : sheetTextValue;
      const range = {
        startRow: row,
        startColumn: column,
        endRow: row,
        endColumn: column,
        startAbsoluteRefType: absType,
        endAbsoluteRefType: absType
      };
      const rangeString = a1 && !a1Value ? serializeRangeToR1C1(range) : serializeRange(range);
      return StringValueObject.create(sheetName !== "" ? `${sheetName}!${rangeString}` : rangeString);
    }
  };
  function transformAbsoluteRefType(number) {
    switch (number) {
      case 1:
        return 3 /* ALL */;
      case 2:
        return 1 /* ROW */;
      case 3:
        return 2 /* COLUMN */;
      case 4:
        return 0 /* NONE */;
      default:
        return 3 /* ALL */;
    }
  }

  // ../packages/engine-formula/src/functions/lookup/column/index.ts
  var Column = class extends BaseFunction {
    calculate(reference) {
      if (reference == null) {
        return NumberValueObject.create(this.column + 1);
      }
      if (reference.isError()) {
        return reference;
      }
      if (!reference.isArray()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const column = reference.getCurrentColumn();
      const columnCount = reference.getColumnCount();
      const calculateValueList = [];
      for (let i = 0; i < columnCount; i++) {
        calculateValueList.push(NumberValueObject.create(column + i + 1));
      }
      const arrayValueObjectData = {
        calculateValueList: [calculateValueList],
        rowCount: 1,
        columnCount,
        unitId: this.unitId || "",
        sheetId: this.subUnitId || "",
        row: this.row,
        column: this.column
      };
      return ArrayValueObject.create(arrayValueObjectData);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/columns/index.ts
  var Columns = class extends BaseFunction {
    calculate(reference) {
      if (reference == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (reference.isError()) {
        return reference;
      }
      if (reference.isString() || reference.isNumber() || reference.isBoolean()) {
        return NumberValueObject.create(1);
      }
      if (!reference.isArray()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const columnCount = reference.getColumnCount();
      return NumberValueObject.create(columnCount);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/hlookup/index.ts
  var Hlookup = class extends BaseFunction {
    calculate(lookupValue, tableArray, rowIndexNum, rangeLookup) {
      if (lookupValue == null || tableArray == null || rowIndexNum == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (lookupValue.isError()) {
        return lookupValue;
      }
      if (tableArray.isError()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!tableArray.isArray()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (rowIndexNum.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (rangeLookup == null ? void 0 : rangeLookup.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const rangeLookupValue = this.getZeroOrOneByOneDefault(rangeLookup);
      if (rangeLookupValue == null) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const rowIndexNumValue = this.getIndexNumValue(rowIndexNum);
      if (rowIndexNumValue instanceof ErrorValueObject) {
        return rowIndexNumValue;
      }
      const searchArray2 = tableArray.slice([0, 1]);
      const resultArray = tableArray.slice([rowIndexNumValue - 1, rowIndexNumValue]);
      if (searchArray2 == null || resultArray == null) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (lookupValue.isArray()) {
        return lookupValue.map((value) => this._handleSingleObject(value, searchArray2, resultArray, rangeLookupValue));
      }
      return this._handleSingleObject(lookupValue, searchArray2, resultArray, rangeLookupValue);
    }
    _handleSingleObject(value, searchArray2, resultArray, rangeLookupValue) {
      if (rangeLookupValue === 0) {
        return this.equalSearch(value, searchArray2, resultArray);
      }
      return this.binarySearch(value, searchArray2, resultArray);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/indirect/index.ts
  var Indirect = class extends BaseFunction {
    calculate(refText, a1) {
      if (refText == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (refText.isError()) {
        return refText;
      }
      let a1Value = this.getZeroOrOneByOneDefault(a1);
      if (a1Value == null) {
        a1Value = 1;
      }
      if (refText.isArray()) {
        const refTextArray = refText;
        if (refTextArray.getRowCount() === 1 && refTextArray.getColumnCount() === 1) {
          refText = refTextArray.getFirstCell();
        } else {
          return refTextArray.map(() => {
            return ErrorValueObject.create("#VALUE!" /* VALUE */);
          });
        }
      }
      if (!refText.isString()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const refTextV = refText.getValue();
      if (a1Value === 0) {
        const gridRange2 = deserializeRangeForR1C1(refTextV);
        const { range: range2, sheetName: sheetName2, unitId: unitId2 } = gridRange2;
        const rangeReferenceObject2 = new RangeReferenceObject(range2);
        rangeReferenceObject2.setForcedUnitIdDirect(unitId2);
        rangeReferenceObject2.setForcedSheetName(sheetName2);
        return this._setDefault(rangeReferenceObject2);
      }
      if (new RegExp(REFERENCE_SINGLE_RANGE_REGEX).test(refTextV)) {
        return this._setDefault(new CellReferenceObject(refTextV));
      }
      if (new RegExp(REFERENCE_REGEX_ROW).test(refTextV)) {
        return this._setDefault(new RowReferenceObject(refTextV));
      }
      if (new RegExp(REFERENCE_REGEX_COLUMN).test(refTextV)) {
        return this._setDefault(new ColumnReferenceObject(refTextV));
      }
      const gridRange = deserializeRangeWithSheet(refTextV);
      const { range, sheetName, unitId } = gridRange;
      const rangeReferenceObject = new RangeReferenceObject(range);
      rangeReferenceObject.setForcedUnitIdDirect(unitId);
      rangeReferenceObject.setForcedSheetName(sheetName);
      return this._setDefault(rangeReferenceObject);
    }
    _setDefault(object) {
      if (this.unitId == null || this.subUnitId == null) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      object.setDefaultUnitId(this.unitId);
      object.setDefaultSheetId(this.subUnitId);
      return object;
    }
  };

  // ../packages/engine-formula/src/functions/lookup/lookup/index.ts
  var Lookup = class extends BaseFunction {
    constructor() {
      super(...arguments);
      __publicField(this, "needsExpandParams", true);
    }
    calculate(lookupValue, lookupVectorOrArray, resultVector) {
      if (lookupValue == null || lookupVectorOrArray == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (lookupValue.isError()) {
        return lookupValue;
      }
      if (lookupVectorOrArray.isError()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!lookupVectorOrArray.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (resultVector == null ? void 0 : resultVector.isError()) {
        return resultVector;
      }
      if (lookupVectorOrArray.getColumnCount() === 1 || lookupVectorOrArray.getRowCount() === 1) {
        if (resultVector != null && !resultVector.isArray()) {
          return ErrorValueObject.create("#REF!" /* REF */);
        }
        return this._handleVector(lookupValue, lookupVectorOrArray, resultVector);
      }
      return this._handleArray(lookupValue, lookupVectorOrArray);
    }
    _handleVector(lookupValue, lookupVector, resultVector) {
      if (resultVector == null) {
        resultVector = lookupVector;
      } else if (resultVector.getRowCount() !== lookupVector.getRowCount() || resultVector.getColumnCount() !== lookupVector.getColumnCount()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (lookupValue.isArray()) {
        return lookupValue.map((value) => {
          return this.binarySearch(value, lookupVector, resultVector);
        });
      }
      return this.binarySearch(lookupValue, lookupVector, resultVector);
    }
    _handleArray(lookupValue, lookupArray) {
      const rowCount = lookupArray.getRowCount();
      const columnCount = lookupArray.getColumnCount();
      let searchArray2;
      let resultArray;
      if (columnCount > rowCount) {
        searchArray2 = lookupArray.slice([0, 1]);
        resultArray = lookupArray.slice([rowCount - 1, rowCount]);
      } else {
        searchArray2 = lookupArray.slice(void 0, [0, 1]);
        resultArray = lookupArray.slice(void 0, [columnCount - 1, columnCount]);
      }
      if (searchArray2 == null || resultArray == null) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (lookupValue.isArray()) {
        return lookupValue.map((value) => {
          return this.binarySearch(value, searchArray2, resultArray);
        });
      }
      return this.binarySearch(lookupValue, searchArray2, resultArray);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/match/index.ts
  var Match = class extends BaseFunction {
    calculate(lookupValue, lookupArray, matchType) {
      if (lookupValue == null || lookupArray == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (lookupValue.isError()) {
        return lookupValue;
      }
      if (lookupArray.isError()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!lookupArray.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const rowCountLookup = lookupArray.getRowCount();
      const columnCountLookup = lookupArray.getColumnCount();
      if (rowCountLookup !== 1 && columnCountLookup !== 1) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (matchType == null ? void 0 : matchType.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const matchTypeValue = this.getMatchTypeValue(matchType);
      if (matchTypeValue == null) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (lookupValue.isArray()) {
        return lookupValue.map((value) => this._handleSingleObject(
          value,
          lookupArray,
          matchTypeValue
        ));
      }
      return this._handleSingleObject(
        lookupValue,
        lookupArray,
        matchTypeValue
      );
    }
    _handleSingleObject(value, searchArray2, matchTypeValue) {
      const searchType = this._getSearchModeValue(matchTypeValue);
      const result = searchArray2.orderSearch(value, searchType);
      if (result == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (result instanceof ErrorValueObject) {
        return result;
      }
      const resultNumber = searchArray2.getRowCount() === 1 ? result.column + 1 : result.row + 1;
      return NumberValueObject.create(resultNumber);
    }
    _getSearchModeValue(searchModeValue) {
      switch (searchModeValue) {
        case 1:
          return 1 /* MIN */;
        case 0:
          return 0 /* NORMAL */;
        case -1:
          return 2 /* MAX */;
      }
    }
  };

  // ../packages/engine-formula/src/functions/lookup/offset/index.ts
  var Offset = class extends BaseFunction {
    constructor() {
      super(...arguments);
      __publicField(this, "needsReferenceObject", true);
    }
    calculate(reference, rows, columns, height, width) {
      if (reference == null || rows == null || columns == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (reference.isError()) {
        return reference;
      }
      if (rows.isError()) {
        return rows;
      }
      if (columns.isError()) {
        return columns;
      }
      if (height == null ? void 0 : height.isError()) {
        return height;
      }
      if (width == null ? void 0 : width.isError()) {
        return width;
      }
      if (!reference.isReferenceObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      reference = reference;
      const rowCount = reference.getRowCount();
      const columnCount = reference.getColumnCount();
      if (rows.isReferenceObject()) {
        rows = rows.toArrayValueObject();
      }
      if (columns.isReferenceObject()) {
        columns = columns.toArrayValueObject();
      }
      if (!height) {
        height = NumberValueObject.create(rowCount);
      } else if (height.isReferenceObject()) {
        height = height.toArrayValueObject();
      }
      if (!width) {
        width = NumberValueObject.create(columnCount);
      } else if (width.isReferenceObject()) {
        width = width.toArrayValueObject();
      }
      const maxRowLength = Math.max(
        rows.isArray() ? rows.getRowCount() : 1,
        columns.isArray() ? columns.getRowCount() : 1,
        height.isArray() ? height.getRowCount() : 1,
        width.isArray() ? width.getRowCount() : 1
      );
      const maxColumnLength = Math.max(
        rows.isArray() ? rows.getColumnCount() : 1,
        columns.isArray() ? columns.getColumnCount() : 1,
        height.isArray() ? height.getColumnCount() : 1,
        width.isArray() ? width.getColumnCount() : 1
      );
      rows = rows;
      columns = columns;
      height = height;
      width = width;
      if (maxRowLength === 1 && maxColumnLength === 1) {
        return this._handleSingleObject(reference, rows, columns, height, width);
      }
      const rowsArray = expandArrayValueObject(maxRowLength, maxColumnLength, rows, ErrorValueObject.create("#N/A" /* NA */));
      const columnsArray = expandArrayValueObject(maxRowLength, maxColumnLength, columns, ErrorValueObject.create("#N/A" /* NA */));
      const heightArray = expandArrayValueObject(maxRowLength, maxColumnLength, height, ErrorValueObject.create("#N/A" /* NA */));
      const widthArray = expandArrayValueObject(maxRowLength, maxColumnLength, width, ErrorValueObject.create("#N/A" /* NA */));
      return rowsArray.mapValue((rowsValue, rowIndex, columnIndex) => {
        const columnsValue = columnsArray.get(rowIndex, columnIndex);
        const heightValue = heightArray.get(rowIndex, columnIndex);
        const widthValue = widthArray.get(rowIndex, columnIndex);
        if (rowsValue.isError()) {
          return rowsValue;
        }
        if (columnsValue.isError()) {
          return columnsValue;
        }
        if (heightValue.isError()) {
          return heightValue;
        }
        if (widthValue.isError()) {
          return widthValue;
        }
        return this._handleSingleObject(reference, rowsValue, columnsValue, heightValue, widthValue, true);
      });
    }
    _handleSingleObject(reference, rowsValue, columnsValue, heightValue, widthValue, isReportError = false) {
      const { startRow: referenceStartRow, startColumn: referenceStartColumn } = reference.getRangeData();
      const rowOffset = this.getIndexNumValue(rowsValue);
      const columnOffset = this.getIndexNumValue(columnsValue);
      if (typeof rowOffset !== "number" || typeof columnOffset !== "number") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const targetRow = referenceStartRow + rowOffset;
      const targetColumn = referenceStartColumn + columnOffset;
      if (targetRow < 0 || targetColumn < 0) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const heightCount = this.getIndexNumValue(heightValue);
      const widthCount = this.getIndexNumValue(widthValue);
      if (typeof heightCount !== "number" || typeof widthCount !== "number") {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (heightCount === 0 || widthCount === 0) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const targetRowWithHeight = heightCount > 0 ? targetRow + heightCount - 1 : targetRow + heightCount + 1;
      const targetColumnWithWidth = widthCount > 0 ? targetColumn + widthCount - 1 : targetColumn + widthCount + 1;
      if (targetRowWithHeight < 0 || targetColumnWithWidth < 0) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (isReportError) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const startRow = targetRow < targetRowWithHeight ? targetRow : targetRowWithHeight;
      const startColumn = targetColumn < targetColumnWithWidth ? targetColumn : targetColumnWithWidth;
      const endRow = targetRow > targetRowWithHeight ? targetRow : targetRowWithHeight;
      const endColumn = targetColumn > targetColumnWithWidth ? targetColumn : targetColumnWithWidth;
      const range = {
        startRow,
        startColumn,
        endRow,
        endColumn
      };
      return this.createReferenceObject(reference, range);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/row/index.ts
  var Row = class extends BaseFunction {
    calculate(reference) {
      if (reference == null) {
        return NumberValueObject.create(this.row + 1);
      }
      if (reference.isError()) {
        return reference;
      }
      if (!reference.isArray()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const row = reference.getCurrentRow();
      const rowCount = reference.getRowCount();
      const calculateValueList = [];
      for (let i = 0; i < rowCount; i++) {
        calculateValueList.push([NumberValueObject.create(row + i + 1)]);
      }
      const arrayValueObjectData = {
        calculateValueList,
        rowCount,
        columnCount: 1,
        unitId: this.unitId || "",
        sheetId: this.subUnitId || "",
        row: this.row,
        column: this.column
      };
      return ArrayValueObject.create(arrayValueObjectData);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/rows/index.ts
  var Rows = class extends BaseFunction {
    calculate(reference) {
      if (reference == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (reference.isError()) {
        return reference;
      }
      if (reference.isString() || reference.isNumber() || reference.isBoolean()) {
        return NumberValueObject.create(1);
      }
      if (!reference.isArray()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const rowCount = reference.getRowCount();
      return NumberValueObject.create(rowCount);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/vlookup/index.ts
  var Vlookup = class extends BaseFunction {
    calculate(lookupValue, tableArray, colIndexNum, rangeLookup) {
      if (lookupValue == null || tableArray == null || colIndexNum == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (lookupValue.isError()) {
        return lookupValue;
      }
      if (tableArray.isError()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!tableArray.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (colIndexNum.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (rangeLookup == null ? void 0 : rangeLookup.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      rangeLookup = rangeLookup != null ? rangeLookup : BooleanValueObject.create(true);
      if (isSingleValueObject(lookupValue) && isSingleValueObject(rangeLookup) && colIndexNum.isArray()) {
        lookupValue = lookupValue.isArray() ? lookupValue.getFirstCell() : lookupValue;
        const rangeLookupValue = this.getZeroOrOneByOneDefault(rangeLookup);
        if (rangeLookupValue == null) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        let errorValue;
        const result = [];
        colIndexNum.iterator((colIndexNumValueObject, rowIndex, columnIndex) => {
          if (colIndexNumValueObject === null || colIndexNumValueObject === void 0) {
            errorValue = ErrorValueObject.create("#VALUE!" /* VALUE */);
            return false;
          }
          const searchObject = this._handleTableArray(lookupValue, tableArray, colIndexNumValueObject, rangeLookupValue);
          if (searchObject.isError()) {
            errorValue = searchObject;
            return false;
          }
          if (result[rowIndex] === void 0) {
            result[rowIndex] = [];
          }
          result[rowIndex][columnIndex] = searchObject;
        });
        if (errorValue) {
          return errorValue;
        }
        return createNewArray(result, result.length, result[0].length, this.unitId || "", this.subUnitId || "");
      }
      const maxRowLength = Math.max(
        lookupValue.isArray() ? lookupValue.getRowCount() : 1,
        rangeLookup.isArray() ? rangeLookup.getRowCount() : 1
      );
      const maxColumnLength = Math.max(
        lookupValue.isArray() ? lookupValue.getColumnCount() : 1,
        rangeLookup.isArray() ? rangeLookup.getColumnCount() : 1
      );
      const lookupValueArray = expandArrayValueObject(maxRowLength, maxColumnLength, lookupValue);
      const rangeLookupArray = expandArrayValueObject(maxRowLength, maxColumnLength, rangeLookup);
      return lookupValueArray.map((lookupValue2, rowIndex, columnIndex) => {
        if (lookupValue2.isError()) {
          return lookupValue2;
        }
        const rangeLookupValueObject = rangeLookupArray.get(rowIndex, columnIndex);
        if (rangeLookupValueObject == null) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        if (rangeLookupValueObject.isError()) {
          return rangeLookupValueObject;
        }
        const rangeLookupValue = this.getZeroOrOneByOneDefault(rangeLookupValueObject);
        if (rangeLookupValue == null) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        return this._handleTableArray(lookupValue2, tableArray, colIndexNum, rangeLookupValue);
      });
    }
    _handleTableArray(lookupValue, tableArray, colIndexNum, rangeLookupValue) {
      const colIndexNumValue = this.getIndexNumValue(colIndexNum);
      if (colIndexNumValue instanceof ErrorValueObject) {
        return colIndexNumValue;
      }
      const searchArray2 = tableArray.slice(void 0, [0, 1]);
      if (searchArray2 == null) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const resultArray = tableArray.slice(void 0, [colIndexNumValue - 1, colIndexNumValue]);
      if (resultArray == null) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      return this._handleSingleObject(lookupValue, searchArray2, resultArray, rangeLookupValue);
    }
    _handleSingleObject(value, searchArray2, resultArray, rangeLookupValue) {
      if (rangeLookupValue === 0) {
        return this.equalSearch(value, searchArray2, resultArray);
      }
      return this.binarySearch(value, searchArray2, resultArray);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/xlookup/index.ts
  var Xlookup = class extends BaseFunction {
    calculate(lookupValue, lookupArray, returnArray, ifNotFound, matchMode, searchMode) {
      if (lookupValue == null || lookupArray == null || returnArray == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (lookupValue.isError()) {
        return lookupValue;
      }
      if (lookupArray.isError()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!lookupArray.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const rowCountLookup = lookupArray.getRowCount();
      const columnCountLookup = lookupArray.getColumnCount();
      if (rowCountLookup !== 1 && columnCountLookup !== 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (returnArray.isError()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!returnArray.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const rowCountReturn = returnArray.getRowCount();
      const columnCountReturn = returnArray.getColumnCount();
      if (rowCountLookup !== rowCountReturn && columnCountLookup !== columnCountReturn) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (ifNotFound == null ? void 0 : ifNotFound.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (matchMode == null ? void 0 : matchMode.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (searchMode == null ? void 0 : searchMode.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (ifNotFound == null) {
        ifNotFound = ErrorValueObject.create("#N/A" /* NA */);
      }
      const matchModeValue = this.getIndexNumValue(matchMode || NumberValueObject.create(0));
      if (matchModeValue instanceof ErrorValueObject) {
        return matchModeValue;
      }
      const searchModeValue = this.getIndexNumValue(searchMode || NumberValueObject.create(1));
      if (searchModeValue instanceof ErrorValueObject) {
        return searchModeValue;
      }
      if (lookupValue.isArray()) {
        let resultArray2;
        if (rowCountLookup === 1) {
          resultArray2 = returnArray.slice([0, 1]);
        } else {
          resultArray2 = returnArray.slice(void 0, [0, 1]);
        }
        if (resultArray2 == null) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
        return lookupValue.map((value) => {
          const result = this._handleSingleObject(
            value,
            lookupArray,
            resultArray2,
            matchModeValue,
            searchModeValue
          );
          if (result.isError()) {
            return ifNotFound;
          }
          return result;
        });
      }
      if (columnCountLookup === columnCountReturn && rowCountLookup === rowCountReturn) {
        const result = this._handleSingleObject(
          lookupValue,
          lookupArray,
          returnArray,
          matchModeValue,
          searchModeValue
        );
        if (result.isError()) {
          return ifNotFound;
        }
        return result;
      }
      let axis = 0;
      if (columnCountLookup === columnCountReturn) {
        axis = 1;
      }
      const resultArray = this._handleExpandObject(
        lookupValue,
        lookupArray,
        returnArray,
        matchModeValue,
        searchModeValue,
        axis
      );
      if (resultArray == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return resultArray;
    }
    _handleExpandObject(value, searchArray2, resultArray, matchModeValue, searchModeValue, axis = 0) {
      if ((searchModeValue === 2 || searchModeValue === -2) && matchModeValue !== 2) {
        return this.binarySearchExpand(
          value,
          searchArray2,
          resultArray,
          axis,
          this._getSearchModeValue(searchModeValue)
        );
      }
      if (matchModeValue === 2) {
        return this.fuzzySearchExpand(value, searchArray2, resultArray, searchModeValue !== -1, axis);
      }
      if (matchModeValue === -1 || matchModeValue === 1) {
        return this.orderSearchExpand(
          value,
          searchArray2,
          resultArray,
          matchModeValue === 1 ? 2 /* MAX */ : 1 /* MIN */,
          searchModeValue === -1,
          axis
        );
      }
      return this.equalSearchExpand(value, searchArray2, resultArray, searchModeValue !== -1, axis);
    }
    _handleSingleObject(value, searchArray2, resultArray, matchModeValue, searchModeValue) {
      if ((searchModeValue === 2 || searchModeValue === -2) && matchModeValue !== 2) {
        return this.binarySearch(value, searchArray2, resultArray, this._getSearchModeValue(searchModeValue));
      }
      if (matchModeValue === 2) {
        return this.fuzzySearch(value, searchArray2, resultArray, searchModeValue !== -1);
      }
      if (matchModeValue === -1 || matchModeValue === 1) {
        return this.orderSearch(
          value,
          searchArray2,
          resultArray,
          matchModeValue === 1 ? 2 /* MAX */ : 1 /* MIN */,
          searchModeValue === -1
        );
      }
      return this.equalSearch(value, searchArray2, resultArray, searchModeValue !== -1);
    }
    _getSearchModeValue(searchModeValue) {
      return searchModeValue === -2 ? 1 /* MAX */ : 0 /* MIN */;
    }
  };

  // ../packages/engine-formula/src/functions/lookup/xmatch/index.ts
  var Xmatch = class extends BaseFunction {
    calculate(lookupValue, lookupArray, matchMode, searchMode) {
      if (lookupValue == null || lookupArray == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (lookupValue.isError()) {
        return lookupValue;
      }
      if (lookupArray.isError()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!lookupArray.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const rowCountLookup = lookupArray.getRowCount();
      const columnCountLookup = lookupArray.getColumnCount();
      if (rowCountLookup !== 1 && columnCountLookup !== 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (matchMode == null ? void 0 : matchMode.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (searchMode == null ? void 0 : searchMode.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const matchModeValue = this.getIndexNumValue(matchMode || NumberValueObject.create(0));
      if (matchModeValue instanceof ErrorValueObject) {
        return matchModeValue;
      }
      const searchModeValue = this.getIndexNumValue(searchMode || NumberValueObject.create(1));
      if (searchModeValue instanceof ErrorValueObject) {
        return searchModeValue;
      }
      if (lookupValue.isArray()) {
        return lookupValue.map((value) => this._handleSingleObject(
          value,
          lookupArray,
          matchModeValue,
          searchModeValue
        ));
      }
      return this._handleSingleObject(
        lookupValue,
        lookupArray,
        matchModeValue,
        searchModeValue
      );
      ;
    }
    _handleSingleObject(value, searchArray2, matchModeValue, searchModeValue) {
      let rowOrColumn;
      if ((searchModeValue === 2 || searchModeValue === -2) && matchModeValue !== 2) {
        const searchType = this._getSearchModeValue(searchModeValue);
        rowOrColumn = searchArray2.binarySearch(value, searchType);
      } else if (matchModeValue === 2) {
        const matchObject = searchArray2.compare(value, "=" /* EQUALS */);
        let position;
        if (searchModeValue !== -1) {
          position = matchObject.getFirstTruePosition();
        } else {
          position = matchObject.getLastTruePosition();
        }
        if (position == null) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
        rowOrColumn = searchArray2.getRowCount() === 1 ? position.column : position.row;
      } else if (matchModeValue === -1 || matchModeValue === 1) {
        const position = searchArray2.orderSearch(value, matchModeValue === 1 ? 2 /* MAX */ : 1 /* MIN */, searchModeValue === -1);
        if (position == null) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
        if (position instanceof ErrorValueObject) {
          return position;
        }
        rowOrColumn = searchArray2.getRowCount() === 1 ? position.column : position.row;
      } else {
        const matchObject = searchArray2.isEqual(value);
        let position;
        if (searchModeValue !== -1) {
          position = matchObject.getFirstTruePosition();
        } else {
          position = matchObject.getLastTruePosition();
        }
        if (position == null) {
          return ErrorValueObject.create("#N/A" /* NA */);
        }
        rowOrColumn = searchArray2.getRowCount() === 1 ? position.column : position.row;
      }
      if (rowOrColumn == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      return NumberValueObject.create(rowOrColumn + 1);
    }
    _getSearchModeValue(searchModeValue) {
      return searchModeValue === -2 ? 1 /* MAX */ : 0 /* MIN */;
    }
  };

  // ../packages/engine-formula/src/functions/lookup/index/index.ts
  var Index = class extends BaseFunction {
    constructor() {
      super(...arguments);
      __publicField(this, "needsReferenceObject", true);
    }
    calculate(reference, rowNum, columnNum, areaNum) {
      if (reference == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (reference.isError()) {
        return reference;
      }
      if (rowNum == null ? void 0 : rowNum.isError()) {
        return rowNum;
      }
      if (columnNum == null ? void 0 : columnNum.isError()) {
        return columnNum;
      }
      if (areaNum == null ? void 0 : areaNum.isError()) {
        return areaNum;
      }
      let referenceRowCount = 0;
      let referenceColumnCount = 0;
      if (reference.isValueObject()) {
        referenceRowCount = 1;
        referenceColumnCount = 1;
      } else if (reference.isReferenceObject()) {
        const { startRow, endRow, startColumn, endColumn } = reference.getRangeData();
        referenceRowCount = endRow - startRow + 1;
        referenceColumnCount = endColumn - startColumn + 1;
      } else {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (referenceRowCount === 1 && referenceColumnCount > 1 && columnNum == null) {
        columnNum = rowNum != null ? rowNum : NumberValueObject.create(0);
        rowNum = NumberValueObject.create(0);
      } else {
        rowNum = rowNum != null ? rowNum : NumberValueObject.create(0);
        columnNum = columnNum != null ? columnNum : NumberValueObject.create(0);
      }
      areaNum = areaNum != null ? areaNum : NumberValueObject.create(1);
      if (rowNum.isReferenceObject()) {
        rowNum = rowNum.toArrayValueObject();
      }
      if (columnNum.isReferenceObject()) {
        columnNum = columnNum.toArrayValueObject();
      }
      if (areaNum.isReferenceObject()) {
        areaNum = areaNum.toArrayValueObject();
      }
      const maxRowLength = Math.max(
        rowNum.isArray() ? rowNum.getRowCount() : 1,
        columnNum.isArray() ? columnNum.getRowCount() : 1,
        areaNum.isArray() ? areaNum.getRowCount() : 1
      );
      const maxColumnLength = Math.max(
        rowNum.isArray() ? rowNum.getColumnCount() : 1,
        columnNum.isArray() ? columnNum.getColumnCount() : 1,
        areaNum.isArray() ? areaNum.getColumnCount() : 1
      );
      rowNum = rowNum;
      columnNum = columnNum;
      areaNum = areaNum;
      if (maxRowLength === 1 && maxColumnLength === 1) {
        return this._calculateSingleCell(reference, rowNum, columnNum, areaNum);
      } else {
        const rowNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, rowNum, ErrorValueObject.create("#N/A" /* NA */));
        const columnNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, columnNum, ErrorValueObject.create("#N/A" /* NA */));
        const areaNumArray = expandArrayValueObject(maxRowLength, maxColumnLength, areaNum, ErrorValueObject.create("#N/A" /* NA */));
        return rowNumArray.map((rowNumValue, rowIndex, columnIndex) => {
          const columnNumValue = columnNumArray.get(rowIndex, columnIndex) || NullValueObject.create();
          const areaNumValue = areaNumArray.get(rowIndex, columnIndex) || NullValueObject.create();
          const result = this._calculateSingleCell(reference, rowNumValue, columnNumValue, areaNumValue);
          if (result.isReferenceObject()) {
            return result.toArrayValueObject().getFirstCell();
          }
          return result;
        });
      }
    }
    _calculateSingleCell(reference, rowNum, columnNum, areaNum) {
      if (rowNum.isError()) {
        return rowNum;
      }
      const rowNumberValue = this._getNumberValue(rowNum);
      if (rowNumberValue === void 0 || rowNumberValue < 0) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (columnNum.isError()) {
        return columnNum;
      }
      const columnNumberValue = this._getNumberValue(columnNum);
      if (columnNumberValue === void 0 || columnNumberValue < 0) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (areaNum.isError()) {
        return areaNum;
      }
      const areaNumberValue = this._getAreaNumberValue(areaNum);
      if (areaNumberValue === void 0 || areaNumberValue < 1) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (reference.isReferenceObject()) {
        return this._getReferenceObject(reference, rowNumberValue, columnNumberValue, areaNumberValue);
      } else if (reference.isValueObject() && rowNumberValue === 1 && columnNumberValue === 1) {
        return reference;
      } else {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
    }
    _getNumberValue(numberValueObject) {
      if (numberValueObject == null) {
        return 0;
      }
      let logicValue = 0;
      if (numberValueObject.isBoolean()) {
        const logicV = numberValueObject.getValue();
        if (logicV === true) {
          logicValue = 1;
        }
      } else if (numberValueObject.isString()) {
        return;
      } else if (numberValueObject.isNumber()) {
        logicValue = Math.floor(numberValueObject.getValue());
      } else if (numberValueObject.isNull()) {
        logicValue = 0;
      }
      return logicValue;
    }
    _getAreaNumberValue(numberValueObject) {
      if (numberValueObject == null) {
        return 1;
      }
      let logicValue = 0;
      if (numberValueObject.isBoolean()) {
        const logicV = numberValueObject.getValue();
        if (logicV === true) {
          logicValue = 1;
        }
      } else if (numberValueObject.isString()) {
        return;
      } else if (numberValueObject.isNumber()) {
        logicValue = Math.floor(numberValueObject.getValue());
      } else if (numberValueObject.isNull()) {
        logicValue = 0;
      }
      return logicValue;
    }
    _getReferenceObject(reference, rowNumberValue, columnNumberValue, areaNumberValue) {
      const { startRow, endRow, startColumn, endColumn } = reference.getRangeData();
      let referenceStartRow = 0;
      let referenceEndRow = 0;
      let referenceStartColumn = 0;
      let referenceEndColumn = 0;
      if (rowNumberValue === 0) {
        referenceStartRow = startRow;
        referenceEndRow = endRow;
      } else {
        referenceStartRow = referenceEndRow = startRow + rowNumberValue - 1;
      }
      if (columnNumberValue === 0) {
        referenceStartColumn = startColumn;
        referenceEndColumn = endColumn;
      } else {
        referenceStartColumn = referenceEndColumn = startColumn + columnNumberValue - 1;
      }
      if (referenceStartRow > endRow || referenceStartColumn > endColumn) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      const range = {
        startRow: referenceStartRow,
        startColumn: referenceStartColumn,
        endRow: referenceEndRow,
        endColumn: referenceEndColumn
      };
      return this.createReferenceObject(reference, range);
    }
  };

  // ../packages/engine-formula/src/functions/lookup/function-map.ts
  var functionLookup = [
    [Address, "ADDRESS" /* ADDRESS */],
    [Column, "COLUMN" /* COLUMN */],
    [Columns, "COLUMNS" /* COLUMNS */],
    [Index, "INDEX" /* INDEX */],
    [Indirect, "INDIRECT" /* INDIRECT */],
    [Offset, "OFFSET" /* OFFSET */],
    [Row, "ROW" /* ROW */],
    [Rows, "ROWS" /* ROWS */],
    [Vlookup, "VLOOKUP" /* VLOOKUP */],
    [Lookup, "LOOKUP" /* LOOKUP */],
    [Match, "MATCH" /* MATCH */],
    [Hlookup, "HLOOKUP" /* HLOOKUP */],
    [Xlookup, "XLOOKUP" /* XLOOKUP */],
    [Xmatch, "XMATCH" /* XMATCH */]
  ];

  // ../packages/engine-formula/src/functions/math/abs/index.ts
  var Abs = class extends BaseFunction {
    calculate(variant) {
      if (variant == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return variant.abs();
    }
  };

  // ../packages/engine-formula/src/functions/math/acos/index.ts
  var Acos = class extends BaseFunction {
    calculate(variant) {
      if (variant == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return new ErrorValueObject("#VALUE!" /* VALUE */);
      }
      return variant.acos();
    }
  };

  // ../packages/engine-formula/src/functions/math/acosh/index.ts
  var Acosh = class extends BaseFunction {
    calculate(variant) {
      if (variant == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return variant.acosh();
    }
  };

  // ../packages/engine-formula/src/functions/math/acot/index.ts
  var Acot = class extends BaseFunction {
    calculate(variant) {
      if (variant == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (variant.isString()) {
        variant = variant.convertToNumberObjectValue();
      }
      if (variant.isError()) {
        return variant;
      }
      if (variant.isArray()) {
        return variant.map((currentValue) => {
          if (currentValue.isError()) {
            return currentValue;
          }
          return acot(currentValue);
        });
      }
      return acot(variant);
    }
  };
  function acot(num) {
    let currentValue = num.getValue();
    if (num.isBoolean()) {
      currentValue = currentValue ? 1 : 0;
    }
    if (!Number.isFinite(currentValue)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    const result = Math.atan(1 / Number(currentValue));
    if (Number.isNaN(result)) {
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    return NumberValueObject.create(result);
  }

  // ../packages/engine-formula/src/functions/math/mod/index.ts
  var Mod = class extends BaseFunction {
    calculate(number, divisor) {
      if (number == null || divisor == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (number.isString()) {
        number = number.convertToNumberObjectValue();
      }
      if (number.isError()) {
        return number;
      }
      if (divisor.isString()) {
        divisor = divisor.convertToNumberObjectValue();
      }
      if (divisor.isError()) {
        return divisor;
      }
      return number.mod(divisor);
    }
  };

  // ../packages/engine-formula/src/functions/math/power/index.ts
  var Power = class extends BaseFunction {
    calculate(number, power) {
      if (number == null || power == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (number.isString()) {
        number = number.convertToNumberObjectValue();
      }
      if (number.isError()) {
        return number;
      }
      if (power.isString()) {
        power = power.convertToNumberObjectValue();
      }
      if (power.isError()) {
        return power;
      }
      return number.pow(power);
    }
  };

  // ../packages/engine-formula/src/functions/math/product/index.ts
  var Product = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let accumulatorAll = NumberValueObject.create(1);
      for (let i = 0; i < variants.length; i++) {
        let variant = variants[i];
        if (variant.isNull()) {
          continue;
        }
        if (variant.isString()) {
          variant = variant.convertToNumberObjectValue();
        }
        if (variant.isArray()) {
          variant = this._multiplyArray(variant);
        }
        if (variant.isError()) {
          return variant;
        }
        accumulatorAll = accumulatorAll.multiply(variant);
        if (accumulatorAll.isError()) {
          return accumulatorAll;
        }
      }
      return accumulatorAll;
    }
    _multiplyArray(array) {
      let result = NumberValueObject.create(1);
      array.iterator((valueObject) => {
        if (valueObject == null || valueObject.isString() || valueObject.isBoolean() || valueObject.isNull()) {
          return true;
        }
        if (valueObject.isError()) {
          result = valueObject;
          return false;
        }
        result = result.multiply(
          valueObject
        );
      });
      return result;
    }
  };

  // ../packages/engine-formula/src/functions/math/subtotal/index.ts
  var Subtotal = class extends BaseFunction {
    constructor() {
      super(...arguments);
      __publicField(this, "needsReferenceObject", true);
    }
    calculate(functionNum, ...refs) {
      if (functionNum == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (functionNum.isError()) {
        return functionNum;
      }
      if (refs.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (functionNum.isReferenceObject()) {
        const result = [];
        functionNum.iterator((valueObject, rowIndex, columnIndex) => {
          if (result[rowIndex] == null) {
            result[rowIndex] = [];
          }
          result[rowIndex][columnIndex] = this._handleSingleObject(
            valueObject,
            ...refs
          );
        });
        return createNewArray(result, result.length, result[0].length);
      }
      return this._handleSingleObject(functionNum, ...refs);
    }
    _handleSingleObject(functionNum, ...refs) {
      const indexNum = this._getIndexNumValue(functionNum);
      let result;
      if (indexNum instanceof ErrorValueObject) {
        return indexNum;
      }
      switch (indexNum) {
        case 1 /* AVERAGE */:
          result = this._average(false, ...refs);
          break;
        case 2 /* COUNT */:
          result = this._count(false, ...refs);
          break;
        case 3 /* COUNTA */:
          result = this._counta(false, ...refs);
          break;
        case 4 /* MAX */:
          result = this._max(false, ...refs);
          break;
        case 5 /* MIN */:
          result = this._min(false, ...refs);
          break;
        case 6 /* PRODUCT */:
          result = this._product(false, ...refs);
          break;
        case 7 /* STDEV */:
          result = this._stdev(false, ...refs);
          break;
        case 8 /* STDEVP */:
          result = this._stdevp(false, ...refs);
          break;
        case 9 /* SUM */:
          result = this._sum(false, ...refs);
          break;
        case 10 /* VAR */:
          result = this._var(false, ...refs);
          break;
        case 11 /* VARP */:
          result = this._varp(false, ...refs);
          break;
        case 101 /* AVERAGE */:
          result = this._average(true, ...refs);
          break;
        case 102 /* COUNT */:
          result = this._count(true, ...refs);
          break;
        case 103 /* COUNTA */:
          result = this._counta(true, ...refs);
          break;
        case 104 /* MAX */:
          result = this._max(true, ...refs);
          break;
        case 105 /* MIN */:
          result = this._min(true, ...refs);
          break;
        case 106 /* PRODUCT */:
          result = this._product(true, ...refs);
          break;
        case 107 /* STDEV */:
          result = this._stdev(true, ...refs);
          break;
        case 108 /* STDEVP */:
          result = this._stdevp(true, ...refs);
          break;
        case 109 /* SUM */:
          result = this._sum(true, ...refs);
          break;
        case 110 /* VAR */:
          result = this._var(true, ...refs);
          break;
        case 111 /* VARP */:
          result = this._varp(true, ...refs);
          break;
        default:
          result = ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return result;
    }
    _getIndexNumValue(indexNum) {
      const indexNumValue = indexNum ? Number(indexNum.getValue()) : 0;
      if (Number.isNaN(indexNumValue)) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const indexNumValueInt = Math.floor(indexNumValue);
      if (indexNumValueInt >= 1 && indexNumValueInt <= 11 || indexNumValueInt >= 101 && indexNumValueInt <= 111) {
        return indexNumValueInt;
      }
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
    _average(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.mean();
    }
    _count(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.count();
    }
    _counta(ignoreHidden, ...refs) {
      let accumulatorAll = NumberValueObject.create(0);
      for (let i = 0; i < refs.length; i++) {
        const variant = refs[i];
        if (!variant.isReferenceObject()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        const rowData = variant.getRowData();
        variant.iterator((valueObject, rowIndex) => {
          if (ignoreHidden && this._isRowHidden(rowData, rowIndex)) {
            return true;
          }
          if (valueObject == null || valueObject.isNull()) {
            return true;
          }
          accumulatorAll = accumulatorAll.plusBy(1);
        });
      }
      return accumulatorAll;
    }
    _max(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      if (this._isBlankArrayObject(flattenArray)) {
        return NumberValueObject.create(0);
      }
      return flattenArray.max();
    }
    _min(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      if (this._isBlankArrayObject(flattenArray)) {
        return NumberValueObject.create(0);
      }
      return flattenArray.min();
    }
    _product(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      if (this._isBlankArrayObject(flattenArray)) {
        return NumberValueObject.create(0);
      }
      let result = NumberValueObject.create(1);
      flattenArray.iterator((valueObject) => {
        result = result.multiply(
          valueObject
        );
      });
      return result;
    }
    _stdev(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      if (this._isBlankArrayObject(flattenArray)) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return flattenArray.std(1);
    }
    _stdevp(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      if (this._isBlankArrayObject(flattenArray)) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return flattenArray.std();
    }
    _sum(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.sum();
    }
    _var(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      if (this._isBlankArrayObject(flattenArray)) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return flattenArray.var(1);
    }
    _varp(ignoreHidden, ...refs) {
      const flattenArray = this._flattenRefArray(ignoreHidden, ...refs);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      if (this._isBlankArrayObject(flattenArray)) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return flattenArray.var();
    }
    _flattenRefArray(ignoreHidden, ...variants) {
      const flattenValues = [];
      flattenValues[0] = [];
      for (let i = 0; i < variants.length; i++) {
        const variant = variants[i];
        if (variant.isError()) {
          return variant;
        }
        if (!variant.isReferenceObject()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        const rowData = variant.getRowData();
        let errorValue;
        variant.iterator((valueObject, rowIndex) => {
          if (ignoreHidden && this._isRowHidden(rowData, rowIndex)) {
            return true;
          }
          if (valueObject == null || valueObject.isNull() || valueObject.isString() || valueObject.isBoolean()) {
            return true;
          }
          if (valueObject.isError()) {
            errorValue = valueObject;
            return false;
          }
          flattenValues[0].push(valueObject);
        });
        if (errorValue == null ? void 0 : errorValue.isError()) {
          return errorValue;
        }
      }
      return createNewArray(flattenValues, 1, flattenValues[0].length);
    }
    _isRowHidden(rowData, rowIndex) {
      const row = rowData[rowIndex];
      if (!row) {
        return false;
      }
      return row.hd === 1 /* TRUE */;
    }
    _isBlankArrayObject(arrayObject) {
      return arrayObject.getArrayValue()[0].length === 0;
    }
  };

  // ../packages/engine-formula/src/functions/math/sum/index.ts
  var Sum = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let accumulatorAll = NumberValueObject.create(0);
      for (let i = 0; i < variants.length; i++) {
        let variant = variants[i];
        if (variant.isString()) {
          variant = variant.convertToNumberObjectValue();
        }
        if (variant.isError()) {
          return variant;
        }
        if (variant.isArray()) {
          variant = variant.sum();
        }
        accumulatorAll = accumulatorAll.plus(variant);
        if (accumulatorAll.isError()) {
          return accumulatorAll;
        }
      }
      return accumulatorAll;
    }
  };

  // ../packages/engine-formula/src/engine/utils/object-compare.ts
  function findCompareToken(str) {
    const comparisonTokens = [
      "=" /* EQUALS */,
      "<>" /* NOT_EQUAL */,
      ">=" /* GREATER_THAN_OR_EQUAL */,
      ">" /* GREATER_THAN */,
      "<=" /* LESS_THAN_OR_EQUAL */,
      "<" /* LESS_THAN */
    ];
    for (const token of comparisonTokens) {
      if (str.startsWith(token)) {
        const content = str.substring(token.length);
        return [token, ValueObjectFactory.create(content)];
      }
    }
    return ["=" /* EQUALS */, ValueObjectFactory.create(str)];
  }
  function valueObjectCompare(range, criteria, operator) {
    if (!operator) {
      if (criteria.isString()) {
        const criteriaValueString = `${criteria.getValue()}`;
        const [token, criteriaStringObject] = findCompareToken(criteriaValueString);
        operator = token;
        criteria = criteriaStringObject;
      } else {
        operator = "=" /* EQUALS */;
      }
    }
    return range.compare(criteria, operator);
  }
  function booleanObjectIntersection(valueObject1, valueObject2) {
    const maxRowLength = Math.max(valueObject1.isArray() ? valueObject1.getRowCount() : 1, valueObject2.isArray() ? valueObject2.getRowCount() : 1);
    const maxColumnLength = Math.max(valueObject1.isArray() ? valueObject1.getColumnCount() : 1, valueObject2.isArray() ? valueObject2.getColumnCount() : 1);
    const valueObject1Array = expandArrayValueObject(maxRowLength, maxColumnLength, valueObject1);
    const valueObject2Array = expandArrayValueObject(maxRowLength, maxColumnLength, valueObject2);
    return valueObject1Array.mapValue((valueObject12, rowIndex, columnIndex) => {
      const valueObject22 = valueObject2Array.get(rowIndex, columnIndex);
      if (valueObject12 == null ? void 0 : valueObject12.isError()) {
        return valueObject12;
      }
      if (valueObject22 == null ? void 0 : valueObject22.isError()) {
        return valueObject22;
      }
      if ((valueObject12 == null ? void 0 : valueObject12.isBoolean()) && (valueObject22 == null ? void 0 : valueObject22.isBoolean())) {
        return createBooleanValueObjectByRawValue(valueObject12.getValue() && valueObject22.getValue());
      }
      return BooleanValueObject.create(false);
    });
  }

  // ../packages/engine-formula/src/functions/math/sumif/index.ts
  var Sumif = class extends BaseFunction {
    calculate(range, criteria, sumRange) {
      if (range == null || criteria == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (range.isError() || criteria.isError() || (sumRange == null ? void 0 : sumRange.isError())) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (!range.isArray() || sumRange && !sumRange.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (criteria.isArray()) {
        return criteria.map((criteriaItem) => this._handleSingleObject(range, criteriaItem, sumRange));
      }
      return this._handleSingleObject(range, criteria, sumRange);
    }
    _handleSingleObject(range, criteria, sumRange) {
      const resultArrayObject = valueObjectCompare(range, criteria);
      const sumRangeArray = sumRange ? sumRange.slice(
        [0, range.getRowCount()],
        [0, range.getColumnCount()]
      ) : range;
      if (!sumRangeArray) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return sumRangeArray.pick(resultArrayObject).sum();
    }
  };

  // ../packages/engine-formula/src/functions/math/sumifs/index.ts
  var Sumifs = class extends BaseFunction {
    calculate(sumRange, ...variants) {
      if (sumRange == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (variants.length < 2) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (sumRange.isError()) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (!sumRange.isArray()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (variants.length < 2 || variants.length % 2 !== 0) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (variants.some((variant, i) => i % 2 === 0 && !variant.isArray())) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const sumRowLength = sumRange.getRowCount();
      const sumColumnLength = sumRange.getColumnCount();
      let maxRowLength = 0;
      let maxColumnLength = 0;
      variants.forEach((variant, i) => {
        if (i % 2 === 1) {
          if (variant.isArray()) {
            const arrayValue = variant;
            maxRowLength = Math.max(maxRowLength, arrayValue.getRowCount());
            maxColumnLength = Math.max(maxColumnLength, arrayValue.getColumnCount());
          } else {
            maxRowLength = Math.max(maxRowLength, 1);
            maxColumnLength = Math.max(maxColumnLength, 1);
          }
        }
      });
      const booleanResults = [];
      for (let i = 0; i < variants.length; i++) {
        if (i % 2 === 1)
          continue;
        const range = variants[i];
        const rangeRowLength = range.getRowCount();
        const rangeColumnLength = range.getColumnCount();
        if (rangeRowLength !== sumRowLength || rangeColumnLength !== sumColumnLength) {
          return expandArrayValueObject(maxRowLength, maxColumnLength, ErrorValueObject.create("#N/A" /* NA */));
        }
        const criteria = variants[i + 1];
        const criteriaArray = expandArrayValueObject(maxRowLength, maxColumnLength, criteria, ErrorValueObject.create("#N/A" /* NA */));
        criteriaArray.iterator((criteriaValueObject, rowIndex, columnIndex) => {
          if (!criteriaValueObject) {
            return;
          }
          const resultArrayObject = valueObjectCompare(range, criteriaValueObject);
          if (booleanResults[rowIndex] === void 0) {
            booleanResults[rowIndex] = [];
          }
          if (booleanResults[rowIndex][columnIndex] === void 0) {
            booleanResults[rowIndex][columnIndex] = resultArrayObject;
            return;
          }
          booleanResults[rowIndex][columnIndex] = booleanObjectIntersection(booleanResults[rowIndex][columnIndex], resultArrayObject);
        });
      }
      const sumResults = booleanResults.map((row) => {
        return row.map((booleanResult) => {
          return sumRange.pick(booleanResult).sum();
        });
      });
      const arrayValueObjectData = {
        calculateValueList: sumResults,
        rowCount: sumResults.length,
        columnCount: sumResults[0].length,
        unitId: this.unitId || "",
        sheetId: this.subUnitId || "",
        row: this.row,
        column: this.column
      };
      return ArrayValueObject.create(arrayValueObjectData);
    }
  };

  // ../packages/engine-formula/src/functions/math/function-map.ts
  var functionMath = [
    [Abs, "ABS" /* ABS */],
    [Acos, "ACOS" /* ACOS */],
    [Acosh, "ACOSH" /* ACOSH */],
    [Acot, "ACOT" /* ACOT */],
    [Mod, "MOD" /* MOD */],
    [Subtotal, "SUBTOTAL" /* SUBTOTAL */],
    [Sum, "SUM" /* SUM */],
    [Sumif, "SUMIF" /* SUMIF */],
    [Sumifs, "SUMIFS" /* SUMIFS */],
    [Power, "POWER" /* POWER */],
    [Product, "PRODUCT" /* PRODUCT */]
  ];

  // ../packages/engine-formula/src/functions/meta/compare/index.ts
  var Compare = class extends BaseFunction {
    constructor() {
      super(...arguments);
      __publicField(this, "_compareType", "=" /* EQUALS */);
    }
    setCompareType(token) {
      this._compareType = token;
    }
    calculate(variant1, variant2) {
      if (variant1.isError()) {
        return variant1;
      }
      if (variant2.isError()) {
        return variant2;
      }
      return variant1.compare(variant2, this._compareType);
    }
  };

  // ../packages/engine-formula/src/engine/value-object/cube-value-object.ts
  var CubeValueObject = class _CubeValueObject extends BaseValueObject {
    constructor(values) {
      super("");
      __publicField(this, "_values", []);
      this._values = values;
    }
    static create(values) {
      return new _CubeValueObject(values);
    }
    isCube() {
      return true;
    }
    sum() {
      const result = NumberValueObject.create(0);
      this._values.forEach((arr) => {
        result.plus(arr.sum());
      });
      return result;
    }
    max() {
      let result = NumberValueObject.create(Number.NEGATIVE_INFINITY);
      this._values.forEach((arr) => {
        const compare2 = arr.max();
        if (result.isLessThan(compare2)) {
          result = compare2;
        }
      });
      return result;
    }
    min() {
      let result = NumberValueObject.create(Number.POSITIVE_INFINITY);
      this._values.forEach((arr) => {
        const compare2 = arr.max();
        if (result.isGreaterThan(compare2)) {
          result = compare2;
        }
      });
      return result;
    }
    count() {
      const count = NumberValueObject.create(0);
      this._values.forEach((arr) => {
        count.plus(arr.count());
      });
      return count;
    }
    countA() {
      const count = NumberValueObject.create(0);
      this._values.forEach((arr) => {
        count.plus(arr.countA());
      });
      return count;
    }
    countBlank() {
      const count = NumberValueObject.create(0);
      this._values.forEach((arr) => {
        count.plus(arr.countBlank());
      });
      return count;
    }
  };

  // ../packages/engine-formula/src/functions/meta/cube/index.ts
  var Cube = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const values = [];
      for (let i = 0; i < variants.length; i++) {
        const variant = variants[i];
        if (variant.isError()) {
          return variant;
        }
        if (!variant.isArray()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        values.push(variant);
      }
      return CubeValueObject.create(values);
    }
  };

  // ../packages/engine-formula/src/functions/meta/divided/index.ts
  var Divided = class extends BaseFunction {
    calculate(variant1, variant2) {
      if (variant1.isError()) {
        return variant1;
      }
      if (variant2.isError()) {
        return variant2;
      }
      if (!variant2.isArray() && variant2.getValue() === 0) {
        return ErrorValueObject.create("#DIV/0!" /* DIV_BY_ZERO */);
      }
      return variant1.divided(variant2);
    }
  };

  // ../packages/engine-formula/src/functions/meta/minus/index.ts
  var Minus = class extends BaseFunction {
    calculate(variant1, variant2) {
      if (variant1.isError()) {
        return variant1;
      }
      if (variant2.isError()) {
        return variant2;
      }
      return variant1.minus(variant2);
    }
  };

  // ../packages/engine-formula/src/functions/meta/multiply/index.ts
  var Multiply = class extends BaseFunction {
    calculate(variant1, variant2) {
      if (variant1.isError()) {
        return variant1;
      }
      if (variant2.isError()) {
        return variant2;
      }
      return variant1.multiply(variant2);
    }
  };

  // ../packages/engine-formula/src/functions/meta/plus/index.ts
  var Plus = class extends BaseFunction {
    calculate(variant1, variant2) {
      if (variant1.isError()) {
        return variant1;
      }
      if (variant2.isError()) {
        return variant2;
      }
      return variant1.plus(variant2);
    }
  };

  // ../packages/engine-formula/src/functions/meta/function-map.ts
  var functionMeta = [
    [Compare, "COMPARE" /* COMPARE */],
    [Divided, "DIVIDED" /* DIVIDED */],
    [Minus, "MINUS" /* MINUS */],
    [Multiply, "MULTIPLY" /* MULTIPLY */],
    [Plus, "PLUS" /* PLUS */],
    [Cube, "CUBE" /* CUBE */]
  ];

  // ../packages/engine-formula/src/functions/statistical/average/index.ts
  var Average = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let accumulatorSum = NumberValueObject.create(0);
      let accumulatorCount = NumberValueObject.create(0);
      for (let i = 0; i < variants.length; i++) {
        let variant = variants[i];
        if (variant.isString()) {
          variant = variant.convertToNumberObjectValue();
        }
        if (variant.isError()) {
          return variant;
        }
        if (variant.isArray()) {
          accumulatorSum = accumulatorSum.plus(variant.sum());
          if (accumulatorSum.isError()) {
            return accumulatorSum;
          }
          accumulatorCount = accumulatorCount.plus(variant.count());
        } else if (!variant.isNull()) {
          accumulatorSum = accumulatorSum.plus(variant);
          accumulatorCount = accumulatorCount.plus(NumberValueObject.create(1));
        }
      }
      return accumulatorSum.divided(accumulatorCount);
    }
  };

  // ../packages/engine-formula/src/functions/statistical/count/index.ts
  var Count = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let accumulatorAll = NumberValueObject.create(0);
      for (let i = 0; i < variants.length; i++) {
        const variant = variants[i];
        if (variant.isError()) {
          continue;
        }
        if (variant.isArray()) {
          accumulatorAll = accumulatorAll.plus(variant.count());
        } else if (variant.isString()) {
          if (!variant.convertToNumberObjectValue().isError()) {
            accumulatorAll = accumulatorAll.plus(NumberValueObject.create(1));
          }
        } else if (!variant.isNull()) {
          accumulatorAll = accumulatorAll.plus(NumberValueObject.create(1));
        }
      }
      return accumulatorAll;
    }
  };

  // ../packages/engine-formula/src/functions/statistical/counta/index.ts
  var Counta = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let accumulatorAll = NumberValueObject.create(0);
      for (let i = 0; i < variants.length; i++) {
        let variant = variants[i];
        if (variant.isError()) {
          accumulatorAll = accumulatorAll.plus(NumberValueObject.create(1));
          continue;
        }
        if (variant.isArray()) {
          variant = variant.countA();
          accumulatorAll = accumulatorAll.plus(variant);
        } else if (!variant.isNull()) {
          accumulatorAll = accumulatorAll.plus(NumberValueObject.create(1));
        }
      }
      return accumulatorAll;
    }
  };

  // ../packages/engine-formula/src/functions/statistical/max/index.ts
  var Max = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let accumulatorAll = NumberValueObject.create(Number.NEGATIVE_INFINITY);
      for (let i = 0; i < variants.length; i++) {
        let variant = variants[i];
        if (variant.isNull()) {
          continue;
        }
        if (variant.isString() || variant.isBoolean()) {
          variant = variant.convertToNumberObjectValue();
        }
        if (variant.isArray()) {
          variant = variant.max();
        }
        if (variant.isError()) {
          return variant;
        }
        accumulatorAll = this._validator(accumulatorAll, variant);
      }
      return accumulatorAll;
    }
    _validator(accumulatorAll, valueObject) {
      const validator = accumulatorAll.isLessThan(valueObject);
      if (validator.getValue()) {
        accumulatorAll = valueObject;
      }
      return accumulatorAll;
    }
  };

  // ../packages/engine-formula/src/functions/statistical/min/index.ts
  var Min = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let accumulatorAll = NumberValueObject.create(Number.POSITIVE_INFINITY);
      for (let i = 0; i < variants.length; i++) {
        let variant = variants[i];
        if (variant.isString() || variant.isBoolean()) {
          variant = variant.convertToNumberObjectValue();
        }
        if (variant.isArray()) {
          variant = variant.min();
        }
        if (variant.isError()) {
          return variant;
        }
        if (variant.isNull()) {
          continue;
        }
        accumulatorAll = this._validator(accumulatorAll, variant);
      }
      return accumulatorAll;
    }
    _validator(accumulatorAll, valueObject) {
      const validator = accumulatorAll.isGreaterThan(valueObject);
      if (validator.getValue()) {
        accumulatorAll = valueObject;
      }
      return accumulatorAll;
    }
  };

  // ../packages/engine-formula/src/functions/statistical/stdeva/index.ts
  var Stdeva = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const flattenArray = this.flattenArray(variants, false);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.std(1);
    }
  };

  // ../packages/engine-formula/src/functions/statistical/stdevpa/index.ts
  var Stdevpa = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const flattenArray = this.flattenArray(variants, false);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.std();
    }
  };

  // ../packages/engine-formula/src/functions/statistical/vara/index.ts
  var Vara = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const flattenArray = this.flattenArray(variants, false);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.var(1);
    }
  };

  // ../packages/engine-formula/src/functions/statistical/varpa/index.ts
  var Varpa = class extends BaseFunction {
    calculate(...variants) {
      if (variants.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      const flattenArray = this.flattenArray(variants, false);
      if (flattenArray.isError()) {
        return flattenArray;
      }
      return flattenArray.var();
    }
  };

  // ../packages/engine-formula/src/functions/statistical/function-map.ts
  var functionStatistical = [
    [Average, "AVERAGE" /* AVERAGE */],
    [Count, "COUNT" /* COUNT */],
    [Max, "MAX" /* MAX */],
    [Min, "MIN" /* MIN */],
    [Min, "MIN" /* MIN */],
    [Counta, "COUNTA" /* COUNTA */],
    [StdevP, "STDEV.P" /* STDEV_P */],
    [StdevS, "STDEV.S" /* STDEV_S */],
    [Stdeva, "STDEVA" /* STDEVA */],
    [Stdevpa, "STDEVPA" /* STDEVPA */],
    [VarP, "VAR.P" /* VAR_P */],
    [VarS, "VAR.S" /* VAR_S */],
    [Vara, "VARA" /* VARA */],
    [Varpa, "VARPA" /* VARPA */]
  ];

  // ../packages/engine-formula/src/functions/text/concatenate/index.ts
  var Concatenate = class extends BaseFunction {
    calculate(...textValues) {
      if (textValues.length === 0) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      let maxRowLength = 0;
      let maxColumnLength = 0;
      textValues.forEach((textValue) => {
        if (textValue.isArray()) {
          const arrayValue = textValue;
          maxRowLength = Math.max(maxRowLength, arrayValue.getRowCount());
          maxColumnLength = Math.max(maxColumnLength, arrayValue.getColumnCount());
        } else {
          maxRowLength = Math.max(maxRowLength, 1);
          maxColumnLength = Math.max(maxColumnLength, 1);
        }
      });
      let result = null;
      for (const textValue of textValues) {
        const textValueArray = expandArrayValueObject(maxRowLength, maxColumnLength, textValue, ErrorValueObject.create("#N/A" /* NA */));
        result = textValueArray.mapValue((textValueObject, rowIndex, columnIndex) => {
          var _a2, _b2;
          const resultValueObject = result && result.get(rowIndex, columnIndex);
          if (resultValueObject == null ? void 0 : resultValueObject.isError()) {
            return resultValueObject;
          }
          if (textValueObject.isError()) {
            return textValueObject;
          }
          const resultValueObjectString = (resultValueObject == null ? void 0 : resultValueObject.isNull()) ? "" : (_a2 = resultValueObject == null ? void 0 : resultValueObject.getValue()) != null ? _a2 : "";
          const textValueObjectString = (textValueObject == null ? void 0 : textValueObject.isNull()) ? "" : (_b2 = textValueObject == null ? void 0 : textValueObject.getValue()) != null ? _b2 : "";
          return createStringValueObjectByRawValue(`${resultValueObjectString}${textValueObjectString}`);
        });
      }
      if (!result) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      return result;
    }
  };

  // ../packages/engine-formula/src/functions/text/len/index.ts
  var Len = class extends BaseFunction {
    calculate(text) {
      if (text == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (text.isError()) {
        return text;
      }
      if (text.isArray()) {
        return text.mapValue((textValue) => {
          return this._handleSingleText(textValue);
        });
      }
      return this._handleSingleText(text);
    }
    _handleSingleText(text) {
      if (text.isError()) {
        return text;
      }
      if (text.isNull()) {
        return NumberValueObject.create(0);
      }
      if (text.isString() || text.isBoolean() || text.isNumber()) {
        const textValue = text.getValue().toString();
        return NumberValueObject.create(textValue.length);
      }
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };

  // ../packages/engine-formula/src/engine/utils/char-kit.ts
  function charLenByte(str) {
    let byteCount = 0;
    for (let i = 0; i < str.length; i++) {
      const charCode2 = str.charCodeAt(i);
      if (charCode2 >= 12352 && charCode2 <= 12543 || // Japanese hiragana and katakana
      charCode2 >= 19968 && charCode2 <= 40959 || // Chinese (simplified and traditional)
      charCode2 >= 44032 && charCode2 <= 55215) {
        byteCount += 2;
      } else {
        byteCount += 1;
      }
    }
    return byteCount;
  }

  // ../packages/engine-formula/src/functions/text/lenb/index.ts
  var Lenb = class extends BaseFunction {
    calculate(text) {
      if (text == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (text.isError()) {
        return text;
      }
      if (text.isArray()) {
        return text.mapValue((textValue) => {
          return this._handleSingleText(textValue);
        });
      }
      return this._handleSingleText(text);
    }
    _handleSingleText(text) {
      if (text.isError()) {
        return text;
      }
      if (text.isNull()) {
        return NumberValueObject.create(0);
      }
      if (text.isString() || text.isBoolean() || text.isNumber()) {
        const textValue = text.getValue().toString();
        const textByteLen = charLenByte(textValue);
        return NumberValueObject.create(textByteLen);
      }
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };

  // ../packages/engine-formula/src/basics/format.ts
  var import_numfmt = __toESM(require_numfmt2());
  var getFormatPreview = (pattern, value) => {
    return import_numfmt.default.format(pattern, value);
  };

  // ../packages/engine-formula/src/functions/text/text/index.ts
  var Text = class extends BaseFunction {
    calculate(text, formatText) {
      if (text == null || formatText == null) {
        return ErrorValueObject.create("#N/A" /* NA */);
      }
      if (text.isError()) {
        return text;
      }
      if (formatText.isError()) {
        return formatText;
      }
      const maxRowLength = Math.max(
        text.isArray() ? text.getRowCount() : 1,
        formatText.isArray() ? formatText.getRowCount() : 1
      );
      const maxColumnLength = Math.max(
        text.isArray() ? text.getColumnCount() : 1,
        formatText.isArray() ? formatText.getColumnCount() : 1
      );
      const textArray = expandArrayValueObject(maxRowLength, maxColumnLength, text);
      const formatTextArray = expandArrayValueObject(maxRowLength, maxColumnLength, formatText);
      return textArray.map((textValue, rowIndex, columnIndex) => {
        if (textValue.isError() || textValue.isString() || textValue.isBoolean()) {
          return textValue;
        }
        let formatTextValue = formatTextArray.get(rowIndex, columnIndex) || StringValueObject.create(" ");
        if (formatTextValue.isError()) {
          return formatTextValue;
        }
        if (formatTextValue.isBoolean()) {
          return ErrorValueObject.create("#VALUE!" /* VALUE */);
        }
        if (formatTextValue.isNull()) {
          formatTextValue = StringValueObject.create(" ");
        }
        const formatTextValueString = `${formatTextValue.getValue()}`;
        if (textValue.isNull()) {
          textValue = NumberValueObject.create(0);
        }
        const textValueNumber = textValue.getValue();
        const previewText = getFormatPreview(formatTextValueString, textValueNumber);
        return StringValueObject.create(previewText);
      });
    }
  };

  // ../packages/engine-formula/src/functions/text/function-map.ts
  var functionText = [
    [Concatenate, "CONCATENATE" /* CONCATENATE */],
    [Len, "LEN" /* LEN */],
    [Lenb, "LENB" /* LENB */],
    [Text, "TEXT" /* TEXT */]
  ];

  // ../packages/engine-formula/src/functions/univer/function-map.ts
  var functionUniver = [];

  // ../packages/engine-formula/src/functions/web/function-map.ts
  var functionWeb = [];

  // ../packages/engine-formula/src/services/defined-names.service.ts
  var DefinedNamesService = class extends Disposable {
    constructor() {
      super(...arguments);
      // 18.2.6 definedNames (Defined Names)
      __publicField(this, "_definedNameMap", /* @__PURE__ */ new Map());
    }
    dispose() {
      this._definedNameMap.clear();
    }
    registerDefinedName(unitId, name, formulaOrRefString) {
      var _a2;
      const unitMap = this._definedNameMap.get(unitId);
      if (unitMap == null) {
        this._definedNameMap.set(unitId, /* @__PURE__ */ new Map());
      }
      (_a2 = this._definedNameMap.get(unitId)) == null ? void 0 : _a2.set(name, formulaOrRefString);
    }
    removeDefinedName(unitId, name) {
      var _a2;
      (_a2 = this._definedNameMap.get(unitId)) == null ? void 0 : _a2.delete(name);
    }
    getDefinedNameMap(unitId) {
      return this._definedNameMap.get(unitId);
    }
    getValue(unitId, name) {
      var _a2;
      return (_a2 = this._definedNameMap.get(unitId)) == null ? void 0 : _a2.get(name);
    }
    hasDefinedName(unitId) {
      var _a2;
      const size = ((_a2 = this._definedNameMap.get(unitId)) == null ? void 0 : _a2.size) || 0;
      return size !== 0;
    }
  };
  var IDefinedNamesService = createIdentifier("univer.formula.defined-names.service");

  // ../packages/engine-formula/src/services/current-data.service.ts
  var FormulaCurrentConfigService = class extends Disposable {
    constructor(_currentUniverService) {
      super();
      this._currentUniverService = _currentUniverService;
      __publicField(this, "_unitData", {});
      __publicField(this, "_arrayFormulaCellData", {});
      __publicField(this, "_formulaData", {});
      __publicField(this, "_sheetNameMap", {});
      __publicField(this, "_forceCalculate", false);
      __publicField(this, "_dirtyRanges", []);
      __publicField(this, "_dirtyNameMap", {});
      __publicField(this, "_numfmtItemMap", {});
      __publicField(this, "_dirtyUnitFeatureMap", {});
      __publicField(this, "_dirtyUnitOtherFormulaMap", {});
      __publicField(this, "_excludedCell");
      __publicField(this, "_sheetIdToNameMap", {});
    }
    dispose() {
      this._unitData = {};
      this._formulaData = {};
      this._arrayFormulaCellData = {};
      this._sheetNameMap = {};
      this._dirtyRanges = [];
      this._dirtyNameMap = {};
      this._numfmtItemMap = {};
      this._dirtyUnitFeatureMap = {};
      this._excludedCell = {};
      this._sheetIdToNameMap = {};
      this._dirtyUnitOtherFormulaMap = {};
    }
    getExcludedRange() {
      return this._excludedCell;
    }
    getUnitData() {
      return this._unitData;
    }
    getFormulaData() {
      return this._formulaData;
    }
    getArrayFormulaCellData() {
      return this._arrayFormulaCellData;
    }
    getSheetNameMap() {
      return this._sheetNameMap;
    }
    isForceCalculate() {
      return this._forceCalculate;
    }
    getDirtyRanges() {
      return this._dirtyRanges;
    }
    getDirtyNameMap() {
      return this._dirtyNameMap;
    }
    getNumfmtItemMap() {
      return this._numfmtItemMap;
    }
    getDirtyUnitFeatureMap() {
      return this._dirtyUnitFeatureMap;
    }
    getDirtyUnitOtherFormulaMap() {
      return this._dirtyUnitOtherFormulaMap;
    }
    getSheetName(unitId, sheetId) {
      if (this._sheetIdToNameMap[unitId] == null) {
        return "";
      }
      return this._sheetIdToNameMap[unitId][sheetId] || "";
    }
    load(config2) {
      if (config2.allUnitData && config2.unitSheetNameMap) {
        this._unitData = config2.allUnitData;
        this._sheetNameMap = config2.unitSheetNameMap;
      } else {
        const { allUnitData, unitSheetNameMap } = this._loadSheetData();
        this._unitData = allUnitData;
        this._sheetNameMap = unitSheetNameMap;
      }
      this._formulaData = config2.formulaData;
      this._arrayFormulaCellData = convertUnitDataToRuntime(config2.arrayFormulaCellData);
      this._forceCalculate = config2.forceCalculate;
      this._dirtyRanges = config2.dirtyRanges;
      this._dirtyNameMap = config2.dirtyNameMap;
      this._numfmtItemMap = config2.numfmtItemMap;
      this._dirtyUnitFeatureMap = config2.dirtyUnitFeatureMap;
      this._dirtyUnitOtherFormulaMap = config2.dirtyUnitOtherFormulaMap;
      this._excludedCell = config2.excludedCell;
      this._mergeNameMap(this._sheetNameMap, this._dirtyNameMap);
    }
    loadDirtyRangesAndExcludedCell(dirtyRanges, excludedCell) {
      this._dirtyRanges = dirtyRanges;
      this._excludedCell = excludedCell;
      this._dirtyNameMap = {};
    }
    registerUnitData(unitData) {
      this._unitData = unitData;
    }
    registerFormulaData(formulaData) {
      this._formulaData = formulaData;
    }
    registerSheetNameMap(sheetNameMap) {
      this._sheetNameMap = sheetNameMap;
    }
    // private _loadOtherFormulaData() {
    //     const unitAllDoc = this._currentUniverService.getAllUniverDocsInstance();
    //     const unitAllSlide = this._currentUniverService.getAllUniverSlidesInstance();
    //     const otherFormulaData: IOtherFormulaData = {};
    //     for (const documentDataModel of unitAllDoc) {
    //         const unitId = documentDataModel.getUnitId();
    //         if (otherFormulaData[unitId] == null) {
    //             otherFormulaData[unitId] = {};
    //         }
    //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
    //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
    //         }
    //         const subComponent = otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID];
    //         const customRanges = documentDataModel.getBody()?.customRanges;
    //         if (customRanges == null) {
    //             continue;
    //         }
    //         for (const customRange of customRanges) {
    //             subComponent[customRange.rangeId] = {
    //                 f: customRange.endIndex.toString(),
    //             };
    //         }
    //     }
    //     for (const slide of unitAllSlide) {
    //         const unitId = slide.getUnitId();
    //         if (otherFormulaData[unitId] == null) {
    //             otherFormulaData[unitId] = {};
    //         }
    //         if (otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] == null) {
    //             otherFormulaData[unitId][DEFAULT_DOCUMENT_SUB_COMPONENT_ID] = {};
    //         }
    //         const pages = slide.getPages();
    //         if (pages == null) {
    //             continue;
    //         }
    //         const pageIds = Object.keys(pages);
    //         for (const pageId of pageIds) {
    //             const page = pages[pageId];
    //             const subComponent = otherFormulaData[unitId][pageId];
    //             const pageElements = page.pageElements;
    //             if (pageElements == null) {
    //                 continue;
    //             }
    //             const pageElementIds = Object.keys(pageElements);
    //             for (const pageElementId of pageElementIds) {
    //                 const pageElement = pageElements[pageElementId];
    //                 subComponent[pageElementId] = {
    //                     f: pageElement.title,
    //                 };
    //             }
    //         }
    //     }
    //     return otherFormulaData;
    // }
    _mergeNameMap(unitSheetNameMap, dirtyNameMap) {
      Object.keys(dirtyNameMap).forEach((unitId) => {
        if (dirtyNameMap[unitId]) {
          Object.keys(dirtyNameMap[unitId]).forEach((sheetId) => {
            if (unitSheetNameMap[unitId] == null) {
              unitSheetNameMap[unitId] = {};
            }
            unitSheetNameMap[unitId][dirtyNameMap[unitId][sheetId]] = sheetId;
          });
        }
      });
      this._sheetIdToNameMap = {};
      Object.keys(unitSheetNameMap).forEach((unitId) => {
        Object.keys(unitSheetNameMap[unitId]).forEach((sheetName) => {
          if (this._sheetIdToNameMap[unitId] == null) {
            this._sheetIdToNameMap[unitId] = {};
          }
          this._sheetIdToNameMap[unitId][unitSheetNameMap[unitId][sheetName]] = sheetName;
        });
      });
    }
    _loadSheetData() {
      const unitAllSheet = this._currentUniverService.getAllUniverSheetsInstance();
      const allUnitData = {};
      const unitSheetNameMap = {};
      for (const workbook of unitAllSheet) {
        const unitId = workbook.getUnitId();
        const sheets = workbook.getSheets();
        const sheetData = {};
        const sheetNameMap = {};
        for (const sheet of sheets) {
          const sheetId = sheet.getSheetId();
          const sheetConfig = sheet.getConfig();
          sheetData[sheetId] = {
            cellData: new ObjectMatrix(sheetConfig.cellData),
            rowCount: sheetConfig.rowCount,
            columnCount: sheetConfig.columnCount,
            rowData: sheetConfig.rowData,
            columnData: sheetConfig.columnData
          };
          sheetNameMap[sheet.getName()] = sheet.getSheetId();
        }
        allUnitData[unitId] = sheetData;
        unitSheetNameMap[unitId] = sheetNameMap;
      }
      return {
        allUnitData,
        unitSheetNameMap
      };
    }
  };
  FormulaCurrentConfigService = __decorateClass([
    __decorateParam(0, IUniverInstanceService)
  ], FormulaCurrentConfigService);
  var IFormulaCurrentConfigService = createIdentifier(
    "univer.formula.current-data.service"
  );

  // ../packages/engine-formula/src/services/runtime.service.ts
  var FormulaRuntimeService = class extends Disposable {
    constructor(_currentConfigService) {
      super();
      this._currentConfigService = _currentConfigService;
      __publicField(this, "_formulaExecuteStage", 0 /* IDLE */);
      __publicField(this, "_stopState", false);
      __publicField(this, "_currentRow", -1);
      __publicField(this, "_currentColumn", -1);
      __publicField(this, "_currentRowCount", Number.NEGATIVE_INFINITY);
      __publicField(this, "_currentColumnCount", Number.NEGATIVE_INFINITY);
      __publicField(this, "_currentSubUnitId", "");
      __publicField(this, "_currentUnitId", "");
      __publicField(this, "_runtimeData", {});
      __publicField(this, "_runtimeOtherData", {});
      // Data returned by other businesses through formula calculation, excluding the sheet.
      __publicField(this, "_unitArrayFormulaRange", {});
      __publicField(this, "_runtimeArrayFormulaCellData", {});
      __publicField(this, "_runtimeClearArrayFormulaCellData", {});
      __publicField(this, "_numfmtItemMap", {});
      __publicField(this, "_runtimeFeatureRange", {});
      __publicField(this, "_runtimeFeatureCellData", {});
      __publicField(this, "_functionsExecutedState", 0 /* INITIAL */);
      // lambdaId: { key: BaseAstNode }
      __publicField(this, "_functionDefinitionPrivacyVar", /* @__PURE__ */ new Map());
      __publicField(this, "_totalFormulasToCalculate", 0);
      __publicField(this, "_completedFormulasCount", 0);
      __publicField(this, "_totalArrayFormulasToCalculate", 0);
      __publicField(this, "_completedArrayFormulasCount", 0);
      __publicField(this, "_isCycleDependency", false);
    }
    get currentRow() {
      return this._currentRow;
    }
    get currentColumn() {
      return this._currentColumn;
    }
    get currentRowCount() {
      return this._currentRowCount;
    }
    get currentColumnCount() {
      return this._currentColumnCount;
    }
    get currentSubUnitId() {
      return this._currentSubUnitId;
    }
    get currentUnitId() {
      return this._currentUnitId;
    }
    dispose() {
      this.reset();
      this._runtimeFeatureCellData = {};
      this._runtimeFeatureRange = {};
    }
    enableCycleDependency() {
      this._isCycleDependency = true;
    }
    disableCycleDependency() {
      this._isCycleDependency = false;
    }
    isCycleDependency() {
      return this._isCycleDependency;
    }
    setTotalArrayFormulasToCalculate(value) {
      this._totalArrayFormulasToCalculate = value;
    }
    getTotalArrayFormulasToCalculate() {
      return this._totalArrayFormulasToCalculate;
    }
    setCompletedArrayFormulasCount(value) {
      this._completedArrayFormulasCount = value;
    }
    getCompletedArrayFormulasCount() {
      return this._completedArrayFormulasCount;
    }
    setTotalFormulasToCalculate(value) {
      this._totalFormulasToCalculate = value;
    }
    getTotalFormulasToCalculate() {
      return this._totalFormulasToCalculate;
    }
    setCompletedFormulasCount(value) {
      this._completedFormulasCount = value;
    }
    getCompletedFormulasCount() {
      return this._completedFormulasCount;
    }
    markedAsSuccessfullyExecuted() {
      this._functionsExecutedState = 3 /* SUCCESS */;
    }
    markedAsNoFunctionsExecuted() {
      this._functionsExecutedState = 2 /* NOT_EXECUTED */;
    }
    markedAsStopFunctionsExecuted() {
      this._functionsExecutedState = 1 /* STOP_EXECUTION */;
    }
    markedAsInitialFunctionsExecuted() {
      this._functionsExecutedState = 0 /* INITIAL */;
    }
    stopExecution() {
      this._stopState = true;
      this.setFormulaExecuteStage(0 /* IDLE */);
    }
    isStopExecution() {
      return this._stopState;
    }
    setFormulaExecuteStage(type) {
      this._formulaExecuteStage = type;
    }
    getFormulaExecuteStage() {
      return this._formulaExecuteStage;
    }
    reset() {
      this._formulaExecuteStage = 0 /* IDLE */;
      this._runtimeData = {};
      this._runtimeOtherData = {};
      this._unitArrayFormulaRange = {};
      this._numfmtItemMap = {};
      this._runtimeArrayFormulaCellData = {};
      this._runtimeClearArrayFormulaCellData = {};
      this._functionDefinitionPrivacyVar.clear();
      this.markedAsInitialFunctionsExecuted();
      this._isCycleDependency = false;
      this._totalFormulasToCalculate = 0;
      this._completedFormulasCount = 0;
    }
    setCurrent(row, column, rowCount, columnCount, sheetId, unitId) {
      this._currentRow = row;
      this._currentColumn = column;
      this._currentRowCount = rowCount;
      this._currentColumnCount = columnCount;
      this._currentSubUnitId = sheetId;
      this._currentUnitId = unitId;
    }
    clearFunctionDefinitionPrivacyVar() {
      this._functionDefinitionPrivacyVar.clear();
    }
    registerFunctionDefinitionPrivacyVar(lambdaId, lambdaVar) {
      this._functionDefinitionPrivacyVar.set(lambdaId, lambdaVar);
    }
    getFunctionDefinitionPrivacyVar(lambdaId) {
      return this._functionDefinitionPrivacyVar.get(lambdaId);
    }
    setRuntimeOtherData(formulaId, functionVariant) {
      const subUnitId = this._currentSubUnitId;
      const unitId = this._currentUnitId;
      if (this._runtimeOtherData[unitId] === void 0) {
        this._runtimeOtherData[unitId] = {};
      }
      const unitData = this._runtimeOtherData[unitId];
      if (unitData[subUnitId] === void 0) {
        unitData[subUnitId] = {};
      }
      const subComponentData = unitData[subUnitId];
      let cellDatas = [];
      if (functionVariant.isReferenceObject() || functionVariant.isValueObject() && functionVariant.isArray()) {
        const objectValueRefOrArray = functionVariant;
        const { startRow, startColumn } = objectValueRefOrArray.getRangePosition();
        objectValueRefOrArray.iterator((valueObject, rowIndex, columnIndex) => {
          const value = this._objectValueToCellValue(valueObject);
          const row = rowIndex - startRow;
          const column = columnIndex - startColumn;
          if (cellDatas[row] == null) {
            cellDatas[row] = [];
          }
          cellDatas[row][column] = value;
        });
      } else {
        cellDatas = [[this._objectValueToCellValue(functionVariant)]];
      }
      subComponentData[formulaId] = cellDatas;
    }
    setRuntimeData(functionVariant) {
      const row = this._currentRow;
      const column = this._currentColumn;
      const rowCount = this._currentRowCount;
      const columnCount = this.currentColumnCount;
      const sheetId = this._currentSubUnitId;
      const unitId = this._currentUnitId;
      if (this._runtimeData[unitId] == null) {
        this._runtimeData[unitId] = {};
      }
      const unitData = this._runtimeData[unitId];
      if (unitData[sheetId] == null) {
        unitData[sheetId] = new ObjectMatrix();
      }
      if (this._unitArrayFormulaRange[unitId] == null) {
        this._unitArrayFormulaRange[unitId] = {};
      }
      if (this._numfmtItemMap[unitId] == null) {
        this._numfmtItemMap[unitId] = {};
      }
      if (this._numfmtItemMap[unitId][sheetId] == null) {
        this._numfmtItemMap[unitId][sheetId] = {};
      }
      const numfmtItem = this._numfmtItemMap[unitId][sheetId];
      const arrayFormulaRange = this._unitArrayFormulaRange[unitId];
      let arrayData = new ObjectMatrix();
      if (arrayFormulaRange[sheetId]) {
        arrayData = new ObjectMatrix(arrayFormulaRange[sheetId]);
      }
      if (this._runtimeArrayFormulaCellData[unitId] === void 0) {
        this._runtimeArrayFormulaCellData[unitId] = {};
      }
      const arrayFormulaCellData = this._runtimeArrayFormulaCellData[unitId];
      if (arrayFormulaCellData[sheetId] == null) {
        arrayFormulaCellData[sheetId] = new ObjectMatrix();
      }
      if (this._runtimeClearArrayFormulaCellData[unitId] === void 0) {
        this._runtimeClearArrayFormulaCellData[unitId] = {};
      }
      const clearArrayFormulaCellData = this._runtimeClearArrayFormulaCellData[unitId];
      if (clearArrayFormulaCellData[sheetId] == null) {
        clearArrayFormulaCellData[sheetId] = new ObjectMatrix();
      }
      const sheetData = unitData[sheetId];
      const arrayUnitData = arrayFormulaCellData[sheetId];
      const clearArrayUnitData = clearArrayFormulaCellData[sheetId];
      if (functionVariant.isReferenceObject() || functionVariant.isValueObject() && functionVariant.isArray()) {
        const objectValueRefOrArray = functionVariant;
        const { startRow, startColumn, endRow, endColumn } = objectValueRefOrArray.getRangePosition();
        if (startRow === endRow && startColumn === endColumn) {
          const firstCell = objectValueRefOrArray.getFirstCell();
          const valueObject = this._objectValueToCellValue(firstCell);
          sheetData.setValue(row, column, valueObject);
          clearArrayUnitData.setValue(row, column, valueObject);
          if (numfmtItem[row] == null) {
            numfmtItem[row] = {};
          }
          numfmtItem[row][column] = firstCell.getPattern();
          return;
        }
        const arrayRange = {
          startRow: row,
          startColumn: column,
          endRow: endRow - startRow + row,
          endColumn: endColumn - startColumn + column
        };
        arrayData.setValue(row, column, arrayRange);
        arrayFormulaRange[sheetId] = arrayData.getData();
        if (this._checkIfArrayFormulaRangeHasData(unitId, sheetId, row, column, arrayRange) || this._checkIfArrayFormulaExceeded(rowCount, columnCount, arrayRange)) {
          const errorObject = this._objectValueToCellValue(ErrorValueObject.create("#SPILL!" /* SPILL */));
          sheetData.setValue(row, column, errorObject);
          clearArrayUnitData.setValue(row, column, errorObject);
        } else {
          const spillError = ErrorValueObject.create("#SPILL!" /* SPILL */);
          objectValueRefOrArray.iterator((valueObject, rowIndex, columnIndex) => {
            const value = this._objectValueToCellValue(valueObject);
            if (rowIndex === startRow && columnIndex === startColumn) {
              if (valueObject != null && valueObject.isError() && valueObject.isEqualType(spillError)) {
                clearArrayUnitData.setValue(row, column, {});
                sheetData.setValue(row, column, { ...this._objectValueToCellValue(spillError) });
                return false;
              }
              sheetData.setValue(row, column, { ...value });
            }
            const currentRow = rowIndex - startRow + row;
            const currentColumn = columnIndex - startColumn + column;
            arrayUnitData.setValue(currentRow, currentColumn, value);
            const pattern = valueObject == null ? void 0 : valueObject.getPattern();
            if (pattern) {
              if (numfmtItem[currentRow] == null) {
                numfmtItem[currentRow] = {};
              }
              numfmtItem[currentRow][currentColumn] = pattern;
            }
          });
        }
      } else {
        const valueObject = this._objectValueToCellValue(functionVariant);
        sheetData.setValue(row, column, valueObject);
        if (numfmtItem[row] == null) {
          numfmtItem[row] = {};
        }
        numfmtItem[row][column] = functionVariant.getPattern();
        clearArrayUnitData.setValue(row, column, valueObject);
      }
    }
    getUnitData() {
      return this._runtimeData;
    }
    getUnitArrayFormula() {
      return this._unitArrayFormulaRange;
    }
    getNumfmtItemMap() {
      return this._numfmtItemMap;
    }
    getRuntimeOtherData() {
      return this._runtimeOtherData;
    }
    getRuntimeArrayFormulaCellData() {
      return this._runtimeArrayFormulaCellData;
    }
    getRuntimeClearArrayFormulaCellData() {
      return this._runtimeClearArrayFormulaCellData;
    }
    getRuntimeFeatureRange() {
      return this._runtimeFeatureRange;
    }
    setRuntimeFeatureRange(featureId, featureRange) {
      this._runtimeFeatureRange[featureId] = featureRange;
    }
    getRuntimeFeatureCellData() {
      return this._runtimeFeatureCellData;
    }
    setRuntimeFeatureCellData(featureId, featureData) {
      this._runtimeFeatureCellData[featureId] = featureData;
    }
    getAllRuntimeData() {
      return {
        unitData: this.getUnitData(),
        arrayFormulaRange: this.getUnitArrayFormula(),
        unitOtherData: this.getRuntimeOtherData(),
        functionsExecutedState: this._functionsExecutedState,
        arrayFormulaCellData: this.getRuntimeArrayFormulaCellData(),
        clearArrayFormulaCellData: this.getRuntimeClearArrayFormulaCellData(),
        numfmtItemMap: this.getNumfmtItemMap(),
        runtimeFeatureRange: this.getRuntimeFeatureRange(),
        runtimeFeatureCellData: this.getRuntimeFeatureCellData()
      };
    }
    getRuntimeState() {
      return {
        totalFormulasToCalculate: this.getTotalFormulasToCalculate(),
        completedFormulasCount: this.getCompletedFormulasCount(),
        totalArrayFormulasToCalculate: this.getTotalArrayFormulasToCalculate(),
        completedArrayFormulasCount: this.getCompletedArrayFormulasCount(),
        stage: this.getFormulaExecuteStage()
      };
    }
    _objectValueToCellValue(objectValue) {
      if (objectValue == null) {
        return {
          v: 0,
          t: 2 /* NUMBER */
        };
      }
      if (objectValue.isError()) {
        return {
          v: objectValue.getErrorType(),
          t: 1 /* STRING */
        };
      }
      if (objectValue.isValueObject()) {
        const vo = objectValue;
        const v = vo.getValue();
        if (vo.isNumber()) {
          return {
            v,
            t: 2 /* NUMBER */
          };
        }
        if (vo.isBoolean()) {
          return {
            v,
            t: 3 /* BOOLEAN */
          };
        }
        if (vo.isString() && isRealNum(v)) {
          return {
            v,
            t: 4 /* FORCE_STRING */
          };
        }
        return {
          v,
          t: 1 /* STRING */
        };
      }
    }
    _checkIfArrayFormulaRangeHasData(formulaUnitId, formulaSheetId, formulaRow, formulaColumn, arrayRange) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      const { startRow, startColumn, endRow, endColumn } = arrayRange;
      const unitData = this._currentConfigService.getUnitData();
      const unitArrayFormulaRange = (_c = (_b2 = (_a2 = this._unitArrayFormulaRange[formulaUnitId]) == null ? void 0 : _a2[formulaSheetId]) == null ? void 0 : _b2[formulaRow]) == null ? void 0 : _c[formulaColumn];
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startColumn; c <= endColumn; c++) {
          if (r === formulaRow && formulaColumn === c) {
            continue;
          }
          const cell = (_f = (_e = (_d = this._runtimeData) == null ? void 0 : _d[formulaUnitId]) == null ? void 0 : _e[formulaSheetId]) == null ? void 0 : _f.getValue(r, c);
          const arrayDataCell = (_i = (_h = (_g = this._runtimeArrayFormulaCellData) == null ? void 0 : _g[formulaUnitId]) == null ? void 0 : _h[formulaSheetId]) == null ? void 0 : _i.getValue(
            r,
            c
          );
          const currentCell = (_l = (_k = (_j = unitData == null ? void 0 : unitData[formulaUnitId]) == null ? void 0 : _j[formulaSheetId]) == null ? void 0 : _k.cellData) == null ? void 0 : _l.getValue(r, c);
          if (!isNullCell(cell) || !isNullCell(arrayDataCell) && !this._isInArrayFormulaRange(unitArrayFormulaRange, r, c) || !isNullCell(currentCell)) {
            return true;
          }
        }
      }
      return false;
    }
    _isInArrayFormulaRange(range, r, c) {
      if (range == null) {
        return false;
      }
      const { startRow, startColumn, endRow, endColumn } = range;
      if (r >= startRow && r <= endRow && c >= startColumn && c <= endColumn) {
        return true;
      }
      return false;
    }
    _checkIfArrayFormulaExceeded(rowCount, columnCount, arrayRange) {
      if (arrayRange.endRow >= rowCount || arrayRange.endColumn >= columnCount) {
        return true;
      }
      return false;
    }
    _isInDirtyRange(unitId, sheetId, row, column) {
      const dirtyRanges = this._currentConfigService.getDirtyRanges();
      if (dirtyRanges.length === 0) {
        return true;
      }
      return isInDirtyRange(dirtyRanges, unitId, sheetId, row, column);
    }
  };
  FormulaRuntimeService = __decorateClass([
    __decorateParam(0, IFormulaCurrentConfigService)
  ], FormulaRuntimeService);
  var IFormulaRuntimeService = createIdentifier("univer.formula.runtime.service");

  // ../packages/engine-formula/src/engine/analysis/lexer.ts
  var Lexer = class extends Disposable {
    constructor(_definedNamesService, _runtimeService, _lexerTreeBuilder) {
      super();
      this._definedNamesService = _definedNamesService;
      this._runtimeService = _runtimeService;
      this._lexerTreeBuilder = _lexerTreeBuilder;
    }
    treeBuilder(formulaString, transformSuffix = true) {
      return this._lexerTreeBuilder.treeBuilder(formulaString, transformSuffix, this._injectDefinedName.bind(this));
    }
    _injectDefinedName(sequenceArray) {
      var _a2;
      const unitId = this._runtimeService.currentUnitId;
      if (!this._definedNamesService.hasDefinedName(unitId)) {
        return {
          sequenceString: "",
          hasDefinedName: false
        };
      }
      const sequenceNodes = this._lexerTreeBuilder.getSequenceNode(sequenceArray);
      let sequenceString = "";
      let hasDefinedName = false;
      for (let i = 0, len = sequenceNodes.length; i < len; i++) {
        const node = sequenceNodes[i];
        if (typeof node === "string") {
          sequenceString += node;
          continue;
        }
        const { nodeType, token } = node;
        if (nodeType === 4 /* REFERENCE */ || nodeType === 3 /* FUNCTION */) {
          const definedContent = (_a2 = this._definedNamesService.getDefinedNameMap(unitId)) == null ? void 0 : _a2.get(token);
          if (definedContent) {
            sequenceString += definedContent;
            hasDefinedName = true;
          } else {
            sequenceString += token;
          }
        } else {
          sequenceString += token;
        }
      }
      return {
        sequenceString,
        hasDefinedName
      };
    }
  };
  Lexer = __decorateClass([
    __decorateParam(0, IDefinedNamesService),
    __decorateParam(1, IFormulaRuntimeService),
    __decorateParam(2, Inject(LexerTreeBuilder))
  ], Lexer);

  // ../packages/engine-formula/src/engine/ast-node/node-type.ts
  var NODE_ORDER_MAP = /* @__PURE__ */ new Map([
    ["ReferenceNode" /* REFERENCE */, 7],
    ["ValueNode" /* VALUE */, 9],
    ["OperatorNode" /* OPERATOR */, 8],
    ["FunctionNode" /* FUNCTION */, 6],
    ["LambdaNode" /* LAMBDA */, 1],
    ["LambdaNodeParameter" /* LAMBDA_PARAMETER */, 2],
    ["Root" /* ROOT */, 10],
    ["UnionNode" /* UNION */, 3],
    ["PrefixNode" /* PREFIX */, 4],
    ["SuffixNode" /* SUFFIX */, 5]
  ]);

  // ../packages/engine-formula/src/engine/ast-node/base-ast-node.ts
  var BaseAstNode = class extends Disposable {
    constructor(_token) {
      super();
      this._token = _token;
      __publicField(this, "_children", []);
      __publicField(this, "_parent");
      __publicField(this, "_valueObject");
      __publicField(this, "_calculateState", false);
      __publicField(this, "_async", false);
      __publicField(this, "_address", false);
      __publicField(this, "_refOffsetX", 0);
      __publicField(this, "_refOffsetY", 0);
    }
    dispose() {
      var _a2;
      this._children.forEach((node) => {
        node.dispose();
      });
      (_a2 = this._valueObject) == null ? void 0 : _a2.dispose();
      this._parent = null;
    }
    get nodeType() {
      return "Base" /* BASE */;
    }
    isAsync() {
      return this._async;
    }
    isAddress() {
      return this._address;
    }
    setAsync() {
      this._async = true;
    }
    setAddress() {
      this._address = true;
    }
    getParent() {
      return this._parent;
    }
    setParent(node) {
      this._parent = node;
      node.addChildren(this);
    }
    getChildren() {
      return this._children;
    }
    addChildren(...astNode) {
      this._children.push(...astNode);
    }
    getToken() {
      return this._token;
    }
    setValue(value) {
      this._valueObject = value;
    }
    getValue() {
      return this._valueObject;
    }
    isCalculated() {
      return this._calculateState;
    }
    setCalculated() {
      this._calculateState = true;
    }
    execute() {
    }
    setNotEmpty(state = true) {
    }
    setRefOffset(x = 0, y = 0) {
      this._refOffsetX = x;
      this._refOffsetY = y;
    }
    getRefOffset() {
      return {
        x: this._refOffsetX,
        y: this._refOffsetY
      };
    }
    async executeAsync() {
      return Promise.resolve(0 /* SUCCESS */);
    }
    serialize() {
      const token = this.getToken();
      const children = this.getChildren();
      const childrenSerialization = [];
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        childrenSerialization.push(item.serialize());
      }
      const result = {
        token,
        nodeType: this.nodeType
      };
      if (childrenCount > 0) {
        result.children = childrenSerialization;
      }
      return result;
    }
  };
  var ErrorNode = class _ErrorNode extends BaseAstNode {
    constructor(errorType) {
      super(errorType);
      __publicField(this, "_errorValueObject");
      this._errorValueObject = ErrorValueObject.create(errorType);
    }
    get nodeType() {
      return "ErrorNode" /* ERROR */;
    }
    static create(errorType) {
      return new _ErrorNode(errorType);
    }
    getValue() {
      return this._errorValueObject;
    }
  };

  // ../packages/engine-formula/src/engine/ast-node/base-ast-node-factory.ts
  var DEFAULT_AST_NODE_FACTORY_Z_INDEX = 100;
  var BaseAstNodeFactory = class extends Disposable {
    get zIndex() {
      return 0;
    }
    create(param, currentRow, currentColumn) {
      let token;
      if (param instanceof LexerNode) {
        token = param.getToken();
      } else {
        token = param;
      }
      return new BaseAstNode(token);
    }
    checkAndCreateNodeType(param) {
    }
  };

  // ../packages/engine-formula/src/engine/ast-node/ast-root-node.ts
  var AstRootNode = class extends BaseAstNode {
    get nodeType() {
      return "Root" /* ROOT */;
    }
    execute() {
      const children = this.getChildren();
      const node = children[0];
      if (node == null) {
        this.setValue(ErrorValueObject.create("#VALUE!" /* VALUE */));
      } else {
        this.setValue(node.getValue());
      }
    }
  };
  var AstRootNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("Root" /* ROOT */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    checkAndCreateNodeType(param) {
      if (!(param instanceof LexerNode)) {
        return;
      }
      const token = param.getToken();
      if (token === DEFAULT_TOKEN_TYPE_ROOT) {
        return new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
      }
    }
  };

  // ../packages/engine-formula/src/services/function.service.ts
  var FunctionService = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_functionExecutors", /* @__PURE__ */ new Map());
      __publicField(this, "_functionDescriptions", /* @__PURE__ */ new Map());
    }
    dispose() {
      this._functionExecutors.clear();
      this._functionDescriptions.clear();
    }
    registerExecutors(...functions) {
      for (let i = 0; i < functions.length; i++) {
        const func = functions[i];
        this._functionExecutors.set(func.name, func);
      }
    }
    getExecutors() {
      return this._functionExecutors;
    }
    getExecutor(functionToken) {
      return this._functionExecutors.get(functionToken);
    }
    hasExecutor(functionToken) {
      return this._functionExecutors.has(functionToken);
    }
    unregisterExecutors(...functionTokens) {
      for (let i = 0; i < functionTokens.length; i++) {
        const functionToken = functionTokens[i];
        this._functionExecutors.delete(functionToken);
      }
    }
    registerDescriptions(...descriptions) {
      for (let i = 0; i < descriptions.length; i++) {
        const description = descriptions[i];
        this._functionDescriptions.set(description.functionName, description);
      }
    }
    getDescriptions() {
      return this._functionDescriptions;
    }
    getDescription(functionToken) {
      return this._functionDescriptions.get(functionToken);
    }
    hasDescription(functionToken) {
      return this._functionDescriptions.has(functionToken);
    }
    unregisterDescriptions(...functionTokens) {
      for (let i = 0; i < functionTokens.length; i++) {
        const functionToken = functionTokens[i];
        this._functionDescriptions.delete(functionToken);
      }
    }
  };
  var IFunctionService = createIdentifier("univer.formula.function.service");

  // ../packages/engine-formula/src/engine/ast-node/prefix-node.ts
  var PrefixNode = class extends BaseAstNode {
    constructor(_accessor, _operatorString, _functionExecutor) {
      super(_operatorString);
      this._accessor = _accessor;
      this._operatorString = _operatorString;
      this._functionExecutor = _functionExecutor;
    }
    get nodeType() {
      return "PrefixNode" /* PREFIX */;
    }
    execute() {
      const children = this.getChildren();
      let value = children[0].getValue();
      let result;
      if (value == null) {
        throw new Error("object is null");
      }
      if (value.isReferenceObject()) {
        value = value.toArrayValueObject();
      }
      if (this._operatorString === "-" /* MINUS */) {
        result = this._functionExecutor.calculate(
          NumberValueObject.create(0),
          value
        );
      } else if (this._operatorString === "@" /* AT */) {
        result = this._handlerAT(value);
      } else {
        result = ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      this.setValue(result);
    }
    _handlerAT(value) {
      if (!value.isReferenceObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const currentValue = value;
      if (currentValue.isCell()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const runtimeService = this._accessor.get(IFormulaRuntimeService);
      const currentRow = runtimeService.currentRow || 0;
      const currentColumn = runtimeService.currentColumn || 0;
      if (currentValue.isRow()) {
        return currentValue.getCellByColumn(currentColumn);
      }
      if (currentValue.isColumn()) {
        return currentValue.getCellByRow(currentRow);
      }
      if (currentValue.isRange()) {
        return currentValue.getCellByPosition();
      }
      if (currentValue.isTable()) {
        return currentValue.getCellByPosition();
      }
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };
  var PrefixNodeFactory = class extends BaseAstNodeFactory {
    constructor(_functionService, _injector) {
      super();
      this._functionService = _functionService;
      this._injector = _injector;
    }
    get zIndex() {
      return NODE_ORDER_MAP.get("PrefixNode" /* PREFIX */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    checkAndCreateNodeType(param) {
      if (!(param instanceof LexerNode)) {
        return;
      }
      const token = param.getToken();
      const tokenTrim = token.trim();
      if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return;
      }
      let functionName = "";
      if (tokenTrim === "-" /* MINUS */) {
        functionName = "MINUS" /* MINUS */;
      } else if (tokenTrim === "@" /* AT */) {
        return new PrefixNode(this._injector, tokenTrim);
      } else {
        return;
      }
      const functionExecutor = this._functionService.getExecutor(functionName);
      if (!functionExecutor) {
        console.error(`No function ${token}`);
        return ErrorNode.create("#NAME?" /* NAME */);
      }
      return new PrefixNode(this._injector, tokenTrim, functionExecutor);
    }
  };
  PrefixNodeFactory = __decorateClass([
    __decorateParam(0, IFunctionService),
    __decorateParam(1, Inject(Injector))
  ], PrefixNodeFactory);

  // ../packages/engine-formula/src/engine/utils/prefixHandler.ts
  function prefixHandler(tokenTrim, functionService, injector) {
    let minusPrefixNode;
    let atPrefixNode;
    const prefix = tokenTrim.slice(0, 2);
    let sliceLength = 0;
    if (new RegExp("-" /* MINUS */, "g").test(prefix)) {
      const functionExecutor = functionService.getExecutor("MINUS" /* MINUS */);
      minusPrefixNode = new PrefixNode(injector, "-" /* MINUS */, functionExecutor);
      sliceLength++;
    }
    if (new RegExp("@" /* AT */, "g").test(prefix)) {
      atPrefixNode = new PrefixNode(injector, "@" /* AT */);
      if (minusPrefixNode) {
        atPrefixNode.setParent(minusPrefixNode);
      }
      sliceLength++;
    }
    if (sliceLength > 0) {
      tokenTrim = tokenTrim.slice(sliceLength);
    }
    return { tokenTrim, minusPrefixNode, atPrefixNode };
  }

  // ../packages/engine-formula/src/engine/ast-node/function-node.ts
  var FunctionNode = class extends BaseAstNode {
    constructor(token, _functionExecutor, _currentConfigService, _runtimeService) {
      super(token);
      this._functionExecutor = _functionExecutor;
      this._currentConfigService = _currentConfigService;
      this._runtimeService = _runtimeService;
      if (this._functionExecutor.isAsync()) {
        this.setAsync();
      }
      if (this._functionExecutor.isAddress()) {
        this.setAddress();
      }
    }
    get nodeType() {
      return "FunctionNode" /* FUNCTION */;
    }
    async executeAsync() {
      const variants = [];
      const children = this.getChildren();
      const childrenCount = children.length;
      this._compatibility();
      for (let i = 0; i < childrenCount; i++) {
        const object = children[i].getValue();
        if (object == null) {
          continue;
        }
        if (object.isReferenceObject()) {
          variants.push(object.toArrayValueObject());
        } else {
          variants.push(object);
        }
      }
      const resultVariant = this._calculate(variants);
      let result;
      if (resultVariant.isAsyncObject() || resultVariant.isAsyncArrayObject()) {
        result = await resultVariant.getValue();
      } else {
        result = resultVariant;
      }
      this._setRefData(result);
      this.setValue(result);
      return Promise.resolve(0 /* SUCCESS */);
    }
    execute() {
      const variants = [];
      const children = this.getChildren();
      const childrenCount = children.length;
      this._compatibility();
      for (let i = 0; i < childrenCount; i++) {
        const object = children[i].getValue();
        if (object == null) {
          continue;
        }
        if (object.isReferenceObject() && !this._functionExecutor.needsReferenceObject) {
          variants.push(object.toArrayValueObject());
        } else {
          variants.push(object);
        }
      }
      const resultVariant = this._calculate(variants);
      this._setRefData(resultVariant);
      this.setValue(resultVariant);
    }
    /**
     * Compatibility handling for special functions.
     */
    _compatibility() {
      this._lookupCompatibility();
    }
    /**
     * The LOOKUP function follows the following rules when dealing with vectors of different sizes:
     *    If the lookup_vector is larger than the result_vector,
     *    the LOOKUP function will ignore the extra portion of the lookup_vector and only use the portion of the result_vector that is the same size as the lookup_vector for lookup and returning results.
     *    If the lookup_vector is smaller than the result_vector,
     *    the LOOKUP function will continue using the last value of the result_vector for lookup and returning results after the last value of the lookup_vector.
     */
    _lookupCompatibility() {
      const children = this.getChildren();
      const childrenCount = children.length;
      if (!this._functionExecutor.needsExpandParams || childrenCount !== 3) {
        return;
      }
      const lookupVectorOrArray = children[1].getValue();
      const resultVector = children[2].getValue();
      if (!(lookupVectorOrArray == null ? void 0 : lookupVectorOrArray.isReferenceObject()) && !(resultVector == null ? void 0 : resultVector.isReferenceObject())) {
        return;
      }
      const lookupVectorOrArrayRange = lookupVectorOrArray.getRangeData();
      const resultVectorRange = resultVector.getRangeData();
      const { startRow, startColumn, endRow, endColumn } = lookupVectorOrArrayRange;
      const lookupCountRow = endRow - startRow + 1;
      const lookupCountColumn = endColumn - startColumn + 1;
      const { startRow: reStartRow, startColumn: reStartColumn, endRow: reEndRow, endColumn: reEndColumn } = resultVectorRange;
      const resultCountRow = reEndRow - reStartRow + 1;
      const resultCountColumn = reEndColumn - reStartColumn + 1;
      if (lookupCountRow !== resultCountRow) {
        resultVectorRange.endRow += lookupCountRow - resultCountRow;
      }
      if (lookupCountColumn !== resultCountColumn) {
        resultVectorRange.endColumn += lookupCountColumn - resultCountColumn;
      }
    }
    _calculate(variants) {
      var _a2;
      let resultVariant;
      this._setRefInfo();
      if (this._functionExecutor.isCustom()) {
        const resultVariantCustom = this._functionExecutor.calculateCustom(
          ...variants.map((variant) => {
            if (variant.isArray()) {
              return variant.toValue();
            }
            return variant.getValue();
          })
        );
        if (typeof resultVariantCustom !== "object" || resultVariantCustom == null) {
          resultVariant = ValueObjectFactory.create(resultVariantCustom);
        } else {
          const arrayValues = transformToValueObject(resultVariantCustom);
          resultVariant = ArrayValueObject.create({
            calculateValueList: arrayValues,
            rowCount: arrayValues.length,
            columnCount: ((_a2 = arrayValues[0]) == null ? void 0 : _a2.length) || 0,
            unitId: "",
            sheetId: "",
            row: -1,
            column: -1
          });
        }
      } else {
        resultVariant = this._functionExecutor.calculate(...variants);
      }
      return resultVariant;
    }
    _setRefInfo() {
      const { currentUnitId, currentSubUnitId, currentRow, currentColumn } = this._runtimeService;
      this._functionExecutor.setRefInfo(currentUnitId, currentSubUnitId, currentRow, currentColumn);
    }
    _setRefData(variant) {
      if (!variant.isReferenceObject()) {
        return;
      }
      const referenceObject = variant;
      referenceObject.setForcedSheetId(this._currentConfigService.getSheetNameMap());
      referenceObject.setUnitData(this._currentConfigService.getUnitData());
      referenceObject.setArrayFormulaCellData(this._currentConfigService.getArrayFormulaCellData());
      referenceObject.setRuntimeData(this._runtimeService.getUnitData());
      referenceObject.setRuntimeArrayFormulaCellData(this._runtimeService.getRuntimeArrayFormulaCellData());
      referenceObject.setRuntimeFeatureCellData(this._runtimeService.getRuntimeFeatureCellData());
    }
  };
  var FunctionNodeFactory = class extends BaseAstNodeFactory {
    constructor(_functionService, _currentConfigService, _runtimeService, _injector) {
      super();
      this._functionService = _functionService;
      this._currentConfigService = _currentConfigService;
      this._runtimeService = _runtimeService;
      this._injector = _injector;
    }
    get zIndex() {
      return NODE_ORDER_MAP.get("FunctionNode" /* FUNCTION */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    create(token) {
      const functionExecutor = this._functionService.getExecutor(token);
      if (!functionExecutor) {
        console.error(`No function ${token}`);
        return ErrorNode.create("#NAME?" /* NAME */);
      }
      return new FunctionNode(token, functionExecutor, this._currentConfigService, this._runtimeService);
    }
    checkAndCreateNodeType(param) {
      if (typeof param === "string") {
        return;
      }
      const token = param.getToken();
      const { tokenTrim, minusPrefixNode, atPrefixNode } = prefixHandler(token.trim(), this._functionService, this._injector);
      if (!Number.isNaN(Number(tokenTrim))) {
        return ErrorNode.create("#VALUE!" /* VALUE */);
      }
      const tokenTrimUpper = tokenTrim.toUpperCase();
      if (this._functionService.hasExecutor(tokenTrimUpper)) {
        const functionNode = this.create(tokenTrimUpper);
        if (atPrefixNode) {
          functionNode.setParent(atPrefixNode);
        } else if (minusPrefixNode) {
          functionNode.setParent(minusPrefixNode);
        }
        return functionNode;
      }
    }
  };
  FunctionNodeFactory = __decorateClass([
    __decorateParam(0, IFunctionService),
    __decorateParam(1, IFormulaCurrentConfigService),
    __decorateParam(2, IFormulaRuntimeService),
    __decorateParam(3, Inject(Injector))
  ], FunctionNodeFactory);

  // ../packages/engine-formula/src/engine/interpreter/interpreter.ts
  var Interpreter = class extends Disposable {
    constructor(_runtimeService) {
      super();
      this._runtimeService = _runtimeService;
    }
    dispose() {
    }
    async executeAsync(node) {
      if (!node) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      await this._executeAsync(node);
      const value = node.getValue();
      if (value == null) {
        throw new Error("node value is null");
      }
      return Promise.resolve(value);
    }
    execute(node) {
      if (!node) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      this._execute(node);
      const value = node.getValue();
      if (value == null) {
        throw new Error("node value is null");
      }
      return value;
    }
    executePreCalculateNode(node) {
      node.execute();
      return node.getValue();
    }
    checkAsyncNode(node) {
      const result = [];
      this._checkAsyncNode(node, result);
      for (let i = 0, len = result.length; i < len; i++) {
        const item = result[i];
        if (item === true) {
          return true;
        }
      }
      return false;
    }
    _checkAsyncNode(node, resultList) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        resultList.push(item.isAsync());
        this._checkAsyncNode(item, resultList);
      }
    }
    async _executeAsync(node) {
      if (this._runtimeService.isStopExecution()) {
        return Promise.resolve(1 /* ERROR */);
      }
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        const token = item.getToken();
        if (token.toUpperCase() === DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME && item.isEmptyParamFunction()) {
          item.execute();
          continue;
        }
        await this._executeAsync(item);
      }
      if (node.nodeType === "FunctionNode" /* FUNCTION */ && node.isAsync()) {
        await node.executeAsync();
      } else {
        node.execute();
      }
      return Promise.resolve(0 /* SUCCESS */);
    }
    _execute(node) {
      if (this._runtimeService.isStopExecution()) {
        return 1 /* ERROR */;
      }
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        const token = item.getToken();
        if (token.toUpperCase() === DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME && item.isEmptyParamFunction()) {
          item.execute();
          continue;
        }
        this._execute(item);
      }
      node.execute();
      return 0 /* SUCCESS */;
    }
  };
  Interpreter = __decorateClass([
    __decorateParam(0, IFormulaRuntimeService)
  ], Interpreter);

  // ../packages/engine-formula/src/engine/utils/function-definition.ts
  function isFirstChildParameter(lexerNode) {
    if (!(lexerNode instanceof LexerNode)) {
      return false;
    }
    return lexerNode.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER;
  }
  function isChildRunTimeParameter(lexerNode) {
    if (!(lexerNode instanceof LexerNode)) {
      return false;
    }
    return lexerNode.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_OMIT_PARAMETER;
  }

  // ../packages/engine-formula/src/engine/value-object/lambda-value-object.ts
  function getRootLexerHasValueNode(node) {
    if (!node) {
      return;
    }
    if (node.getToken() !== DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
      return node;
    }
    const parameterNode = node;
    const currentLambdaPrivacyVar = parameterNode.getCurrentLambdaPrivacyVar();
    const lambdaParameter = parameterNode.getLambdaParameter();
    if (!currentLambdaPrivacyVar) {
      return;
    }
    const chainNode = currentLambdaPrivacyVar.get(lambdaParameter);
    if (chainNode == null && node.getValue()) {
      return node;
    }
    return getRootLexerHasValueNode(chainNode);
  }
  var LambdaValueObjectObject = class _LambdaValueObjectObject extends BaseValueObject {
    constructor(_lambdaNode, _interpreter, _lambdaPrivacyVarKeys) {
      super(0);
      this._lambdaNode = _lambdaNode;
      this._interpreter = _interpreter;
      this._lambdaPrivacyVarKeys = _lambdaPrivacyVarKeys;
      __publicField(this, "_lambdaPrivacyValueMap", /* @__PURE__ */ new Map());
      this._lambdaPrivacyValueMap.clear();
    }
    static create(lambdaNode, interpreter, lambdaPrivacyVarKeys) {
      return new _LambdaValueObjectObject(lambdaNode, interpreter, lambdaPrivacyVarKeys);
    }
    isLambda() {
      return true;
    }
    execute(...variants) {
      const paramCount = this._lambdaPrivacyVarKeys.length;
      if (variants.length !== paramCount) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      this._setLambdaPrivacyValueMap(variants);
      this._setLambdaNodeValue(this._lambdaNode);
      this._lambdaNode.setNotEmpty(false);
      let value;
      if (this._interpreter.checkAsyncNode(this._lambdaNode)) {
        value = new AsyncObject(this._interpreter.executeAsync(this._lambdaNode));
      } else {
        const o = this._interpreter.execute(this._lambdaNode);
        if (o.isReferenceObject()) {
          value = o.toArrayValueObject();
        } else {
          value = o;
        }
      }
      this._lambdaNode.setNotEmpty(true);
      return value;
    }
    _setLambdaNodeValue(node) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        const token = item.getToken();
        if (token === DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
          const lambdaParameter = item.getLambdaParameter();
          const value = this._lambdaPrivacyValueMap.get(lambdaParameter);
          if (value) {
            item.setValue(value);
          } else {
            const currentLambdaPrivacyVar = item.getCurrentLambdaPrivacyVar();
            const node2 = getRootLexerHasValueNode(currentLambdaPrivacyVar.get(lambdaParameter));
            if (node2 != null) {
              item.setValue(node2.getValue());
            }
          }
          continue;
        }
        this._setLambdaNodeValue(item);
      }
    }
    _setLambdaPrivacyValueMap(variants) {
      for (let i = 0; i < variants.length; i++) {
        const variant = variants[i];
        const key = this._lambdaPrivacyVarKeys[i];
        this._lambdaPrivacyValueMap.set(key, variant);
      }
    }
  };

  // ../packages/engine-formula/src/engine/ast-node/lambda-node.ts
  var LambdaNode = class extends BaseAstNode {
    constructor(token, _lambdaId, _interpreter, _lambdaPrivacyVarKeys) {
      super(token);
      this._lambdaId = _lambdaId;
      this._interpreter = _interpreter;
      this._lambdaPrivacyVarKeys = _lambdaPrivacyVarKeys;
      __publicField(this, "_isNotEmpty", true);
    }
    get nodeType() {
      return "LambdaNode" /* LAMBDA */;
    }
    setNotEmpty(state = false) {
      this._isNotEmpty = state;
    }
    isEmptyParamFunction() {
      return this.getChildren().length < 2 && this._isNotEmpty;
    }
    isFunctionParameter() {
      return this._lambdaId === null;
    }
    getLambdaId() {
      return this._lambdaId;
    }
    execute() {
      if (this.isEmptyParamFunction()) {
        this.setValue(LambdaValueObjectObject.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
      } else {
        const children = this.getChildren();
        const childrenCount = children.length;
        this.setValue(children[childrenCount - 1].getValue());
      }
    }
    // override async executeAsync() {
    //     if (this.isEmptyParamFunction()) {
    //         await this.setValue(LambdaValueObjectObject.create(this, this._interpreter, this._lambdaPrivacyVarKeys));
    //     } else {
    //         const children = this.getChildren();
    //         const childrenCount = children.length;
    //         await this.setValue(children[childrenCount - 1].getValue());
    //     }
    //     return Promise.resolve(AstNodePromiseType.SUCCESS);
    // }
  };
  var LambdaNodeFactory = class extends BaseAstNodeFactory {
    constructor(_runtimeService, _interpreter) {
      super();
      this._runtimeService = _runtimeService;
      this._interpreter = _interpreter;
    }
    get zIndex() {
      return NODE_ORDER_MAP.get("LambdaNode" /* LAMBDA */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    create(param) {
      const children = param.getChildren();
      const lambdaVar = children[0];
      let parameterArray = children.slice(1, -1);
      const functionStatementNode = children[children.length - 1];
      if (!(lambdaVar instanceof LexerNode && functionStatementNode instanceof LexerNode)) {
        return ErrorNode.create("#NAME?" /* NAME */);
      }
      if (lambdaVar.getToken() === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
        const lambdaVarChildren = lambdaVar.getChildren();
        if (parameterArray.length !== lambdaVarChildren.length) {
          return ErrorNode.create("#VALUE!" /* VALUE */);
        }
      } else {
        parameterArray = children.slice(0, -1);
      }
      const lambdaId = Tools.generateRandomId(8);
      const currentLambdaPrivacyVar = /* @__PURE__ */ new Map();
      for (let i = 0; i < parameterArray.length; i++) {
        const parameter = parameterArray[i];
        if (parameter instanceof LexerNode) {
          const variant = parameter.getChildren()[0];
          parameter.setToken(DEFAULT_TOKEN_TYPE_LAMBDA_OMIT_PARAMETER);
          currentLambdaPrivacyVar.set(variant.trim(), void 0);
        } else {
          return ErrorNode.create("#VALUE!" /* VALUE */);
        }
      }
      this._runtimeService.registerFunctionDefinitionPrivacyVar(lambdaId, currentLambdaPrivacyVar);
      this._updateLambdaStatement(functionStatementNode, lambdaId, currentLambdaPrivacyVar);
      return new LambdaNode(param.getToken(), lambdaId, this._interpreter, [...currentLambdaPrivacyVar.keys()]);
    }
    checkAndCreateNodeType(param) {
      if (!(param instanceof LexerNode)) {
        return;
      }
      const token = param.getToken().trim().toUpperCase();
      if (token !== DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME) {
        return;
      }
      return this.create(param);
    }
    _updateLambdaStatement(functionStatementNode, lambdaId, currentLambdaPrivacyVar) {
      this._updateTree(functionStatementNode, lambdaId, currentLambdaPrivacyVar);
    }
    _updateTree(functionStatementNode, lambdaId, currentLambdaPrivacyVar) {
      const children = functionStatementNode.getChildren();
      const childrenCount = children.length;
      const firstChild = children[0];
      for (let i = 0; i < childrenCount; i++) {
        const node = children[i];
        if (isFirstChildParameter(firstChild) && i !== 0) {
          continue;
        }
        if (node instanceof LexerNode) {
          this._updateTree(node, lambdaId, currentLambdaPrivacyVar);
        } else {
          const token = node.trim();
          if (currentLambdaPrivacyVar.has(token)) {
            const newNode = new LexerNode();
            newNode.setToken(DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER);
            newNode.setLambdaId(lambdaId);
            newNode.setLambdaPrivacyVar(currentLambdaPrivacyVar);
            newNode.setLambdaParameter(token);
            children[i] = newNode;
          }
        }
      }
    }
  };
  LambdaNodeFactory = __decorateClass([
    __decorateParam(0, IFormulaRuntimeService),
    __decorateParam(1, Inject(Interpreter))
  ], LambdaNodeFactory);

  // ../packages/engine-formula/src/engine/ast-node/lambda-parameter-node.ts
  function getRootLexerNode(node) {
    if (!node) {
      return;
    }
    if (node.getToken() !== DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
      return node;
    }
    const parameterNode = node;
    const currentLambdaPrivacyVar = parameterNode.getCurrentLambdaPrivacyVar();
    const lambdaParameter = parameterNode.getLambdaParameter();
    if (!currentLambdaPrivacyVar) {
      return;
    }
    return getRootLexerNode(currentLambdaPrivacyVar.get(lambdaParameter));
  }
  var LambdaParameterNode = class extends BaseAstNode {
    constructor(token, _lambdaParameter, _currentLambdaPrivacyVar) {
      super(token);
      this._lambdaParameter = _lambdaParameter;
      this._currentLambdaPrivacyVar = _currentLambdaPrivacyVar;
    }
    getLambdaParameter() {
      return this._lambdaParameter;
    }
    getCurrentLambdaPrivacyVar() {
      return this._currentLambdaPrivacyVar;
    }
    get nodeType() {
      return "LambdaNodeParameter" /* LAMBDA_PARAMETER */;
    }
    execute() {
      const node = getRootLexerNode(this._currentLambdaPrivacyVar.get(this._lambdaParameter));
      if (!node) {
        const value = this.getValue();
        if (value == null || value.isError()) {
          this.setValue(ErrorValueObject.create("#SPILL!" /* SPILL */));
        }
      } else {
        this.setValue(node.getValue());
      }
    }
  };
  var LambdaParameterNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("LambdaNodeParameter" /* LAMBDA_PARAMETER */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    create(param) {
      const currentLambdaPrivacyVar = param.getFunctionDefinitionPrivacyVar();
      const lambdaParameter = param.getLambdaParameter();
      if (!currentLambdaPrivacyVar) {
        return new ErrorNode("#SPILL!" /* SPILL */);
      }
      return new LambdaParameterNode(param.getToken(), lambdaParameter, currentLambdaPrivacyVar);
    }
    checkAndCreateNodeType(param) {
      if (!(param instanceof LexerNode)) {
        return;
      }
      const token = param.getToken().trim();
      if (token !== DEFAULT_TOKEN_TYPE_LAMBDA_RUNTIME_PARAMETER) {
        return;
      }
      return this.create(param);
    }
  };

  // ../packages/engine-formula/src/engine/ast-node/null-node.ts
  var NullNode = class extends BaseAstNode {
    constructor(_operatorString) {
      super(_operatorString);
      this._operatorString = _operatorString;
    }
    get nodeType() {
      return "NullNode" /* NULL */;
    }
    execute() {
      this.setValue(NullValueObject.create());
    }
  };

  // ../packages/engine-formula/src/engine/ast-node/operator-node.ts
  var OperatorNode = class extends BaseAstNode {
    constructor(_operatorString, _functionExecutor) {
      super(_operatorString);
      this._operatorString = _operatorString;
      this._functionExecutor = _functionExecutor;
    }
    get nodeType() {
      return "OperatorNode" /* OPERATOR */;
    }
    execute() {
      var _a2, _b2;
      const children = this.getChildren();
      if (this._functionExecutor.name === "COMPARE" /* COMPARE */) {
        this._functionExecutor.setCompareType(this.getToken());
      }
      let object1 = (_a2 = children[0]) == null ? void 0 : _a2.getValue();
      let object2 = (_b2 = children[1]) == null ? void 0 : _b2.getValue();
      const token = this.getToken();
      if ((object1 == null || object2 == null) && token !== "-" /* MINUS */ && token !== "+" /* PLUS */) {
        this.setValue(ErrorValueObject.create("#VALUE!" /* VALUE */));
        return;
      }
      if (object1 == null) {
        object1 = NullValueObject.create();
      }
      if (object2 == null) {
        object2 = NullValueObject.create();
      }
      if (object1.isReferenceObject()) {
        object1 = object1.toArrayValueObject();
      }
      if (object2.isReferenceObject()) {
        object2 = object2.toArrayValueObject();
      }
      this.setValue(
        this._functionExecutor.calculate(
          object1,
          object2
        )
      );
    }
  };
  var OperatorNodeFactory = class extends BaseAstNodeFactory {
    constructor(_functionService) {
      super();
      this._functionService = _functionService;
    }
    get zIndex() {
      return NODE_ORDER_MAP.get("OperatorNode" /* OPERATOR */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    create(param) {
      let functionName = "";
      const tokenTrim = param;
      if (tokenTrim === "+" /* PLUS */) {
        functionName = "PLUS" /* PLUS */;
      } else if (tokenTrim === "-" /* MINUS */) {
        functionName = "MINUS" /* MINUS */;
      } else if (tokenTrim === "*" /* MULTIPLY */) {
        functionName = "MULTIPLY" /* MULTIPLY */;
      } else if (tokenTrim === "/" /* DIVIDED */) {
        functionName = "DIVIDED" /* DIVIDED */;
      } else if (tokenTrim === "&" /* CONCATENATE */) {
        functionName = "CONCATENATE" /* CONCATENATE */;
      } else if (tokenTrim === "^" /* POWER */) {
        functionName = "POWER" /* POWER */;
      } else if (OPERATOR_TOKEN_COMPARE_SET.has(tokenTrim)) {
        functionName = "COMPARE" /* COMPARE */;
      }
      const functionExecutor = this._functionService.getExecutor(functionName);
      if (!functionExecutor) {
        console.error(`No function ${param}`);
        return ErrorNode.create("#NAME?" /* NAME */);
      }
      return new OperatorNode(tokenTrim, functionExecutor);
    }
    checkAndCreateNodeType(param) {
      if (param instanceof LexerNode) {
        return;
      }
      const tokenTrim = param.trim();
      if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return;
      }
      if (OPERATOR_TOKEN_SET.has(tokenTrim)) {
        return this.create(tokenTrim);
      }
    }
  };
  OperatorNodeFactory = __decorateClass([
    __decorateParam(0, IFunctionService)
  ], OperatorNodeFactory);

  // ../packages/engine-formula/src/services/super-table.service.ts
  var SuperTableService = class extends Disposable {
    constructor() {
      super(...arguments);
      // 18.5.1.2 table (Table)
      __publicField(this, "_tableMap", /* @__PURE__ */ new Map());
      // 18.5.1.2 table (Table) for I18N
      __publicField(this, "_tableOptionMap", /* @__PURE__ */ new Map());
    }
    dispose() {
      this._tableMap.clear();
      this._tableOptionMap.clear();
    }
    remove(unitId, tableName) {
      var _a2;
      (_a2 = this._tableMap.get(unitId)) == null ? void 0 : _a2.delete(tableName);
    }
    getTableMap(unitId) {
      return this._tableMap.get(unitId);
    }
    getTableOptionMap() {
      return this._tableOptionMap;
    }
    registerTable(unitId, tableName, reference) {
      var _a2;
      if (this._tableMap.get(unitId) == null) {
        this._tableMap.set(unitId, /* @__PURE__ */ new Map());
      }
      (_a2 = this._tableMap.get(unitId)) == null ? void 0 : _a2.set(tableName, reference);
    }
    registerTableOptionMap(tableOption, tableOptionType) {
      this._tableOptionMap.set(tableOption, tableOptionType);
    }
  };
  var ISuperTableService = createIdentifier("univer.formula.super-table.service");

  // ../packages/engine-formula/src/engine/reference-object/table-reference-object.ts
  var TableReferenceObject = class extends BaseReferenceObject {
    constructor(token, _tableData, _columnDataString, tableOptionMap) {
      super(token);
      this._tableData = _tableData;
      this._columnDataString = _columnDataString;
      const sheetId = this._tableData.sheetId;
      const range = this._tableData.range;
      const titleMap = this._tableData.titleMap;
      this.setForcedSheetIdDirect(sheetId);
      const columnData = this._stringToColumnData(this._columnDataString, titleMap, tableOptionMap);
      const startColumn = columnData.startColumn;
      const endColumn = columnData.endColumn;
      const type = columnData.type;
      let startRow = -1;
      let endRow = -1;
      const tableStartRow = range.startRow;
      const tableEndRow = range.startColumn;
      if (type === "#All" /* ALL */) {
        startRow = tableStartRow;
        endRow = tableEndRow;
      } else if (type === "#Data" /* DATA */) {
        startRow = tableStartRow + 1;
        endRow = tableEndRow;
      } else if (type === "#Headers" /* HEADERS */) {
        startRow = tableStartRow;
        endRow = tableStartRow;
      } else if (type === "#Totals" /* TOTALS */) {
        startRow = tableEndRow;
        endRow = tableEndRow;
      }
      this.setRangeData({
        startColumn,
        endColumn,
        startRow,
        endRow
      });
    }
    isTable() {
      return true;
    }
    _stringToColumnData(columnDataString, titleMap, tableOptionMap) {
      columnDataString = columnDataString.substring(1, -1);
      const commaIndex = columnDataString.indexOf("," /* COMMA */);
      let startColumn = -1;
      let endColumn = -1;
      let type = "#All" /* ALL */;
      if (commaIndex === -1) {
        const data = this._columnHandler(columnDataString, titleMap);
        startColumn = data.startColumn;
        endColumn = data.endColumn;
      } else {
        const rowString = columnDataString.substring(0, commaIndex).substring(1, -1);
        const columnString = columnDataString.substring(commaIndex + 1);
        const data = this._columnHandler(columnString, titleMap, true);
        startColumn = data.startColumn;
        endColumn = data.endColumn;
        type = tableOptionMap.get(rowString);
        if (!type) {
          type = "#All" /* ALL */;
        }
      }
      return {
        startColumn,
        endColumn,
        type
      };
    }
    _columnHandler(rightString, titleMap, isSingle = false) {
      var _a2, _b2, _c;
      let startColumn = -1;
      let endColumn = -1;
      const colonIndex = rightString.indexOf(":" /* COLON */);
      if (new RegExp($SUPER_TABLE_COLUMN_REGEX, "g").test(rightString)) {
        const startColumnString = rightString.substring(0, colonIndex).substring(1, -1);
        const endColumnString = rightString.substring(colonIndex + 1).substring(1, -1);
        startColumn = (_a2 = titleMap.get(startColumnString)) != null ? _a2 : -1;
        endColumn = (_b2 = titleMap.get(endColumnString)) != null ? _b2 : -1;
      } else {
        if (isSingle) {
          rightString = rightString.substring(1, -1);
        }
        startColumn = (_c = titleMap.get(rightString)) != null ? _c : -1;
        endColumn = startColumn;
      }
      return {
        startColumn,
        endColumn
      };
    }
  };

  // ../packages/engine-formula/src/engine/ast-node/reference-node.ts
  var ReferenceNode = class extends BaseAstNode {
    constructor(_accessor, _operatorString, _referenceObject, _isPrepareMerge = false) {
      super(_operatorString);
      this._accessor = _accessor;
      this._operatorString = _operatorString;
      this._referenceObject = _referenceObject;
      this._isPrepareMerge = _isPrepareMerge;
    }
    get nodeType() {
      return "ReferenceNode" /* REFERENCE */;
    }
    execute() {
      const currentConfigService = this._accessor.get(IFormulaCurrentConfigService);
      const runtimeService = this._accessor.get(IFormulaRuntimeService);
      this._referenceObject.setDefaultUnitId(runtimeService.currentUnitId);
      this._referenceObject.setDefaultSheetId(runtimeService.currentSubUnitId);
      this._referenceObject.setForcedSheetId(currentConfigService.getSheetNameMap());
      this._referenceObject.setUnitData(currentConfigService.getUnitData());
      this._referenceObject.setArrayFormulaCellData(currentConfigService.getArrayFormulaCellData());
      this._referenceObject.setRuntimeData(runtimeService.getUnitData());
      this._referenceObject.setNumfmtItemData(currentConfigService.getNumfmtItemMap());
      this._referenceObject.setRuntimeArrayFormulaCellData(runtimeService.getRuntimeArrayFormulaCellData());
      this._referenceObject.setRuntimeFeatureCellData(runtimeService.getRuntimeFeatureCellData());
      const { x, y } = this.getRefOffset();
      this._referenceObject.setRefOffset(x, y);
      if (!this._isPrepareMerge && this._referenceObject.isExceedRange()) {
        this.setValue(ErrorValueObject.create("#NAME?" /* NAME */));
      } else {
        this.setValue(this._referenceObject);
      }
    }
  };
  var ReferenceNodeFactory = class extends BaseAstNodeFactory {
    constructor(_definedNamesService, _superTableService, _formulaRuntimeService, _functionService, _injector) {
      super();
      this._definedNamesService = _definedNamesService;
      this._superTableService = _superTableService;
      this._formulaRuntimeService = _formulaRuntimeService;
      this._functionService = _functionService;
      this._injector = _injector;
    }
    get zIndex() {
      return NODE_ORDER_MAP.get("ReferenceNode" /* REFERENCE */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    checkAndCreateNodeType(param) {
      var _a2, _b2;
      let isLexerNode = false;
      let tokenTrimPre;
      let isPrepareMerge = false;
      if (param instanceof LexerNode) {
        isLexerNode = true;
        tokenTrimPre = param.getToken().trim();
        if (((_b2 = (_a2 = param.getParent()) == null ? void 0 : _a2.getParent()) == null ? void 0 : _b2.getToken().trim()) === ":" /* COLON */) {
          isPrepareMerge = true;
        }
      } else {
        tokenTrimPre = param.trim();
      }
      const { tokenTrim, minusPrefixNode, atPrefixNode } = prefixHandler(tokenTrimPre, this._functionService, this._injector);
      if (!isLexerNode && tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return;
      }
      let node;
      if (new RegExp(REFERENCE_SINGLE_RANGE_REGEX).test(tokenTrim)) {
        node = new ReferenceNode(this._injector, tokenTrim, new CellReferenceObject(tokenTrim), isPrepareMerge);
      } else if (isLexerNode && new RegExp(REFERENCE_REGEX_SINGLE_ROW).test(tokenTrim)) {
        node = new ReferenceNode(this._injector, tokenTrim, new RowReferenceObject(tokenTrim), isPrepareMerge);
      } else if (isLexerNode && new RegExp(REFERENCE_REGEX_SINGLE_COLUMN).test(tokenTrim)) {
        node = new ReferenceNode(this._injector, tokenTrim, new ColumnReferenceObject(tokenTrim), isPrepareMerge);
      } else {
        const unitId = this._formulaRuntimeService.currentUnitId;
        const tableMap = this._superTableService.getTableMap(unitId);
        const $regex = new RegExp($SUPER_TABLE_COLUMN_REGEX, "g");
        const tableName = tokenTrim.replace($regex, "");
        if (!isLexerNode && (tableMap == null ? void 0 : tableMap.has(tableName))) {
          const columnResult = $regex.exec(tokenTrim);
          let columnDataString = "";
          if (columnResult) {
            columnDataString = columnResult[0];
          }
          const tableData = tableMap.get(tableName);
          const tableOption = this._superTableService.getTableOptionMap();
          node = new ReferenceNode(
            this._injector,
            tokenTrim,
            new TableReferenceObject(tokenTrim, tableData, columnDataString, tableOption)
          );
        }
      }
      if (node) {
        if (atPrefixNode) {
          node.setParent(atPrefixNode);
        } else if (minusPrefixNode) {
          node.setParent(minusPrefixNode);
        }
        return node;
      }
    }
  };
  ReferenceNodeFactory = __decorateClass([
    __decorateParam(0, IDefinedNamesService),
    __decorateParam(1, ISuperTableService),
    __decorateParam(2, IFormulaRuntimeService),
    __decorateParam(3, IFunctionService),
    __decorateParam(4, Inject(Injector))
  ], ReferenceNodeFactory);

  // ../packages/engine-formula/src/engine/ast-node/suffix-node.ts
  var SuffixNode = class extends BaseAstNode {
    constructor(_accessor, _operatorString, _functionExecutor) {
      super(_operatorString);
      this._accessor = _accessor;
      this._operatorString = _operatorString;
      this._functionExecutor = _functionExecutor;
    }
    get nodeType() {
      return "SuffixNode" /* SUFFIX */;
    }
    execute() {
      const children = this.getChildren();
      let value = children[0].getValue();
      let result;
      if (value == null) {
        throw new Error("object is null");
      }
      if (this._operatorString === "%" /* PERCENTAGE */) {
        if (value.isReferenceObject()) {
          value = value.toArrayValueObject();
        }
        result = this._functionExecutor.calculate(
          value,
          NumberValueObject.create(100)
        );
        if (result.isNumber()) {
          result.setPattern("0.00%");
        }
      } else if (this._operatorString === "#" /* POUND */) {
        result = this._handlerPound(value);
      } else {
        result = ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      this.setValue(result);
    }
    _handlerPound(value) {
      var _a2, _b2, _c, _d;
      if (!value.isReferenceObject()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      if (!value.isCell()) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const currentConfigService = this._accessor.get(IFormulaCurrentConfigService);
      const lexer = this._accessor.get(Lexer);
      const cellValue = value;
      const range = cellValue.getRangePosition();
      const unitId = cellValue.getUnitId();
      const sheetId = cellValue.getSheetId();
      const formulaData = currentConfigService.getFormulaData();
      const formulaString = (_d = (_c = (_b2 = (_a2 = formulaData == null ? void 0 : formulaData[unitId]) == null ? void 0 : _a2[sheetId]) == null ? void 0 : _b2[range.startRow]) == null ? void 0 : _c[range.startColumn]) == null ? void 0 : _d.f;
      if (!formulaString) {
        return ErrorValueObject.create("#VALUE!" /* VALUE */);
      }
      const lexerNode = lexer.treeBuilder(formulaString);
      return ErrorValueObject.create("#VALUE!" /* VALUE */);
    }
  };
  var SuffixNodeFactory = class extends BaseAstNodeFactory {
    constructor(_functionService, _injector) {
      super();
      this._functionService = _functionService;
      this._injector = _injector;
    }
    get zIndex() {
      return NODE_ORDER_MAP.get("SuffixNode" /* SUFFIX */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    checkAndCreateNodeType(param) {
      if (!(param instanceof LexerNode)) {
        return;
      }
      const tokenTrim = param.getToken().trim();
      if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return;
      }
      let functionName = "";
      if (tokenTrim === "%" /* PERCENTAGE */) {
        functionName = "DIVIDED" /* DIVIDED */;
      } else if (tokenTrim === "#" /* POUND */) {
        return new SuffixNode(this._injector, tokenTrim);
      } else {
        return;
      }
      const functionExecutor = this._functionService.getExecutor(functionName);
      if (!functionExecutor) {
        console.error(`No function ${param}`);
        return ErrorNode.create("#NAME?" /* NAME */);
      }
      return new SuffixNode(this._injector, tokenTrim, functionExecutor);
    }
  };
  SuffixNodeFactory = __decorateClass([
    __decorateParam(0, IFunctionService),
    __decorateParam(1, Inject(Injector))
  ], SuffixNodeFactory);

  // ../packages/engine-formula/src/engine/ast-node/union-node.ts
  var UnionNode = class extends BaseAstNode {
    constructor(_operatorString) {
      super(_operatorString);
      this._operatorString = _operatorString;
    }
    get nodeType() {
      return "UnionNode" /* UNION */;
    }
    execute() {
      const children = this.getChildren();
      const leftNode = children[0].getValue();
      const rightNode = children[1].getValue();
      if (leftNode == null || rightNode == null) {
        throw new Error("leftNode and rightNode");
      }
      let result;
      if (this._operatorString === ":" /* COLON */) {
        result = this._unionFunction(leftNode, rightNode);
      } else {
        result = ErrorValueObject.create("#NAME?" /* NAME */);
      }
      this.setValue(result);
    }
    _unionFunction(variant1, variant2) {
      if (variant1.isError() || variant2.isError()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      if (!variant1.isReferenceObject() || !variant2.isReferenceObject()) {
        return ErrorValueObject.create("#REF!" /* REF */);
      }
      variant1 = variant1;
      variant2 = variant2;
      if (variant1.isCell() && variant2.isCell()) {
        return variant1.unionBy(variant2);
      }
      if (variant1.isRow() && variant2.isRow()) {
        return variant1.unionBy(variant2);
      }
      if (variant1.isColumn() && variant2.isColumn()) {
        return variant1.unionBy(variant2);
      }
      return ErrorValueObject.create("#REF!" /* REF */);
    }
  };
  var UnionNodeFactory = class extends BaseAstNodeFactory {
    constructor(_functionService) {
      super();
      this._functionService = _functionService;
    }
    get zIndex() {
      return NODE_ORDER_MAP.get("UnionNode" /* UNION */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    create(param) {
      return new UnionNode(param);
    }
    checkAndCreateNodeType(param) {
      if (!(param instanceof LexerNode)) {
        return;
      }
      const token = param.getToken();
      const tokenTrim = token.trim();
      if (tokenTrim.charAt(0) === '"' && tokenTrim.charAt(tokenTrim.length - 1) === '"') {
        return;
      }
      if (tokenTrim !== ":" /* COLON */) {
        return;
      }
      return this.create(tokenTrim);
    }
  };
  UnionNodeFactory = __decorateClass([
    __decorateParam(0, IFunctionService)
  ], UnionNodeFactory);

  // ../packages/engine-formula/src/engine/ast-node/value-node.ts
  var ValueNode = class extends BaseAstNode {
    constructor(_operatorString) {
      super(_operatorString);
      this._operatorString = _operatorString;
    }
    get nodeType() {
      return "ValueNode" /* VALUE */;
    }
    execute() {
      this.setValue(ValueObjectFactory.create(this._operatorString));
    }
  };
  var ValueNodeFactory = class extends BaseAstNodeFactory {
    get zIndex() {
      return NODE_ORDER_MAP.get("ValueNode" /* VALUE */) || DEFAULT_AST_NODE_FACTORY_Z_INDEX;
    }
    _checkValueNode(token) {
      if (Number.isNaN(Number(token))) {
        const tokenTrim = token.trim();
        const startToken = tokenTrim.charAt(0);
        const endToken = tokenTrim.charAt(tokenTrim.length - 1);
        if (ERROR_TYPE_SET.has(tokenTrim)) {
          return this.create(tokenTrim);
        }
        if (startToken === '"' && endToken === '"') {
          return this.create(tokenTrim);
        }
        if (startToken === "{" && endToken === "}") {
          return this.create(tokenTrim);
        }
        const tokenTrimUpper = tokenTrim.toUpperCase();
        if (tokenTrimUpper === "TRUE" /* TRUE */ || tokenTrimUpper === "FALSE" /* FALSE */) {
          return this.create(tokenTrimUpper);
        }
      } else {
        return this.create(token);
      }
    }
    create(param) {
      return new ValueNode(param);
    }
    checkAndCreateNodeType(param) {
      if (param instanceof LexerNode) {
        return;
      }
      return this._checkValueNode(param);
    }
  };

  // ../packages/engine-formula/src/engine/utils/ast-node-tool.ts
  function getAstNodeTopParent(node) {
    let parent = node;
    while (parent == null ? void 0 : parent.getParent()) {
      parent = parent.getParent();
    }
    return parent;
  }

  // ../packages/engine-formula/src/engine/analysis/parser.ts
  var AstTreeBuilder = class extends Disposable {
    constructor(_runtimeService, _astRootNodeFactory, _functionNodeFactory, _lambdaNodeFactory, _lambdaParameterNodeFactory, _operatorNodeFactory, _prefixNodeFactory, _referenceNodeFactory, _suffixNodeFactory, _unionNodeFactory, _valueNodeFactory) {
      super();
      this._runtimeService = _runtimeService;
      this._astRootNodeFactory = _astRootNodeFactory;
      this._functionNodeFactory = _functionNodeFactory;
      this._lambdaNodeFactory = _lambdaNodeFactory;
      this._lambdaParameterNodeFactory = _lambdaParameterNodeFactory;
      this._operatorNodeFactory = _operatorNodeFactory;
      this._prefixNodeFactory = _prefixNodeFactory;
      this._referenceNodeFactory = _referenceNodeFactory;
      this._suffixNodeFactory = _suffixNodeFactory;
      this._unionNodeFactory = _unionNodeFactory;
      this._valueNodeFactory = _valueNodeFactory;
      __publicField(this, "_astNodeFactoryList", []);
      __publicField(this, "_refOffsetX", 0);
      __publicField(this, "_refOffsetY", 0);
      this._initializeAstNode();
    }
    dispose() {
      this._astNodeFactoryList.forEach((nodeFactory) => {
        nodeFactory.dispose();
      });
      this._astNodeFactoryList = [];
    }
    parse(lexerNode, refOffsetX = 0, refOffsetY = 0) {
      const astNode = new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
      this._refOffsetX = refOffsetX;
      this._refOffsetY = refOffsetY;
      const node = this._parse(lexerNode, astNode);
      return node;
    }
    _lambdaParameterHandler(lexerNode, parent) {
      const lambdaId = parent.getLambdaId();
      const parentAstNode = new AstRootNode(DEFAULT_TOKEN_TYPE_ROOT);
      const currentLambdaPrivacyVar = this._runtimeService.getFunctionDefinitionPrivacyVar(lambdaId);
      if (!currentLambdaPrivacyVar) {
        return false;
      }
      const currentLambdaPrivacyVarKeys = [...currentLambdaPrivacyVar.keys()];
      const children = lexerNode.getChildren();
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        if (item instanceof LexerNode) {
          this._parse(item, parentAstNode);
        } else {
          return false;
        }
      }
      const parentChildren = parentAstNode.getChildren();
      const parentChildrenCount = parentChildren.length;
      for (let i = 0; i < parentChildrenCount; i++) {
        const item = parentChildren[i];
        currentLambdaPrivacyVar.set(currentLambdaPrivacyVarKeys[i], item);
      }
      parentAstNode.setParent(parent);
      return parent;
    }
    _changeLetToLambda(letLexerNode) {
      const letChildren = letLexerNode.getChildren();
      const letChildrenCount = letChildren.length;
      if (letChildrenCount % 2 !== 1 || letChildrenCount === 0) {
        return;
      }
      const newLambdaNode = new LexerNode();
      newLambdaNode.setToken(DEFAULT_TOKEN_LAMBDA_FUNCTION_NAME);
      const newLambdaParameterNode = new LexerNode();
      newLambdaParameterNode.setToken(DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER);
      const copyChildren = [...letChildren];
      for (let i = 0; i < letChildrenCount; i++) {
        const child = copyChildren[i];
        if (!(child instanceof LexerNode)) {
          return;
        }
        if (i % 2 === 0) {
          child.changeToParent(newLambdaNode);
        } else {
          child.changeToParent(newLambdaParameterNode);
        }
      }
      newLambdaNode.addChildrenFirst(newLambdaParameterNode);
      newLambdaParameterNode.setParent(newLambdaNode);
      const parent = letLexerNode.getParent();
      parent == null ? void 0 : parent.replaceChild(letLexerNode, newLambdaNode);
      return newLambdaNode;
    }
    _parse(lexerNode, parent) {
      const children = lexerNode.getChildren();
      const childrenCount = children.length;
      const calculateStack = [];
      let currentAstNode = null;
      const token = lexerNode.getToken().trim().toUpperCase();
      if (token === DEFAULT_TOKEN_LET_FUNCTION_NAME) {
        const resultNode = this._changeLetToLambda(lexerNode);
        if (resultNode != null) {
          return this._parse(resultNode, parent);
        }
        return ErrorNode.create("#ERROR!" /* ERROR */);
      }
      if (token === DEFAULT_TOKEN_TYPE_PARAMETER) {
        currentAstNode = parent;
        if (childrenCount === 0) {
          const nullNode = new NullNode(DEFAULT_TOKEN_TYPE_ROOT);
          nullNode.setParent(parent);
          return currentAstNode;
        }
      } else {
        if (token === DEFAULT_TOKEN_TYPE_LAMBDA_PARAMETER) {
          let resultNode = this._lambdaParameterHandler(lexerNode, parent);
          if (resultNode === false) {
            resultNode = ErrorNode.create("#ERROR!" /* ERROR */);
          }
          return resultNode;
        }
        currentAstNode = this._checkAstNode(lexerNode);
        if (currentAstNode == null) {
          return ErrorNode.create("#ERROR!" /* ERROR */);
        }
      }
      const firstChild = children[0];
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        if (isFirstChildParameter(firstChild)) {
          if (i !== 0 && i !== childrenCount - 1) {
            continue;
          }
        } else if (isChildRunTimeParameter(item)) {
          if (i !== childrenCount - 1) {
            continue;
          }
        }
        let astNode = null;
        if (item instanceof LexerNode) {
          astNode = this._parse(item, currentAstNode);
          if (astNode === currentAstNode) {
            continue;
          }
        } else {
          astNode = this._checkAstNode(item);
        }
        if (astNode == null) {
          return ErrorNode.create("#NAME?" /* NAME */);
        }
        astNode = getAstNodeTopParent(astNode);
        if (astNode == null) {
          return;
        }
        switch (astNode.nodeType) {
          case "ErrorNode" /* ERROR */:
            return astNode;
          case "FunctionNode" /* FUNCTION */:
            calculateStack.push(astNode);
            break;
          case "LambdaNode" /* LAMBDA */:
            calculateStack.push(astNode);
            break;
          case "LambdaNodeParameter" /* LAMBDA_PARAMETER */:
            calculateStack.push(astNode);
            break;
          case "OperatorNode" /* OPERATOR */: {
            const parameterNode1 = calculateStack.pop();
            const parameterNode2 = calculateStack.pop();
            if (parameterNode2) {
              parameterNode2.setParent(astNode);
            }
            if (parameterNode1) {
              parameterNode1.setParent(astNode);
            }
            calculateStack.push(astNode);
            break;
          }
          case "ReferenceNode" /* REFERENCE */:
            astNode.setRefOffset(this._refOffsetX, this._refOffsetY);
            calculateStack.push(astNode);
            break;
          case "Root" /* ROOT */:
            calculateStack.push(astNode);
            break;
          case "UnionNode" /* UNION */:
            calculateStack.push(astNode);
            break;
          case "ValueNode" /* VALUE */:
            calculateStack.push(astNode);
            break;
          case "PrefixNode" /* PREFIX */:
            calculateStack.push(astNode);
            break;
          case "SuffixNode" /* SUFFIX */:
            calculateStack.push(astNode);
            break;
        }
      }
      const calculateStackCount = calculateStack.length;
      for (let i = 0; i < calculateStackCount; i++) {
        const item = calculateStack[i];
        item.setParent(currentAstNode);
      }
      return currentAstNode;
    }
    _checkAstNode(item) {
      let astNode = null;
      const astNodeFactoryListCount = this._astNodeFactoryList.length;
      for (let x = 0; x < astNodeFactoryListCount; x++) {
        const astNodeFactory = this._astNodeFactoryList[x];
        astNode = astNodeFactory.checkAndCreateNodeType(item);
        if (astNode != null) {
          break;
        }
      }
      return astNode;
    }
    _initializeAstNode() {
      this._astNodeFactoryList = [
        this._astRootNodeFactory,
        this._functionNodeFactory,
        this._lambdaNodeFactory,
        this._lambdaParameterNodeFactory,
        this._operatorNodeFactory,
        this._prefixNodeFactory,
        this._referenceNodeFactory,
        this._suffixNodeFactory,
        this._unionNodeFactory,
        this._valueNodeFactory
      ].sort(sortRules);
    }
  };
  AstTreeBuilder = __decorateClass([
    __decorateParam(0, IFormulaRuntimeService),
    __decorateParam(1, Inject(AstRootNodeFactory)),
    __decorateParam(2, Inject(FunctionNodeFactory)),
    __decorateParam(3, Inject(LambdaNodeFactory)),
    __decorateParam(4, Inject(LambdaParameterNodeFactory)),
    __decorateParam(5, Inject(OperatorNodeFactory)),
    __decorateParam(6, Inject(PrefixNodeFactory)),
    __decorateParam(7, Inject(ReferenceNodeFactory)),
    __decorateParam(8, Inject(SuffixNodeFactory)),
    __decorateParam(9, Inject(UnionNodeFactory)),
    __decorateParam(10, Inject(ValueNodeFactory))
  ], AstTreeBuilder);

  // ../packages/engine-formula/src/services/feature-calculation-manager.service.ts
  var FeatureCalculationManagerService = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_referenceExecutorMap", /* @__PURE__ */ new Map());
    }
    dispose() {
      this._referenceExecutorMap.clear();
    }
    remove(featureId) {
      this._referenceExecutorMap.delete(featureId);
    }
    get(featureId) {
      return this._referenceExecutorMap.get(featureId);
    }
    has(featureId) {
      return this._referenceExecutorMap.has(featureId);
    }
    register(featureId, referenceExecutor) {
      this._referenceExecutorMap.set(featureId, referenceExecutor);
    }
    getReferenceExecutorMap() {
      return this._referenceExecutorMap;
    }
  };
  var IFeatureCalculationManagerService = createIdentifier(
    "univer.formula.feature-calculation-manager.service"
  );

  // ../packages/engine-formula/src/services/other-formula-manager.service.ts
  var OtherFormulaManagerService = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_otherFormulaData", {});
    }
    dispose() {
      this._otherFormulaData = {};
    }
    remove(searchParam) {
      var _a2, _b2, _c;
      const { unitId, subUnitId, formulaId } = searchParam;
      (_c = (_b2 = (_a2 = this._otherFormulaData) == null ? void 0 : _a2[unitId]) == null ? void 0 : _b2[subUnitId]) == null ? true : delete _c[formulaId];
    }
    get(searchParam) {
      var _a2, _b2;
      const { unitId, subUnitId, formulaId } = searchParam;
      return (_b2 = (_a2 = this._otherFormulaData[unitId]) == null ? void 0 : _a2[subUnitId]) == null ? void 0 : _b2[formulaId];
    }
    has(searchParam) {
      var _a2, _b2;
      const { unitId, subUnitId, formulaId } = searchParam;
      return ((_b2 = (_a2 = this._otherFormulaData[unitId]) == null ? void 0 : _a2[subUnitId]) == null ? void 0 : _b2[formulaId]) != null;
    }
    register(insertParam) {
      const { unitId, subUnitId, formulaId, item } = insertParam;
      if (!this._otherFormulaData[unitId]) {
        this._otherFormulaData[unitId] = {};
      }
      if (!this._otherFormulaData[unitId][subUnitId]) {
        this._otherFormulaData[unitId][subUnitId] = {};
      }
      this._otherFormulaData[unitId][subUnitId][formulaId] = item;
    }
    batchRegister(formulaData) {
      Object.keys(formulaData).forEach((unitId) => {
        const subUnits = formulaData[unitId];
        if (subUnits == null) {
          return true;
        }
        Object.keys(subUnits).forEach((subUnitId) => {
          const subUnit = subUnits[subUnitId];
          if (subUnit == null) {
            return true;
          }
          Object.keys(subUnit).forEach((formulaId) => {
            const item = subUnit[formulaId];
            if (item == null) {
              return true;
            }
            this.register({
              unitId,
              subUnitId,
              formulaId,
              item
            });
          });
        });
      });
    }
    batchRemove(formulaData) {
      Object.keys(formulaData).forEach((unitId) => {
        const subUnits = formulaData[unitId];
        if (subUnits == null) {
          return true;
        }
        Object.keys(subUnits).forEach((subUnitId) => {
          const subUnit = subUnits[subUnitId];
          if (subUnit == null) {
            return true;
          }
          Object.keys(subUnit).forEach((formulaId) => {
            this.remove({
              unitId,
              subUnitId,
              formulaId
            });
          });
        });
      });
    }
    getOtherFormulaData() {
      return this._otherFormulaData;
    }
  };
  var IOtherFormulaManagerService = createIdentifier(
    "univer.formula.other-formula-manager.service"
  );

  // ../packages/engine-formula/src/engine/dependency/dependency-tree.ts
  var FormulaDependencyTree = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "node");
      __publicField(this, "children", []);
      __publicField(this, "parents", []);
      __publicField(this, "formula", "");
      __publicField(this, "row", -1);
      __publicField(this, "column", -1);
      __publicField(this, "rowCount", Number.NEGATIVE_INFINITY);
      __publicField(this, "columnCount", Number.NEGATIVE_INFINITY);
      __publicField(this, "subUnitId", "");
      __publicField(this, "unitId", "");
      __publicField(this, "rangeList", []);
      __publicField(this, "formulaId");
      __publicField(this, "featureId");
      __publicField(this, "getDirtyData");
      __publicField(this, "_state", 0 /* DEFAULT */);
    }
    dispose() {
      var _a2;
      this.children.forEach((tree) => {
        tree.dispose();
      });
      this.rangeList = [];
      this.parents = [];
      (_a2 = this.node) == null ? void 0 : _a2.dispose();
    }
    setAdded() {
      this._state = 1 /* ADDED */;
    }
    isAdded() {
      return this._state === 1 /* ADDED */;
    }
    setSkip() {
      this._state = 2 /* SKIP */;
    }
    isSkip() {
      return this._state === 2 /* SKIP */;
    }
    inRangeData(range) {
      const startRow = range.startRow;
      const startColumn = range.startColumn;
      const endRow = range.endRow;
      const endColumn = range.endColumn;
      if (this.row < startRow || this.row > endRow || this.column < startColumn || this.column > endColumn) {
        return false;
      }
      return true;
    }
    /**
     * "Determine whether all ranges of the current node exist within the dirty area.
     *  If they are within the dirty area, return true, indicating that this node needs to be calculated.
     * @param dependencyRangeList
     */
    dependencyRange(dependencyRangeList, dirtyUnitSheetNameMap, unitExcludedCell) {
      var _a2, _b2;
      if (this.rangeList.length === 0) {
        return false;
      }
      for (let r = 0, len = this.rangeList.length; r < len; r++) {
        const unitRange = this.rangeList[r];
        const { unitId, sheetId, range } = unitRange.gridRange;
        if (((_a2 = dirtyUnitSheetNameMap[unitId]) == null ? void 0 : _a2[sheetId]) != null) {
          return true;
        }
        if (!dependencyRangeList.has(unitId)) {
          continue;
        }
        const sheetRangeMap = dependencyRangeList.get(unitId);
        if (!sheetRangeMap.has(sheetId)) {
          continue;
        }
        const dependencyRanges = sheetRangeMap.get(sheetId);
        const excludedCell = (_b2 = unitExcludedCell == null ? void 0 : unitExcludedCell[unitId]) == null ? void 0 : _b2[sheetId];
        let {
          startRow: rangeStartRow,
          endRow: rangeEndRow,
          startColumn: rangeStartColumn,
          endColumn: rangeEndColumn
        } = range;
        if (Number.isNaN(rangeStartRow)) {
          rangeStartRow = 0;
        }
        if (Number.isNaN(rangeStartColumn)) {
          rangeStartColumn = 0;
        }
        if (Number.isNaN(rangeEndRow)) {
          rangeEndRow = Number.POSITIVE_INFINITY;
        }
        if (Number.isNaN(rangeEndColumn)) {
          rangeEndColumn = Number.POSITIVE_INFINITY;
        }
        for (const dependencyRange of dependencyRanges) {
          const { startRow, startColumn, endRow, endColumn } = dependencyRange;
          if (rangeStartRow > endRow || rangeEndRow < startRow || rangeStartColumn > endColumn || rangeEndColumn < startColumn) {
            continue;
          } else {
            let isInclude = true;
            excludedCell == null ? void 0 : excludedCell.forValue((row, column) => {
              if (row >= rangeStartRow && row <= rangeEndRow && column >= rangeStartColumn && column <= rangeEndColumn) {
                isInclude = false;
                return false;
              }
            });
            if (isInclude) {
              return true;
            }
          }
        }
      }
      return false;
    }
    pushChildren(tree) {
      this.children.push(tree);
      tree._pushParent(this);
    }
    /**
     * Add the range corresponding to the current ast node.
     * @param range
     */
    pushRangeList(range) {
      this.rangeList.push(range);
    }
    /**
     * Determine whether it is dependent on other trees.
     * @param dependenceTree
     */
    dependency(dependenceTree) {
      if (this.rangeList.length === 0) {
        return false;
      }
      for (let r = 0, len = this.rangeList.length; r < len; r++) {
        const unitRange = this.rangeList[r];
        const unitId = unitRange.gridRange.unitId;
        const sheetId = unitRange.gridRange.sheetId;
        const range = unitRange.gridRange.range;
        if (dependenceTree.unitId === unitId && dependenceTree.subUnitId === sheetId && dependenceTree.inRangeData(range)) {
          return true;
        }
      }
      return false;
    }
    _pushParent(tree) {
      this.parents.push(tree);
    }
  };
  var FormulaDependencyTreeCache = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_cacheItems", /* @__PURE__ */ new Map());
    }
    dispose() {
      this.clear();
    }
    size() {
      return this._cacheItems.size;
    }
    add(unitRangeWithToken, tree) {
      const { token } = unitRangeWithToken;
      if (!this._cacheItems.has(token)) {
        this._cacheItems.set(token, {
          unitRangeWithToken,
          treeList: [tree]
        });
        return;
      }
      const cacheItem = this._cacheItems.get(token);
      cacheItem.treeList.push(tree);
    }
    clear() {
      this._cacheItems.clear();
    }
    remove(token, tree) {
      if (!this._cacheItems.has(token)) {
        return;
      }
      const cacheItem = this._cacheItems.get(token);
      const index = cacheItem.treeList.indexOf(tree);
      if (index !== -1) {
        cacheItem.treeList.splice(index, 1);
      }
    }
    delete(token) {
      this._cacheItems.delete(token);
    }
    /**
     * Determine whether range is dependent on other trees.
     * @param dependenceTree
     */
    dependency(dependenceTree) {
      this._cacheItems.forEach((cacheItem) => {
        const { unitRangeWithToken, treeList } = cacheItem;
        const { gridRange } = unitRangeWithToken;
        const { unitId, sheetId, range } = gridRange;
        if (dependenceTree.unitId === unitId && dependenceTree.subUnitId === sheetId && dependenceTree.inRangeData(range)) {
          treeList.forEach((tree) => {
            if (tree === dependenceTree) {
              return true;
            }
            tree.pushChildren(dependenceTree);
          });
        }
      });
    }
  };

  // ../packages/engine-formula/src/engine/dependency/formula-dependency.ts
  var FORMULA_CACHE_LRU_COUNT3 = 1e5;
  var FormulaASTCache = new FormulaAstLRU(FORMULA_CACHE_LRU_COUNT3);
  var FormulaDependencyGenerator = class extends Disposable {
    constructor(_currentConfigService, _runtimeService, _otherFormulaManagerService, _featureCalculationManagerService, _interpreter, _astTreeBuilder, _lexer) {
      super();
      this._currentConfigService = _currentConfigService;
      this._runtimeService = _runtimeService;
      this._otherFormulaManagerService = _otherFormulaManagerService;
      this._featureCalculationManagerService = _featureCalculationManagerService;
      this._interpreter = _interpreter;
      this._astTreeBuilder = _astTreeBuilder;
      this._lexer = _lexer;
      __publicField(this, "_updateRangeFlattenCache", /* @__PURE__ */ new Map());
      __publicField(this, "_dirtyUnitSheetNameMap", {});
    }
    dispose() {
      this._updateRangeFlattenCache.clear();
      FormulaASTCache.clear();
      this._dirtyUnitSheetNameMap = {};
    }
    async generate() {
      this._updateRangeFlatten();
      const formulaData = this._currentConfigService.getFormulaData();
      const otherFormulaData = this._otherFormulaManagerService.getOtherFormulaData();
      const unitData = this._currentConfigService.getUnitData();
      const { treeList, dependencyTreeCache } = await this._generateTreeList(formulaData, otherFormulaData, unitData);
      const updateTreeList = this._getUpdateTreeListAndMakeDependency(treeList, dependencyTreeCache);
      const isCycleDependency = this._checkIsCycleDependency(updateTreeList);
      if (isCycleDependency) {
        this._runtimeService.enableCycleDependency();
      }
      const finalTreeList = this._calculateRunList(updateTreeList);
      return Promise.resolve(finalTreeList);
    }
    _isCyclicUtil(node, visited, recursionStack) {
      if (!visited.has(node)) {
        visited.add(node);
        recursionStack.add(node);
        for (let i = 0; i < node.children.length; i++) {
          if (!visited.has(node.children[i]) && this._isCyclicUtil(node.children[i], visited, recursionStack)) {
            return true;
          }
          if (recursionStack.has(node.children[i])) {
            return true;
          }
        }
      }
      recursionStack.delete(node);
      return false;
    }
    _checkIsCycleDependency(treeList) {
      const visited = /* @__PURE__ */ new Set();
      const recursionStack = /* @__PURE__ */ new Set();
      for (let i = 0, len = treeList.length; i < len; i++) {
        const tree = treeList[i];
        const isCycle = this._isCyclicUtil(tree, visited, recursionStack);
        if (isCycle === true) {
          return true;
        }
      }
      return false;
    }
    /**
     * Generate nodes for the dependency tree, where each node contains all the reference data ranges included in each formula.
     * @param formulaData
     */
    async _generateTreeList(formulaData, otherFormulaData, unitData) {
      const formulaDataKeys = Object.keys(formulaData);
      const otherFormulaDataKeys = Object.keys(otherFormulaData);
      const treeList = [];
      for (const unitId of formulaDataKeys) {
        const sheetData = formulaData[unitId];
        if (sheetData == null) {
          continue;
        }
        const sheetDataKeys = Object.keys(sheetData);
        for (const sheetId of sheetDataKeys) {
          const matrixData = new ObjectMatrix(sheetData[sheetId]);
          matrixData.forValue((row, column, formulaDataItem) => {
            if (formulaDataItem == null) {
              return true;
            }
            const { f: formulaString, x, y } = formulaDataItem;
            const node = this._generateAstNode(formulaString, x, y);
            const FDtree = new FormulaDependencyTree();
            const sheetItem = unitData[unitId][sheetId];
            FDtree.node = node;
            FDtree.formula = formulaString;
            FDtree.unitId = unitId;
            FDtree.subUnitId = sheetId;
            FDtree.row = row;
            FDtree.column = column;
            FDtree.rowCount = sheetItem.rowCount;
            FDtree.columnCount = sheetItem.columnCount;
            treeList.push(FDtree);
          });
        }
      }
      for (const unitId of otherFormulaDataKeys) {
        const subComponentData = otherFormulaData[unitId];
        if (subComponentData == null) {
          continue;
        }
        const subComponentKeys = Object.keys(subComponentData);
        for (const subUnitId of subComponentKeys) {
          const subFormulaData = subComponentData[subUnitId];
          if (subFormulaData == null) {
            continue;
          }
          const subFormulaDataKeys = Object.keys(subFormulaData);
          for (const subFormulaDataId of subFormulaDataKeys) {
            const formulaDataItem = subFormulaData[subFormulaDataId];
            const { f: formulaString } = formulaDataItem;
            const node = this._generateAstNode(formulaString);
            const FDtree = new FormulaDependencyTree();
            FDtree.node = node;
            FDtree.formula = formulaString;
            FDtree.unitId = unitId;
            FDtree.subUnitId = subUnitId;
            FDtree.formulaId = subFormulaDataId;
            treeList.push(FDtree);
          }
        }
      }
      this._featureCalculationManagerService.getReferenceExecutorMap().forEach((params, featureId) => {
        const { unitId, subUnitId, dependencyRanges, getDirtyData } = params;
        const FDtree = new FormulaDependencyTree();
        FDtree.unitId = unitId;
        FDtree.subUnitId = subUnitId;
        FDtree.getDirtyData = getDirtyData;
        FDtree.featureId = featureId;
        FDtree.rangeList = dependencyRanges.map((range) => {
          return {
            gridRange: range,
            token: serializeRangeToRefString({ ...range, sheetName: this._currentConfigService.getSheetName(range.unitId, range.sheetId) })
          };
        });
        treeList.push(FDtree);
      });
      const dependencyTreeCache = new FormulaDependencyTreeCache();
      for (let i = 0, len = treeList.length; i < len; i++) {
        const tree = treeList[i];
        this._runtimeService.setCurrent(
          tree.row,
          tree.column,
          tree.rowCount,
          tree.columnCount,
          tree.subUnitId,
          tree.unitId
        );
        if (tree.node == null) {
          continue;
        }
        const rangeList = await this._getRangeListByNode(tree.node);
        for (let r = 0, rLen = rangeList.length; r < rLen; r++) {
          const range = rangeList[r];
          tree.pushRangeList(range);
          dependencyTreeCache.add(range, tree);
        }
      }
      return { treeList, dependencyTreeCache };
    }
    /**
     * Break down the dirty areas into ranges for subsequent matching.
     */
    _updateRangeFlatten() {
      const forceCalculate = this._currentConfigService.isForceCalculate();
      const dirtyRanges = this._currentConfigService.getDirtyRanges();
      if (forceCalculate) {
        return;
      }
      this._updateRangeFlattenCache.clear();
      for (let i = 0; i < dirtyRanges.length; i++) {
        const gridRange = dirtyRanges[i];
        const range = gridRange.range;
        const sheetId = gridRange.sheetId;
        const unitId = gridRange.unitId;
        this._addFlattenCache(unitId, sheetId, range);
      }
      this._dirtyUnitSheetNameMap = this._currentConfigService.getDirtyNameMap();
    }
    _generateAstNode(formulaString, refOffsetX = 0, refOffsetY = 0) {
      let astNode = FormulaASTCache.get(`${formulaString}##${refOffsetX}${refOffsetY}`);
      if (astNode) {
        return astNode;
      }
      const lexerNode = this._lexer.treeBuilder(formulaString);
      if (ERROR_TYPE_SET.has(lexerNode)) {
        return ErrorNode.create(lexerNode);
      }
      astNode = this._astTreeBuilder.parse(lexerNode, refOffsetX, refOffsetY);
      if (astNode == null) {
        throw new Error("astNode is null");
      }
      FormulaASTCache.set(`${formulaString}##${refOffsetX}${refOffsetY}`, astNode);
      return astNode;
    }
    _addFlattenCache(unitId, sheetId, range) {
      let unitMatrix = this._updateRangeFlattenCache.get(unitId);
      if (unitMatrix == null) {
        unitMatrix = /* @__PURE__ */ new Map();
        this._updateRangeFlattenCache.set(unitId, unitMatrix);
      }
      let ranges = unitMatrix.get(sheetId);
      if (ranges == null) {
        ranges = [];
        unitMatrix.set(sheetId, ranges);
      }
      ranges.push(range);
    }
    _isPreCalculateNode(node) {
      if (node.nodeType === "UnionNode" /* UNION */) {
        return true;
      }
      if (node.nodeType === "PrefixNode" /* PREFIX */ && node.getToken() === "@" /* AT */) {
        return true;
      }
      if (node.nodeType === "SuffixNode" /* SUFFIX */ && node.getToken() === "#" /* POUND */) {
        return true;
      }
      return false;
    }
    _nodeTraversalRef(node, result) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        if (this._isPreCalculateNode(item)) {
          result.push(item);
          continue;
        } else if (item.nodeType === "ReferenceNode" /* REFERENCE */) {
          result.push(item);
        }
        this._nodeTraversalRef(item, result);
      }
    }
    _nodeTraversalReferenceFunction(node, result) {
      const children = node.getChildren();
      const childrenCount = children.length;
      for (let i = 0; i < childrenCount; i++) {
        const item = children[i];
        if (item.nodeType === "FunctionNode" /* FUNCTION */ && item.isAddress()) {
          result.push(item);
          continue;
        }
        this._nodeTraversalReferenceFunction(item, result);
      }
    }
    async _executeNode(node) {
      let value;
      if (this._interpreter.checkAsyncNode(node)) {
        value = await this._interpreter.executeAsync(node);
      } else {
        value = this._interpreter.execute(node);
      }
      return value;
    }
    /**
     * Calculate the range required for collection in advance,
     * including references and location functions (such as OFFSET, INDIRECT, INDEX, etc.).
     * @param node
     */
    async _getRangeListByNode(node) {
      const preCalculateNodeList = [];
      const referenceFunctionList = [];
      this._nodeTraversalRef(node, preCalculateNodeList);
      this._nodeTraversalReferenceFunction(node, referenceFunctionList);
      const rangeList = [];
      for (let i = 0, len = preCalculateNodeList.length; i < len; i++) {
        const node2 = preCalculateNodeList[i];
        const value = await this._executeNode(node2);
        const gridRange = value.toUnitRange();
        const token = serializeRangeToRefString({ ...gridRange, sheetName: this._currentConfigService.getSheetName(gridRange.unitId, gridRange.sheetId) });
        rangeList.push({ gridRange, token });
      }
      for (let i = 0, len = referenceFunctionList.length; i < len; i++) {
        const node2 = referenceFunctionList[i];
        const value = await this._executeNode(node2);
        const gridRange = value.toUnitRange();
        const token = serializeRangeToRefString({ ...gridRange, sheetName: this._currentConfigService.getSheetName(gridRange.unitId, gridRange.sheetId) });
        rangeList.push({ gridRange, token });
      }
      return rangeList;
    }
    /**
     * Build a formula dependency tree based on the dependency relationships.
     * @param treeList
     */
    _getUpdateTreeListAndMakeDependency(treeList, dependencyTreeCache) {
      const newTreeList = [];
      const existTree = /* @__PURE__ */ new Set();
      const forceCalculate = this._currentConfigService.isForceCalculate();
      let dependencyAlgorithm = true;
      if (dependencyTreeCache.size() > treeList.length) {
        dependencyAlgorithm = false;
      }
      for (let i = 0, len = treeList.length; i < len; i++) {
        const tree = treeList[i];
        if (dependencyAlgorithm) {
          dependencyTreeCache.dependency(tree);
        } else {
          for (let m = 0, mLen = treeList.length; m < mLen; m++) {
            const treeMatch = treeList[m];
            if (tree === treeMatch) {
              continue;
            }
            if (tree.dependency(treeMatch)) {
              tree.pushChildren(treeMatch);
            }
          }
        }
        if ((forceCalculate || tree.dependencyRange(
          this._updateRangeFlattenCache,
          this._dirtyUnitSheetNameMap,
          this._currentConfigService.getExcludedRange()
        ) || this._includeTree(tree)) && !existTree.has(tree)) {
          newTreeList.push(tree);
          existTree.add(tree);
        }
      }
      dependencyTreeCache.dispose();
      return newTreeList;
    }
    /**
     * Determine whether all ranges of the current node exist within the dirty area.
     * If they are within the dirty area, return true, indicating that this node needs to be calculated.
     * @param tree
     */
    _includeTree(tree) {
      var _a2, _b2, _c, _d, _e, _f, _g;
      const unitId = tree.unitId;
      const subUnitId = tree.subUnitId;
      const featureId = tree.featureId;
      if (featureId != null) {
        const featureMap = this._currentConfigService.getDirtyUnitFeatureMap();
        const state = (_b2 = (_a2 = featureMap == null ? void 0 : featureMap[unitId]) == null ? void 0 : _a2[subUnitId]) == null ? void 0 : _b2[featureId];
        if (state != null) {
          return true;
        }
      }
      const formulaId = tree.formulaId;
      if (formulaId != null) {
        const otherFormulaMap = this._currentConfigService.getDirtyUnitOtherFormulaMap();
        const state = (_d = (_c = otherFormulaMap == null ? void 0 : otherFormulaMap[unitId]) == null ? void 0 : _c[subUnitId]) == null ? void 0 : _d[formulaId];
        if (state != null) {
          return true;
        }
      }
      const excludedCell = (_f = (_e = this._currentConfigService.getExcludedRange()) == null ? void 0 : _e[unitId]) == null ? void 0 : _f[subUnitId];
      let isExclude = false;
      excludedCell == null ? void 0 : excludedCell.forValue((row, column) => {
        if (tree.row === row && tree.column === column) {
          isExclude = true;
          return false;
        }
      });
      if (isExclude) {
        return false;
      }
      if (((_g = this._dirtyUnitSheetNameMap[unitId]) == null ? void 0 : _g[subUnitId]) != null) {
        return true;
      }
      if (!this._updateRangeFlattenCache.has(unitId)) {
        return false;
      }
      const sheetRangeMap = this._updateRangeFlattenCache.get(unitId);
      if (!sheetRangeMap.has(subUnitId)) {
        return false;
      }
      const ranges = sheetRangeMap.get(subUnitId);
      for (const range of ranges) {
        if (tree.inRangeData(range)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Generate the final formula calculation order array by traversing the dependency tree established via depth-first search.
     * @param treeList
     */
    _calculateRunList(treeList) {
      let stack = treeList;
      const formulaRunList = [];
      while (stack.length > 0) {
        const tree = stack.pop();
        if (tree === void 0 || tree.isSkip()) {
          continue;
        }
        if (tree.isAdded()) {
          formulaRunList.push(tree);
          continue;
        }
        const cacheStack = [];
        for (let i = 0, len = tree.parents.length; i < len; i++) {
          const parentTree = tree.parents[i];
          if (parentTree.isAdded() || tree.isSkip()) {
            continue;
          }
          cacheStack.push(parentTree);
        }
        if (cacheStack.length === 0) {
          formulaRunList.push(tree);
          tree.setSkip();
        } else {
          tree.setAdded();
          stack.push(tree);
          stack = stack.concat(cacheStack);
        }
      }
      return formulaRunList.reverse();
    }
  };
  FormulaDependencyGenerator = __decorateClass([
    OnLifecycle(2 /* Rendered */, FormulaDependencyGenerator),
    __decorateParam(0, IFormulaCurrentConfigService),
    __decorateParam(1, IFormulaRuntimeService),
    __decorateParam(2, IOtherFormulaManagerService),
    __decorateParam(3, IFeatureCalculationManagerService),
    __decorateParam(4, Inject(Interpreter)),
    __decorateParam(5, Inject(AstTreeBuilder)),
    __decorateParam(6, Inject(Lexer))
  ], FormulaDependencyGenerator);

  // ../packages/engine-formula/src/services/calculate-formula.service.ts
  var DEFAULT_CYCLE_REFERENCE_COUNT = 1;
  var CalculateFormulaService = class extends Disposable {
    constructor(_configService, _lexer, _currentConfigService, _runtimeService, _formulaDependencyGenerator, _interpreter, _astTreeBuilder) {
      super();
      this._configService = _configService;
      this._lexer = _lexer;
      this._currentConfigService = _currentConfigService;
      this._runtimeService = _runtimeService;
      this._formulaDependencyGenerator = _formulaDependencyGenerator;
      this._interpreter = _interpreter;
      this._astTreeBuilder = _astTreeBuilder;
      __publicField(this, "_executionStartListener$", new Subject());
      __publicField(this, "executionStartListener$", this._executionStartListener$.asObservable());
      __publicField(this, "_executionCompleteListener$", new Subject());
      __publicField(this, "executionCompleteListener$", this._executionCompleteListener$.asObservable());
      __publicField(this, "_executionInProgressListener$", new Subject());
      __publicField(this, "executionInProgressListener$", this._executionInProgressListener$.asObservable());
    }
    dispose() {
    }
    /**
     * Stop the execution of the formula.
     */
    stopFormulaExecution() {
      this._runtimeService.stopExecution();
    }
    /**
     * When the feature is loading,
     * the pre-calculated content needs to be input to the formula engine in advance,
     * so that the formula can read the correct values.
     * @param featureId
     * @param featureData
     */
    setRuntimeFeatureCellData(featureId, featureData) {
      this._runtimeService.setRuntimeFeatureCellData(featureId, featureData);
    }
    setRuntimeFeatureRange(featureId, featureRange) {
      this._runtimeService.setRuntimeFeatureRange(featureId, featureRange);
    }
    async execute(formulaDatasetConfig) {
      this._executionStartListener$.next(true);
      this._currentConfigService.load(formulaDatasetConfig);
      this._runtimeService.reset();
      const cycleReferenceCount = this._configService.getConfig("CYCLE_REFERENCE_COUNT") || DEFAULT_CYCLE_REFERENCE_COUNT;
      for (let i = 0; i < cycleReferenceCount; i++) {
        await this._execute();
        const isCycleDependency = this._runtimeService.isCycleDependency();
        if (!isCycleDependency) {
          break;
        }
      }
      this._runtimeService.setFormulaExecuteStage(7 /* CALCULATION_COMPLETED */);
      this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
      this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData());
      FORMULA_REF_TO_ARRAY_CACHE.clear();
      CELL_INVERTED_INDEX_CACHE.clear();
    }
    async _execute() {
      const executeState = await this._apply();
      if (executeState == null) {
        return;
      }
      const { arrayFormulaRange, runtimeFeatureRange } = executeState;
      const { dirtyRanges, excludedCell } = this._getArrayFormulaDirtyRangeAndExcludedRange(
        arrayFormulaRange,
        runtimeFeatureRange
      );
      if (dirtyRanges == null || dirtyRanges.length === 0) {
        return true;
      }
      this._currentConfigService.loadDirtyRangesAndExcludedCell(dirtyRanges, excludedCell);
      await this._apply(true);
      return true;
    }
    _getArrayFormulaDirtyRangeAndExcludedRange(arrayFormulaRange, runtimeFeatureRange) {
      const dirtyRanges = [];
      const excludedCell = {};
      Object.keys(arrayFormulaRange).forEach((unitId) => {
        const sheetArrayFormulaRange = arrayFormulaRange[unitId];
        if (sheetArrayFormulaRange == null) {
          return true;
        }
        Object.keys(sheetArrayFormulaRange).forEach((sheetId) => {
          const cellValue = new ObjectMatrix(sheetArrayFormulaRange[sheetId]);
          if (cellValue == null) {
            return true;
          }
          const newCellData = new ObjectMatrix();
          cellValue.forValue((row, column, range) => {
            newCellData.setValue(row, column, true);
            dirtyRanges.push({ unitId, sheetId, range });
          });
          if (excludedCell[unitId] == null) {
            excludedCell[unitId] = {};
          }
          excludedCell[unitId][sheetId] = newCellData;
        });
      });
      Object.keys(runtimeFeatureRange).forEach((featureId) => {
        const arrayRange = runtimeFeatureRange[featureId];
        Object.keys(arrayRange).forEach((unitId) => {
          const sheetArrayFormulaRange = arrayRange[unitId];
          if (sheetArrayFormulaRange == null) {
            return true;
          }
          Object.keys(sheetArrayFormulaRange).forEach((sheetId) => {
            const ranges = sheetArrayFormulaRange[sheetId];
            if (ranges == null) {
              return true;
            }
            for (const range of ranges) {
              dirtyRanges.push({ unitId, sheetId, range });
            }
          });
        });
      });
      return { dirtyRanges, excludedCell };
    }
    async _apply(isArrayFormulaState = false) {
      if (isArrayFormulaState) {
        this._runtimeService.setFormulaExecuteStage(4 /* START_DEPENDENCY_ARRAY_FORMULA */);
      } else {
        this._runtimeService.setFormulaExecuteStage(1 /* START_DEPENDENCY */);
      }
      this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
      const treeList = await this._formulaDependencyGenerator.generate();
      const interpreter = this._interpreter;
      if (isArrayFormulaState) {
        this._runtimeService.setFormulaExecuteStage(5 /* START_CALCULATION_ARRAY_FORMULA */);
        this._runtimeService.setTotalArrayFormulasToCalculate(treeList.length);
      } else {
        this._runtimeService.setFormulaExecuteStage(2 /* START_CALCULATION */);
        this._runtimeService.setTotalFormulasToCalculate(treeList.length);
      }
      this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
      for (let i = 0, len = treeList.length; i < len; i++) {
        await new Promise((resolve) => {
          requestImmediateMacroTask(resolve);
        });
        if (this._runtimeService.isStopExecution()) {
          this._runtimeService.setFormulaExecuteStage(0 /* IDLE */);
          this._runtimeService.markedAsStopFunctionsExecuted();
          this._executionCompleteListener$.next(this._runtimeService.getAllRuntimeData());
          return;
        }
        const tree = treeList[i];
        const astNode = tree.node;
        const getDirtyData = tree.getDirtyData;
        let value;
        if (astNode == null && getDirtyData == null) {
          throw new Error("AstNode or executor is null");
        }
        this._runtimeService.setCurrent(
          tree.row,
          tree.column,
          tree.rowCount,
          tree.columnCount,
          tree.subUnitId,
          tree.unitId
        );
        if (getDirtyData != null && tree.featureId != null) {
          const { runtimeCellData, dirtyRanges } = getDirtyData(tree);
          this._runtimeService.setRuntimeFeatureCellData(tree.featureId, runtimeCellData);
          this._runtimeService.setRuntimeFeatureRange(tree.featureId, dirtyRanges);
        } else if (astNode != null) {
          if (interpreter.checkAsyncNode(astNode)) {
            value = await interpreter.executeAsync(astNode);
          } else {
            value = interpreter.execute(astNode);
          }
          if (tree.formulaId != null) {
            this._runtimeService.setRuntimeOtherData(tree.formulaId, value);
          } else {
            this._runtimeService.setRuntimeData(value);
          }
        }
        if (isArrayFormulaState) {
          this._runtimeService.setFormulaExecuteStage(
            6 /* CURRENTLY_CALCULATING_ARRAY_FORMULA */
          );
          this._runtimeService.setCompletedArrayFormulasCount(i + 1);
        } else {
          this._runtimeService.setFormulaExecuteStage(3 /* CURRENTLY_CALCULATING */);
          this._runtimeService.setCompletedFormulasCount(i + 1);
        }
        this._executionInProgressListener$.next(this._runtimeService.getRuntimeState());
      }
      if (treeList.length > 0) {
        this._runtimeService.markedAsSuccessfullyExecuted();
      } else if (!isArrayFormulaState) {
        this._runtimeService.markedAsNoFunctionsExecuted();
      }
      return this._runtimeService.getAllRuntimeData();
    }
    calculate(formulaString, transformSuffix = true) {
      const lexerNode = this._lexer.treeBuilder(formulaString, transformSuffix);
      if (Object.values(ErrorType).includes(lexerNode)) {
        return ErrorNode.create(lexerNode);
      }
      const astNode = this._astTreeBuilder.parse(lexerNode);
      astNode == null ? void 0 : astNode.serialize();
    }
  };
  CalculateFormulaService = __decorateClass([
    OnLifecycle(2 /* Rendered */, CalculateFormulaService),
    __decorateParam(0, IConfigService),
    __decorateParam(1, Inject(Lexer)),
    __decorateParam(2, IFormulaCurrentConfigService),
    __decorateParam(3, IFormulaRuntimeService),
    __decorateParam(4, Inject(FormulaDependencyGenerator)),
    __decorateParam(5, Inject(Interpreter)),
    __decorateParam(6, Inject(AstTreeBuilder))
  ], CalculateFormulaService);

  // ../packages/engine-formula/src/commands/mutations/set-numfmt-formula-data.mutation.ts
  var SetNumfmtFormulaDataMutation = {
    id: "formula.mutation.set-numfmt-formula-data",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const formulaDataModel = accessor.get(FormulaDataModel);
      formulaDataModel.updateNumfmtItemMap(params.numfmtItemMap);
      return true;
    }
  };

  // ../packages/engine-formula/src/controller/calculate.controller.ts
  var CalculateController = class extends Disposable {
    constructor(_commandService, _calculateFormulaService, _currentUniverService, _formulaDataModel) {
      super();
      this._commandService = _commandService;
      this._calculateFormulaService = _calculateFormulaService;
      this._currentUniverService = _currentUniverService;
      this._formulaDataModel = _formulaDataModel;
      this._initialize();
    }
    _initialize() {
      this._commandExecutedListener();
      this._initialExecuteFormulaListener();
      this._initialExecuteFormulaProcessListener();
    }
    _commandExecutedListener() {
      this.disposeWithMe(
        this._commandService.onCommandExecuted((command, options) => {
          if (command.id === SetFormulaCalculationStopMutation.id) {
            this._calculateFormulaService.stopFormulaExecution();
          } else if (command.id === SetFormulaDataMutation.id) {
            const formulaData = command.params.formulaData;
            this._formulaDataModel.setFormulaData(formulaData);
          } else if (command.id === SetFormulaCalculationStartMutation.id) {
            const params = command.params;
            if (params.forceCalculation === true) {
              this._calculate(true);
            } else {
              const { dirtyRanges, dirtyNameMap, dirtyUnitFeatureMap, dirtyUnitOtherFormulaMap, numfmtItemMap } = params;
              this._calculate(false, dirtyRanges, dirtyNameMap, dirtyUnitFeatureMap, dirtyUnitOtherFormulaMap, numfmtItemMap);
            }
          } else if (command.id === SetArrayFormulaDataMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { arrayFormulaRange, arrayFormulaCellData } = params;
            this._formulaDataModel.setArrayFormulaRange(arrayFormulaRange);
            this._formulaDataModel.setArrayFormulaCellData(arrayFormulaCellData);
          }
        })
      );
    }
    async _calculate(forceCalculate = false, dirtyRanges = [], dirtyNameMap = {}, dirtyUnitFeatureMap = {}, dirtyUnitOtherFormulaMap = {}, numfmtItemMap = {}) {
      if (dirtyRanges.length === 0 && Object.keys(dirtyNameMap).length === 0 && Object.keys(dirtyUnitFeatureMap).length === 0 && Object.keys(dirtyUnitOtherFormulaMap).length === 0 && forceCalculate === false) {
        return;
      }
      const formulaData = this._formulaDataModel.getFormulaData();
      const arrayFormulaCellData = this._formulaDataModel.getArrayFormulaCellData();
      this._calculateFormulaService.execute({
        formulaData,
        arrayFormulaCellData,
        forceCalculate,
        dirtyRanges,
        dirtyNameMap,
        dirtyUnitFeatureMap,
        dirtyUnitOtherFormulaMap,
        numfmtItemMap
      });
    }
    // Notification
    _initialExecuteFormulaListener() {
      this._calculateFormulaService.executionCompleteListener$.subscribe((data) => {
        const functionsExecutedState = data.functionsExecutedState;
        switch (functionsExecutedState) {
          case 2 /* NOT_EXECUTED */:
            break;
          case 1 /* STOP_EXECUTION */:
            break;
          case 3 /* SUCCESS */:
            this._applyFormula(data);
            break;
          case 0 /* INITIAL */:
            break;
        }
        this._commandService.executeCommand(
          SetFormulaCalculationNotificationMutation.id,
          {
            functionsExecutedState
          },
          {
            onlyLocal: true
          }
        );
      });
    }
    _initialExecuteFormulaProcessListener() {
      this._calculateFormulaService.executionInProgressListener$.subscribe((data) => {
        const {
          totalFormulasToCalculate,
          completedFormulasCount,
          totalArrayFormulasToCalculate,
          completedArrayFormulasCount,
          stage
        } = data;
        if (totalArrayFormulasToCalculate > 0) {
        } else {
        }
        this._commandService.executeCommand(
          SetFormulaCalculationNotificationMutation.id,
          {
            stageInfo: data
          },
          {
            onlyLocal: true
          }
        );
      });
    }
    async _applyFormula(data) {
      const { unitData, unitOtherData, arrayFormulaRange, arrayFormulaCellData, clearArrayFormulaCellData, numfmtItemMap } = data;
      if (!unitData) {
        console.error("No sheetData from Formula Engine!");
        return;
      }
      if (arrayFormulaRange) {
        this._formulaDataModel.clearPreviousArrayFormulaCellData(clearArrayFormulaCellData);
        this._formulaDataModel.mergeArrayFormulaCellData(arrayFormulaCellData);
        this._formulaDataModel.mergeArrayFormulaRange(arrayFormulaRange);
        this._commandService.executeCommand(
          SetArrayFormulaDataMutation.id,
          {
            arrayFormulaRange: this._formulaDataModel.getArrayFormulaRange(),
            arrayFormulaCellData: this._formulaDataModel.getArrayFormulaCellData()
          },
          {
            onlyLocal: true
          }
        );
      }
      if (!Tools.isEmptyObject(numfmtItemMap)) {
        this._commandService.executeCommand(
          SetNumfmtFormulaDataMutation.id,
          {
            numfmtItemMap
          },
          {
            onlyLocal: true
          }
        );
      }
      this._commandService.executeCommand(
        SetFormulaCalculationResultMutation.id,
        {
          unitData: convertRuntimeToUnitData(unitData),
          unitOtherData
        },
        {
          onlyLocal: true
        }
      );
    }
  };
  CalculateController = __decorateClass([
    OnLifecycle(1 /* Ready */, CalculateController),
    __decorateParam(0, ICommandService),
    __decorateParam(1, Inject(CalculateFormulaService)),
    __decorateParam(2, IUniverInstanceService),
    __decorateParam(3, Inject(FormulaDataModel))
  ], CalculateController);

  // ../packages/engine-formula/src/controller/formula.controller.ts
  var FormulaController = class extends Disposable {
    constructor(_function = [], _commandService, _injector, _functionService) {
      super();
      this._function = _function;
      this._commandService = _commandService;
      this._injector = _injector;
      this._functionService = _functionService;
      this._initialize();
    }
    _initialize() {
      this._registerCommands();
      this._registerFunctions();
    }
    _registerCommands() {
      [
        SetFormulaDataMutation,
        SetArrayFormulaDataMutation,
        SetFormulaCalculationStartMutation,
        SetFormulaCalculationStopMutation,
        SetFormulaCalculationNotificationMutation,
        SetFormulaCalculationResultMutation,
        SetNumfmtFormulaDataMutation,
        SetDefinedNameMutation,
        RemoveDefinedNameMutation,
        SetFeatureCalculationMutation,
        RemoveFeatureCalculationMutation,
        SetOtherFormulaMutation,
        RemoveOtherFormulaMutation,
        SetSuperTableMutation,
        RemoveSuperTableMutation,
        SetSuperTableOptionMutation,
        RegisterFunctionMutation,
        UnregisterFunctionMutation
      ].forEach((command) => this.disposeWithMe(this._commandService.registerCommand(command)));
    }
    _registerFunctions() {
      const functions = [
        ...functionArray,
        ...functionCompatibility,
        ...functionCube,
        ...functionDatabase,
        ...functionDate,
        ...functionEngineering,
        ...functionFinancial,
        ...functionInformation,
        ...functionLogical,
        ...functionLookup,
        ...functionMath,
        ...functionMeta,
        ...functionStatistical,
        ...functionText,
        ...functionUniver,
        ...functionWeb
      ].concat(this._function).map((registerObject) => {
        const Func = registerObject[0];
        const name = registerObject[1];
        return new Func(name);
      });
      this._functionService.registerExecutors(...functions);
    }
  };
  FormulaController = __decorateClass([
    OnLifecycle(1 /* Ready */, FormulaController),
    __decorateParam(1, ICommandService),
    __decorateParam(2, Inject(Injector)),
    __decorateParam(3, IFunctionService)
  ], FormulaController);

  // ../packages/engine-formula/src/controller/register-function.controller.ts
  var RegisterFunctionController = class extends Disposable {
    constructor(_commandService, _formulaDataModel, _functionService) {
      super();
      this._commandService = _commandService;
      this._formulaDataModel = _formulaDataModel;
      this._functionService = _functionService;
      this._initialize();
    }
    _initialize() {
      this._commandExecutedListener();
    }
    _commandExecutedListener() {
      this.disposeWithMe(
        this._commandService.onCommandExecuted((command, options) => {
          if (command.id === RegisterFunctionMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { functions } = params;
            const functionList = functions.map((func) => {
              const functionString = func[0];
              const functionName = func[1];
              return createFunction(functionString, functionName);
            });
            this._functionService.registerExecutors(...functionList);
          } else if (command.id === UnregisterFunctionMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { functions } = params;
            this._functionService.unregisterExecutors(...functions);
          }
        })
      );
    }
  };
  RegisterFunctionController = __decorateClass([
    OnLifecycle(1 /* Ready */, RegisterFunctionController),
    __decorateParam(0, ICommandService),
    __decorateParam(1, Inject(FormulaDataModel)),
    __decorateParam(2, IFunctionService)
  ], RegisterFunctionController);
  var CustomFunction = class extends BaseFunction {
    isCustom() {
      return true;
    }
  };
  function createFunction(functionString, functionName) {
    const instance = new CustomFunction(functionName);
    const functionCalculate = new Function(`return ${functionString}`)();
    instance.calculateCustom = functionCalculate;
    return instance;
  }

  // ../packages/engine-formula/src/controller/set-defined-name.controller.ts
  var SetDefinedNameController = class extends Disposable {
    constructor(_commandService, _definedNamesService) {
      super();
      this._commandService = _commandService;
      this._definedNamesService = _definedNamesService;
      this._initialize();
    }
    _initialize() {
      this._commandExecutedListener();
    }
    _commandExecutedListener() {
      this.disposeWithMe(
        this._commandService.onCommandExecuted((command) => {
          if (command.id === SetDefinedNameMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { unitId, name, formulaOrRefString } = params;
            this._definedNamesService.registerDefinedName(unitId, name, formulaOrRefString);
          } else if (command.id === RemoveDefinedNameMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { unitId, name } = params;
            this._definedNamesService.removeDefinedName(unitId, name);
          }
        })
      );
    }
  };
  SetDefinedNameController = __decorateClass([
    OnLifecycle(1 /* Ready */, SetDefinedNameController),
    __decorateParam(0, ICommandService),
    __decorateParam(1, IDefinedNamesService)
  ], SetDefinedNameController);

  // ../packages/engine-formula/src/controller/set-feature-calculation.controller.ts
  var SetFeatureCalculationController = class extends Disposable {
    constructor(_commandService, _featureCalculationManagerService) {
      super();
      this._commandService = _commandService;
      this._featureCalculationManagerService = _featureCalculationManagerService;
      this._initialize();
    }
    _initialize() {
      this._commandExecutedListener();
    }
    _commandExecutedListener() {
      this.disposeWithMe(
        this._commandService.onCommandExecuted((command) => {
          if (command.id === SetFeatureCalculationMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { featureId, calculationParam } = params;
            this._featureCalculationManagerService.register(featureId, calculationParam);
          } else if (command.id === RemoveFeatureCalculationMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { featureId } = params;
            this._featureCalculationManagerService.remove(featureId);
          }
        })
      );
    }
  };
  SetFeatureCalculationController = __decorateClass([
    OnLifecycle(1 /* Ready */, SetFeatureCalculationController),
    __decorateParam(0, ICommandService),
    __decorateParam(1, IFeatureCalculationManagerService)
  ], SetFeatureCalculationController);

  // ../packages/engine-formula/src/controller/set-other-formula.controller.ts
  var SetOtherFormulaController = class extends Disposable {
    constructor(_commandService, _otherFormulaManagerService) {
      super();
      this._commandService = _commandService;
      this._otherFormulaManagerService = _otherFormulaManagerService;
      this._initialize();
    }
    _initialize() {
      this._commandExecutedListener();
    }
    _commandExecutedListener() {
      this.disposeWithMe(
        this._commandService.onCommandExecuted((command) => {
          if (command.id === SetOtherFormulaMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const config2 = { [params.unitId]: { [params.subUnitId]: params.formulaMap } };
            this._otherFormulaManagerService.batchRegister(config2);
          } else if (command.id === RemoveOtherFormulaMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const obj = {};
            params.formulaIdList.forEach((id) => obj[id] = true);
            const config2 = { [params.unitId]: { [params.subUnitId]: obj } };
            this._otherFormulaManagerService.batchRemove(config2);
          }
        })
      );
    }
  };
  SetOtherFormulaController = __decorateClass([
    OnLifecycle(1 /* Ready */, SetOtherFormulaController),
    __decorateParam(0, ICommandService),
    __decorateParam(1, IOtherFormulaManagerService)
  ], SetOtherFormulaController);

  // ../packages/engine-formula/src/controller/set-super-table.controller.ts
  var SetSuperTableController = class extends Disposable {
    constructor(_commandService, _superTableService) {
      super();
      this._commandService = _commandService;
      this._superTableService = _superTableService;
      this._initialize();
    }
    _initialize() {
      this._commandExecutedListener();
    }
    _commandExecutedListener() {
      this.disposeWithMe(
        this._commandService.onCommandExecuted((command) => {
          if (command.id === SetDefinedNameMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { unitId, tableName, reference } = params;
            this._superTableService.registerTable(unitId, tableName, reference);
          } else if (command.id === RemoveDefinedNameMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { unitId, tableName } = params;
            this._superTableService.remove(unitId, tableName);
          } else if (command.id === SetSuperTableOptionMutation.id) {
            const params = command.params;
            if (params == null) {
              return;
            }
            const { tableOption, tableOptionType } = params;
            this._superTableService.registerTableOptionMap(tableOption, tableOptionType);
          }
        })
      );
    }
  };
  SetSuperTableController = __decorateClass([
    OnLifecycle(1 /* Ready */, SetSuperTableController),
    __decorateParam(0, ICommandService),
    __decorateParam(1, ISuperTableService)
  ], SetSuperTableController);

  // ../packages/engine-formula/src/services/active-dirty-manager.service.ts
  var ActiveDirtyManagerService = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "_dirtyConversionMap", /* @__PURE__ */ new Map());
    }
    dispose() {
      this._dirtyConversionMap.clear();
    }
    remove(commandId) {
      this._dirtyConversionMap.delete(commandId);
    }
    get(commandId) {
      return this._dirtyConversionMap.get(commandId);
    }
    has(commandId) {
      return this._dirtyConversionMap.has(commandId);
    }
    register(commandId, dirtyConversion) {
      this._dirtyConversionMap.set(commandId, dirtyConversion);
    }
    getDirtyConversionMap() {
      return this._dirtyConversionMap;
    }
  };
  var IActiveDirtyManagerService = createIdentifier(
    "univer.formula.active-dirty-manager.service"
  );

  // ../packages/engine-formula/src/plugin.ts
  var PLUGIN_NAME = "base-formula-engine";
  var UniverFormulaEnginePlugin = class extends Plugin {
    constructor(_config, _injector) {
      super(PLUGIN_NAME);
      this._config = _config;
      this._injector = _injector;
    }
    onStarting() {
      this._initialize();
    }
    _initialize() {
      var _a2;
      const dependencies = [
        // Services
        [IFunctionService, { useClass: FunctionService }],
        [IFeatureCalculationManagerService, { useClass: FeatureCalculationManagerService }],
        [IDefinedNamesService, { useClass: DefinedNamesService }],
        [IActiveDirtyManagerService, { useClass: ActiveDirtyManagerService }],
        // Models
        [FormulaDataModel],
        // Engine
        [LexerTreeBuilder],
        //Controllers
        [
          FormulaController,
          {
            useFactory: () => {
              var _a3;
              return this._injector.createInstance(FormulaController, (_a3 = this._config) == null ? void 0 : _a3.function);
            }
          }
        ],
        [SetFeatureCalculationController]
      ];
      if (!((_a2 = this._config) == null ? void 0 : _a2.notExecuteFormula)) {
        dependencies.push(
          // Services
          [CalculateFormulaService],
          [IOtherFormulaManagerService, { useClass: OtherFormulaManagerService }],
          [ISuperTableService, { useClass: SuperTableService }],
          [IFormulaCurrentConfigService, { useClass: FormulaCurrentConfigService }],
          [IFormulaRuntimeService, { useClass: FormulaRuntimeService }],
          //Controller
          [CalculateController],
          [SetDefinedNameController],
          [SetOtherFormulaController],
          [SetSuperTableController],
          [RegisterFunctionController],
          // Calculation engine
          [FormulaDependencyGenerator],
          [Interpreter],
          [AstTreeBuilder],
          [Lexer],
          // AstNode factory
          [AstRootNodeFactory],
          [FunctionNodeFactory],
          [LambdaNodeFactory],
          [LambdaParameterNodeFactory],
          [OperatorNodeFactory],
          [PrefixNodeFactory],
          [ReferenceNodeFactory],
          [SuffixNodeFactory],
          [UnionNodeFactory],
          [ValueNodeFactory]
        );
      }
      dependencies.forEach((dependency) => this._injector.add(dependency));
    }
    onReady() {
      this._injector.get(FormulaDataModel).initFormulaData();
    }
  };
  UniverFormulaEnginePlugin = __decorateClass([
    __decorateParam(1, Inject(Injector))
  ], UniverFormulaEnginePlugin);

  // ../packages/rpc/src/services/remote-instance/remote-instance.service.ts
  var RemoteSyncServiceName = "univer.remote-sync-service";
  var IRemoteSyncService = createIdentifier(RemoteSyncServiceName);
  var RemoteSyncPrimaryService = class {
    constructor(_commandService) {
      this._commandService = _commandService;
    }
    async syncMutation(params) {
      return this._commandService.syncExecuteCommand(params.mutationInfo.id, params.mutationInfo.params, {
        onlyLocal: true,
        fromSync: true
      });
    }
  };
  RemoteSyncPrimaryService = __decorateClass([
    __decorateParam(0, ICommandService)
  ], RemoteSyncPrimaryService);
  var RemoteInstanceServiceName = "univer.remote-instance-service";
  var IRemoteInstanceService = createIdentifier(RemoteInstanceServiceName);
  var RemoteInstanceReplicaService = class {
    constructor(_univerInstanceService, _commandService) {
      this._univerInstanceService = _univerInstanceService;
      this._commandService = _commandService;
    }
    whenReady() {
      return Promise.resolve(true);
    }
    async syncMutation(params) {
      return this._commandService.syncExecuteCommand(params.mutationInfo.id, params.mutationInfo.params, {
        onlyLocal: true,
        fromSync: true
      });
    }
    async createInstance(params) {
      const { type, snapshot } = params;
      try {
        switch (type) {
          case 2 /* SHEET */:
            return !!this._univerInstanceService.createSheet(snapshot);
          default:
            throw new Error(
              `[RemoteInstanceReplicaService]: cannot create replica for document type: ${type}.`
            );
        }
      } catch (err) {
        if (err instanceof Error) {
          throw err;
        } else {
          throw new TypeError(`${err}`);
        }
      }
    }
    async disposeInstance(params) {
      return this._univerInstanceService.disposeDocument(params.unitID);
    }
  };
  RemoteInstanceReplicaService = __decorateClass([
    __decorateParam(0, IUniverInstanceService),
    __decorateParam(1, ICommandService)
  ], RemoteInstanceReplicaService);

  // ../packages/rpc/src/services/rpc/rpc.service.ts
  function fromModule(module) {
    const handler = module;
    return new class {
      call(method, args) {
        const target = handler[method];
        if (typeof target === "function") {
          let res = target.apply(handler, [args]);
          if (!(res instanceof Promise)) {
            res = Promise.resolve(res);
          }
          return res;
        }
        throw new Error(`[RPC]: method not found for ${method}!`);
      }
      subscribe(eventMethod, args) {
        const target = handler[eventMethod];
        if (typeof target === "function") {
          const res = target.apply(handler, args);
          if (!isObservable(res)) {
            return of(res);
          }
          return res;
        }
        throw new Error(`[RPC]: observable method not found for ${eventMethod}!`);
      }
    }();
  }
  function toModule(channel) {
    return new Proxy({}, {
      get(_820, propKey) {
        if (propKey === "dispose") {
          return void 0;
        }
        return function(...args) {
          const isObservable2 = propertyIsEventSource(propKey);
          if (isObservable2) {
            const observable2 = channel.subscribe(propKey, args[0]);
            return observable2;
          }
          return channel.call(propKey, args[0]);
        };
      }
    });
  }
  function propertyIsEventSource(name) {
    return name.endsWith("$");
  }
  var ChannelClient = class extends RxDisposable {
    constructor(_protocol) {
      super();
      this._protocol = _protocol;
      __publicField(this, "_initialized", new BehaviorSubject(false));
      __publicField(this, "_lastRequestCounter", 0);
      __publicField(this, "_pendingRequests", /* @__PURE__ */ new Map());
      __publicField(this, "_pendingSubscriptions", /* @__PURE__ */ new Map());
      this._protocol.onMessage.pipe(takeUntil(this.dispose$)).subscribe((message) => this._onMessage(message));
    }
    getChannel(channelName) {
      const self2 = this;
      return {
        call(method, args) {
          if (self2._disposed) {
            return Promise.reject();
          }
          return self2._remoteCall(channelName, method, args);
        },
        subscribe(eventMethod, args) {
          if (self2._disposed) {
            throw new Error("[ChannelClient]: client is disposed!");
          }
          return self2._remoteSubscribe(channelName, eventMethod, args);
        }
      };
    }
    _whenReady() {
      return firstValueFrom(
        this._initialized.pipe(
          filter((v) => v),
          take(1)
        )
      );
    }
    async _remoteCall(channelName, method, args) {
      await this._whenReady();
      const sequence2 = ++this._lastRequestCounter;
      const type = 100 /* CALL */;
      const request = { seq: sequence2, type, channelName, method, args };
      const client = this;
      return new Promise((resolve, reject) => {
        const responseHandler = {
          handle(response) {
            switch (response.type) {
              case 201 /* CALL_SUCCESS */:
                client._pendingRequests.delete(sequence2);
                resolve(response.data);
                break;
              case 202 /* CALL_FAILURE */:
                client._pendingRequests.delete(sequence2);
                reject(response.data);
                break;
              default:
                throw new Error("[ChannelClient]: unknown response type!");
            }
          }
        };
        this._pendingRequests.set(sequence2, responseHandler);
        this._sendRequest(request);
      });
    }
    _remoteSubscribe(channelName, method, args) {
      return new Observable((subscriber) => {
        let sequence2 = -1;
        this._whenReady().then(() => {
          sequence2 = ++this._lastRequestCounter;
          const type = 101 /* SUBSCRIBE */;
          const request = { seq: sequence2, type, channelName, method, args };
          const responseHandler = {
            handle(response) {
              switch (response.type) {
                case 300 /* SUBSCRIBE_NEXT */:
                  subscriber.next(response.data);
                  break;
                case 301 /* SUBSCRIBE_ERROR */:
                  subscriber.error(response.data);
                  break;
                case 302 /* SUBSCRIBE_COMPLETE */:
                  subscriber.complete();
                  break;
                default:
                  throw new Error("[ChannelClient]: unknown response type!");
              }
            }
          };
          this._pendingRequests.set(sequence2, responseHandler);
          this._sendRequest(request);
        });
        return () => {
          if (sequence2 === -1) {
            return;
          }
          const cancelSubscriptionRequest = {
            type: 102 /* UNSUBSCRIBE */,
            seq: sequence2,
            channelName,
            method
          };
          this._sendRequest(cancelSubscriptionRequest);
        };
      });
    }
    _sendRequest(request) {
      this._protocol.send(request);
    }
    _onMessage(response) {
      var _a2;
      switch (response.type) {
        case 0 /* INITIALIZE */:
          this._initialized.next(true);
          break;
        case 201 /* CALL_SUCCESS */:
        case 202 /* CALL_FAILURE */:
        case 300 /* SUBSCRIBE_NEXT */:
        case 302 /* SUBSCRIBE_COMPLETE */:
        case 301 /* SUBSCRIBE_ERROR */:
          (_a2 = this._pendingRequests.get(response.seq)) == null ? void 0 : _a2.handle(response);
          break;
      }
    }
  };
  var ChannelServer = class extends RxDisposable {
    constructor(_protocol) {
      super();
      this._protocol = _protocol;
      __publicField(this, "_channels", /* @__PURE__ */ new Map());
      __publicField(this, "_subscriptions", /* @__PURE__ */ new Map());
      this._protocol.onMessage.pipe(takeUntil(this.dispose$)).subscribe((message) => this._onRequest(message));
      this._sendResponse({ seq: -1, type: 0 /* INITIALIZE */ });
    }
    registerChannel(channelName, channel) {
      this._channels.set(channelName, channel);
    }
    _onRequest(request) {
      switch (request.type) {
        case 100 /* CALL */:
          this._onMethodCall(request);
          break;
        case 101 /* SUBSCRIBE */:
          this._onSubscribe(request);
          break;
        case 102 /* UNSUBSCRIBE */:
          this._onUnsubscribe(request);
          break;
        default:
          break;
      }
    }
    _onMethodCall(request) {
      const { channelName, method, args } = request;
      const channel = this._channels.get(channelName);
      let promise;
      try {
        if (!channel) {
          throw new Error(`[ChannelServer]: Channel ${channelName} not found!`);
        }
        promise = channel.call(method, args);
      } catch (err) {
        promise = Promise.reject(err);
      }
      promise.then((data) => {
        this._sendResponse({ seq: request.seq, type: 201 /* CALL_SUCCESS */, data });
      }).catch((err) => {
        if (err instanceof Error) {
          this._sendResponse({ seq: request.seq, type: 202 /* CALL_FAILURE */, data: err.message });
        } else {
          this._sendResponse({ seq: request.seq, type: 202 /* CALL_FAILURE */, data: String(err) });
        }
      });
    }
    _onSubscribe(request) {
      const { channelName, seq } = request;
      const channel = this._channels.get(channelName);
      try {
        if (!channel) {
          throw new Error(`[ChannelServer]: Channel ${channelName} not found!`);
        }
        const observable2 = channel.subscribe(request.method, request.args);
        const subscription = observable2.subscribe({
          next: (data) => {
            this._sendResponse({ seq, type: 300 /* SUBSCRIBE_NEXT */, data });
          },
          error: (err) => {
            this._sendResponse({ seq, type: 301 /* SUBSCRIBE_ERROR */, data: err.message });
            this._sendResponse({ seq, type: 302 /* SUBSCRIBE_COMPLETE */ });
          },
          complete: () => {
            this._sendResponse({ seq, type: 302 /* SUBSCRIBE_COMPLETE */ });
          }
        });
        this._subscriptions.set(request.seq, subscription);
      } catch (err) {
        if (err instanceof Error) {
          this._sendResponse({ seq: request.seq, type: 301 /* SUBSCRIBE_ERROR */, data: err.message });
        } else {
          this._sendResponse({ seq: request.seq, type: 301 /* SUBSCRIBE_ERROR */, data: String(err) });
        }
      }
    }
    _onUnsubscribe(request) {
      const subscription = this._subscriptions.get(request.seq);
      if (subscription) {
        subscription.unsubscribe();
        this._subscriptions.delete(request.seq);
      }
    }
    _sendResponse(response) {
      this._protocol.send(response);
    }
  };

  // ../packages/rpc/src/services/rpc/channel.service.ts
  var IRPChannelService = createIdentifier("IRPChannelService");
  var ChannelService = class {
    constructor(_messageProtocol) {
      __publicField(this, "_client");
      __publicField(this, "_server");
      this._client = new ChannelClient(_messageProtocol);
      this._server = new ChannelServer(_messageProtocol);
    }
    requestChannel(name) {
      return this._client.getChannel(name);
    }
    registerChannel(name, channel) {
      this._server.registerChannel(name, channel);
    }
  };

  // ../packages/rpc/src/controllers/data-sync/data-sync-primary.controller.ts
  var DataSyncPrimaryController = class extends RxDisposable {
    constructor(_injector, _commandService, _univerInstanceService, _rpcChannelService, _remoteSyncService) {
      super();
      this._injector = _injector;
      this._commandService = _commandService;
      this._univerInstanceService = _univerInstanceService;
      this._rpcChannelService = _rpcChannelService;
      this._remoteSyncService = _remoteSyncService;
      __publicField(this, "_remoteInstanceService");
      __publicField(this, "_syncingUnits", /* @__PURE__ */ new Set());
      this._initRPCChannels();
      this._init();
    }
    _initRPCChannels() {
      this._rpcChannelService.registerChannel(RemoteSyncServiceName, fromModule(this._remoteSyncService));
      this._injector.add([
        IRemoteInstanceService,
        {
          useFactory: () => toModule(this._rpcChannelService.requestChannel(RemoteInstanceServiceName))
        }
      ]);
      this._remoteInstanceService = this._injector.get(IRemoteInstanceService);
    }
    _init() {
      this._univerInstanceService.sheetAdded$.pipe(takeUntil(this.dispose$)).subscribe((sheet) => {
        this._syncingUnits.add(sheet.getUnitId());
        this._remoteInstanceService.createInstance({
          unitID: sheet.getUnitId(),
          type: 2 /* SHEET */,
          snapshot: sheet.getSnapshot()
        });
      });
      this._univerInstanceService.sheetDisposed$.pipe(takeUntil(this.dispose$)).subscribe((workbook) => {
        this._syncingUnits.delete(workbook.getUnitId());
        this._remoteInstanceService.disposeInstance({
          unitID: workbook.getUnitId()
        });
      });
      this.disposeWithMe(
        // Mutations executed on the main thread should be synced to the worker thread.
        this._commandService.onCommandExecuted((commandInfo, options) => {
          const { type, params } = commandInfo;
          const unitID = (params == null ? void 0 : params.unitId) || "";
          if (
            // only sync mutations to the worker thread
            type === 2 /* MUTATION */ && (!unitID || this._syncingUnits.has(unitID)) && // do not sync mutations from the web worker back to the web worker
            !(options == null ? void 0 : options.fromSync)
          ) {
            this._remoteInstanceService.syncMutation({ mutationInfo: commandInfo });
          }
        })
      );
    }
  };
  DataSyncPrimaryController = __decorateClass([
    OnLifecycle(0 /* Starting */, DataSyncPrimaryController),
    __decorateParam(0, Inject(Injector)),
    __decorateParam(1, ICommandService),
    __decorateParam(2, IUniverInstanceService),
    __decorateParam(3, IRPChannelService),
    __decorateParam(4, IRemoteSyncService)
  ], DataSyncPrimaryController);

  // ../packages/rpc/src/controllers/data-sync/data-sync-replica.controller.ts
  var DataSyncReplicaController = class extends Disposable {
    constructor(_injector, _remoteInstanceService, _commandService, _rpcChannelService) {
      super();
      this._injector = _injector;
      this._remoteInstanceService = _remoteInstanceService;
      this._commandService = _commandService;
      this._rpcChannelService = _rpcChannelService;
      __publicField(this, "_remoteSyncService");
      this._initRPCChannels();
      this._init();
    }
    _initRPCChannels() {
      this._rpcChannelService.registerChannel(RemoteInstanceServiceName, fromModule(this._remoteInstanceService));
      this._injector.add([
        IRemoteSyncService,
        {
          useFactory: () => toModule(this._rpcChannelService.requestChannel(RemoteSyncServiceName))
        }
      ]);
      this._remoteSyncService = this._injector.get(IRemoteSyncService);
    }
    _init() {
      this.disposeWithMe(
        // Mutations executed on the main thread should be synced to the worker thread.
        this._commandService.onCommandExecuted((commandInfo, options) => {
          if (commandInfo.type === 2 /* MUTATION */ && !(options == null ? void 0 : options.fromSync)) {
            this._remoteSyncService.syncMutation({
              mutationInfo: commandInfo
            });
          }
        })
      );
    }
  };
  DataSyncReplicaController = __decorateClass([
    OnLifecycle(0 /* Starting */, DataSyncReplicaController),
    __decorateParam(0, Inject(Injector)),
    __decorateParam(1, IRemoteInstanceService),
    __decorateParam(2, ICommandService),
    __decorateParam(3, IRPChannelService)
  ], DataSyncReplicaController);

  // ../packages/rpc/src/services/rpc/implementations/web-worker-rpc.service.ts
  function createWebWorkerMessagePortOnWorker() {
    return {
      send(message) {
        postMessage(message);
      },
      onMessage: new Observable((subscriber) => {
        const handler = (event) => {
          subscriber.next(event.data);
        };
        addEventListener("message", handler);
        return () => removeEventListener("message", handler);
      }).pipe(shareReplay(1))
    };
  }
  function createWebWorkerMessagePortOnMain(worker) {
    return {
      send(message) {
        worker.postMessage(message);
      },
      onMessage: new Observable((subscriber) => {
        const handler = (event) => {
          subscriber.next(event.data);
        };
        worker.addEventListener("message", handler);
        return () => worker.removeEventListener("message", handler);
      }).pipe(shareReplay(1))
    };
  }

  // ../packages/rpc/src/plugin.ts
  var UniverRPCMainThreadPlugin = class extends Plugin {
    constructor(_config, _injector) {
      super("UNIVER_RPC_MAIN_THREAD_PLUGIN");
      this._config = _config;
      this._injector = _injector;
    }
    async onStarting(injector) {
      const { workerURL } = this._config;
      const worker = workerURL instanceof Worker ? workerURL : new Worker(workerURL);
      const messageProtocol = createWebWorkerMessagePortOnMain(worker);
      const dependencies = [
        [
          IRPChannelService,
          {
            useFactory: () => new ChannelService(messageProtocol)
          }
        ],
        [DataSyncPrimaryController],
        [IRemoteSyncService, { useClass: RemoteSyncPrimaryService }]
      ];
      dependencies.forEach((dependency) => injector.add(dependency));
      injector.get(DataSyncPrimaryController);
    }
  };
  __publicField(UniverRPCMainThreadPlugin, "type", 0 /* Univer */);
  UniverRPCMainThreadPlugin = __decorateClass([
    __decorateParam(1, Inject(Injector))
  ], UniverRPCMainThreadPlugin);
  var UniverRPCWorkerThreadPlugin = class extends Plugin {
    constructor(_config, _injector) {
      super("UNIVER_RPC_WORKER_THREAD_PLUGIN");
      this._config = _config;
      this._injector = _injector;
    }
    onStarting(injector) {
      [
        [DataSyncReplicaController],
        [
          IRPChannelService,
          {
            useFactory: () => new ChannelService(createWebWorkerMessagePortOnWorker())
          }
        ],
        [IRemoteInstanceService, { useClass: RemoteInstanceReplicaService }]
      ].forEach((dependency) => injector.add(dependency));
      injector.get(DataSyncReplicaController);
    }
  };
  __publicField(UniverRPCWorkerThreadPlugin, "type", 0 /* Univer */);
  UniverRPCWorkerThreadPlugin = __decorateClass([
    __decorateParam(1, Inject(Injector))
  ], UniverRPCWorkerThreadPlugin);

  // ../packages/sheets/src/services/selection-manager.service.ts
  var NORMAL_SELECTION_PLUGIN_NAME = "normalSelectionPluginName";
  var SelectionManagerService = class {
    // get isSelectionEnabled() {
    //     return this._isSelectionEnabled;
    // }
    // get currentStyle() {
    //     return this._currentStyle;
    // }
    constructor(_themeService) {
      this._themeService = _themeService;
      __publicField(this, "_selectionInfo", /* @__PURE__ */ new Map());
      __publicField(this, "_currentSelection", null);
      __publicField(this, "_selectionMoveStart$", new Subject());
      __publicField(this, "selectionMoveStart$", this._selectionMoveStart$.asObservable());
      __publicField(this, "_selectionMoving$", new Subject());
      __publicField(this, "selectionMoving$", this._selectionMoving$.asObservable());
      __publicField(this, "_selectionMoveEnd$", new BehaviorSubject(null));
      __publicField(this, "selectionMoveEnd$", this._selectionMoveEnd$.asObservable());
      __publicField(this, "_dirty", true);
    }
    getCurrent() {
      return this._currentSelection;
    }
    getLastByPlugin(pluginName) {
      if (this._currentSelection == null) {
        return;
      }
      return this._getLastByParam({ ...this._currentSelection, pluginName });
    }
    changePlugin(pluginName) {
      var _a2, _b2;
      if (this._currentSelection == null) {
        return;
      }
      this._currentSelection = {
        pluginName,
        unitId: (_a2 = this._currentSelection) == null ? void 0 : _a2.unitId,
        sheetId: (_b2 = this._currentSelection) == null ? void 0 : _b2.sheetId
      };
      this._refresh(this._currentSelection);
    }
    changePluginNoRefresh(pluginName) {
      var _a2, _b2;
      if (this._currentSelection == null) {
        return;
      }
      this._currentSelection = {
        pluginName,
        unitId: (_a2 = this._currentSelection) == null ? void 0 : _a2.unitId,
        sheetId: (_b2 = this._currentSelection) == null ? void 0 : _b2.sheetId
      };
    }
    reset() {
      var _a2, _b2;
      if (this._currentSelection == null) {
        return;
      }
      this._currentSelection = {
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        unitId: (_a2 = this._currentSelection) == null ? void 0 : _a2.unitId,
        sheetId: (_b2 = this._currentSelection) == null ? void 0 : _b2.sheetId
      };
      this._selectionInfo.clear();
      this._refresh(this._currentSelection);
    }
    resetPlugin() {
      if (this._currentSelection == null) {
        return;
      }
      this._currentSelection.pluginName = NORMAL_SELECTION_PLUGIN_NAME;
      this._refresh(this._currentSelection);
    }
    dispose() {
      this._selectionMoveEnd$.complete();
      this._selectionMoveStart$.complete();
      this._selectionMoving$.complete();
    }
    makeDirty(dirty = true) {
      this._dirty = dirty;
    }
    refreshSelection() {
      if (this._currentSelection == null) {
        return;
      }
      this._refresh(this._currentSelection);
    }
    setCurrentSelection(param) {
      if (this._dirty === false) {
        return;
      }
      this._currentSelection = param;
      this._refresh(param);
    }
    setCurrentSelectionNotRefresh(param) {
      this._currentSelection = param;
    }
    getSelectionInfo() {
      return this._selectionInfo;
    }
    getSelectionDatasByParam(param) {
      return this._getSelectionDatas(param);
    }
    getSelections() {
      return this._getSelectionDatas(this._currentSelection);
    }
    getSelectionRanges() {
      const selectionDataList = this.getSelections();
      if (selectionDataList == null) {
        return;
      }
      return selectionDataList.map((selectionData) => selectionData.range);
    }
    getFirst() {
      return this._getFirstByParam(this._currentSelection);
    }
    getLast() {
      return this._getLastByParam(this._currentSelection);
    }
    addNoRefresh(selectionDatas) {
      if (this._currentSelection == null) {
        return;
      }
      this._addByParam(
        {
          ...this._currentSelection,
          selectionDatas
        },
        false
      );
    }
    add(selectionDatas) {
      if (this._currentSelection == null) {
        return;
      }
      this._addByParam({
        ...this._currentSelection,
        selectionDatas
      });
    }
    replace(selectionDatas, type = 2 /* MOVE_END */) {
      if (this._currentSelection == null) {
        return;
      }
      this._replaceByParam({
        ...this._currentSelection,
        selectionDatas
      });
      if (type === 0 /* MOVE_START */) {
        this._refreshStart(this._currentSelection);
      } else if (type === 1 /* MOVING */) {
        this._refreshMoving(this._currentSelection);
      } else {
        this._refresh(this._currentSelection);
      }
    }
    replaceWithNoRefresh(selectionDatas) {
      if (this._currentSelection == null) {
        return;
      }
      this._replaceByParam({
        ...this._currentSelection,
        selectionDatas
      });
    }
    clear() {
      if (this._currentSelection == null) {
        return;
      }
      this._clearByParam(this._currentSelection);
    }
    remove(index) {
      if (this._currentSelection == null) {
        return;
      }
      this._removeByParam(index, this._currentSelection);
    }
    createDefaultAutoFillSelection() {
      return {
        strokeWidth: 2,
        stroke: "#FFF000",
        fill: "rgba(0, 0, 0, 0.2)",
        widgets: {},
        hasAutoFill: true
      };
    }
    createCopyPasteSelection() {
      return {
        strokeWidth: 1.5,
        stroke: this._themeService.getCurrentTheme().primaryColor,
        fill: "rgba(178, 178, 178, 0.10)",
        widgets: {},
        hasAutoFill: false,
        strokeDash: 8
      };
    }
    createDefaultSelection() {
      return {
        strokeWidth: 2,
        stroke: "#FFF000",
        fill: "rgba(0, 0, 0, 0.2)",
        widgets: { tr: true, tl: true, br: true, bl: true },
        hasAutoFill: false
      };
    }
    /**
     * Determine whether multiple current selections overlap
     */
    isOverlapping() {
      const selectionDataList = this.getSelections();
      if (selectionDataList == null) {
        return false;
      }
      return selectionDataList.some(
        ({ range }, index) => selectionDataList.some(({ range: range2 }, index2) => {
          if (index === index2) {
            return false;
          }
          return range.startRow <= range2.endRow && range.endRow >= range2.startRow && range.startColumn <= range2.endColumn && range.endColumn >= range2.startColumn;
        })
      );
    }
    _getSelectionDatas(param) {
      var _a2, _b2;
      if (param == null) {
        return;
      }
      const { pluginName, unitId, sheetId } = param;
      return (_b2 = (_a2 = this._selectionInfo.get(pluginName)) == null ? void 0 : _a2.get(unitId)) == null ? void 0 : _b2.get(sheetId);
    }
    _refresh(param) {
      this._selectionMoveEnd$.next(this._getSelectionDatas(param));
    }
    _refreshStart(param) {
      this._selectionMoveStart$.next(this._getSelectionDatas(param));
    }
    _refreshMoving(param) {
      this._selectionMoving$.next(this._getSelectionDatas(param));
    }
    _getFirstByParam(param) {
      const selectionData = this._getSelectionDatas(param);
      return selectionData == null ? void 0 : selectionData[0];
    }
    _getLastByParam(param) {
      const selectionData = this._getSelectionDatas(param);
      return selectionData == null ? void 0 : selectionData[selectionData.length - 1];
    }
    _addByParam(insertParam, isRefresh = true) {
      const { pluginName, unitId, sheetId, selectionDatas } = insertParam;
      if (!this._selectionInfo.has(pluginName)) {
        this._selectionInfo.set(pluginName, /* @__PURE__ */ new Map());
      }
      const unitSelectionData = this._selectionInfo.get(pluginName);
      if (!unitSelectionData.has(unitId)) {
        unitSelectionData.set(unitId, /* @__PURE__ */ new Map());
      }
      const sheetSelectionData = unitSelectionData.get(unitId);
      if (!sheetSelectionData.has(sheetId)) {
        sheetSelectionData.set(sheetId, [...selectionDatas]);
      } else {
        let oldSelectionDatas = sheetSelectionData.get(sheetId);
        if (oldSelectionDatas == null) {
          oldSelectionDatas = [];
          sheetSelectionData.set(sheetId, oldSelectionDatas);
        }
        oldSelectionDatas.push(...selectionDatas);
      }
      if (isRefresh) {
        this._refresh({ pluginName, unitId, sheetId });
      }
    }
    _replaceByParam(insertParam) {
      const { pluginName, unitId, sheetId, selectionDatas } = insertParam;
      if (!this._selectionInfo.has(pluginName)) {
        this._selectionInfo.set(pluginName, /* @__PURE__ */ new Map());
      }
      const unitSelectionData = this._selectionInfo.get(pluginName);
      if (!unitSelectionData.has(unitId)) {
        unitSelectionData.set(unitId, /* @__PURE__ */ new Map());
      }
      const sheetSelectionData = unitSelectionData.get(unitId);
      if (!sheetSelectionData.has(sheetId)) {
        sheetSelectionData.set(sheetId, selectionDatas);
      } else {
        let oldSelectionDatas = sheetSelectionData.get(sheetId);
        if (oldSelectionDatas == null) {
          oldSelectionDatas = [];
          sheetSelectionData.set(sheetId, oldSelectionDatas);
        }
        oldSelectionDatas.splice(0, oldSelectionDatas.length, ...selectionDatas);
      }
    }
    _clearByParam(param) {
      const selectionData = this._getSelectionDatas(param);
      selectionData == null ? void 0 : selectionData.splice(0);
      this._refresh(param);
    }
    _removeByParam(index, param) {
      const selectionData = this._getSelectionDatas(param);
      selectionData == null ? void 0 : selectionData.splice(index, 1);
      this._refresh(param);
    }
    // private refreshCurrentSelection(): void {
    //     this._currentSelection$.next(this._currentSelection);
    // }
  };
  SelectionManagerService = __decorateClass([
    __decorateParam(0, Inject(ThemeService))
  ], SelectionManagerService);

  // ../packages/sheets/src/services/sheet-interceptor/interceptor-const.ts
  var CELL_CONTENT = createInterceptorKey("CELL_CONTENT");
  var PERMISSION = createInterceptorKey("PERMISSION");
  var INTERCEPTOR_POINT = {
    CELL_CONTENT,
    PERMISSION
  };

  // ../packages/sheets/src/services/sheet-interceptor/sheet-interceptor.service.ts
  var SheetInterceptorService = class extends Disposable {
    constructor(_currentUniverService) {
      super();
      this._currentUniverService = _currentUniverService;
      __publicField(this, "_interceptorsByName", /* @__PURE__ */ new Map());
      __publicField(this, "_commandInterceptors", []);
      __publicField(this, "_workbookDisposables", /* @__PURE__ */ new Map());
      __publicField(this, "_worksheetDisposables", /* @__PURE__ */ new Map());
      this.disposeWithMe(
        toDisposable(
          this._currentUniverService.sheetAdded$.subscribe((workbook) => {
            this._interceptWorkbook(workbook);
          })
        )
      );
      this.disposeWithMe(
        toDisposable(
          this._currentUniverService.sheetDisposed$.subscribe(
            (workbook) => this._disposeWorkbookInterceptor(workbook)
          )
        )
      );
      this.intercept(INTERCEPTOR_POINT.CELL_CONTENT, {
        priority: -1,
        handler(value, context2) {
          const rawData = context2.worksheet.getCellRaw(context2.row, context2.col);
          if (value) {
            return { ...rawData, ...value };
          }
          return rawData;
        }
      });
      this.intercept(INTERCEPTOR_POINT.PERMISSION, {
        priority: -1,
        handler: () => true
      });
    }
    dispose() {
      super.dispose();
      this._workbookDisposables.forEach((disposable) => disposable.dispose());
      this._workbookDisposables.clear();
      this._worksheetDisposables.clear();
    }
    interceptCommand(interceptor) {
      if (this._commandInterceptors.includes(interceptor)) {
        throw new Error("[SheetInterceptorService]: Interceptor already exists!");
      }
      this._commandInterceptors.push(interceptor);
      this._commandInterceptors.sort((a, b) => {
        var _a2, _b2;
        return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a.priority) != null ? _b2 : 0);
      });
      return this.disposeWithMe(toDisposable(() => remove(this._commandInterceptors, interceptor)));
    }
    /**
     * When command is executing, call this method to gether undo redo mutations from upper features.
     * @param command
     * @returns
     */
    onCommandExecute(command) {
      const infos = this._commandInterceptors.map((i) => i.getMutations(command));
      return {
        preUndos: infos.map((i) => {
          var _a2;
          return (_a2 = i.preUndos) != null ? _a2 : [];
        }).flat(),
        undos: infos.map((i) => i.undos).flat(),
        preRedos: infos.map((i) => {
          var _a2;
          return (_a2 = i.preRedos) != null ? _a2 : [];
        }).flat(),
        redos: infos.map((i) => i.redos).flat()
      };
    }
    intercept(name, interceptor) {
      const key = name;
      if (!this._interceptorsByName.has(key)) {
        this._interceptorsByName.set(key, []);
      }
      const interceptors = this._interceptorsByName.get(key);
      interceptors.push(interceptor);
      this._interceptorsByName.set(
        key,
        interceptors.sort((a, b) => {
          var _a2, _b2;
          return ((_a2 = b.priority) != null ? _a2 : 0) - ((_b2 = a.priority) != null ? _b2 : 0);
        })
      );
      return this.disposeWithMe(toDisposable(() => remove(this._interceptorsByName.get(key), interceptor)));
    }
    fetchThroughInterceptors(name) {
      const key = name;
      const interceptors = this._interceptorsByName.get(key);
      return composeInterceptors(interceptors || []);
    }
    _interceptWorkbook(workbook) {
      const disposables = new DisposableCollection();
      const unitId = workbook.getUnitId();
      const self2 = this;
      const interceptViewModel = (worksheet) => {
        const subUnitId = worksheet.getSheetId();
        worksheet.__interceptViewModel((viewModel) => {
          const sheetDisposables = new DisposableCollection();
          const cellInterceptorDisposable = viewModel.registerCellContentInterceptor({
            getCell(row, col) {
              return self2.fetchThroughInterceptors(INTERCEPTOR_POINT.CELL_CONTENT)(
                worksheet.getCellRaw(row, col),
                {
                  unitId,
                  subUnitId,
                  row,
                  col,
                  worksheet,
                  workbook
                }
              );
            }
          });
          sheetDisposables.add(cellInterceptorDisposable);
          self2._worksheetDisposables.set(getWorksheetDisposableID(unitId, worksheet), sheetDisposables);
        });
      };
      workbook.getSheets().forEach((worksheet) => interceptViewModel(worksheet));
      disposables.add(toDisposable(workbook.sheetCreated$.subscribe((worksheet) => interceptViewModel(worksheet))));
      disposables.add(
        toDisposable(
          workbook.sheetDisposed$.subscribe((worksheet) => this._disposeSheetInterceptor(unitId, worksheet))
        )
      );
      disposables.add(
        toDisposable(
          () => workbook.getSheets().forEach((worksheet) => this._disposeSheetInterceptor(unitId, worksheet))
        )
      );
    }
    _disposeWorkbookInterceptor(workbook) {
      const unitId = workbook.getUnitId();
      const disposable = this._workbookDisposables.get(unitId);
      if (disposable) {
        disposable.dispose();
        this._workbookDisposables.delete(unitId);
      }
    }
    _disposeSheetInterceptor(unitId, worksheet) {
      const disposableId = getWorksheetDisposableID(unitId, worksheet);
      const disposable = this._worksheetDisposables.get(disposableId);
      if (disposable) {
        disposable.dispose();
        this._worksheetDisposables.delete(disposableId);
      }
    }
  };
  SheetInterceptorService = __decorateClass([
    OnLifecycle(0 /* Starting */, SheetInterceptorService),
    __decorateParam(0, IUniverInstanceService)
  ], SheetInterceptorService);
  function getWorksheetDisposableID(unitId, worksheet) {
    return `${unitId}|${worksheet.getSheetId()}`;
  }

  // ../packages/sheets/src/commands/mutations/set-range-values.mutation.ts
  var SetRangeValuesUndoMutationFactory = (accessor, params) => {
    const { unitId, subUnitId, cellValue } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getUniverSheetInstance(unitId);
    if (workbook == null) {
      throw new Error("workbook is null error!");
    }
    const worksheet = workbook.getSheetBySheetId(subUnitId);
    if (worksheet == null) {
      throw new Error("worksheet is null error!");
    }
    const cellMatrix = worksheet.getCellMatrix();
    const styles = workbook.getStyles();
    const undoData = new ObjectMatrix();
    const newValues = new ObjectMatrix(cellValue);
    newValues.forValue((row, col, newVal) => {
      const cell = Tools.deepClone(cellMatrix == null ? void 0 : cellMatrix.getValue(row, col)) || {};
      const oldStyle = styles.getStyleByCell(cell);
      const newStyle = transformStyle(oldStyle, newVal && newVal.s ? newVal.s : null);
      cell.s = newStyle;
      undoData.setValue(row, col, setNull(cell));
    });
    return {
      ...params,
      options: {},
      cellValue: undoData.getMatrix()
    };
  };
  function setNull(value) {
    if (value == null)
      return null;
    if (value.f === void 0) {
      value.f = null;
    }
    if (value.si === void 0) {
      value.si = null;
    }
    if (value.p === void 0) {
      value.p = null;
    }
    if (value.v === void 0) {
      value.v = null;
    }
    if (value.t === void 0) {
      value.t = null;
    }
    if (value.s === void 0) {
      value.s = null;
    }
    return value;
  }
  var SetRangeValuesMutation = {
    id: "sheet.mutation.set-range-values",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const { cellValue, subUnitId, unitId } = params;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook) {
        return false;
      }
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet) {
        return false;
      }
      const cellMatrix = worksheet.getCellMatrix();
      const styles = workbook.getStyles();
      const newValues = new ObjectMatrix(cellValue);
      newValues.forValue((row, col, newVal) => {
        if (!newVal) {
          cellMatrix == null ? void 0 : cellMatrix.setValue(row, col, {});
        } else {
          const oldVal = cellMatrix.getValue(row, col) || {};
          const type = newVal.t === 4 /* FORCE_STRING */ ? newVal.t : newVal.v !== void 0 ? checkCellValueType(newVal.v, newVal.t) : checkCellValueType(oldVal.v, oldVal.t);
          if (newVal.f !== void 0) {
            oldVal.f = newVal.f;
          }
          if (newVal.si !== void 0) {
            oldVal.si = newVal.si;
          }
          if (newVal.p !== void 0) {
            oldVal.p = newVal.p;
          }
          if (newVal.v !== void 0) {
            oldVal.v = type === 2 /* NUMBER */ ? Number(newVal.v) : type === 3 /* BOOLEAN */ ? extractBooleanValue(newVal.v) ? 1 : 0 : newVal.v;
          }
          if (oldVal.v !== void 0) {
            oldVal.t = type;
          }
          if (newVal.s !== void 0) {
            const oldStyle = styles.getStyleByCell(oldVal);
            if (oldStyle == null) {
              delete oldVal.s;
            }
            if (typeof newVal.s === "string") {
              newVal.s = styles.get(newVal.s);
            }
            const merge = mergeStyle(oldStyle, newVal.s ? newVal.s : null);
            merge && Tools.removeNull(merge);
            if (Tools.isEmptyObject(merge)) {
              delete oldVal.s;
            } else {
              oldVal.s = styles.setValue(merge);
            }
            if (!newVal.p && oldVal.p) {
              mergeRichTextStyle(oldVal.p, newVal.s ? newVal.s : null);
            }
          }
          cellMatrix.setValue(row, col, Tools.removeNull(oldVal));
        }
      });
      return true;
    }
  };
  function checkCellValueType(v, oldType) {
    if (v === null)
      return null;
    if (typeof v === "string") {
      if (isSafeNumeric(v)) {
        if ((+v === 0 || +v === 1) && oldType === 3 /* BOOLEAN */) {
          return 3 /* BOOLEAN */;
        }
        return 2 /* NUMBER */;
      } else if (isBooleanString(v)) {
        return 3 /* BOOLEAN */;
      }
      return 1 /* STRING */;
    }
    if (typeof v === "number") {
      if ((v === 0 || v === 1) && oldType === 3 /* BOOLEAN */) {
        return 3 /* BOOLEAN */;
      }
      return 2 /* NUMBER */;
    }
    if (typeof v === "boolean") {
      return 3 /* BOOLEAN */;
    }
    return 4 /* FORCE_STRING */;
  }
  function extractBooleanValue(value) {
    if (typeof value === "string") {
      if (value.toUpperCase() === "TRUE") {
        return true;
      }
      ;
      if (value.toUpperCase() === "FALSE") {
        return false;
      }
      if (isSafeNumeric(value)) {
        if (Number(value) === 0) {
          return false;
        }
        if (Number(value) === 1) {
          return true;
        }
      }
    }
    if (typeof value === "number") {
      if (value === 0) {
        return false;
      }
      if (value === 1) {
        return true;
      }
    }
    if (typeof value === "boolean") {
      return value;
    }
    return null;
  }
  function transformStyle(oldStyle, newStyle) {
    const backupStyle = transformNormalKey(oldStyle, newStyle);
    return backupStyle;
  }
  function transformNormalKey(oldStyle, newStyle) {
    if (!newStyle || !Object.keys(newStyle).length) {
      return oldStyle;
    }
    const backupStyle = oldStyle || {};
    for (const k in newStyle) {
      if (k === "bd") {
        backupStyle[k] = transformBorders(backupStyle[k] || {}, newStyle[k]);
      } else if (!(k in backupStyle)) {
        backupStyle[k] = null;
      }
    }
    return backupStyle;
  }
  function transformBorders(oldBorders, newBorders) {
    if (!newBorders || !Object.keys(newBorders).length) {
      return oldBorders;
    }
    for (const k in newBorders) {
      if (!(k in oldBorders)) {
        oldBorders[k] = null;
      }
    }
    return oldBorders;
  }
  function mergeStyle(oldStyle, newStyle, isRichText = false) {
    if (newStyle === null)
      return newStyle;
    if (newStyle === void 0)
      return oldStyle;
    const backupStyle = Tools.deepClone(oldStyle) || {};
    if (!backupStyle)
      return;
    for (const k in newStyle) {
      if (isRichText && ["bd", "tr", "td", "ht", "vt", "tb", "pd"].includes(k)) {
        continue;
      }
      if (k in backupStyle && k === "bd") {
        backupStyle[k] = Object.assign(backupStyle[k], newStyle[k]);
      } else {
        backupStyle[k] = newStyle[k];
      }
    }
    if ("cl" in backupStyle) {
      if ("ul" in backupStyle && backupStyle.ul) {
        backupStyle.ul.cl = backupStyle.cl;
      }
      if ("ol" in backupStyle && backupStyle.ol) {
        backupStyle.ol.cl = backupStyle.cl;
      }
      if ("st" in backupStyle && backupStyle.st) {
        backupStyle.st.cl = backupStyle.cl;
      }
    }
    return backupStyle;
  }
  function skipParagraphs(paragraphs, offset) {
    if (paragraphs.some((p) => p.startIndex === offset)) {
      return skipParagraphs(paragraphs, offset + 1);
    }
    return offset;
  }
  function mergeRichTextStyle(p, newStyle) {
    var _a2;
    if (p.body == null) {
      return;
    }
    if (!Array.isArray(p.body.textRuns)) {
      p.body.textRuns = [];
    }
    let index = 0;
    const newTextRuns = [];
    const paragraphs = ((_a2 = p.body) == null ? void 0 : _a2.paragraphs) || [];
    for (const textRun of p.body.textRuns) {
      const { st, ed, ts = {} } = textRun;
      if (index < st) {
        const tr = {
          st: index,
          ed: st
        };
        const merge2 = mergeStyle({}, newStyle, true);
        merge2 && Tools.removeNull(merge2);
        if (!Tools.isEmptyObject(merge2)) {
          tr.ts = merge2;
        }
        newTextRuns.push(tr);
      }
      const merge = mergeStyle(ts, newStyle, true);
      merge && Tools.removeNull(merge);
      if (Tools.isEmptyObject(merge)) {
        delete textRun.ts;
      } else {
        textRun.ts = merge;
      }
      newTextRuns.push(textRun);
      index = skipParagraphs(paragraphs, ed);
    }
    const endIndex = p.body.dataStream.endsWith("\r\n") ? p.body.dataStream.length - 2 : p.body.dataStream.length;
    if (index < endIndex) {
      const tr = {
        st: index,
        ed: endIndex
      };
      const merge = mergeStyle({}, newStyle, true);
      merge && Tools.removeNull(merge);
      if (!Tools.isEmptyObject(merge)) {
        tr.ts = merge;
      }
      newTextRuns.push(tr);
    }
    p.body.textRuns = newTextRuns;
  }
  function isNumeric(str) {
    return /^-?\d+(\.\d+)?$/.test(str);
  }
  function isSafeNumeric(str) {
    const numeric = isNumeric(str);
    if (!numeric) {
      return false;
    }
    return Number(str) <= Number.MAX_SAFE_INTEGER;
  }
  function isBooleanString(str) {
    return str.toUpperCase() === "TRUE" || str.toUpperCase() === "FALSE";
  }

  // ../packages/sheets/src/commands/commands/clear-selection-all.command.ts
  var ClearSelectionAllCommand = {
    id: "sheet.command.clear-selection-all",
    type: 0 /* COMMAND */,
    handler: async (accessor) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const commandService = accessor.get(ICommandService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const unitId = workbook.getUnitId();
      const worksheet = workbook.getActiveSheet();
      const subUnitId = worksheet.getSheetId();
      const selections = selectionManagerService.getSelectionRanges();
      if (!(selections == null ? void 0 : selections.length)) {
        return false;
      }
      const sequenceExecuteList = [];
      const sequenceExecuteUndoList = [];
      const clearMutationParams = {
        subUnitId,
        unitId,
        cellValue: generateNullCellValue(selections)
      };
      const undoClearMutationParams = SetRangeValuesUndoMutationFactory(
        accessor,
        clearMutationParams
      );
      sequenceExecuteList.push({
        id: SetRangeValuesMutation.id,
        params: clearMutationParams
      });
      sequenceExecuteUndoList.push({
        id: SetRangeValuesMutation.id,
        params: undoClearMutationParams
      });
      const intercepted = sheetInterceptorService.onCommandExecute({ id: ClearSelectionAllCommand.id });
      sequenceExecuteList.push(...intercepted.redos);
      sequenceExecuteUndoList.unshift(...intercepted.undos);
      const result = sequenceExecute(sequenceExecuteList, commandService);
      if (result) {
        undoRedoService.pushUndoRedo({
          // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
          // Hooks can be used to hook the code of external controllers to add new actions.
          unitID: unitId,
          undoMutations: sequenceExecuteUndoList,
          redoMutations: sequenceExecuteList
        });
        return true;
      }
      return false;
    }
  };
  function generateNullCellValue(range) {
    const cellValue = new ObjectMatrix();
    range.forEach((range2) => {
      const { startRow, startColumn, endRow, endColumn } = range2;
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startColumn; j <= endColumn; j++) {
          cellValue.setValue(i, j, null);
        }
      }
    });
    return cellValue.getData();
  }

  // ../packages/sheets/src/commands/commands/clear-selection-content.command.ts
  var ClearSelectionContentCommand = {
    id: "sheet.command.clear-selection-content",
    type: 0 /* COMMAND */,
    handler: async (accessor) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const commandService = accessor.get(ICommandService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const unitId = workbook.getUnitId();
      const worksheet = workbook.getActiveSheet();
      const subUnitId = worksheet.getSheetId();
      const selections = selectionManagerService.getSelectionRanges();
      if (!(selections == null ? void 0 : selections.length)) {
        return false;
      }
      const clearMutationParams = {
        subUnitId,
        unitId,
        cellValue: generateNullCellValue2(selections)
      };
      const undoClearMutationParams = SetRangeValuesUndoMutationFactory(
        accessor,
        clearMutationParams
      );
      const intercepted = sheetInterceptorService.onCommandExecute({ id: ClearSelectionContentCommand.id });
      const redos = [{ id: SetRangeValuesMutation.id, params: clearMutationParams }, ...intercepted.redos];
      const undos = [...intercepted.undos, { id: SetRangeValuesMutation.id, params: undoClearMutationParams }];
      const result = sequenceExecute(redos, commandService).result;
      if (result) {
        undoRedoService.pushUndoRedo({
          // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
          // Hooks can be used to hook the code of external controllers to add new actions.
          unitID: unitId,
          undoMutations: undos,
          redoMutations: redos
        });
        return true;
      }
      return false;
    }
  };
  function generateNullCellValue2(range) {
    const cellValue = new ObjectMatrix();
    range.forEach((range2) => {
      const { startRow, startColumn, endRow, endColumn } = range2;
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startColumn; j <= endColumn; j++) {
          cellValue.setValue(i, j, {
            v: null,
            p: null,
            f: null,
            si: null
          });
        }
      }
    });
    return cellValue.getData();
  }

  // ../packages/sheets/src/commands/commands/clear-selection-format.command.ts
  var ClearSelectionFormatCommand = {
    id: "sheet.command.clear-selection-format",
    type: 0 /* COMMAND */,
    handler: async (accessor) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const commandService = accessor.get(ICommandService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const unitId = workbook.getUnitId();
      const worksheet = workbook.getActiveSheet();
      const subUnitId = worksheet.getSheetId();
      const selections = selectionManagerService.getSelectionRanges();
      if (!(selections == null ? void 0 : selections.length)) {
        return false;
      }
      const sequenceExecuteList = [];
      const sequenceExecuteUndoList = [];
      const clearMutationParams = {
        subUnitId,
        unitId,
        cellValue: generateNullCellValue3(selections)
      };
      const undoClearMutationParams = SetRangeValuesUndoMutationFactory(
        accessor,
        clearMutationParams
      );
      sequenceExecuteList.push({
        id: SetRangeValuesMutation.id,
        params: clearMutationParams
      });
      sequenceExecuteUndoList.push({
        id: SetRangeValuesMutation.id,
        params: undoClearMutationParams
      });
      const intercepted = sheetInterceptorService.onCommandExecute({ id: ClearSelectionFormatCommand.id });
      sequenceExecuteList.push(...intercepted.redos);
      sequenceExecuteUndoList.unshift(...intercepted.undos);
      const result = sequenceExecute(sequenceExecuteList, commandService);
      if (result) {
        undoRedoService.pushUndoRedo({
          // If there are multiple mutations that form an encapsulated project, they must be encapsulated in the same undo redo element.
          // Hooks can be used to hook the code of external controllers to add new actions.
          unitID: unitId,
          undoMutations: sequenceExecuteUndoList,
          redoMutations: sequenceExecuteList
        });
        return true;
      }
      return false;
    }
  };
  function generateNullCellValue3(ranges) {
    const cellValue = new ObjectMatrix();
    ranges.forEach((range) => {
      const { startRow, startColumn, endRow, endColumn } = range;
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startColumn; j <= endColumn; j++) {
          cellValue.setValue(i, j, {
            s: null
          });
        }
      }
    });
    return cellValue.getData();
  }

  // ../packages/sheets/src/commands/mutations/insert-sheet.mutation.ts
  var InsertSheetUndoMutationFactory = (_accessor, params) => ({
    subUnitId: params.sheet.id,
    unitId: params.unitId,
    subUnitName: params.sheet.name
  });
  var InsertSheetMutation = {
    id: "sheet.mutation.insert-sheet",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const { sheet, index, unitId } = params;
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook) {
        return false;
      }
      return workbook.addWorksheet(sheet.id, index, sheet);
    }
  };

  // ../packages/sheets/src/commands/mutations/remove-sheet.mutation.ts
  var RemoveSheetUndoMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getCurrentUniverSheetInstance();
    const { subUnitId, unitId } = params;
    const sheet = workbook.getSheetBySheetId(subUnitId).getConfig();
    const config2 = workbook.getConfig();
    const index = config2.sheetOrder.findIndex((id) => id === subUnitId);
    return {
      index,
      sheet,
      unitId
    };
  };
  var RemoveSheetMutation = {
    id: "sheet.mutation.remove-sheet",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const { subUnitId, unitId } = params;
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook) {
        return false;
      }
      return workbook.removeSheet(subUnitId);
    }
  };

  // ../packages/sheets/src/commands/commands/copy-worksheet.command.ts
  var CopySheetCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.copy-sheet",
    handler: async (accessor, params) => {
      var _a2, _b2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const localeService = accessor.get(LocaleService);
      let unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      let subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      if (params) {
        unitId = (_a2 = params.unitId) != null ? _a2 : unitId;
        subUnitId = (_b2 = params.subUnitId) != null ? _b2 : subUnitId;
      }
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const config2 = Tools.deepClone(worksheet.getConfig());
      config2.name += localeService.t("sheets.sheetCopy");
      config2.id = Tools.generateRandomId();
      const sheetIndex = workbook.getSheetIndex(worksheet);
      const insertSheetMutationParams = {
        index: sheetIndex + 1,
        sheet: config2,
        unitId
      };
      const removeSheetMutationParams = InsertSheetUndoMutationFactory(
        accessor,
        insertSheetMutationParams
      );
      const insertResult = commandService.syncExecuteCommand(InsertSheetMutation.id, insertSheetMutationParams);
      if (insertResult) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: RemoveSheetMutation.id, params: removeSheetMutationParams }],
          redoMutations: [{ id: InsertSheetMutation.id, params: insertSheetMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/move-range.mutation.ts
  var MoveRangeMutation = {
    id: "sheet.mutation.move-range",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const { from: from2, to } = params;
      if (!from2 || !to) {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook) {
        return false;
      }
      const fromWorksheet = workbook.getSheetBySheetId(params.from.subUnitId);
      const toWorksheet = workbook.getSheetBySheetId(params.to.subUnitId);
      if (!fromWorksheet || !toWorksheet) {
        return false;
      }
      const fromCellMatrix = fromWorksheet.getCellMatrix();
      const toCellMatrix = toWorksheet.getCellMatrix();
      new ObjectMatrix(from2.value).forValue((row, col, newVal) => {
        fromCellMatrix.setValue(row, col, newVal);
      });
      new ObjectMatrix(to.value).forValue((row, col, newVal) => {
        toCellMatrix.setValue(row, col, newVal);
      });
      return true;
    }
  };

  // ../packages/sheets/src/commands/operations/selection.operation.ts
  var SetSelectionsOperation = {
    id: "sheet.operation.set-selections",
    type: 1 /* OPERATION */,
    handler: (accessor, params) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      if (!params) {
        return false;
      }
      const { selections, type } = params;
      selectionManagerService.replace(selections, type);
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/utils/selection-utils.ts
  function alignToMergedCellsBorders(startRange, worksheet, shouldRecursive = true) {
    const coveredMergedCells = worksheet.getMatrixWithMergedCells(...selectionToArray(startRange));
    const exceededMergedCells = [];
    coveredMergedCells.forValue((row, col, value) => {
      if (value.colSpan !== void 0 && value.rowSpan !== void 0) {
        const mergedCellRange = {
          startRow: row,
          startColumn: col,
          endRow: row + value.rowSpan - 1,
          endColumn: col + value.colSpan - 1
        };
        if (!Rectangle.contains(startRange, mergedCellRange)) {
          exceededMergedCells.push(mergedCellRange);
        }
      }
    });
    if (exceededMergedCells.length === 0) {
      return startRange;
    }
    const union = Rectangle.union(startRange, ...exceededMergedCells);
    if (shouldRecursive) {
      return alignToMergedCellsBorders(union, worksheet, shouldRecursive);
    }
    return union;
  }
  function getPrimaryForRange(range, worksheet) {
    const startRow = Number.isNaN(range.startRow) ? 0 : range.startRow;
    const startColumn = Number.isNaN(range.startColumn) ? 0 : range.startColumn;
    const mergedRange = worksheet.getMergedCell(startRow, startColumn);
    if (!mergedRange) {
      return {
        startRow,
        startColumn,
        endRow: range.startRow,
        endColumn: range.startColumn,
        actualRow: startRow,
        actualColumn: startColumn,
        rangeType: 0 /* NORMAL */,
        isMerged: false,
        isMergedMainCell: false
      };
    }
    return {
      ...mergedRange,
      actualRow: startRow,
      actualColumn: startColumn,
      rangeType: 0 /* NORMAL */,
      isMerged: true,
      isMergedMainCell: true
    };
  }
  var followSelectionOperation = (range, workbook, worksheet) => ({
    id: SetSelectionsOperation.id,
    params: {
      unitId: workbook.getUnitId(),
      subUnitId: worksheet.getSheetId(),
      pluginName: NORMAL_SELECTION_PLUGIN_NAME,
      selections: [{ range, primary: getPrimaryForRange(range, worksheet) }]
    }
  });

  // ../packages/sheets/src/commands/commands/move-range.command.ts
  var MoveRangeCommandId = "sheet.command.move-range";
  var MoveRangeCommand = {
    type: 0 /* COMMAND */,
    id: MoveRangeCommandId,
    handler: (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const errorService = accessor.get(ErrorService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const worksheet = workbook.getActiveSheet();
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const moveRangeMutations = getMoveRangeUndoRedoMutations(
        accessor,
        { unitId, subUnitId, range: params.fromRange },
        { unitId, subUnitId, range: params.toRange }
      );
      if (moveRangeMutations === null) {
        errorService.emit("Across a merged cell.");
        return false;
      }
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const interceptorCommands = sheetInterceptorService.onCommandExecute({
        id: MoveRangeCommand.id,
        params: { ...params }
      });
      const redos = [
        ...moveRangeMutations.redos,
        ...interceptorCommands.redos,
        {
          id: SetSelectionsOperation.id,
          params: {
            unitId,
            subUnitId,
            pluginName: NORMAL_SELECTION_PLUGIN_NAME,
            selections: [{ range: params.toRange, primary: getPrimaryForRange(params.toRange, worksheet) }]
          }
        }
      ];
      const undos = [
        {
          id: SetSelectionsOperation.id,
          params: {
            unitId,
            subUnitId,
            pluginName: NORMAL_SELECTION_PLUGIN_NAME,
            selections: [{ range: params.fromRange, primary: getPrimaryForRange(params.fromRange, worksheet) }]
          }
        },
        ...moveRangeMutations.undos,
        ...interceptorCommands.undos
      ];
      const result = sequenceExecute(redos, commandService).result;
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undos,
          redoMutations: redos
        });
        return true;
      }
      return false;
    }
  };
  function getMoveRangeUndoRedoMutations(accessor, from2, to, ignoreMerge = false) {
    const redos = [];
    const undos = [];
    const { range: fromRange, subUnitId: fromSubUnitId, unitId } = from2;
    const { range: toRange, subUnitId: toSubUnitId } = to;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getUniverSheetInstance(unitId);
    const toWorksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(toSubUnitId);
    const fromWorksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(fromSubUnitId);
    const toCellMatrix = toWorksheet == null ? void 0 : toWorksheet.getCellMatrix();
    const fromCellMatrix = fromWorksheet == null ? void 0 : fromWorksheet.getCellMatrix();
    if (toWorksheet && fromWorksheet && toCellMatrix && fromCellMatrix) {
      const alignedRangeWithToRange = alignToMergedCellsBorders(toRange, toWorksheet, false);
      if (!Rectangle.equals(toRange, alignedRangeWithToRange) && !ignoreMerge) {
        return null;
      }
      const fromCellValue = new ObjectMatrix();
      const newFromCellValue = new ObjectMatrix();
      Range.foreach(fromRange, (row, col) => {
        fromCellValue.setValue(row, col, fromCellMatrix.getValue(row, col));
        newFromCellValue.setValue(row, col, null);
      });
      const toCellValue = new ObjectMatrix();
      Range.foreach(toRange, (row, col) => {
        toCellValue.setValue(row, col, toCellMatrix.getValue(row, col));
      });
      const newToCellValue = new ObjectMatrix();
      Range.foreach(fromRange, (row, col) => {
        const cellRange = cellToRange(row, col);
        const relativeRange = Rectangle.getRelativeRange(cellRange, fromRange);
        const range = Rectangle.getPositionRange(relativeRange, toRange);
        newToCellValue.setValue(range.startRow, range.startColumn, fromCellMatrix.getValue(row, col));
      });
      const doMoveRangeMutation = {
        from: {
          value: newFromCellValue.getMatrix(),
          subUnitId: fromSubUnitId
        },
        to: {
          value: newToCellValue.getMatrix(),
          subUnitId: toSubUnitId
        },
        unitId
      };
      const undoMoveRangeMutation = {
        from: {
          value: fromCellValue.getMatrix(),
          subUnitId: fromSubUnitId
        },
        to: {
          value: toCellValue.getMatrix(),
          subUnitId: toSubUnitId
        },
        unitId
      };
      redos.push({ id: MoveRangeMutation.id, params: doMoveRangeMutation });
      undos.push({ id: MoveRangeMutation.id, params: undoMoveRangeMutation });
    }
    return {
      redos,
      undos
    };
  }

  // ../packages/sheets/src/commands/commands/set-range-values.command.ts
  var SetRangeValuesCommand = {
    id: "sheet.command.set-range-values",
    type: 0 /* COMMAND */,
    handler: (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const {
        value,
        range,
        unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId(),
        subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId()
      } = params;
      const currentSelections = range ? [range] : selectionManagerService.getSelectionRanges();
      if (!currentSelections || !currentSelections.length) {
        return false;
      }
      const cellValue = new ObjectMatrix();
      let realCellValue;
      if (Tools.isArray(value)) {
        for (let i = 0; i < currentSelections.length; i++) {
          const { startRow, startColumn, endRow, endColumn } = currentSelections[i];
          for (let r = 0; r <= endRow - startRow; r++) {
            for (let c = 0; c <= endColumn - startColumn; c++) {
              cellValue.setValue(r + startRow, c + startColumn, value[r][c]);
            }
          }
        }
      } else if (isICellData(value)) {
        for (let i = 0; i < currentSelections.length; i++) {
          const { startRow, startColumn, endRow, endColumn } = currentSelections[i];
          for (let r = startRow; r <= endRow; r++) {
            for (let c = startColumn; c <= endColumn; c++) {
              cellValue.setValue(r, c, value);
            }
          }
        }
      } else {
        realCellValue = value;
      }
      const setRangeValuesMutationParams = {
        subUnitId,
        unitId,
        cellValue: realCellValue != null ? realCellValue : cellValue.getMatrix()
      };
      const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(accessor, setRangeValuesMutationParams);
      if (!sheetInterceptorService.fetchThroughInterceptors(INTERCEPTOR_POINT.PERMISSION)(null, {
        id: SetRangeValuesCommand.id,
        params: setRangeValuesMutationParams
      })) {
        return false;
      }
      const setValueMutationResult = commandService.syncExecuteCommand(
        SetRangeValuesMutation.id,
        setRangeValuesMutationParams
      );
      const { undos, redos } = sheetInterceptorService.onCommandExecute({
        id: SetRangeValuesCommand.id,
        params: { ...setRangeValuesMutationParams, range: currentSelections }
      });
      const result = sequenceExecute([...redos], commandService);
      if (setValueMutationResult && result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams }, ...undos],
          redoMutations: [{ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }, ...redos]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/utils/handle-range-mutation.ts
  function getInsertRangeMutations(accessor, params) {
    const redo = [];
    const undo = [];
    const { unitId, subUnitId, range, shiftDimension, cellValue = {} } = params;
    const instanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const workbook = instanceService.getUniverSheetInstance(unitId);
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    if (worksheet) {
      const cellMatrix = worksheet.getCellMatrix();
      const dataRange = cellMatrix.getDataRange();
      if (range.startColumn <= dataRange.endColumn || range.startRow <= dataRange.endRow) {
        let moveFromRange;
        let moveToRange;
        if (shiftDimension === 0 /* COLUMNS */) {
          const endRow = Math.min(range.endRow, dataRange.endRow);
          let endColumn = 0;
          for (let row = range.startRow; row <= endRow; row++) {
            const rowData = cellMatrix.getRow(row);
            const rowLength = rowData ? getArrayLength(rowData) - 1 : 0;
            endColumn = Math.max(endColumn, rowLength);
          }
          moveFromRange = {
            startRow: range.startRow,
            startColumn: range.startColumn,
            endRow,
            endColumn
          };
          const shift = range.endColumn - range.startColumn + 1;
          moveToRange = {
            startRow: range.startRow,
            startColumn: moveFromRange.startColumn + shift,
            endRow,
            endColumn: moveFromRange.endColumn + shift
          };
        } else {
          const endColumn = Math.min(range.endColumn, dataRange.endColumn);
          const endRow = dataRange.endRow;
          moveFromRange = {
            startRow: range.startRow,
            startColumn: range.startColumn,
            endRow,
            endColumn
          };
          const shift = range.endRow - range.startRow + 1;
          moveToRange = {
            startRow: moveFromRange.startRow + shift,
            startColumn: range.startColumn,
            endRow: moveFromRange.endRow + shift,
            endColumn
          };
        }
        const moveRangeMutations = getMoveRangeUndoRedoMutations(
          accessor,
          { unitId, subUnitId, range: moveFromRange },
          { unitId, subUnitId, range: moveToRange },
          true
        );
        if (moveRangeMutations) {
          redo.push(...moveRangeMutations.redos);
          undo.push(...moveRangeMutations.undos);
        }
      }
      if (Object.entries(cellValue).length === 0) {
        for (let row = range.startRow; row <= range.endRow; row++) {
          if (!cellValue[row]) {
            cellValue[row] = {};
          }
          for (let column = range.startColumn; column <= range.endColumn; column++) {
            cellValue[row][column] = null;
          }
        }
      }
      const setRangeValuesMutationParams = {
        subUnitId,
        unitId,
        cellValue
      };
      const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(
        accessor,
        setRangeValuesMutationParams
      );
      const { undos: interceptorUndos, redos: interceptorRedos } = sheetInterceptorService.onCommandExecute({
        id: SetRangeValuesCommand.id,
        params: { ...setRangeValuesMutationParams, range }
      });
      redo.push({ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }, ...interceptorRedos);
      undo.push({ id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams }, ...interceptorUndos);
    }
    return {
      redo,
      undo
    };
  }
  function getRemoveRangeMutations(accessor, params) {
    const redo = [];
    const undo = [];
    const { unitId, subUnitId, range, shiftDimension } = params;
    const instanceService = accessor.get(IUniverInstanceService);
    const sheetInterceptorService = accessor.get(SheetInterceptorService);
    const workbook = instanceService.getUniverSheetInstance(unitId);
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    if (worksheet) {
      const cellMatrix = worksheet.getCellMatrix();
      const dataRange = cellMatrix.getDataRange();
      const setRangeValuesMutationParams = {
        subUnitId,
        unitId,
        cellValue: generateNullCellValue4([range])
      };
      const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(
        accessor,
        setRangeValuesMutationParams
      );
      const intercepted = sheetInterceptorService.onCommandExecute({
        id: SetRangeValuesCommand.id,
        params: setRangeValuesMutationParams
      });
      redo.push({ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }, ...intercepted.redos);
      undo.push(...intercepted.undos, {
        id: SetRangeValuesMutation.id,
        params: undoSetRangeValuesMutationParams
      });
      if (range.startColumn <= dataRange.endColumn || range.startRow <= dataRange.endRow) {
        let moveFromRange = null;
        let moveToRange = null;
        if (shiftDimension === 0 /* COLUMNS */ && range.endColumn < dataRange.endColumn) {
          const endRow = Math.min(range.endRow, dataRange.endRow);
          let endColumn = 0;
          for (let row = range.startRow; row <= endRow; row++) {
            const rowData = cellMatrix.getRow(row);
            const rowLength = rowData ? getArrayLength(rowData) - 1 : 0;
            endColumn = Math.max(endColumn, rowLength);
          }
          moveFromRange = {
            startRow: range.startRow,
            startColumn: range.endColumn + 1,
            endRow,
            endColumn
          };
          const shift = range.endColumn - range.startColumn + 1;
          moveToRange = {
            startRow: range.startRow,
            startColumn: moveFromRange.startColumn - shift,
            endRow,
            endColumn: moveFromRange.endColumn - shift
          };
        }
        if (shiftDimension === 1 /* ROWS */ && range.endRow < dataRange.endRow) {
          const endColumn = Math.min(range.endColumn, dataRange.endColumn);
          const endRow = dataRange.endRow;
          moveFromRange = {
            startRow: range.endRow + 1,
            startColumn: range.startColumn,
            endRow,
            endColumn
          };
          const shift = range.endRow - range.startRow + 1;
          moveToRange = {
            startRow: moveFromRange.startRow - shift,
            startColumn: range.startColumn,
            endRow: moveFromRange.endRow - shift,
            endColumn
          };
        }
        if (moveFromRange && moveToRange) {
          const moveRangeMutations = getMoveRangeUndoRedoMutations(
            accessor,
            { unitId, subUnitId, range: moveFromRange },
            { unitId, subUnitId, range: moveToRange },
            true
          );
          if (moveRangeMutations) {
            redo.push(...moveRangeMutations.redos);
            undo.push(...moveRangeMutations.undos);
          }
        }
      }
    }
    return {
      redo,
      undo
    };
  }
  function generateNullCellValue4(range) {
    const cellValue = new ObjectMatrix();
    range.forEach((range2) => {
      const { startRow, startColumn, endRow, endColumn } = range2;
      for (let i = startRow; i <= endRow; i++) {
        for (let j = startColumn; j <= endColumn; j++) {
          cellValue.setValue(i, j, null);
        }
      }
    });
    return cellValue.getData();
  }

  // ../packages/sheets/src/commands/commands/delete-range-move-left.command.ts
  var DeleteRangeMoveLeftCommandId = "sheet.command.delete-range-move-left";
  var DeleteRangeMoveLeftCommand = {
    type: 0 /* COMMAND */,
    id: DeleteRangeMoveLeftCommandId,
    handler: async (accessor, params) => {
      var _a2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      let range = params == null ? void 0 : params.range;
      if (!range) {
        range = (_a2 = selectionManagerService.getLast()) == null ? void 0 : _a2.range;
      }
      if (!range)
        return false;
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const deleteRangeMutationParams = {
        range,
        subUnitId,
        unitId,
        shiftDimension: 0 /* COLUMNS */
      };
      const sheetInterceptor = sheetInterceptorService.onCommandExecute({
        id: DeleteRangeMoveLeftCommand.id,
        params: { range }
      });
      const { redo: removeRangeRedo, undo: removeRangeUndo } = getRemoveRangeMutations(
        accessor,
        deleteRangeMutationParams
      );
      const redos = [...removeRangeRedo];
      const undos = [...removeRangeUndo];
      redos.push(...sheetInterceptor.redos);
      redos.push(followSelectionOperation(range, workbook, worksheet));
      undos.push(...sheetInterceptor.undos);
      const result = sequenceExecute(redos, commandService).result;
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undos.reverse(),
          redoMutations: redos
        });
        return true;
      }
      return false;
    }
    // all subsequent mutations should succeed inorder to make the whole process succeed
    // Promise.all([]).then(() => true),
  };

  // ../packages/sheets/src/commands/commands/delete-range-move-up.command.ts
  var DeleteRangeMoveUpCommandId = "sheet.command.delete-range-move-up";
  var DeleteRangeMoveUpCommand = {
    type: 0 /* COMMAND */,
    id: DeleteRangeMoveUpCommandId,
    handler: async (accessor, params) => {
      var _a2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      let range = params == null ? void 0 : params.range;
      if (!range) {
        range = (_a2 = selectionManagerService.getLast()) == null ? void 0 : _a2.range;
      }
      if (!range)
        return false;
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const deleteRangeMutationParams = {
        range,
        subUnitId,
        unitId,
        shiftDimension: 1 /* ROWS */
      };
      const sheetInterceptor = sheetInterceptorService.onCommandExecute({
        id: DeleteRangeMoveUpCommand.id,
        params: { range }
      });
      const { redo: removeRangeRedo, undo: removeRangeUndo } = getRemoveRangeMutations(
        accessor,
        deleteRangeMutationParams
      );
      const redos = [...removeRangeRedo];
      const undos = [...removeRangeUndo];
      redos.push(...sheetInterceptor.redos);
      redos.push(followSelectionOperation(range, workbook, worksheet));
      undos.push(...sheetInterceptor.undos);
      const result = await sequenceExecute(redos, commandService).result;
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undos.reverse(),
          redoMutations: redos
        });
        return true;
      }
      return false;
    }
    // all subsequent mutations should succeed inorder to make the whole process succeed
    // Promise.all([]).then(() => true),
  };

  // ../packages/sheets/src/commands/mutations/insert-row-col.mutation.ts
  var InsertRowMutationUndoFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      range: params.range
    };
  };
  var InsertRowMutation = {
    id: "sheet.mutation.insert-row",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      var _a2;
      const { unitId, subUnitId, range, rowInfo } = params;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const worksheet = universheet.getSheetBySheetId(subUnitId);
      if (worksheet == null) {
        throw new Error("worksheet is null error!");
      }
      const rowWrapper = worksheet.getRowManager().getRowData();
      const defaultRowInfo = {
        h: worksheet.getConfig().defaultRowHeight,
        hd: 0
      };
      const rowIndex = range.startRow;
      const rowCount = range.endRow - range.startRow + 1;
      for (let j = rowIndex; j < rowIndex + rowCount; j++) {
        if (rowInfo) {
          insertMatrixArray(j, (_a2 = rowInfo[j - range.startRow]) != null ? _a2 : defaultRowInfo, rowWrapper);
        } else {
          insertMatrixArray(j, defaultRowInfo, rowWrapper);
        }
      }
      worksheet.setRowCount(worksheet.getRowCount() + range.endRow - range.startRow + 1);
      const cellMatrix = worksheet.getCellMatrix();
      cellMatrix.insertRows(range.startRow, rowCount);
      return true;
    }
  };
  var InsertColMutationUndoFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      range: params.range
    };
  };
  var InsertColMutation = {
    id: "sheet.mutation.insert-col",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      var _a2;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet)
        return false;
      const manager = worksheet.getColumnManager();
      const { range, colInfo } = params;
      const columnPrimitive = manager.getColumnData();
      const columnWrapper = columnPrimitive;
      const colIndex = range.startColumn;
      const colCount = range.endColumn - range.startColumn + 1;
      const defaultColWidth = worksheet.getConfig().defaultColumnWidth;
      for (let j = colIndex; j < colIndex + colCount; j++) {
        const defaultColInfo = {
          w: defaultColWidth,
          hd: 0
        };
        if (colInfo) {
          insertMatrixArray(j, (_a2 = colInfo[j - range.startColumn]) != null ? _a2 : defaultColInfo, columnWrapper);
        } else {
          insertMatrixArray(j, defaultColInfo, columnWrapper);
        }
      }
      worksheet.setColumnCount(worksheet.getColumnCount() + range.endColumn - range.startColumn + 1);
      const cellMatrix = worksheet.getCellMatrix();
      cellMatrix.insertColumns(range.startColumn, colCount);
      return true;
    }
  };

  // ../packages/sheets/src/commands/mutations/remove-row-col.mutation.ts
  var RemoveRowsUndoMutationFactory = (params, worksheet) => {
    const manager = worksheet.getRowManager();
    const rowPrimitive = manager.getRowData();
    const rowWrapper = rowPrimitive;
    const rowInfo = {};
    const range = params.range;
    const slice = sliceMatrixArray(range.startRow, range.endRow, rowWrapper);
    const _rowInfo = concatMatrixArray(rowInfo, slice);
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      range: params.range,
      rowInfo: _rowInfo
    };
  };
  var RemoveRowMutation = {
    id: "sheet.mutation.remove-rows",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet)
        return false;
      const range = params.range;
      const manager = worksheet.getRowManager();
      const rowPrimitive = manager.getRowData();
      const rowCount = range.endRow - range.startRow + 1;
      spliceArray(range.startRow, rowCount, rowPrimitive);
      const cellMatrix = worksheet.getCellMatrix();
      cellMatrix.removeRows(range.startRow, rowCount);
      worksheet.setRowCount(worksheet.getRowCount() - rowCount);
      return true;
    }
  };
  var RemoveColMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (worksheet == null) {
      throw new Error("worksheet is null error!");
    }
    const manager = worksheet.getColumnManager();
    const columnPrimitive = manager.getColumnData();
    const columnWrapper = columnPrimitive;
    const colInfo = {};
    const range = params.range;
    const slice = sliceMatrixArray(range.startColumn, range.endColumn, columnWrapper);
    const _colInfo = concatMatrixArray(colInfo, slice);
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      range: params.range,
      colInfo: _colInfo
    };
  };
  var RemoveColMutation = {
    id: "sheet.mutation.remove-col",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet)
        return false;
      const range = params.range;
      const manager = worksheet.getColumnManager();
      const colPrimitive = manager.getColumnData();
      const colCount = range.endColumn - range.startColumn + 1;
      spliceArray(range.startColumn, colCount, colPrimitive);
      worksheet.setColumnCount(worksheet.getColumnCount() - colCount);
      const cellMatrix = worksheet.getCellMatrix();
      cellMatrix.removeColumns(range.startColumn, colCount);
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/insert-range-move-down.command.ts
  var InsertRangeMoveDownCommandId = "sheet.command.insert-range-move-down";
  var InsertRangeMoveDownCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.insert-range-move-down",
    handler: async (accessor, params) => {
      var _a2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const logService = accessor.get(ILogService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      if (selectionManagerService.isOverlapping()) {
        logService.error("Cannot use that command on overlapping selections.");
        return false;
      }
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      let range = params == null ? void 0 : params.range;
      if (!range) {
        range = (_a2 = selectionManagerService.getLast()) == null ? void 0 : _a2.range;
      }
      if (!range)
        return false;
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const redoMutations = [];
      const undoMutations = [];
      const cellMatrix = worksheet.getCellMatrix();
      const dataRange = cellMatrix.getDataRange();
      const moveSlice = cellMatrix.getSlice(dataRange.startRow, dataRange.endRow, range.startColumn, range.endColumn);
      const sliceMaxRow = moveSlice.getDataRange().endRow;
      const insertRowCount = Math.max(sliceMaxRow + (range.endRow - range.startRow + 1) - dataRange.endRow, 0);
      if (insertRowCount > 0) {
        const anchorRow = range.startRow - 1;
        const height = worksheet.getRowHeight(anchorRow);
        const insertRowParams = {
          unitId,
          subUnitId,
          range: {
            startRow: dataRange.endRow + 1,
            endRow: dataRange.endRow + insertRowCount,
            startColumn: dataRange.startColumn,
            endColumn: dataRange.endColumn
          },
          rowInfo: new Array(insertRowCount).fill(void 0).map(() => ({
            h: height,
            hd: 0 /* FALSE */
          }))
        };
        redoMutations.push({
          id: InsertRowMutation.id,
          params: insertRowParams
        });
        const undoRowInsertionParams = InsertRowMutationUndoFactory(
          accessor,
          insertRowParams
        );
        undoMutations.push({ id: RemoveRowMutation.id, params: undoRowInsertionParams });
      }
      const cellValue = {};
      Range.foreach(range, (row, col) => {
        const cell = worksheet.getCell(row, col);
        if (!cell) {
          return;
        }
        if (!cellValue[row]) {
          cellValue[row] = {};
        }
        cellValue[row][col] = { s: cell.s };
      });
      const insertRangeMutationParams = {
        range,
        subUnitId,
        unitId,
        shiftDimension: 1 /* ROWS */,
        cellValue
      };
      const { redo: insertRangeRedo, undo: insertRangeUndo } = getInsertRangeMutations(
        accessor,
        insertRangeMutationParams
      );
      redoMutations.push(...insertRangeRedo);
      undoMutations.push(...insertRangeUndo);
      const sheetInterceptor = sheetInterceptorService.onCommandExecute({
        id: InsertRangeMoveDownCommand.id,
        params: { range }
      });
      redoMutations.push(...sheetInterceptor.redos);
      redoMutations.push(followSelectionOperation(range, workbook, worksheet));
      undoMutations.push(...sheetInterceptor.undos);
      const result = sequenceExecute(redoMutations, commandService);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undoMutations.reverse(),
          redoMutations
        });
        return true;
      }
      return false;
    }
    // all subsequent mutations should succeed inorder to make the whole process succeed
    // Promise.all([]).then(() => true),
  };

  // ../packages/sheets/src/commands/commands/insert-range-move-right.command.ts
  var InsertRangeMoveRightCommandId = "sheet.command.insert-range-move-right";
  var InsertRangeMoveRightCommand = {
    type: 0 /* COMMAND */,
    id: InsertRangeMoveRightCommandId,
    handler: async (accessor, params) => {
      var _a2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const logService = accessor.get(ILogService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      if (selectionManagerService.isOverlapping()) {
        logService.error("Cannot use that command on overlapping selections.");
        return false;
      }
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      let range = params == null ? void 0 : params.range;
      if (!range) {
        range = (_a2 = selectionManagerService.getLast()) == null ? void 0 : _a2.range;
      }
      if (!range)
        return false;
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const redoMutations = [];
      const undoMutations = [];
      const cellMatrix = worksheet.getCellMatrix();
      const dataRange = cellMatrix.getDataRange();
      const moveSlice = cellMatrix.getSlice(range.startRow, range.endRow, dataRange.startColumn, dataRange.endColumn);
      const sliceMaxCol = moveSlice.getDataRange().endColumn;
      const insertColCount = Math.max(
        sliceMaxCol + (range.endColumn - range.startColumn + 1) - dataRange.endColumn,
        0
      );
      if (insertColCount > 0) {
        const anchorCol = range.startColumn - 1;
        const width = worksheet.getColumnWidth(anchorCol);
        const insertColParams = {
          unitId,
          subUnitId,
          range: {
            startRow: dataRange.startRow + 1,
            endRow: dataRange.endRow,
            startColumn: dataRange.endColumn + 1,
            endColumn: dataRange.endColumn + insertColCount
          },
          colInfo: new Array(insertColCount).fill(void 0).map(() => ({
            w: width,
            hd: 0 /* FALSE */
          }))
        };
        redoMutations.push({
          id: InsertColMutation.id,
          params: insertColParams
        });
        const undoColInsertionParams = InsertColMutationUndoFactory(
          accessor,
          insertColParams
        );
        undoMutations.push({ id: RemoveColMutation.id, params: undoColInsertionParams });
      }
      const cellValue = {};
      Range.foreach(range, (row, col) => {
        const cell = worksheet.getCell(row, col);
        if (!cell || !cell.s) {
          return;
        }
        if (!cellValue[row]) {
          cellValue[row] = {};
        }
        cellValue[row][col] = { s: cell.s };
      });
      const insertRangeMutationParams = {
        range,
        subUnitId,
        unitId,
        shiftDimension: 0 /* COLUMNS */,
        cellValue
      };
      const { redo: insertRangeRedo, undo: insertRangeUndo } = getInsertRangeMutations(
        accessor,
        insertRangeMutationParams
      );
      redoMutations.push(...insertRangeRedo);
      undoMutations.push(...insertRangeUndo);
      const sheetInterceptor = sheetInterceptorService.onCommandExecute({
        id: InsertRangeMoveRightCommand.id,
        params: { range }
      });
      redoMutations.push(...sheetInterceptor.redos);
      redoMutations.push(followSelectionOperation(range, workbook, worksheet));
      undoMutations.push(...sheetInterceptor.undos);
      const result = sequenceExecute(redoMutations, commandService);
      if (result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undoMutations.reverse(),
          redoMutations
        });
        return true;
      }
      return false;
    }
    // all subsequent mutations should succeed inorder to make the whole process succeed
    // Promise.all([]).then(() => true),
  };

  // ../packages/sheets/src/commands/commands/insert-row-col.command.ts
  var InsertRowCommandId = "sheet.command.insert-row";
  var InsertRowCommand = {
    type: 0 /* COMMAND */,
    id: InsertRowCommandId,
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const workbook = univerInstanceService.getUniverSheetInstance(params.unitId);
      const worksheet = workbook.getSheetBySheetId(params.subUnitId);
      const { range, direction, unitId, subUnitId } = params;
      const { startRow, endRow } = range;
      const anchorRow = direction === 0 /* UP */ ? startRow : startRow - 1;
      const height = worksheet.getRowHeight(anchorRow);
      const insertRowParams = {
        unitId,
        subUnitId,
        range,
        rowInfo: new Array(endRow - startRow + 1).fill(void 0).map(() => ({
          h: height,
          hd: 0 /* FALSE */
        }))
        // row height should inherit from the anchor row
      };
      const undoRowInsertionParams = InsertRowMutationUndoFactory(
        accessor,
        insertRowParams
      );
      const intercepted = sheetInterceptorService.onCommandExecute({
        id: InsertRowCommand.id,
        params
      });
      const result = sequenceExecute(
        [
          { id: InsertRowMutation.id, params: insertRowParams },
          ...intercepted.redos,
          followSelectionOperation(range, workbook, worksheet)
        ],
        commandService
      );
      if (result.result) {
        undoRedoService.pushUndoRedo({
          unitID: params.unitId,
          undoMutations: [{ id: RemoveRowMutation.id, params: undoRowInsertionParams }, ...intercepted.undos],
          redoMutations: [{ id: InsertRowMutation.id, params: insertRowParams }, ...intercepted.redos]
        });
        return true;
      }
      return false;
    }
  };
  var InsertRowBeforeCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.insert-row-before",
    handler: async (accessor) => {
      var _a2;
      const selectionManagerService = accessor.get(SelectionManagerService);
      const selections = (_a2 = selectionManagerService.getSelections()) == null ? void 0 : _a2.map((s) => s.range);
      let range;
      if ((selections == null ? void 0 : selections.length) === 1) {
        range = selections[0];
      } else {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook) {
        return false;
      }
      const worksheet = workbook.getActiveSheet();
      if (!worksheet) {
        return false;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const rowCount = range.endRow - range.startRow + 1;
      const cellValue = {};
      Range.foreach(range, (row, col) => {
        const cell = worksheet.getCell(row, col);
        if (!cell || !cell.s) {
          return;
        }
        if (!cellValue[row]) {
          cellValue[row] = {};
        }
        cellValue[row][col] = { s: cell.s };
      });
      const insertRowParams = {
        unitId,
        subUnitId,
        direction: 0 /* UP */,
        range: {
          startRow: range.startRow,
          endRow: range.startRow + rowCount - 1,
          startColumn: 0,
          endColumn: worksheet.getColumnCount() - 1
        },
        cellValue
      };
      return accessor.get(ICommandService).executeCommand(InsertRowCommand.id, insertRowParams);
    }
  };
  var InsertRowAfterCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.insert-row-after",
    handler: async (accessor) => {
      var _a2;
      const selectionManagerService = accessor.get(SelectionManagerService);
      const selections = (_a2 = selectionManagerService.getSelections()) == null ? void 0 : _a2.map((s) => s.range);
      let range;
      if ((selections == null ? void 0 : selections.length) === 1) {
        range = selections[0];
      } else {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook) {
        return false;
      }
      const worksheet = workbook.getActiveSheet();
      if (!worksheet) {
        return false;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const count = range.endRow - range.startRow + 1;
      const insertRowParams = {
        unitId,
        subUnitId,
        direction: 2 /* DOWN */,
        range: {
          startRow: range.endRow + 1,
          endRow: range.endRow + count,
          startColumn: 0,
          endColumn: worksheet.getColumnCount() - 1
        }
      };
      return accessor.get(ICommandService).executeCommand(InsertRowCommand.id, insertRowParams);
    }
  };
  var InsertColCommandId = "sheet.command.insert-col";
  var InsertColCommand = {
    type: 0 /* COMMAND */,
    id: InsertColCommandId,
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const { range, direction, subUnitId, unitId, cellValue } = params;
      const { startColumn, endColumn } = params.range;
      const workbook = univerInstanceService.getUniverSheetInstance(params.unitId);
      const worksheet = workbook.getSheetBySheetId(params.subUnitId);
      const anchorCol = direction === 3 /* LEFT */ ? startColumn : startColumn - 1;
      const width = worksheet.getColumnWidth(anchorCol);
      const insertColParams = {
        unitId,
        subUnitId,
        range,
        colInfo: new Array(endColumn - startColumn + 1).fill(void 0).map(() => ({
          w: width,
          hd: 0 /* FALSE */
        }))
      };
      const undoColInsertionParams = InsertColMutationUndoFactory(
        accessor,
        insertColParams
      );
      const insertRangeMutationParams = {
        unitId: params.unitId,
        subUnitId: params.subUnitId,
        range: params.range,
        shiftDimension: 0 /* COLUMNS */,
        cellValue
      };
      const intercepted = sheetInterceptorService.onCommandExecute({
        id: InsertColCommand.id,
        params
      });
      const result = sequenceExecute(
        [
          { id: InsertColMutation.id, params: insertColParams },
          ...intercepted.redos,
          followSelectionOperation(range, workbook, worksheet)
        ],
        commandService
      );
      if (result.result) {
        undoRedoService.pushUndoRedo({
          unitID: params.unitId,
          undoMutations: [
            {
              id: RemoveColMutation.id,
              params: undoColInsertionParams
            },
            ...intercepted.undos
          ].filter(Boolean),
          redoMutations: [
            { id: InsertColMutation.id, params: insertColParams },
            ...intercepted.redos
          ].filter(Boolean)
        });
        return true;
      }
      return false;
    }
  };
  var InsertColBeforeCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.insert-col-before",
    handler: async (accessor) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const selections = selectionManagerService.getSelections();
      let range;
      if ((selections == null ? void 0 : selections.length) === 1) {
        range = selections[0].range;
      } else {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook) {
        return false;
      }
      const worksheet = workbook.getActiveSheet();
      if (!worksheet) {
        return false;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const count = range.endColumn - range.startColumn + 1;
      const cellValue = {};
      Range.foreach(range, (row, col) => {
        const cell = worksheet.getCell(row, col);
        if (!cell || !cell.s) {
          return;
        }
        if (!cellValue[row]) {
          cellValue[row] = {};
        }
        cellValue[row][col] = { s: cell.s };
      });
      const insertColParams = {
        unitId,
        subUnitId,
        direction: 3 /* LEFT */,
        range: {
          startColumn: range.startColumn,
          endColumn: range.startColumn + count - 1,
          startRow: 0,
          endRow: worksheet.getLastRowWithContent()
        },
        cellValue
      };
      return accessor.get(ICommandService).executeCommand(InsertColCommand.id, insertColParams);
    }
  };
  var InsertColAfterCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.insert-col-after",
    handler: async (accessor) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const selections = selectionManagerService.getSelections();
      let range;
      if ((selections == null ? void 0 : selections.length) === 1) {
        range = selections[0].range;
      } else {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook) {
        return false;
      }
      const worksheet = workbook.getActiveSheet();
      if (!worksheet) {
        return false;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const count = range.endColumn - range.startColumn + 1;
      const insertColParams = {
        unitId,
        subUnitId,
        direction: 1 /* RIGHT */,
        range: {
          startColumn: range.endColumn + 1,
          endColumn: range.endColumn + count,
          startRow: 0,
          endRow: worksheet.getLastRowWithContent()
        }
      };
      return accessor.get(ICommandService).executeCommand(InsertColCommand.id, insertColParams);
    }
  };

  // ../packages/sheets/src/commands/commands/insert-sheet.command.ts
  var InsertSheetCommand = {
    id: "sheet.command.insert-sheet",
    type: 0 /* COMMAND */,
    handler: (accessor, params) => {
      var _a2, _b2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const localeService = accessor.get(LocaleService);
      const unitId = (_a2 = params == null ? void 0 : params.unitId) != null ? _a2 : univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      let index = workbook.getSheets().length;
      let sheetConfig = mergeWorksheetSnapshotWithDefault({});
      if (params) {
        index = (_b2 = params.index) != null ? _b2 : index;
        if (params.sheet) {
          sheetConfig = params.sheet;
        } else {
          sheetConfig.id = Tools.generateRandomId();
          sheetConfig.name = workbook.generateNewSheetName(`${localeService.t("sheets.sheet")}`);
        }
      } else {
        sheetConfig.id = Tools.generateRandomId();
        sheetConfig.name = workbook.generateNewSheetName(`${localeService.t("sheets.sheet")}`);
      }
      const insertSheetMutationParams = {
        index,
        sheet: sheetConfig,
        unitId
      };
      const removeSheetMutationParams = InsertSheetUndoMutationFactory(
        accessor,
        insertSheetMutationParams
      );
      const result = commandService.syncExecuteCommand(InsertSheetMutation.id, insertSheetMutationParams);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: RemoveSheetMutation.id, params: removeSheetMutationParams }],
          redoMutations: [{ id: InsertSheetMutation.id, params: insertSheetMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/move-rows-cols.mutation.ts
  function MoveRowsMutationUndoFactory(_accessor, params) {
    const { unitId, subUnitId, sourceRange, targetRange } = params;
    const movingBackward = sourceRange.startRow > targetRange.startRow;
    const count = sourceRange.endRow - sourceRange.startRow + 1;
    if (movingBackward) {
      return {
        unitId,
        subUnitId,
        sourceRange: Rectangle.clone(targetRange),
        targetRange: {
          ...sourceRange,
          endRow: sourceRange.endRow + count,
          startRow: sourceRange.startRow + count
        }
      };
    }
    return {
      unitId,
      subUnitId,
      targetRange: Rectangle.clone(sourceRange),
      sourceRange: {
        ...targetRange,
        endRow: targetRange.endRow - count,
        startRow: targetRange.startRow - count
      }
    };
  }
  var MoveRowsMutation = {
    id: "sheet.mutation.move-rows",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const { unitId, subUnitId, sourceRange, targetRange } = params;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const univerSheet = univerInstanceService.getUniverSheetInstance(unitId);
      if (!univerSheet) {
        throw new Error("[MoveRowMutation] univerSheet is null!");
      }
      const worksheet = univerSheet.getSheetBySheetId(subUnitId);
      if (!worksheet) {
        throw new Error("[MoveRowMutation] worksheet is null!");
      }
      const fromRow = sourceRange.startRow;
      const count = sourceRange.endRow - sourceRange.startRow + 1;
      const toRow = targetRange.startRow;
      const rowWrapper = worksheet.getRowManager().getRowData();
      moveMatrixArray(fromRow, count, toRow, rowWrapper);
      const cellMatrix = worksheet.getCellMatrix();
      cellMatrix.moveRows(fromRow, count, toRow);
      return true;
    }
  };
  function MoveColsMutationUndoFactory(_accessor, params) {
    const { unitId, subUnitId, sourceRange, targetRange } = params;
    const movingBackward = sourceRange.startColumn > targetRange.startColumn;
    const count = sourceRange.endColumn - sourceRange.startColumn + 1;
    if (movingBackward) {
      return {
        unitId,
        subUnitId,
        sourceRange: Rectangle.clone(targetRange),
        targetRange: {
          ...sourceRange,
          endColumn: sourceRange.endColumn + count,
          startColumn: sourceRange.startColumn + count
        }
      };
    }
    return {
      unitId,
      subUnitId,
      targetRange: Rectangle.clone(sourceRange),
      sourceRange: {
        ...targetRange,
        startColumn: targetRange.startColumn - count,
        endColumn: targetRange.endColumn - count
      }
    };
  }
  var MoveColsMutation = {
    id: "sheet.mutation.move-columns",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const { unitId, subUnitId, sourceRange, targetRange } = params;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const univerSheet = univerInstanceService.getUniverSheetInstance(unitId);
      if (!univerSheet) {
        throw new Error("[MoveColumnMutation] univerSheet is null!");
      }
      const worksheet = univerSheet.getSheetBySheetId(subUnitId);
      if (!worksheet) {
        throw new Error("[MoveColumnMutation] worksheet is null!");
      }
      const fromCol = sourceRange.startColumn;
      const count = sourceRange.endColumn - sourceRange.startColumn + 1;
      const toCol = targetRange.startColumn;
      const columnWrapper = worksheet.getColumnManager().getColumnData();
      moveMatrixArray(fromCol, count, toCol, columnWrapper);
      const cellMatrix = worksheet.getCellMatrix();
      cellMatrix.moveColumns(fromCol, count, toCol);
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/utils/merged-cell-util.ts
  function rowAcrossMergedCell(row, worksheet) {
    return worksheet.getMergeData().some((mergedCell) => mergedCell.startRow < row && row <= mergedCell.endRow);
  }
  function columnAcrossMergedCell(col, worksheet) {
    return worksheet.getMergeData().some((mergedCell) => mergedCell.startColumn < col && col <= mergedCell.endColumn);
  }

  // ../packages/sheets/src/commands/commands/move-rows-cols.command.ts
  var MoveRowsCommandId = "sheet.command.move-rows";
  var MoveRowsCommand = {
    id: MoveRowsCommandId,
    type: 0 /* COMMAND */,
    handler: async (accessor, params) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const selections = selectionManagerService.getSelections();
      const {
        fromRange: { startRow: fromRow },
        toRange: { startRow: toRow }
      } = params;
      const filteredSelections = selections == null ? void 0 : selections.filter(
        (selection) => selection.range.rangeType === 1 /* ROW */ && selection.range.startRow <= fromRow && fromRow <= selection.range.endRow
      );
      if ((filteredSelections == null ? void 0 : filteredSelections.length) !== 1) {
        return false;
      }
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook) {
        return false;
      }
      const worksheet = workbook.getActiveSheet();
      if (!worksheet) {
        return false;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const errorService = accessor.get(ErrorService);
      const rangeToMove = filteredSelections[0].range;
      const beforePrimary = filteredSelections[0].primary;
      const alignedRange = alignToMergedCellsBorders(rangeToMove, worksheet, false);
      if (!Rectangle.equals(rangeToMove, alignedRange)) {
        errorService.emit("Only part of a merged cell is selected.");
        return false;
      }
      if (rowAcrossMergedCell(toRow, worksheet)) {
        errorService.emit("Across a merged cell.");
        return false;
      }
      const destinationRange = {
        ...rangeToMove,
        startRow: toRow,
        endRow: toRow + rangeToMove.endRow - rangeToMove.startRow
      };
      const moveRowsParams = {
        unitId,
        subUnitId,
        sourceRange: rangeToMove,
        targetRange: destinationRange
      };
      const undoMoveRowsParams = MoveRowsMutationUndoFactory(accessor, moveRowsParams);
      const movedLength = toRow - fromRow;
      const moveBackward = movedLength < 0;
      const count = rangeToMove.endRow - rangeToMove.startRow + 1;
      const destSelection = moveBackward ? destinationRange : {
        ...destinationRange,
        startRow: destinationRange.startRow - count,
        endRow: destinationRange.endRow - count
      };
      const setSelectionsParam = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: [{ range: destSelection, primary: getPrimaryForRange(destSelection, worksheet), style: null }]
      };
      const undoSetSelectionsParam = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: [{ range: rangeToMove, primary: beforePrimary, style: null }]
      };
      const commandService = accessor.get(ICommandService);
      const interceptorCommands = sheetInterceptorService.onCommandExecute({ id: MoveRowsCommand.id, params });
      const redos = [
        { id: MoveRowsMutation.id, params: moveRowsParams },
        { id: SetSelectionsOperation.id, params: setSelectionsParam },
        ...interceptorCommands.redos
      ];
      const undos = [
        { id: MoveRowsMutation.id, params: undoMoveRowsParams },
        { id: SetSelectionsOperation.id, params: undoSetSelectionsParam },
        ...interceptorCommands.undos
      ];
      const result = sequenceExecute(redos, commandService);
      if (result.result) {
        const undoRedoService = accessor.get(IUndoRedoService);
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undos,
          redoMutations: redos
        });
        return true;
      }
      return false;
    }
  };
  var MoveColsCommandId = "sheet.command.move-cols";
  var MoveColsCommand = {
    id: MoveColsCommandId,
    type: 0 /* COMMAND */,
    handler: async (accessor, params) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const selections = selectionManagerService.getSelections();
      const {
        fromRange: { startColumn: fromCol },
        toRange: { startColumn: toCol }
      } = params;
      const filteredSelections = selections == null ? void 0 : selections.filter(
        (selection) => selection.range.rangeType === 2 /* COLUMN */ && selection.range.startColumn <= fromCol && fromCol <= selection.range.endColumn
      );
      if ((filteredSelections == null ? void 0 : filteredSelections.length) !== 1) {
        return false;
      }
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook) {
        return false;
      }
      const worksheet = workbook.getActiveSheet();
      if (!worksheet) {
        return false;
      }
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const errorService = accessor.get(ErrorService);
      const rangeToMove = filteredSelections[0].range;
      const beforePrimary = filteredSelections[0].primary;
      const alignedRange = alignToMergedCellsBorders(rangeToMove, worksheet, false);
      if (!Rectangle.equals(rangeToMove, alignedRange)) {
        errorService.emit("Only part of a merged cell is selected.");
        return false;
      }
      if (columnAcrossMergedCell(toCol, worksheet)) {
        errorService.emit("Across a merged cell.");
        return false;
      }
      const destinationRange = {
        ...rangeToMove,
        startColumn: toCol,
        endColumn: toCol + rangeToMove.endColumn - rangeToMove.startColumn
      };
      const moveColsParams = {
        unitId,
        subUnitId,
        sourceRange: rangeToMove,
        targetRange: destinationRange
      };
      const undoMoveColsParams = MoveColsMutationUndoFactory(accessor, moveColsParams);
      const count = rangeToMove.endColumn - rangeToMove.startColumn + 1;
      const movedLength = toCol - fromCol;
      const moveBackward = movedLength < 0;
      const destSelection = moveBackward ? destinationRange : {
        ...destinationRange,
        startColumn: destinationRange.startColumn - count,
        endColumn: destinationRange.endColumn - count
      };
      const setSelectionsParam = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: [{ range: destSelection, primary: getPrimaryForRange(destSelection, worksheet), style: null }]
      };
      const undoSetSelectionsParam = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: [{ range: rangeToMove, primary: beforePrimary, style: null }]
      };
      const commandService = accessor.get(ICommandService);
      const interceptorCommands = sheetInterceptorService.onCommandExecute({ id: MoveColsCommand.id, params });
      const redos = [
        { id: MoveColsMutation.id, params: moveColsParams },
        { id: SetSelectionsOperation.id, params: setSelectionsParam },
        ...interceptorCommands.redos
      ];
      const undos = [
        { id: MoveColsMutation.id, params: undoMoveColsParams },
        { id: SetSelectionsOperation.id, params: undoSetSelectionsParam },
        ...interceptorCommands.undos
      ];
      const result = sequenceExecute(redos, commandService);
      if (result.result) {
        const undoRedoService = accessor.get(IUndoRedoService);
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undos,
          redoMutations: redos
        });
        return true;
      }
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/remove-row-col.command.ts
  var RemoveRowCommandId = "sheet.command.remove-row";
  var RemoveRowCommand = {
    type: 0 /* COMMAND */,
    id: RemoveRowCommandId,
    handler: async (accessor, params) => {
      var _a2, _b2, _c, _d;
      const selectionManagerService = accessor.get(SelectionManagerService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      let range = params == null ? void 0 : params.range;
      if (!range) {
        range = (_a2 = selectionManagerService.getLast()) == null ? void 0 : _a2.range;
      }
      if (!range) {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const worksheet = workbook.getActiveSheet();
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      range = {
        ...range,
        startColumn: 0,
        endColumn: Math.max(worksheet.getMaxColumns() - 1, 0)
      };
      const removeRowsParams = {
        unitId,
        subUnitId,
        range
      };
      const undoRemoveRowsParams = RemoveRowsUndoMutationFactory(
        removeRowsParams,
        worksheet
      );
      const intercepted = sheetInterceptorService.onCommandExecute({
        id: RemoveRowCommand.id,
        params: { range }
      });
      const commandService = accessor.get(ICommandService);
      const result = sequenceExecute(
        [
          ...(_b2 = intercepted.preRedos) != null ? _b2 : [],
          { id: RemoveRowMutation.id, params: removeRowsParams },
          ...intercepted.redos,
          followSelectionOperation(range, workbook, worksheet)
        ],
        commandService
      );
      if (result.result) {
        accessor.get(IUndoRedoService).pushUndoRedo({
          unitID: unitId,
          undoMutations: [...(_c = intercepted.preUndos) != null ? _c : [], { id: InsertRowMutation.id, params: undoRemoveRowsParams }, ...intercepted.undos],
          redoMutations: [...(_d = intercepted.preRedos) != null ? _d : [], { id: RemoveRowMutation.id, params: removeRowsParams }, ...intercepted.redos]
        });
        return true;
      }
      return false;
    }
  };
  var RemoveColCommandId = "sheet.command.remove-col";
  var RemoveColCommand = {
    type: 0 /* COMMAND */,
    id: RemoveColCommandId,
    handler: async (accessor, params) => {
      var _a2, _b2, _c, _d;
      const selectionManagerService = accessor.get(SelectionManagerService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      let range = params == null ? void 0 : params.range;
      if (!range) {
        range = (_a2 = selectionManagerService.getLast()) == null ? void 0 : _a2.range;
      }
      if (!range) {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const worksheet = workbook.getActiveSheet();
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      range = {
        ...range,
        startRow: 0,
        endRow: Math.max(worksheet.getMaxRows() - 1, 0)
      };
      const removeColParams = {
        unitId,
        subUnitId,
        range
      };
      const undoRemoveColParams = RemoveColMutationFactory(accessor, removeColParams);
      const intercepted = sheetInterceptorService.onCommandExecute({
        id: RemoveColCommand.id,
        params: { range }
      });
      const commandService = accessor.get(ICommandService);
      const result = sequenceExecute(
        [
          ...(_b2 = intercepted.preRedos) != null ? _b2 : [],
          { id: RemoveColMutation.id, params: removeColParams },
          ...intercepted.redos,
          followSelectionOperation(range, workbook, worksheet)
        ],
        commandService
      );
      if (result.result) {
        const undoRedoService = accessor.get(IUndoRedoService);
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [
            ...(_c = intercepted.preUndos) != null ? _c : [],
            { id: InsertColMutation.id, params: undoRemoveColParams },
            ...intercepted.undos
          ],
          redoMutations: [
            ...(_d = intercepted.preRedos) != null ? _d : [],
            { id: RemoveColMutation.id, params: removeColParams },
            ...intercepted.redos
          ]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/commands/remove-sheet.command.ts
  var RemoveSheetCommand = {
    id: "sheet.command.remove-sheet",
    type: 0 /* COMMAND */,
    handler: async (accessor, params) => {
      var _a2, _b2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      let unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      let subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      if (params) {
        unitId = (_a2 = params.unitId) != null ? _a2 : unitId;
        subUnitId = (_b2 = params.subUnitId) != null ? _b2 : subUnitId;
      }
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      if (workbook.getSheets().length <= 1)
        return false;
      const index = workbook.getSheetIndex(worksheet);
      const activateSheetId = workbook.getConfig().sheetOrder[index + 1];
      const activeSheetMutationParams = {
        unitId,
        subUnitId: activateSheetId
      };
      const RemoveSheetMutationParams = {
        subUnitId,
        unitId,
        subUnitName: worksheet.getName()
      };
      const InsertSheetMutationParams = RemoveSheetUndoMutationFactory(
        accessor,
        RemoveSheetMutationParams
      );
      const intercepted = sheetInterceptorService.onCommandExecute({
        id: RemoveSheetCommand.id,
        params: { unitId, subUnitId }
      });
      const redos = [{ id: RemoveSheetMutation.id, params: RemoveSheetMutationParams }, ...intercepted.redos];
      const undos = [...intercepted.undos, { id: InsertSheetMutation.id, params: InsertSheetMutationParams }];
      const result = sequenceExecute(redos, commandService);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undos,
          redoMutations: redos
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/add-worksheet-merge.mutation.ts
  var AddMergeUndoMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      ranges: params.ranges
    };
  };
  var AddWorksheetMergeMutation = {
    id: "sheet.mutation.add-worksheet-merge",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet)
        return false;
      const config2 = worksheet.getConfig();
      const mergeConfigData = config2.mergeData;
      const mergeAppendData = params.ranges;
      for (let i = 0; i < mergeAppendData.length; i++) {
        mergeConfigData.push(mergeAppendData[i]);
      }
      return true;
    }
  };

  // ../packages/sheets/src/commands/mutations/remove-worksheet-merge.mutation.ts
  var RemoveMergeUndoMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (worksheet == null) {
      throw new Error("worksheet is null error!");
    }
    const config2 = worksheet.getConfig();
    const mergeConfigData = config2.mergeData;
    const mergeRemoveData = params.ranges;
    const ranges = [];
    for (let j = 0; j < mergeRemoveData.length; j++) {
      for (let i = mergeConfigData.length - 1; i >= 0; i--) {
        const configMerge = mergeConfigData[i];
        const removeMerge = mergeRemoveData[j];
        if (Rectangle.intersects(configMerge, removeMerge)) {
          ranges.push(mergeConfigData[i]);
        }
      }
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      ranges
    };
  };
  var RemoveWorksheetMergeMutation = {
    id: "sheet.mutation.remove-worksheet-merge",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet)
        return false;
      const config2 = worksheet.getConfig();
      const mergeConfigData = config2.mergeData;
      const mergeRemoveData = params.ranges;
      for (let j = 0; j < mergeRemoveData.length; j++) {
        for (let i = mergeConfigData.length - 1; i >= 0; i--) {
          const configMerge = mergeConfigData[i];
          const removeMerge = mergeRemoveData[j];
          if (Rectangle.intersects(configMerge, removeMerge)) {
            mergeConfigData.splice(i, 1);
          }
        }
      }
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/remove-worksheet-merge.command.ts
  var RemoveWorksheetMergeCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.remove-worksheet-merge",
    handler: async (accessor) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const selections = selectionManagerService.getSelectionRanges();
      if (!(selections == null ? void 0 : selections.length))
        return false;
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const removeMergeMutationParams = {
        unitId,
        subUnitId,
        ranges: selections
      };
      let hasMerge = false;
      const mergeData = worksheet.getConfig().mergeData;
      selections.forEach((selection) => {
        mergeData.forEach((merge) => {
          if (Rectangle.intersects(selection, merge)) {
            hasMerge = true;
          }
        });
      });
      if (!hasMerge)
        return false;
      const undoredoMutationParams = RemoveMergeUndoMutationFactory(
        accessor,
        removeMergeMutationParams
      );
      const result = commandService.syncExecuteCommand(RemoveWorksheetMergeMutation.id, undoredoMutationParams);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: AddWorksheetMergeMutation.id, params: undoredoMutationParams }],
          // params should be the merged cells to be deleted accurately, rather than the selection
          redoMutations: [{ id: RemoveWorksheetMergeMutation.id, params: undoredoMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/services/border-style-manager.service.ts
  var BorderStyleManagerService = class {
    constructor() {
      __publicField(this, "_borderInfo", {
        type: "all" /* ALL */,
        color: "#000000",
        style: 1 /* THIN */,
        activeBorderType: false
      });
      __publicField(this, "_borderInfo$", new BehaviorSubject(this._borderInfo));
      __publicField(this, "borderInfo$", this._borderInfo$.asObservable());
    }
    dispose() {
      this._borderInfo$.complete();
    }
    setType(type) {
      this._borderInfo.type = type;
      this.setActiveBorderType(true);
      this.refresh();
    }
    setColor(color) {
      this._borderInfo.color = color;
      this.refresh();
    }
    setStyle(style) {
      this._borderInfo.style = style;
      this.refresh();
    }
    setActiveBorderType(status) {
      this._borderInfo.activeBorderType = status;
    }
    getBorderInfo() {
      return this._borderInfo;
    }
    refresh() {
      this._borderInfo$.next(this._borderInfo);
    }
  };

  // ../packages/sheets/src/commands/utils/get-target.ts
  function getCommandTarget(univerInstanceService, unitId, subUnitId) {
    const workbook = unitId ? univerInstanceService.getUniverSheetInstance(unitId) : univerInstanceService.getCurrentUniverSheetInstance();
    if (!workbook) {
      throw new Error();
    }
    const worksheet = subUnitId ? workbook.getSheetBySheetId(subUnitId) : workbook.getActiveSheet();
    if (!worksheet) {
      throw new Error();
    }
    return {
      workbook,
      worksheet,
      unitId: unitId != null ? unitId : workbook.getUnitId(),
      subUnitId: subUnitId != null ? subUnitId : worksheet.getSheetId()
    };
  }

  // ../packages/sheets/src/commands/commands/set-border-command.ts
  function forEach(range, action) {
    const { startRow, startColumn, endRow, endColumn } = range;
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        action(i, j);
      }
    }
  }
  var SetBorderBasicCommand = {
    id: "sheet.command.set-border-basic",
    type: 0 /* COMMAND */,
    handler: async (accessor, params) => {
      const { unitId, subUnitId, value } = params;
      const { type, color, style } = value;
      const commandService = accessor.get(ICommandService);
      const borderManager = accessor.get(BorderStyleManagerService);
      borderManager.setType(type);
      borderManager.setColor(color);
      borderManager.setStyle(style);
      return commandService.executeCommand(SetBorderCommand.id, {
        unitId,
        subUnitId
      });
    }
  };
  var SetBorderPositionCommand = {
    id: "sheet.command.set-border-position",
    type: 0 /* COMMAND */,
    handler: async (accessor, params) => {
      if (!params.value)
        return false;
      const commandService = accessor.get(ICommandService);
      const borderManager = accessor.get(BorderStyleManagerService);
      borderManager.setType(params.value);
      return commandService.executeCommand(SetBorderCommand.id);
    }
  };
  var SetBorderStyleCommand = {
    id: "sheet.command.set-border-style",
    type: 0 /* COMMAND */,
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const borderManager = accessor.get(BorderStyleManagerService);
      borderManager.setStyle(params.value);
      return commandService.executeCommand(SetBorderCommand.id);
    }
  };
  var SetBorderColorCommand = {
    id: "sheet.command.set-border-color",
    type: 0 /* COMMAND */,
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const borderManager = accessor.get(BorderStyleManagerService);
      borderManager.setColor(params.value);
      return commandService.executeCommand(SetBorderCommand.id);
    }
  };
  var SetBorderCommand = {
    id: "sheet.command.set-border",
    type: 0 /* COMMAND */,
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const borderStyleManagerService = accessor.get(BorderStyleManagerService);
      const { worksheet, unitId, subUnitId } = getCommandTarget(
        univerInstanceService,
        params == null ? void 0 : params.unitId,
        params == null ? void 0 : params.subUnitId
      );
      const selections = selectionManagerService.getSelectionRanges();
      const mergeData = worksheet.getConfig().mergeData;
      if (!(selections == null ? void 0 : selections.length)) {
        return false;
      }
      const { style, color, type, activeBorderType } = borderStyleManagerService.getBorderInfo();
      if (!activeBorderType)
        return false;
      const top = type === "top" /* TOP */ || type === "all" /* ALL */ || type === "outside" /* OUTSIDE */;
      const left = type === "left" /* LEFT */ || type === "all" /* ALL */ || type === "outside" /* OUTSIDE */;
      const bottom = type === "bottom" /* BOTTOM */ || type === "all" /* ALL */ || type === "outside" /* OUTSIDE */;
      const right = type === "right" /* RIGHT */ || type === "all" /* ALL */ || type === "outside" /* OUTSIDE */;
      const vertical = type === "vertical" /* VERTICAL */ || type === "all" /* ALL */ || type === "inside" /* INSIDE */;
      const horizontal = type === "horizontal" /* HORIZONTAL */ || type === "all" /* ALL */ || type === "inside" /* INSIDE */;
      const tl_br = type.indexOf("tlbr") > -1;
      const tl_bc = type.indexOf("tlbc") > -1;
      const tl_mr = type.indexOf("tlmr") > -1;
      const bl_tr = type.indexOf("bltr") > -1;
      const ml_tr = type.indexOf("mltr") > -1;
      const bc_tr = type.indexOf("bctr") > -1;
      const range = selections[0];
      const topRangeOut = {
        startRow: range.startRow - 1,
        startColumn: range.startColumn,
        endRow: range.startRow - 1,
        endColumn: range.endColumn
      };
      const leftRangeOut = {
        startRow: range.startRow,
        startColumn: range.startColumn - 1,
        endRow: range.endRow,
        endColumn: range.startColumn - 1
      };
      const bottomRangeOut = {
        startRow: range.endRow + 1,
        startColumn: range.startColumn,
        endRow: range.endRow + 1,
        endColumn: range.endColumn
      };
      const rightRangeOut = {
        startRow: range.startRow,
        startColumn: range.endColumn + 1,
        endRow: range.endRow,
        endColumn: range.endColumn + 1
      };
      const topRange = {
        startRow: range.startRow,
        startColumn: range.startColumn,
        endRow: range.startRow,
        endColumn: range.endColumn
      };
      const leftRange = {
        startRow: range.startRow,
        startColumn: range.startColumn,
        endRow: range.endRow,
        endColumn: range.startColumn
      };
      const bottomRange = {
        startRow: range.endRow,
        startColumn: range.startColumn,
        endRow: range.endRow,
        endColumn: range.endColumn
      };
      const rightRange = {
        startRow: range.startRow,
        startColumn: range.endColumn,
        endRow: range.endRow,
        endColumn: range.endColumn
      };
      const mr = new ObjectMatrix();
      const border = {
        s: style,
        cl: {
          rgb: color
        }
      };
      const hasMerge = (row, column) => {
        let res = null;
        mergeData.forEach((merge) => {
          if (Rectangle.intersects(merge, {
            startColumn: column,
            endColumn: column,
            startRow: row,
            endRow: row
          })) {
            res = merge;
          }
        });
        return res;
      };
      function setBorderStyle(range2, defaultStyle, reserve) {
        if (range2.startRow < 0 || range2.startColumn < 0)
          return;
        forEach(range2, (row, column) => {
          var _a2, _b2;
          const rectangle = hasMerge(row, column);
          let bdStyle = defaultStyle;
          if (rectangle && (defaultStyle.bc_tr || defaultStyle.ml_tr || defaultStyle.bl_tr || defaultStyle.tl_mr || defaultStyle.tl_bc || defaultStyle.tl_br)) {
            if (reserve) {
              const style2 = Tools.deepClone(
                (_a2 = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _a2.s
              );
              bdStyle = (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, defaultStyle) : defaultStyle;
            }
            mr.setValue(rectangle.startRow, rectangle.startColumn, {
              s: {
                bd: bdStyle
              }
            });
          } else {
            if (reserve) {
              const style2 = Tools.deepClone((_b2 = mr.getValue(row, column)) == null ? void 0 : _b2.s);
              bdStyle = (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, defaultStyle) : defaultStyle;
            }
            mr.setValue(row, column, { s: { bd: bdStyle } });
          }
        });
      }
      if (top) {
        setBorderStyle(topRangeOut, { b: null });
        setBorderStyle(topRange, { t: Tools.deepClone(border) }, true);
      }
      if (bottom) {
        setBorderStyle(bottomRangeOut, { t: null });
        setBorderStyle(bottomRange, { b: Tools.deepClone(border) }, true);
      }
      if (left) {
        setBorderStyle(leftRangeOut, { r: null });
        setBorderStyle(leftRange, { l: Tools.deepClone(border) }, true);
      }
      if (right) {
        setBorderStyle(rightRangeOut, { l: null });
        setBorderStyle(rightRange, { r: Tools.deepClone(border) }, true);
      }
      if (tl_br) {
        setBorderStyle(range, { tl_br: Tools.deepClone(border) }, true);
      }
      if (tl_bc) {
        setBorderStyle(range, { tl_bc: Tools.deepClone(border) }, true);
      }
      if (tl_mr) {
        setBorderStyle(range, { tl_mr: Tools.deepClone(border) }, true);
      }
      if (bl_tr) {
        setBorderStyle(range, { bl_tr: Tools.deepClone(border) }, true);
      }
      if (ml_tr) {
        setBorderStyle(range, { ml_tr: Tools.deepClone(border) }, true);
      }
      if (bc_tr) {
        setBorderStyle(range, { bc_tr: Tools.deepClone(border) }, true);
      }
      if (vertical) {
        forEach(range, (row, column) => {
          var _a2, _b2, _c, _d;
          const rectangle = hasMerge(row, column);
          if (rectangle) {
            if (rectangle.endColumn !== range.endColumn) {
              const style2 = (_a2 = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _a2.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { r: Tools.deepClone(border) }) : { r: Tools.deepClone(border) }
                }
              });
            }
            if (rectangle.startColumn !== range.startColumn) {
              const style2 = (_b2 = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _b2.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { l: Tools.deepClone(border) }) : { l: Tools.deepClone(border) }
                }
              });
            }
          } else {
            if (column !== range.endColumn) {
              const style2 = (_c = mr.getValue(row, column)) == null ? void 0 : _c.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { r: Tools.deepClone(border) }) : { r: Tools.deepClone(border) }
                }
              });
            }
            if (column !== range.startColumn) {
              const style2 = (_d = mr.getValue(row, column)) == null ? void 0 : _d.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { l: Tools.deepClone(border) }) : { l: Tools.deepClone(border) }
                }
              });
            }
          }
        });
      }
      if (horizontal) {
        forEach(range, (row, column) => {
          var _a2, _b2, _c, _d;
          const rectangle = hasMerge(row, column);
          if (rectangle) {
            if (rectangle.endRow !== range.endRow) {
              const style2 = (_a2 = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _a2.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { b: Tools.deepClone(border) }) : { b: Tools.deepClone(border) }
                }
              });
            }
            if (rectangle.startRow !== range.startRow) {
              const style2 = (_b2 = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _b2.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { t: Tools.deepClone(border) }) : { t: Tools.deepClone(border) }
                }
              });
            }
          } else {
            if (row !== range.endRow) {
              const style2 = (_c = mr.getValue(row, column)) == null ? void 0 : _c.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { b: Tools.deepClone(border) }) : { b: Tools.deepClone(border) }
                }
              });
            }
            if (row !== range.startRow) {
              const style2 = (_d = mr.getValue(row, column)) == null ? void 0 : _d.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { t: Tools.deepClone(border) }) : { t: Tools.deepClone(border) }
                }
              });
            }
          }
        });
      }
      if (!top && !bottom && !left && !right && !vertical && !horizontal && !tl_br && !tl_bc && !tl_mr && !bl_tr && !ml_tr && !bc_tr) {
        setBorderStyle(topRangeOut, { b: null });
        setBorderStyle(topRange, { t: null }, true);
        setBorderStyle(bottomRangeOut, { t: null });
        setBorderStyle(bottomRange, { b: null }, true);
        setBorderStyle(leftRangeOut, { r: null });
        setBorderStyle(leftRange, { l: null }, true);
        setBorderStyle(rightRangeOut, { l: null });
        setBorderStyle(rightRange, { r: null }, true);
        setBorderStyle(range, { tl_br: null }, true);
        setBorderStyle(range, { tl_bc: null }, true);
        setBorderStyle(range, { tl_mr: null }, true);
        setBorderStyle(range, { bl_tr: null }, true);
        setBorderStyle(range, { ml_tr: null }, true);
        setBorderStyle(range, { bc_tr: null }, true);
        forEach(range, (row, column) => {
          var _a2, _b2, _c, _d, _e, _f, _g, _h;
          const rectangle = hasMerge(row, column);
          if (rectangle) {
            if (rectangle.endColumn !== range.endColumn) {
              const style2 = (_a2 = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _a2.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { r: null }) : { r: null }
                }
              });
            }
            if (rectangle.startColumn !== range.startColumn) {
              const style2 = (_b2 = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _b2.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { l: null }) : { l: null }
                }
              });
            }
            if (rectangle.endRow !== range.endRow) {
              const style2 = (_c = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _c.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { b: null }) : { b: null }
                }
              });
            }
            if (rectangle.startRow !== range.startRow) {
              const style2 = (_d = mr.getValue(rectangle.startRow, rectangle.startColumn)) == null ? void 0 : _d.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { t: null }) : { t: null }
                }
              });
            }
          } else {
            if (column !== range.endColumn) {
              const style2 = (_e = mr.getValue(row, column)) == null ? void 0 : _e.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { r: null }) : { r: null }
                }
              });
            }
            if (column !== range.startColumn) {
              const style2 = (_f = mr.getValue(row, column)) == null ? void 0 : _f.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { l: null }) : { l: null }
                }
              });
            }
            if (row !== range.endRow) {
              const style2 = (_g = mr.getValue(row, column)) == null ? void 0 : _g.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { b: null }) : { b: null }
                }
              });
            }
            if (row !== range.startRow) {
              const style2 = (_h = mr.getValue(row, column)) == null ? void 0 : _h.s;
              mr.setValue(row, column, {
                s: {
                  bd: (style2 == null ? void 0 : style2.bd) ? Object.assign(style2.bd, { t: null }) : { t: null }
                }
              });
            }
          }
        });
      }
      const setRangeValuesMutationParams = {
        unitId,
        subUnitId,
        cellValue: mr.getData()
      };
      const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(
        accessor,
        setRangeValuesMutationParams
      );
      const result = commandService.syncExecuteCommand(SetRangeValuesMutation.id, setRangeValuesMutationParams);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams }],
          redoMutations: [{ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/set-col-visible.mutation.ts
  var SetColHiddenUndoMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      ranges: params.ranges
    };
  };
  var SetColHiddenMutation = {
    id: "sheet.mutation.set-col-hidden",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (!universheet) {
        return false;
      }
      const manager = universheet.getSheetBySheetId(params.subUnitId).getColumnManager();
      for (let i = 0; i < params.ranges.length; i++) {
        const range = params.ranges[i];
        for (let j = range.startColumn; j < range.endColumn + 1; j++) {
          const column = manager.getColumnOrCreate(j);
          if (column != null) {
            column.hd = 1 /* TRUE */;
          }
        }
      }
      return true;
    }
  };
  var SetColVisibleUndoMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      ranges: params.ranges
    };
  };
  var SetColVisibleMutation = {
    id: "sheet.mutation.set-col-visible",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (!universheet) {
        return false;
      }
      const manager = universheet.getSheetBySheetId(params.subUnitId).getColumnManager();
      for (let i = 0; i < params.ranges.length; i++) {
        const range = params.ranges[i];
        for (let j = range.startColumn; j < range.endColumn + 1; j++) {
          const column = manager.getColumnOrCreate(j);
          if (column != null) {
            column.hd = 0 /* FALSE */;
          }
        }
      }
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-col-visible.command.ts
  var SetSpecificColsVisibleCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-col-visible-on-cols",
    handler: async (accessor, params) => {
      const { unitId, subUnitId, ranges } = params;
      const worksheet = accessor.get(IUniverInstanceService).getUniverSheetInstance(unitId).getSheetBySheetId(subUnitId);
      const redoMutationParams = {
        unitId,
        subUnitId,
        ranges
      };
      const undoMutationParams = SetColVisibleUndoMutationFactory(accessor, redoMutationParams);
      const setSelectionOperationParams = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: ranges.map((r) => ({ range: r, primary: getPrimaryForRange(r, worksheet), style: null }))
      };
      const undoSetSelectionsOperationParams = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: getSelectionsAfterHiding(ranges).map((range) => ({
          range,
          primary: getPrimaryForRange(range, worksheet),
          style: null
        }))
      };
      const commandService = accessor.get(ICommandService);
      const result = sequenceExecute(
        [
          { id: SetColVisibleMutation.id, params: redoMutationParams },
          { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
        ],
        commandService
      );
      if (result.result) {
        const undoRedoService = accessor.get(IUndoRedoService);
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [
            { id: SetColHiddenMutation.id, params: undoMutationParams },
            { id: SetSelectionsOperation.id, params: undoSetSelectionsOperationParams }
          ],
          redoMutations: [
            { id: SetColVisibleMutation.id, params: redoMutationParams },
            { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
          ]
        });
        return true;
      }
      return true;
    }
  };
  var SetSelectedColsVisibleCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-selected-cols-visible",
    handler: async (accessor) => {
      var _a2;
      const selectionManagerService = accessor.get(SelectionManagerService);
      const ranges = (_a2 = selectionManagerService.getSelections()) == null ? void 0 : _a2.map((s) => s.range).filter((r) => r.rangeType === 2 /* COLUMN */);
      if (!(ranges == null ? void 0 : ranges.length)) {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook)
        return false;
      const worksheet = workbook.getActiveSheet();
      if (!worksheet)
        return false;
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const hiddenRanges = ranges.map((r) => worksheet.getHiddenCols(r.startColumn, r.endColumn)).flat();
      return accessor.get(ICommandService).executeCommand(SetSpecificColsVisibleCommand.id, {
        unitId,
        subUnitId,
        ranges: hiddenRanges
      });
    }
  };
  var SetColHiddenCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-col-hidden",
    handler: async (accessor) => {
      var _a2;
      const selectionManagerService = accessor.get(SelectionManagerService);
      const ranges = (_a2 = selectionManagerService.getSelections()) == null ? void 0 : _a2.map((s) => s.range).filter((r) => r.rangeType === 2 /* COLUMN */);
      if (!(ranges == null ? void 0 : ranges.length)) {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook)
        return false;
      const worksheet = workbook.getActiveSheet();
      if (!worksheet)
        return false;
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const redoMutationParams = {
        unitId,
        subUnitId,
        ranges
      };
      const setSelectionOperationParams = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: getSelectionsAfterHiding(ranges).map((range) => ({
          range,
          primary: getPrimaryForRange(range, worksheet),
          style: null
        }))
      };
      const undoSetSelectionsOperationParams = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: ranges.map((range) => ({
          range,
          primary: getPrimaryForRange(range, worksheet),
          style: null
        }))
      };
      const commandService = accessor.get(ICommandService);
      const result = sequenceExecute(
        [
          { id: SetColHiddenMutation.id, params: redoMutationParams },
          { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
        ],
        commandService
      );
      if (result.result) {
        const undoRedoService = accessor.get(IUndoRedoService);
        const undoMutationParams = SetColHiddenUndoMutationFactory(accessor, redoMutationParams);
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [
            { id: SetColVisibleMutation.id, params: undoMutationParams },
            { id: SetSelectionsOperation.id, params: undoSetSelectionsOperationParams }
          ],
          redoMutations: [
            { id: SetColHiddenMutation.id, params: redoMutationParams },
            { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
          ]
        });
        return true;
      }
      return false;
    }
  };
  function getSelectionsAfterHiding(ranges) {
    const merged = mergeSelections(ranges);
    return merged.map((range) => {
      const column = range.startColumn === 0 ? range.endColumn + 1 : range.startColumn - 1;
      return {
        ...range,
        startColumn: column,
        endColumn: column
      };
    });
  }
  function mergeSelections(ranges) {
    const merged = [];
    let current;
    ranges.sort((a, b) => a.startColumn - b.startColumn).forEach((range) => {
      if (!current) {
        current = range;
        return;
      }
      if (current.endColumn === range.startColumn - 1) {
        current.endColumn = range.endColumn;
      } else {
        merged.push(current);
        current = range;
      }
    });
    merged.push(current);
    return merged;
  }

  // ../packages/sheets/src/commands/mutations/set-frozen.mutation.ts
  var SetFrozenMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (worksheet == null) {
      throw new Error("worksheet is null error!");
    }
    const config2 = worksheet.getConfig();
    const freeze = config2.freeze;
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      ...freeze
    };
  };
  var SetFrozenMutation = {
    id: "sheet.mutation.set-frozen",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet)
        return false;
      const config2 = worksheet.getConfig();
      const { startRow, startColumn, ySplit, xSplit } = params;
      config2.freeze = { startRow, startColumn, ySplit, xSplit };
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-frozen.command.ts
  var SetFrozenCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-frozen",
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const { startColumn, startRow, xSplit, ySplit } = params;
      if (startRow >= worksheet.getRowCount() || startColumn >= worksheet.getColumnCount() || xSplit >= worksheet.getColumnCount() || ySplit >= worksheet.getRowCount()) {
        return false;
      }
      const redoMutationParams = {
        unitId,
        subUnitId,
        ...params
      };
      const undoMutationParams = SetFrozenMutationFactory(accessor, redoMutationParams);
      const result = commandService.syncExecuteCommand(SetFrozenMutation.id, redoMutationParams);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetFrozenMutation.id, params: undoMutationParams }],
          redoMutations: [{ id: SetFrozenMutation.id, params: redoMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/commands/set-frozen-cancel.command.ts
  var SetFrozenCancelCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-frozen-cancel",
    handler: async (accessor) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const redoMutationParams = {
        unitId,
        subUnitId,
        startRow: -1,
        startColumn: -1,
        ySplit: 0,
        xSplit: 0
      };
      const undoMutationParams = SetFrozenMutationFactory(accessor, redoMutationParams);
      const result = commandService.syncExecuteCommand(SetFrozenMutation.id, redoMutationParams);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetFrozenMutation.id, params: undoMutationParams }],
          redoMutations: [{ id: SetFrozenMutation.id, params: redoMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/set-row-visible.mutation.ts
  var SetRowVisibleUndoMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      ranges: params.ranges
    };
  };
  var SetRowVisibleMutation = {
    id: "sheet.mutation.set-row-visible",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const manager = universheet.getSheetBySheetId(params.subUnitId).getRowManager();
      for (let i = 0; i < params.ranges.length; i++) {
        const range = params.ranges[i];
        for (let j = range.startRow; j < range.endRow + 1; j++) {
          const row = manager.getRowOrCreate(j);
          if (row != null) {
            row.hd = 0;
          }
        }
      }
      return true;
    }
  };
  var SetRowHiddenUndoMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      ranges: params.ranges
    };
  };
  var SetRowHiddenMutation = {
    id: "sheet.mutation.set-row-hidden",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const manager = universheet.getSheetBySheetId(params.subUnitId).getRowManager();
      for (let i = 0; i < params.ranges.length; i++) {
        const range = params.ranges[i];
        for (let j = range.startRow; j < range.endRow + 1; j++) {
          const row = manager.getRowOrCreate(j);
          if (row != null) {
            row.hd = 1;
          }
        }
      }
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-row-visible.command.ts
  var SetSpecificRowsVisibleCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-specific-rows-visible",
    handler: async (accessor, params) => {
      const { unitId, subUnitId, ranges } = params;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const worksheet = accessor.get(IUniverInstanceService).getUniverSheetInstance(unitId).getSheetBySheetId(subUnitId);
      const redoMutationParams = {
        unitId,
        subUnitId,
        ranges
      };
      const undoMutationParams = SetRowVisibleUndoMutationFactory(accessor, redoMutationParams);
      const setSelectionOperationParams = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: ranges.map((range) => ({
          range,
          primary: getPrimaryForRange(range, worksheet),
          style: null
        }))
      };
      const undoSetSelectionsOperationParams = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: getSelectionsAfterHiding2(ranges).map((range) => ({
          range,
          primary: getPrimaryForRange(range, worksheet),
          style: null
        }))
      };
      const result = sequenceExecute(
        [
          { id: SetRowVisibleMutation.id, params: redoMutationParams },
          { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
        ],
        commandService
      );
      if (result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [
            { id: SetRowHiddenMutation.id, params: undoMutationParams },
            { id: SetSelectionsOperation.id, params: undoSetSelectionsOperationParams }
          ],
          redoMutations: [
            { id: SetRowVisibleMutation.id, params: redoMutationParams },
            { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
          ]
        });
        return true;
      }
      return true;
    }
  };
  var SetSelectedRowsVisibleCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-selected-rows-visible",
    handler: async (accessor) => {
      var _a2;
      const selectionManagerService = accessor.get(SelectionManagerService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const ranges = (_a2 = selectionManagerService.getSelections()) == null ? void 0 : _a2.map((s) => s.range).filter((r) => r.rangeType === 1 /* ROW */);
      if (!(ranges == null ? void 0 : ranges.length)) {
        return false;
      }
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      if (!workbook)
        return false;
      const worksheet = workbook.getActiveSheet();
      if (!worksheet)
        return false;
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const hiddenRanges = ranges.map((r) => worksheet.getHiddenRows(r.startRow, r.endRow)).flat();
      return accessor.get(ICommandService).executeCommand(SetSpecificRowsVisibleCommand.id, {
        unitId,
        subUnitId,
        ranges: hiddenRanges
      });
    }
  };
  var SetRowHiddenCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-rows-hidden",
    handler: async (accessor) => {
      var _a2;
      const selectionManagerService = accessor.get(SelectionManagerService);
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const ranges = (_a2 = selectionManagerService.getSelections()) == null ? void 0 : _a2.map((s) => s.range).filter((r) => r.rangeType === 1 /* ROW */);
      if (!(ranges == null ? void 0 : ranges.length)) {
        return false;
      }
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const redoMutationParams = {
        unitId,
        subUnitId,
        ranges
      };
      const setSelectionOperationParams = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: getSelectionsAfterHiding2(ranges).map((range) => ({
          range,
          primary: getPrimaryForRange(range, worksheet),
          style: null
        }))
      };
      const undoSetSelectionsOperationParams = {
        unitId,
        subUnitId,
        pluginName: NORMAL_SELECTION_PLUGIN_NAME,
        selections: ranges.map((range) => ({
          range,
          primary: getPrimaryForRange(range, worksheet),
          style: null
        }))
      };
      const undoMutationParams = SetRowHiddenUndoMutationFactory(accessor, redoMutationParams);
      const result = sequenceExecute(
        [
          { id: SetRowHiddenMutation.id, params: redoMutationParams },
          { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
        ],
        commandService
      );
      if (result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [
            { id: SetRowVisibleMutation.id, params: undoMutationParams },
            { id: SetSelectionsOperation.id, params: undoSetSelectionsOperationParams }
          ],
          redoMutations: [
            { id: SetRowHiddenMutation.id, params: redoMutationParams },
            { id: SetSelectionsOperation.id, params: setSelectionOperationParams }
          ]
        });
        return true;
      }
      return true;
    }
  };
  function getSelectionsAfterHiding2(ranges) {
    const merged = mergeSelections2(ranges);
    return merged.map((range) => {
      const row = range.startRow === 0 ? range.endRow + 1 : range.startRow - 1;
      return {
        ...range,
        startRow: row,
        endRow: row
      };
    });
  }
  function mergeSelections2(ranges) {
    const merged = [];
    let current;
    ranges.sort((a, b) => a.startRow - b.startRow).forEach((range) => {
      if (!current) {
        current = range;
        return;
      }
      if (range.startRow === current.endRow + 1) {
        current.endRow = range.endRow;
      } else {
        merged.push(current);
        current = range;
      }
    });
    merged.push(current);
    return merged;
  }

  // ../packages/sheets/src/commands/commands/set-style.command.ts
  var SetStyleCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-style",
    handler: async (accessor, params) => {
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const {
        unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId(),
        subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId(),
        range,
        style
      } = params;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const ranges = range ? [range] : selectionManagerService.getSelectionRanges();
      if (!(ranges == null ? void 0 : ranges.length)) {
        return false;
      }
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
      if (worksheet == null) {
        return false;
      }
      const cellValue = new ObjectMatrix();
      if (Tools.isArray(style.value)) {
        for (let i = 0; i < ranges.length; i++) {
          const { startRow, endRow, startColumn, endColumn } = ranges[i];
          for (let r = 0; r <= endRow - startRow; r++) {
            for (let c = 0; c <= endColumn - startColumn; c++) {
              cellValue.setValue(r + startRow, c + startColumn, {
                s: {
                  [style.type]: style.value[r][c]
                }
              });
            }
          }
        }
      } else {
        for (let i = 0; i < ranges.length; i++) {
          const { startRow, endRow, startColumn, endColumn } = ranges[i];
          const styleObj = {
            s: {
              [style.type]: style.value
            }
          };
          for (let r = startRow; r <= endRow; r++) {
            for (let c = startColumn; c <= endColumn; c++) {
              cellValue.setValue(r, c, styleObj);
            }
          }
        }
      }
      const setRangeValuesMutationParams = {
        subUnitId,
        unitId,
        cellValue: cellValue.getMatrix()
      };
      const undoSetRangeValuesMutationParams = SetRangeValuesUndoMutationFactory(
        accessor,
        setRangeValuesMutationParams
      );
      const setRangeValuesResult = commandService.syncExecuteCommand(
        SetRangeValuesMutation.id,
        setRangeValuesMutationParams
      );
      const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
        id: SetStyleCommand.id,
        params
      });
      const result = sequenceExecute([...redos], commandService);
      if (setRangeValuesResult && result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetRangeValuesMutation.id, params: undoSetRangeValuesMutationParams }, ...undos],
          redoMutations: [{ id: SetRangeValuesMutation.id, params: setRangeValuesMutationParams }, ...redos]
        });
        return true;
      }
      return false;
    }
  };
  var SetBoldCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-bold",
    handler: async (accessor) => {
      const selection = accessor.get(SelectionManagerService).getLast();
      if (!selection) {
        return false;
      }
      const worksheet = accessor.get(IUniverInstanceService).getCurrentUniverSheetInstance().getActiveSheet();
      const { actualRow, actualColumn } = selection.primary;
      const currentlyBold = worksheet.getRange(actualRow, actualColumn).getFontWeight() === 1 /* BOLD */;
      const setStyleParams = {
        style: {
          type: "bl",
          value: currentlyBold ? 0 /* FALSE */ : 1 /* TRUE */
        }
      };
      return accessor.get(ICommandService).executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetItalicCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-italic",
    handler: async (accessor) => {
      const selection = accessor.get(SelectionManagerService).getLast();
      if (!selection) {
        return false;
      }
      const worksheet = accessor.get(IUniverInstanceService).getCurrentUniverSheetInstance().getActiveSheet();
      let currentlyItalic = true;
      if (selection.primary) {
        const { startRow, startColumn } = selection.primary;
        currentlyItalic = worksheet.getRange(startRow, startColumn).getFontStyle() === 1 /* ITALIC */;
      }
      const setStyleParams = {
        style: {
          type: "it",
          value: currentlyItalic ? 0 /* FALSE */ : 1 /* TRUE */
        }
      };
      return accessor.get(ICommandService).executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetUnderlineCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-underline",
    handler: async (accessor) => {
      const selection = accessor.get(SelectionManagerService).getLast();
      if (!selection) {
        return false;
      }
      const worksheet = accessor.get(IUniverInstanceService).getCurrentUniverSheetInstance().getActiveSheet();
      let currentlyUnderline = true;
      if (selection.primary) {
        currentlyUnderline = !!worksheet.getRange(selection.primary.startRow, selection.primary.startColumn).getUnderline().s;
      }
      const setStyleParams = {
        style: {
          type: "ul",
          value: {
            s: currentlyUnderline ? 0 /* FALSE */ : 1 /* TRUE */
          }
        }
      };
      return accessor.get(ICommandService).executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetStrikeThroughCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-stroke",
    handler: async (accessor) => {
      const selection = accessor.get(SelectionManagerService).getLast();
      if (!selection) {
        return false;
      }
      const worksheet = accessor.get(IUniverInstanceService).getCurrentUniverSheetInstance().getActiveSheet();
      let currentlyStrokeThrough = true;
      if (selection.primary) {
        currentlyStrokeThrough = !!worksheet.getRange(selection.primary.actualRow, selection.primary.actualColumn).getStrikeThrough().s;
      }
      const setStyleParams = {
        style: {
          type: "st",
          value: { s: currentlyStrokeThrough ? 0 /* FALSE */ : 1 /* TRUE */ }
        }
      };
      return accessor.get(ICommandService).executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetOverlineCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-overline",
    handler: async (accessor) => {
      const selection = accessor.get(SelectionManagerService).getLast();
      if (!selection) {
        return false;
      }
      const worksheet = accessor.get(IUniverInstanceService).getCurrentUniverSheetInstance().getActiveSheet();
      let currentlyOverline = true;
      if (selection.primary) {
        currentlyOverline = !!worksheet.getRange(selection.primary.startRow, selection.primary.startColumn).getOverline().s;
      }
      const setStyleParams = {
        style: {
          type: "ol",
          value: {
            s: currentlyOverline ? 0 /* FALSE */ : 1 /* TRUE */
          }
        }
      };
      return accessor.get(ICommandService).executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetFontFamilyCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-font-family",
    handler: async (accessor, params) => {
      if (!params) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        style: {
          type: "ff",
          value: params.value
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetFontSizeCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-font-size",
    handler: async (accessor, params) => {
      if (!params) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        style: {
          type: "fs",
          value: params.value
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetTextColorCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-text-color",
    handler: async (accessor, params) => {
      if (!params || !params.value) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        style: {
          type: "cl",
          value: {
            rgb: params.value
          }
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var ResetTextColorCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.reset-text-color",
    handler: async (accessor) => {
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        style: {
          type: "cl",
          value: {
            rgb: null
            // use null to reset text color
          }
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetBackgroundColorCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-background-color",
    handler: async (accessor, params) => {
      if (!params || !params.value) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        style: {
          type: "bg",
          value: {
            rgb: params.value
          }
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var ResetBackgroundColorCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.reset-background-color",
    handler: async (accessor) => {
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        style: {
          type: "bg",
          value: {
            rgb: null
            // use null to reset background color
          }
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetVerticalTextAlignCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-vertical-text-align",
    handler: async (accessor, params) => {
      if (!params) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        unitId: params.unitId,
        subUnitId: params.subUnitId,
        range: params.range,
        style: {
          type: "vt",
          value: params.value
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetHorizontalTextAlignCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-horizontal-text-align",
    handler: async (accessor, params) => {
      if (!params) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        unitId: params.unitId,
        subUnitId: params.subUnitId,
        range: params.range,
        style: {
          type: "ht",
          value: params.value
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetTextWrapCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-text-wrap",
    handler: async (accessor, params) => {
      if (!params) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        unitId: params.unitId,
        subUnitId: params.subUnitId,
        range: params.range,
        style: {
          type: "tb",
          value: params.value
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };
  var SetTextRotationCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-text-rotation",
    handler: async (accessor, params) => {
      if (!params) {
        return false;
      }
      const value = typeof params.value === "number" ? { a: params.value } : { a: 0, v: 1 /* TRUE */ };
      const commandService = accessor.get(ICommandService);
      const setStyleParams = {
        style: {
          type: "tr",
          value
        }
      };
      return commandService.executeCommand(SetStyleCommand.id, setStyleParams);
    }
  };

  // ../packages/sheets/src/commands/mutations/set-tab-color.mutation.ts
  var SetTabColorUndoMutationFactory = (accessor, params) => {
    const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
    const worksheet = workbook.getSheetBySheetId(params.subUnitId);
    const config2 = worksheet.getConfig();
    const oldTabColor = config2.tabColor;
    return {
      ...Tools.deepClone(params),
      color: oldTabColor
    };
  };
  var SetTabColorMutation = {
    id: "sheet.mutation.set-tab-color",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(params.subUnitId);
      if (!worksheet)
        return false;
      worksheet.getConfig().tabColor = params.color;
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-tab-color.command.ts
  var SetTabColorCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-tab-color",
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const setTabColorMutationParams = {
        color: params.value,
        unitId,
        subUnitId
      };
      const undoMutationParams = SetTabColorUndoMutationFactory(accessor, setTabColorMutationParams);
      const result = commandService.syncExecuteCommand(SetTabColorMutation.id, setTabColorMutationParams);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetTabColorMutation.id, params: undoMutationParams }],
          redoMutations: [{ id: SetTabColorMutation.id, params: setTabColorMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/operations/set-worksheet-active.operation.ts
  var SetWorksheetActiveOperation = {
    id: "sheet.operation.set-worksheet-active",
    type: 1 /* OPERATION */,
    handler: (accessor, params) => {
      const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
      if (!workbook)
        return false;
      const worksheets = workbook.getWorksheets();
      for (const [, worksheet] of worksheets) {
        if (worksheet.getSheetId() === params.subUnitId) {
          workbook.setActiveSheet(worksheet);
          return true;
        }
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/commands/set-worksheet-activate.command.ts
  var SET_WORKSHEET_ACTIVE_DELAY = 4;
  var SetWorksheetActivateCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-worksheet-activate",
    handler: (accessor, params, options) => {
      var _a2, _b2;
      const commandService = accessor.get(ICommandService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      let unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      let subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      if (params) {
        unitId = (_a2 = params.unitId) != null ? _a2 : unitId;
        subUnitId = (_b2 = params.subUnitId) != null ? _b2 : subUnitId;
      }
      return new Promise((resolve) => {
        setTimeout(() => {
          const result = commandService.syncExecuteCommand(SetWorksheetActiveOperation.id, {
            unitId,
            subUnitId
          }, options);
          resolve(result);
        }, SET_WORKSHEET_ACTIVE_DELAY);
      });
    }
  };

  // ../packages/sheets/src/commands/mutations/set-worksheet-col-width.mutation.ts
  var SetWorksheetColWidthMutationFactory = (accessor, params) => {
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
    if (universheet == null) {
      throw new Error("universheet is null error!");
    }
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (worksheet == null) {
      throw new Error("universheet is null error!");
    }
    const colWidth = {};
    const manager = worksheet.getColumnManager();
    const ranges = params.ranges;
    for (let i = 0; i < ranges.length; i++) {
      const range = ranges[i];
      for (let j = range.startColumn; j < range.endColumn + 1; j++) {
        const column = manager.getColumnOrCreate(j);
        colWidth[j] = column.w;
      }
    }
    return {
      unitId: params.unitId,
      subUnitId: params.subUnitId,
      ranges: params.ranges,
      colWidth
    };
  };
  var SetWorksheetColWidthMutation = {
    id: "sheet.mutation.set-worksheet-col-width",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      var _a2;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const universheet = univerInstanceService.getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        throw new Error("universheet is null error!");
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet) {
        return false;
      }
      const defaultColumnWidth = worksheet.getConfig().defaultColumnWidth;
      const manager = worksheet.getColumnManager();
      const ranges = params.ranges;
      for (let i = 0; i < ranges.length; i++) {
        const range = ranges[i];
        for (let j = range.startColumn; j < range.endColumn + 1; j++) {
          const column = manager.getColumnOrCreate(j);
          if (typeof params.colWidth === "number") {
            column.w = params.colWidth;
          } else {
            column.w = (_a2 = params.colWidth[j - range.startColumn]) != null ? _a2 : defaultColumnWidth;
          }
        }
      }
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-worksheet-col-width.command.ts
  var DeltaColumnWidthCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.delta-column-width",
    handler: async (accessor, params) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const selections = selectionManagerService.getSelections();
      if (!(selections == null ? void 0 : selections.length)) {
        return false;
      }
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const worksheet = workbook.getActiveSheet();
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const { anchorCol, deltaX } = params;
      const anchorColWidth = worksheet.getColumnWidth(anchorCol);
      const destColumnWidth = anchorColWidth + deltaX;
      const isAllSheetRange = selections.length === 1 && selections[0].range.rangeType === 3 /* ALL */;
      const colSelections = selections.filter((s) => s.range.rangeType === 2 /* COLUMN */);
      const rangeType = isAllSheetRange ? 3 /* ALL */ : colSelections.some(({ range }) => {
        const { startColumn, endColumn } = range;
        return startColumn <= anchorCol && anchorCol <= endColumn;
      }) ? 2 /* COLUMN */ : 0 /* NORMAL */;
      let redoMutationParams;
      if (rangeType === 3 /* ALL */) {
        const rowCount = worksheet.getRowCount();
        const allColRanges = new Array(worksheet.getColumnCount()).fill(void 0).map(
          (_820, index) => ({ startRow: 0, endRow: rowCount - 1, startColumn: index, endColumn: index })
        );
        redoMutationParams = {
          subUnitId,
          unitId,
          colWidth: destColumnWidth,
          ranges: allColRanges
        };
      } else if (rangeType === 2 /* COLUMN */) {
        redoMutationParams = {
          subUnitId,
          unitId,
          ranges: colSelections.map((s) => Rectangle.clone(s.range)),
          colWidth: destColumnWidth
        };
      } else {
        redoMutationParams = {
          subUnitId,
          unitId,
          colWidth: destColumnWidth,
          ranges: [
            {
              startRow: 0,
              endRow: worksheet.getMaxRows() - 1,
              startColumn: anchorCol,
              endColumn: anchorCol
            }
          ]
        };
      }
      const undoMutationParams = SetWorksheetColWidthMutationFactory(
        accessor,
        redoMutationParams
      );
      const setColWidthResult = commandService.syncExecuteCommand(
        SetWorksheetColWidthMutation.id,
        redoMutationParams
      );
      const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
        id: DeltaColumnWidthCommand.id,
        params: redoMutationParams
      });
      const result = sequenceExecute([...redos], commandService);
      if (setColWidthResult && result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetWorksheetColWidthMutation.id, params: undoMutationParams }, ...undos],
          redoMutations: [{ id: SetWorksheetColWidthMutation.id, params: redoMutationParams }, ...redos]
        });
        return true;
      }
      return true;
    }
  };
  var SetColWidthCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-worksheet-col-width",
    handler: async (accessor, params) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const selections = selectionManagerService.getSelectionRanges();
      if (!(selections == null ? void 0 : selections.length)) {
        return false;
      }
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      const redoMutationParams = {
        subUnitId,
        unitId,
        ranges: selections,
        colWidth: params.value
      };
      const undoMutationParams = SetWorksheetColWidthMutationFactory(
        accessor,
        redoMutationParams
      );
      const setColWidthResult = commandService.syncExecuteCommand(
        SetWorksheetColWidthMutation.id,
        redoMutationParams
      );
      const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
        id: SetColWidthCommand.id,
        params: redoMutationParams
      });
      const result = sequenceExecute([...redos], commandService);
      if (setColWidthResult && result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetWorksheetColWidthMutation.id, params: undoMutationParams }, ...undos],
          redoMutations: [{ id: SetWorksheetColWidthMutation.id, params: redoMutationParams }, ...redos]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/set-worksheet-hide.mutation.ts
  var SetWorksheetHideMutationFactory = (accessor, params) => {
    const universheet = accessor.get(IUniverInstanceService).getCurrentUniverSheetInstance();
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (worksheet == null) {
      throw new Error("worksheet is null error!");
    }
    return {
      hidden: worksheet.isSheetHidden(),
      unitId: params.unitId,
      subUnitId: worksheet.getSheetId()
    };
  };
  var SetWorksheetHideMutation = {
    id: "sheet.mutation.set-worksheet-hidden",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const universheet = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        return false;
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet) {
        return false;
      }
      worksheet.getConfig().hidden = params.hidden;
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-worksheet-hide.command.ts
  var SetWorksheetHideCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-worksheet-hidden",
    handler: async (accessor, params) => {
      var _a2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const errorService = accessor.get(ErrorService);
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      let subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      if (params) {
        subUnitId = (_a2 = params.subUnitId) != null ? _a2 : subUnitId;
      }
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const hidden = worksheet.getConfig().hidden;
      if (hidden === 1 /* TRUE */)
        return false;
      const redoMutationParams = {
        unitId,
        subUnitId,
        hidden: 1 /* TRUE */
      };
      const undoMutationParams = SetWorksheetHideMutationFactory(accessor, redoMutationParams);
      const worksheets = workbook.getSheets();
      const visibleWorksheets = worksheets.filter((sheet) => sheet.getConfig().hidden === 0 /* FALSE */);
      if (visibleWorksheets.length === 1) {
        errorService.emit("No visible sheet after you hide this.");
        return false;
      }
      const result = commandService.syncExecuteCommand(SetWorksheetHideMutation.id, redoMutationParams);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetWorksheetHideMutation.id, params: undoMutationParams }],
          redoMutations: [{ id: SetWorksheetHideMutation.id, params: redoMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/set-worksheet-name.mutation.ts
  var SetWorksheetNameMutationFactory = (accessor, params) => {
    const universheet = accessor.get(IUniverInstanceService).getCurrentUniverSheetInstance();
    const worksheet = universheet.getSheetBySheetId(params.subUnitId);
    if (worksheet == null) {
      throw new Error("worksheet is null error!");
    }
    return {
      unitId: params.unitId,
      name: worksheet.getName(),
      subUnitId: worksheet.getSheetId()
    };
  };
  var SetWorksheetNameMutation = {
    id: "sheet.mutation.set-worksheet-name",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const universheet = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
      if (universheet == null) {
        return false;
      }
      const worksheet = universheet.getSheetBySheetId(params.subUnitId);
      if (!worksheet) {
        return false;
      }
      worksheet.getConfig().name = params.name;
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-worksheet-name.command.ts
  var SetWorksheetNameCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-worksheet-name",
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const sheetInterceptorService = accessor.get(SheetInterceptorService);
      const unitId = params.unitId || univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = params.subUnitId || univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      const redoMutationParams = {
        subUnitId,
        name: params.name,
        unitId
      };
      const undoMutationParams = SetWorksheetNameMutationFactory(
        accessor,
        redoMutationParams
      );
      const interceptorCommands = sheetInterceptorService.onCommandExecute({
        id: SetWorksheetNameCommand.id,
        params
      });
      const redos = [{ id: SetWorksheetNameMutation.id, params: redoMutationParams }, ...interceptorCommands.redos];
      const undos = [...interceptorCommands.undos, { id: SetWorksheetNameMutation.id, params: undoMutationParams }];
      const result = await sequenceExecute(redos, commandService).result;
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: undos,
          redoMutations: redos
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/set-worksheet-order.mutation.ts
  var SetWorksheetOrderUndoMutationFactory = (accessor, params) => {
    return {
      ...Tools.deepClone(params),
      toOrder: params.fromOrder,
      fromOrder: params.toOrder
    };
  };
  var SetWorksheetOrderMutation = {
    id: "sheet.mutation.set-worksheet-order",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const workbook = accessor.get(IUniverInstanceService).getUniverSheetInstance(params.unitId);
      if (!workbook)
        return false;
      const config2 = workbook.getConfig();
      config2.sheetOrder.splice(params.fromOrder, 1);
      config2.sheetOrder.splice(params.toOrder, 0, params.subUnitId);
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-worksheet-order.command.ts
  var SetWorksheetOrderCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-worksheet-order",
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const unitId = params.unitId || univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const subUnitId = params.subUnitId || univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const fromOrder = workbook.getConfig().sheetOrder.indexOf(subUnitId);
      const setWorksheetOrderMutationParams = {
        fromOrder,
        toOrder: params.order,
        unitId,
        subUnitId
      };
      const undoMutationParams = SetWorksheetOrderUndoMutationFactory(accessor, setWorksheetOrderMutationParams);
      const result = commandService.syncExecuteCommand(SetWorksheetOrderMutation.id, setWorksheetOrderMutationParams);
      if (result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetWorksheetOrderMutation.id, params: undoMutationParams }],
          redoMutations: [{ id: SetWorksheetOrderMutation.id, params: setWorksheetOrderMutationParams }]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/mutations/set-worksheet-row-height.mutation.ts
  var MAXIMUM_ROW_HEIGHT = 2e3;
  var SetWorksheetRowHeightMutationFactory = (accessor, params) => {
    const { unitId, subUnitId, ranges } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getUniverSheetInstance(unitId);
    const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
    if (worksheet == null) {
      throw new Error("worksheet is null error!");
    }
    const rowHeight = {};
    const manager = worksheet.getRowManager();
    for (const { startRow, endRow } of ranges) {
      for (let rowIndex = startRow; rowIndex < endRow + 1; rowIndex++) {
        const row = manager.getRowOrCreate(rowIndex);
        rowHeight[rowIndex] = row.h;
      }
    }
    return {
      unitId,
      subUnitId,
      ranges,
      rowHeight
    };
  };
  var SetWorksheetRowIsAutoHeightMutationFactory = (accessor, params) => {
    const { unitId, subUnitId, ranges } = params;
    const univerInstanceService = accessor.get(IUniverInstanceService);
    const workbook = univerInstanceService.getUniverSheetInstance(unitId);
    const worksheet = workbook.getSheetBySheetId(subUnitId);
    const autoHeightHash = {};
    const manager = worksheet.getRowManager();
    for (const { startRow, endRow } of ranges) {
      for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
        const row = manager.getRowOrCreate(rowIndex);
        autoHeightHash[rowIndex] = row.ia;
      }
    }
    return {
      unitId,
      subUnitId,
      ranges,
      autoHeightInfo: autoHeightHash
    };
  };
  var SetWorksheetRowHeightMutation = {
    id: "sheet.mutation.set-worksheet-row-height",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      var _a2;
      const { unitId, subUnitId, ranges, rowHeight } = params;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
      if (!worksheet) {
        return false;
      }
      const defaultRowHeight = worksheet.getConfig().defaultRowHeight;
      const manager = worksheet.getRowManager();
      for (const { startRow, endRow } of ranges) {
        for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
          const row = manager.getRowOrCreate(rowIndex);
          if (typeof rowHeight === "number") {
            row.h = rowHeight;
          } else {
            row.h = (_a2 = rowHeight[rowIndex]) != null ? _a2 : defaultRowHeight;
          }
          row.h = Math.min(MAXIMUM_ROW_HEIGHT, row.h);
        }
      }
      return true;
    }
  };
  var SetWorksheetRowIsAutoHeightMutation = {
    id: "sheet.mutation.set-worksheet-row-is-auto-height",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      var _a2;
      const { unitId, subUnitId, ranges, autoHeightInfo } = params;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
      if (!worksheet) {
        return false;
      }
      const defaultRowIsAutoHeight = void 0;
      const manager = worksheet.getRowManager();
      for (const { startRow, endRow } of ranges) {
        for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
          const row = manager.getRowOrCreate(rowIndex);
          if (typeof autoHeightInfo === "number") {
            row.ia = autoHeightInfo;
          } else {
            row.ia = (_a2 = autoHeightInfo[rowIndex - startRow]) != null ? _a2 : defaultRowIsAutoHeight;
          }
        }
      }
      return true;
    }
  };
  var SetWorksheetRowAutoHeightMutation = {
    id: "sheet.mutation.set-worksheet-row-auto-height",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      const { unitId, subUnitId, rowsAutoHeightInfo } = params;
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      const worksheet = workbook == null ? void 0 : workbook.getSheetBySheetId(subUnitId);
      if (!worksheet || !workbook) {
        return false;
      }
      const rowManager = worksheet.getRowManager();
      for (const { row, autoHeight } of rowsAutoHeightInfo) {
        const curRow = rowManager.getRowOrCreate(row);
        curRow.ah = autoHeight;
      }
      return true;
    }
  };

  // ../packages/sheets/src/commands/commands/set-worksheet-row-height.command.ts
  var DeltaRowHeightCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.delta-row-height",
    handler: async (accessor, params) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const selections = selectionManagerService.getSelections();
      if (!(selections == null ? void 0 : selections.length)) {
        return false;
      }
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const worksheet = workbook.getActiveSheet();
      const unitId = workbook.getUnitId();
      const subUnitId = worksheet.getSheetId();
      const { anchorRow, deltaY } = params;
      const anchorRowHeight = worksheet.getRowHeight(anchorRow);
      const destRowHeight = anchorRowHeight + deltaY;
      const isAllSheetRange = selections.length === 1 && selections[0].range.rangeType === 3 /* ALL */;
      const rowSelections = selections.filter((s) => s.range.rangeType === 1 /* ROW */);
      const rangeType = isAllSheetRange ? 3 /* ALL */ : rowSelections.some(({ range }) => {
        const { startRow, endRow } = range;
        return startRow <= anchorRow && anchorRow <= endRow;
      }) ? 1 /* ROW */ : 0 /* NORMAL */;
      let redoMutationParams;
      if (rangeType === 3 /* ALL */) {
        const colCount = worksheet.getRowCount();
        const allRowRanges = new Array(worksheet.getColumnCount()).fill(void 0).map(
          (_820, index) => ({ startRow: index, endRow: index, startColumn: 0, endColumn: colCount - 1 })
        );
        redoMutationParams = {
          subUnitId,
          unitId,
          rowHeight: destRowHeight,
          ranges: allRowRanges
        };
      } else if (rangeType === 1 /* ROW */) {
        redoMutationParams = {
          subUnitId,
          unitId,
          ranges: rowSelections.map((s) => Rectangle.clone(s.range)),
          rowHeight: destRowHeight
        };
      } else {
        redoMutationParams = {
          subUnitId,
          unitId,
          rowHeight: destRowHeight,
          ranges: [
            {
              startRow: anchorRow,
              endRow: anchorRow,
              startColumn: 0,
              endColumn: worksheet.getMaxColumns() - 1
            }
          ]
        };
      }
      const undoMutationParams = SetWorksheetRowHeightMutationFactory(
        accessor,
        redoMutationParams
      );
      const redoSetIsAutoHeightParams = {
        unitId,
        subUnitId,
        ranges: redoMutationParams.ranges,
        autoHeightInfo: 0 /* FALSE */
      };
      const undoSetIsAutoHeightParams = SetWorksheetRowIsAutoHeightMutationFactory(accessor, redoSetIsAutoHeightParams);
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const result = sequenceExecute(
        [
          {
            id: SetWorksheetRowHeightMutation.id,
            params: redoMutationParams
          },
          {
            id: SetWorksheetRowIsAutoHeightMutation.id,
            params: redoSetIsAutoHeightParams
          }
        ],
        commandService
      );
      if (result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [
            {
              id: SetWorksheetRowHeightMutation.id,
              params: undoMutationParams
            },
            {
              id: SetWorksheetRowIsAutoHeightMutation.id,
              params: undoSetIsAutoHeightParams
            }
          ],
          redoMutations: [
            {
              id: SetWorksheetRowHeightMutation.id,
              params: redoMutationParams
            },
            {
              id: SetWorksheetRowIsAutoHeightMutation.id,
              params: redoSetIsAutoHeightParams
            }
          ]
        });
        return true;
      }
      return false;
    }
  };
  var SetRowHeightCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-row-height",
    handler: (accessor, params) => {
      const selectionManagerService = accessor.get(SelectionManagerService);
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const selections = selectionManagerService.getSelectionRanges();
      if (!(selections == null ? void 0 : selections.length)) {
        return false;
      }
      const workbook = univerInstanceService.getCurrentUniverSheetInstance();
      const unitId = workbook.getUnitId();
      const subUnitId = workbook.getActiveSheet().getSheetId();
      const redoMutationParams = {
        subUnitId,
        unitId,
        ranges: selections,
        rowHeight: params.value
      };
      const undoMutationParams = SetWorksheetRowHeightMutationFactory(
        accessor,
        redoMutationParams
      );
      const redoSetIsAutoHeightParams = {
        unitId,
        subUnitId,
        ranges: redoMutationParams.ranges,
        autoHeightInfo: 0 /* FALSE */
      };
      const undoSetIsAutoHeightParams = SetWorksheetRowIsAutoHeightMutationFactory(accessor, redoSetIsAutoHeightParams);
      const result = sequenceExecute(
        [
          {
            id: SetWorksheetRowHeightMutation.id,
            params: redoMutationParams
          },
          {
            id: SetWorksheetRowIsAutoHeightMutation.id,
            params: redoSetIsAutoHeightParams
          }
        ],
        commandService
      );
      if (result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [
            {
              id: SetWorksheetRowHeightMutation.id,
              params: undoMutationParams
            },
            {
              id: SetWorksheetRowIsAutoHeightMutation.id,
              params: undoSetIsAutoHeightParams
            }
          ],
          redoMutations: [
            {
              id: SetWorksheetRowHeightMutation.id,
              params: redoMutationParams
            },
            {
              id: SetWorksheetRowIsAutoHeightMutation.id,
              params: redoSetIsAutoHeightParams
            }
          ]
        });
        return true;
      }
      return false;
    }
  };
  var SetWorksheetRowIsAutoHeightCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-row-is-auto-height",
    handler: async (accessor, params) => {
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const selectionManagerService = accessor.get(SelectionManagerService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      const workSheet = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet();
      const subUnitId = workSheet.getSheetId();
      const { anchorRow } = params != null ? params : {};
      const ranges = anchorRow != null ? [
        {
          startRow: anchorRow,
          endRow: anchorRow,
          startColumn: 0,
          endColumn: workSheet.getMaxColumns() - 1
        }
      ] : selectionManagerService.getSelectionRanges();
      if (!(ranges == null ? void 0 : ranges.length)) {
        return false;
      }
      const redoMutationParams = {
        unitId,
        subUnitId,
        ranges,
        autoHeightInfo: 1 /* TRUE */
        // Hard code first, maybe it will change by the menu item in the future.
      };
      const undoMutationParams = SetWorksheetRowIsAutoHeightMutationFactory(accessor, redoMutationParams);
      const setIsAutoHeightResult = commandService.syncExecuteCommand(
        SetWorksheetRowIsAutoHeightMutation.id,
        redoMutationParams
      );
      const { undos, redos } = accessor.get(SheetInterceptorService).onCommandExecute({
        id: SetWorksheetRowIsAutoHeightCommand.id,
        params: redoMutationParams
      });
      const result = sequenceExecute([...redos], commandService);
      if (setIsAutoHeightResult && result.result) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [{ id: SetWorksheetRowIsAutoHeightMutation.id, params: undoMutationParams }, ...undos],
          redoMutations: [{ id: SetWorksheetRowIsAutoHeightMutation.id, params: redoMutationParams }, ...redos]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/commands/commands/set-worksheet-show.command.ts
  var SetWorksheetShowCommand = {
    type: 0 /* COMMAND */,
    id: "sheet.command.set-worksheet-show",
    handler: async (accessor, params) => {
      var _a2;
      const commandService = accessor.get(ICommandService);
      const undoRedoService = accessor.get(IUndoRedoService);
      const univerInstanceService = accessor.get(IUniverInstanceService);
      const unitId = univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
      let subUnitId = univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
      if (params) {
        subUnitId = (_a2 = params.value) != null ? _a2 : subUnitId;
      }
      const workbook = univerInstanceService.getUniverSheetInstance(unitId);
      if (!workbook)
        return false;
      const worksheet = workbook.getSheetBySheetId(subUnitId);
      if (!worksheet)
        return false;
      const hidden = worksheet.getConfig().hidden;
      if (hidden === 0 /* FALSE */)
        return false;
      const redoMutationParams = {
        unitId,
        subUnitId,
        hidden: 0 /* FALSE */
      };
      const undoMutationParams = SetWorksheetHideMutationFactory(accessor, redoMutationParams);
      const result = commandService.syncExecuteCommand(SetWorksheetHideMutation.id, redoMutationParams);
      const activeSheetMutationParams = {
        unitId,
        subUnitId
      };
      const activeResult = commandService.syncExecuteCommand(
        SetWorksheetActiveOperation.id,
        activeSheetMutationParams
      );
      if (result && activeResult) {
        undoRedoService.pushUndoRedo({
          unitID: unitId,
          undoMutations: [
            { id: SetWorksheetHideMutation.id, params: undoMutationParams }
            // { id: SetWorksheetActiveOperation.id, params: unActiveMutationParams },
          ],
          redoMutations: [
            // { id: SetWorksheetActiveOperation.id, params: activeSheetMutationParams },
            { id: SetWorksheetHideMutation.id, params: redoMutationParams }
          ]
        });
        return true;
      }
      return false;
    }
  };

  // ../packages/sheets/src/services/numfmt/type.ts
  var INumfmtService = createIdentifier("INumfmtService");
  runOnLifecycle(1 /* Ready */, INumfmtService);

  // ../packages/sheets/src/commands/mutations/numfmt-mutation.ts
  var SetNumfmtMutation = {
    id: "sheet.mutation.set.numfmt",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      if (!params) {
        return false;
      }
      const { values, refMap } = params;
      const numfmtService = accessor.get(INumfmtService);
      const unitId = params.unitId;
      const sheetId = params.subUnitId;
      const setValues = Object.keys(values).reduce(
        (result, id) => {
          const value = refMap[id];
          const ranges = values[id].ranges;
          if (value) {
            result.push({
              ...value,
              ranges
            });
          }
          return result;
        },
        []
      );
      numfmtService.setValues(unitId, sheetId, setValues);
      return true;
    }
  };
  var RemoveNumfmtMutation = {
    id: "sheet.mutation.remove.numfmt",
    type: 2 /* MUTATION */,
    handler: (accessor, params) => {
      if (!params) {
        return false;
      }
      const { unitId, subUnitId, ranges } = params;
      const numfmtService = accessor.get(INumfmtService);
      numfmtService.deleteValues(unitId, subUnitId, ranges);
      return true;
    }
  };

  // ../packages/sheets/src/commands/mutations/empty.mutation.ts
  var EmptyMutation = {
    id: "sheet.mutation.empty",
    type: 2 /* MUTATION */,
    handler: () => {
      return true;
    }
  };

  // ../packages/sheets/src/controllers/config/config.ts
  var MAX_CELL_PER_SHEET_KEY = "maxCellsPerSheet";
  var MAX_CELL_PER_SHEET_DEFAULT = 3e6;

  // ../packages/sheets/src/controllers/basic-worksheet.controller.ts
  var BasicWorksheetController = class extends Disposable {
    constructor(_commandService, _configService) {
      super();
      this._commandService = _commandService;
      this._configService = _configService;
      [
        AddWorksheetMergeMutation,
        ClearSelectionAllCommand,
        ClearSelectionContentCommand,
        ClearSelectionFormatCommand,
        CopySheetCommand,
        DeleteRangeMoveLeftCommand,
        DeleteRangeMoveUpCommand,
        DeltaColumnWidthCommand,
        DeltaRowHeightCommand,
        InsertColAfterCommand,
        InsertColBeforeCommand,
        InsertColCommand,
        InsertColMutation,
        InsertRangeMoveDownCommand,
        InsertRangeMoveRightCommand,
        InsertRowAfterCommand,
        InsertRowBeforeCommand,
        InsertRowCommand,
        InsertRowMutation,
        InsertSheetCommand,
        InsertSheetMutation,
        MoveColsCommand,
        MoveColsMutation,
        MoveRangeCommand,
        MoveRangeMutation,
        MoveRowsCommand,
        MoveRowsMutation,
        RemoveColCommand,
        RemoveColMutation,
        RemoveRowCommand,
        RemoveRowMutation,
        RemoveSheetCommand,
        RemoveSheetMutation,
        RemoveWorksheetMergeCommand,
        RemoveWorksheetMergeMutation,
        ResetBackgroundColorCommand,
        ResetTextColorCommand,
        SetBackgroundColorCommand,
        SetBorderBasicCommand,
        SetBorderColorCommand,
        SetBorderCommand,
        SetBorderPositionCommand,
        SetBorderStyleCommand,
        SetColHiddenCommand,
        SetColHiddenMutation,
        SetColVisibleMutation,
        SetColWidthCommand,
        SetFrozenCancelCommand,
        SetFrozenCommand,
        SetFrozenMutation,
        SetHorizontalTextAlignCommand,
        SetRangeValuesCommand,
        SetRangeValuesMutation,
        SetRowHeightCommand,
        SetRowHiddenCommand,
        SetRowHiddenMutation,
        SetRowVisibleMutation,
        SetSelectedColsVisibleCommand,
        SetSelectedRowsVisibleCommand,
        SetSpecificColsVisibleCommand,
        SetSpecificRowsVisibleCommand,
        SetStyleCommand,
        SetTabColorCommand,
        SetTabColorMutation,
        SetTextColorCommand,
        SetTextRotationCommand,
        SetTextWrapCommand,
        SetVerticalTextAlignCommand,
        SetWorksheetActivateCommand,
        SetWorksheetActiveOperation,
        SetWorksheetColWidthMutation,
        SetWorksheetHideCommand,
        SetWorksheetHideMutation,
        SetWorksheetNameCommand,
        SetWorksheetNameMutation,
        SetWorksheetOrderCommand,
        SetWorksheetOrderMutation,
        SetWorksheetRowAutoHeightMutation,
        SetWorksheetRowHeightMutation,
        SetWorksheetRowIsAutoHeightCommand,
        SetWorksheetRowIsAutoHeightMutation,
        SetWorksheetShowCommand,
        SetNumfmtMutation,
        SetSelectionsOperation,
        RemoveNumfmtMutation,
        EmptyMutation
      ].forEach((command) => this.disposeWithMe(this._commandService.registerCommand(command)));
      this._configService.setConfig(MAX_CELL_PER_SHEET_KEY, MAX_CELL_PER_SHEET_DEFAULT);
    }
  };
  BasicWorksheetController = __decorateClass([
    OnLifecycle(0 /* Starting */, BasicWorksheetController),
    __decorateParam(0, ICommandService),
    __decorateParam(1, IConfigService)
  ], BasicWorksheetController);

  // ../packages/sheets/src/controllers/calculate-result-apply.controller.ts
  var CalculateResultApplyController = class extends Disposable {
    constructor(_commandService) {
      super();
      this._commandService = _commandService;
      this._initialize();
    }
    _initialize() {
      this._commandExecutedListener();
    }
    _commandExecutedListener() {
      this.disposeWithMe(
        this._commandService.onCommandExecuted((command) => {
          if (command.id !== SetFormulaCalculationResultMutation.id) {
            return;
          }
          const params = command.params;
          const { unitData, unitOtherData } = params;
          const unitIds = Object.keys(unitData);
          const redoMutationsInfo = [];
          unitIds.forEach((unitId) => {
            const sheetData = unitData[unitId];
            if (sheetData == null) {
              return true;
            }
            const sheetIds = Object.keys(sheetData);
            sheetIds.forEach((sheetId) => {
              const cellData = sheetData[sheetId];
              if (cellData == null) {
                return true;
              }
              const setRangeValuesMutation = {
                subUnitId: sheetId,
                unitId,
                cellValue: cellData
              };
              redoMutationsInfo.push({
                id: SetRangeValuesMutation.id,
                params: setRangeValuesMutation
              });
            });
          });
          const result = redoMutationsInfo.every(
            (m) => this._commandService.executeCommand(m.id, m.params, {
              onlyLocal: true
            })
          );
          return result;
        })
      );
    }
  };
  CalculateResultApplyController = __decorateClass([
    OnLifecycle(1 /* Ready */, CalculateResultApplyController),
    __decorateParam(0, ICommandService)
  ], CalculateResultApplyController);

  // ../packages/sheets/src/controllers/feature-calculation.controller.ts
  var FeatureCalculationController = class extends Disposable {
    constructor(_commandService, _featureCalculationManagerService, _currentUniverService, _formulaDataModel) {
      super();
      this._commandService = _commandService;
      this._featureCalculationManagerService = _featureCalculationManagerService;
      this._currentUniverService = _currentUniverService;
      this._formulaDataModel = _formulaDataModel;
    }
    /**
     * Test function access to the formula system example , feature calculation ,
     * you can register a listening range and callback function ,
     * the range will be analyzed through the dependency after the callback function execution ,
     * the callback function to return to an execution result ,
     * you can continue to enter the formula dependency system , to get the final result .
     */
    _initialize() {
      const featureId = "test";
      const unitId = "workbook-01";
      const subUnitId = "sheet-0011";
      const runtimeCellData = {
        [unitId]: {
          [subUnitId]: new ObjectMatrix({
            4: {
              0: {
                v: 10,
                t: 2
              }
            }
          })
        }
      };
      const dirtyRanges = {
        [unitId]: {
          [subUnitId]: [
            {
              startRow: 4,
              startColumn: 0,
              endRow: 4,
              endColumn: 0
            }
          ]
        }
      };
      this._featureCalculationManagerService.register(featureId, {
        unitId,
        subUnitId,
        dependencyRanges: [
          {
            unitId,
            sheetId: subUnitId,
            range: {
              startRow: 0,
              endRow: 3,
              startColumn: 0,
              endColumn: 3
            }
          }
        ],
        getDirtyData: () => {
          return {
            runtimeCellData,
            dirtyRanges
          };
        }
      });
    }
  };
  FeatureCalculationController = __decorateClass([
    OnLifecycle(1 /* Ready */, FeatureCalculationController),
    __decorateParam(0, ICommandService),
    __decorateParam(1, IFeatureCalculationManagerService),
    __decorateParam(2, IUniverInstanceService),
    __decorateParam(3, Inject(FormulaDataModel))
  ], FeatureCalculationController);

  // ../packages/sheets/src/services/ref-range/type.ts
  var EffectRefRangId = {
    MoveRangeCommandId,
    InsertRowCommandId,
    InsertColCommandId,
    RemoveColCommandId,
    RemoveRowCommandId,
    DeleteRangeMoveLeftCommandId,
    DeleteRangeMoveUpCommandId,
    InsertRangeMoveDownCommandId,
    InsertRangeMoveRightCommandId,
    MoveColsCommandId,
    MoveRowsCommandId
  };

  // ../packages/sheets/src/services/ref-range/ref-range.service.ts
  var MERGE_REDO = createInterceptorKey("MERGE_REDO");
  var MERGE_UNDO = createInterceptorKey("MERGE_UNDO");
  var RefRangeService = class extends Disposable {
    constructor(_sheetInterceptorService, _univerInstanceService, _selectionManagerService) {
      super();
      this._sheetInterceptorService = _sheetInterceptorService;
      this._univerInstanceService = _univerInstanceService;
      this._selectionManagerService = _selectionManagerService;
      __publicField(this, "interceptor", new InterceptorManager({ MERGE_REDO, MERGE_UNDO }));
      __publicField(this, "_refRangeManagerMap", /* @__PURE__ */ new Map());
      __publicField(this, "_serializer", createRangeSerializer());
      __publicField(this, "_onRefRangeChange", () => {
        this._sheetInterceptorService.interceptCommand({
          getMutations: (command) => {
            const workSheet = this._univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet();
            const unitId = getunitId(this._univerInstanceService);
            const subUnitId = getsubUnitId(this._univerInstanceService);
            const getEffectsCbList = () => {
              switch (command.id) {
                case EffectRefRangId.MoveColsCommandId: {
                  const params = command.params;
                  const startColumn = Math.min(params.fromRange.startColumn, params.toRange.startColumn);
                  return this._checkRange(
                    [{ ...params.fromRange, startColumn, endColumn: workSheet.getColumnCount() - 1 }],
                    unitId,
                    subUnitId
                  );
                }
                case EffectRefRangId.MoveRowsCommandId: {
                  const params = command.params;
                  const startRow = Math.min(params.fromRange.startRow, params.toRange.startRow);
                  return this._checkRange(
                    [{ ...params.fromRange, startRow, endRow: workSheet.getRowCount() - 1 }],
                    unitId,
                    subUnitId
                  );
                }
                case EffectRefRangId.MoveRangeCommandId: {
                  const params = command;
                  return this._checkRange(
                    [params.params.fromRange, params.params.toRange],
                    unitId,
                    subUnitId
                  );
                }
                case EffectRefRangId.InsertRowCommandId: {
                  const params = command;
                  const rowStart = params.params.range.startRow;
                  const range = {
                    startRow: rowStart,
                    endRow: workSheet.getRowCount() - 1,
                    startColumn: 0,
                    endColumn: workSheet.getColumnCount() - 1
                  };
                  return this._checkRange([range], unitId, subUnitId);
                }
                case EffectRefRangId.InsertColCommandId: {
                  const params = command;
                  const colStart = params.params.range.startColumn;
                  const range = {
                    startRow: 0,
                    endRow: workSheet.getRowCount() - 1,
                    startColumn: colStart,
                    endColumn: workSheet.getColumnCount() - 1
                  };
                  return this._checkRange([range], unitId, subUnitId);
                }
                case EffectRefRangId.RemoveRowCommandId: {
                  const params = command;
                  const rowStart = params.params.range.startRow;
                  const range = {
                    startRow: rowStart,
                    endRow: workSheet.getRowCount() - 1,
                    startColumn: 0,
                    endColumn: workSheet.getColumnCount() - 1
                  };
                  return this._checkRange([range], unitId, subUnitId);
                }
                case EffectRefRangId.RemoveColCommandId: {
                  const params = command;
                  const colStart = params.params.range.startColumn;
                  const range = {
                    startRow: 0,
                    endRow: workSheet.getRowCount() - 1,
                    startColumn: colStart,
                    endColumn: workSheet.getColumnCount() - 1
                  };
                  return this._checkRange([range], unitId, subUnitId);
                }
                case EffectRefRangId.DeleteRangeMoveUpCommandId:
                case EffectRefRangId.InsertRangeMoveDownCommandId: {
                  const params = command;
                  const range = params.params.range || getSelectionRanges(this._selectionManagerService)[0];
                  const effectRange = {
                    startRow: range.startRow,
                    startColumn: range.startColumn,
                    endColumn: range.endColumn,
                    endRow: workSheet.getRowCount() - 1
                  };
                  return this._checkRange([effectRange], unitId, subUnitId);
                }
                case EffectRefRangId.DeleteRangeMoveLeftCommandId:
                case EffectRefRangId.InsertRangeMoveRightCommandId: {
                  const params = command;
                  const range = params.params.range || getSelectionRanges(this._selectionManagerService)[0];
                  const effectRange = {
                    startRow: range.startRow,
                    startColumn: range.startColumn,
                    endColumn: workSheet.getColumnCount() - 1,
                    endRow: range.endRow
                  };
                  return this._checkRange([effectRange], unitId, subUnitId);
                }
              }
            };
            const cbList = getEffectsCbList() || [];
            const result = cbList.reduce(
              (result2, currentFn) => {
                const v = currentFn(command);
                result2.push(v);
                return result2;
              },
              []
            ).reduce(
              (result2, currentValue) => {
                var _a2, _b2;
                result2.redos.push(...currentValue.redos);
                result2.undos.push(...currentValue.undos);
                result2.preRedos.push(...(_a2 = currentValue.preRedos) != null ? _a2 : []);
                result2.preUndos.push(...(_b2 = currentValue.preUndos) != null ? _b2 : []);
                return result2;
              },
              { redos: [], undos: [], preUndos: [], preRedos: [] }
            );
            const preRedos = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_REDO)(
              result.preRedos,
              null
            ) || [];
            const redos = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_REDO)(
              result.redos,
              null
            ) || [];
            const preUndos = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_UNDO)(
              result.preUndos,
              null
            ) || [];
            const undos = this.interceptor.fetchThroughInterceptors(this.interceptor.getInterceptPoints().MERGE_UNDO)(
              result.undos,
              null
            ) || [];
            return { redos, undos, preRedos, preUndos };
          }
        });
      });
      __publicField(this, "_checkRange", (effectRanges, unitId, subUnitId) => {
        const managerId = getRefRangId(unitId, subUnitId);
        const manager = this._refRangeManagerMap.get(managerId);
        if (manager) {
          const callbackSet = /* @__PURE__ */ new Set();
          const keyList = [...manager.keys()];
          keyList.forEach((key) => {
            const cbList = manager.get(key);
            const range = this._serializer.deserialize(key);
            if (effectRanges.some((item) => Rectangle.intersects(item, range))) {
              cbList && cbList.forEach((callback) => {
                callbackSet.add(callback);
              });
            }
          });
          return [...callbackSet];
        }
        return [];
      });
      /**
       * Listens to an area and triggers a fall back when movement occurs
       * @param {IRange} range the area that needs to be monitored
       * @param {RefRangCallback} callback the callback function that is executed when the range changes
       * @param {string} [_unitId]
       * @param {string} [_subUnitId]
       * @memberof RefRangeService
       */
      __publicField(this, "registerRefRange", (range, callback, _unitId, _subUnitId) => {
        const unitId = _unitId || getunitId(this._univerInstanceService);
        const subUnitId = _subUnitId || getsubUnitId(this._univerInstanceService);
        const refRangeManagerId = getRefRangId(unitId, subUnitId);
        const rangeString = this._serializer.serialize(range);
        let manager = this._refRangeManagerMap.get(refRangeManagerId);
        if (!manager) {
          manager = /* @__PURE__ */ new Map();
          this._refRangeManagerMap.set(refRangeManagerId, manager);
        }
        const refRangeCallbackList = manager.get(rangeString);
        if (refRangeCallbackList) {
          refRangeCallbackList.add(callback);
        } else {
          manager.set(rangeString, /* @__PURE__ */ new Set([callback]));
        }
        return toDisposable(() => {
          const refRangeCallbackList2 = manager.get(rangeString);
          if (refRangeCallbackList2) {
            refRangeCallbackList2.delete(callback);
            if (!refRangeCallbackList2.size) {
              manager.delete(rangeString);
              if (!manager.size) {
                this._refRangeManagerMap.delete(refRangeManagerId);
              }
            }
          }
        });
      });
      this._onRefRangeChange();
      this.interceptor.intercept(this.interceptor.getInterceptPoints().MERGE_REDO, {
        priority: -1,
        handler: (list) => list
      });
      this.interceptor.intercept(this.interceptor.getInterceptPoints().MERGE_UNDO, {
        priority: -1,
        handler: (list) => list
      });
    }
  };
  RefRangeService = __decorateClass([
    OnLifecycle(3 /* Steady */, RefRangeService),
    __decorateParam(0, Inject(SheetInterceptorService)),
    __decorateParam(1, Inject(IUniverInstanceService)),
    __decorateParam(2, Inject(SelectionManagerService))
  ], RefRangeService);
  function getunitId(univerInstanceService) {
    return univerInstanceService.getCurrentUniverSheetInstance().getUnitId();
  }
  function getsubUnitId(univerInstanceService) {
    return univerInstanceService.getCurrentUniverSheetInstance().getActiveSheet().getSheetId();
  }
  function getSelectionRanges(selectionManagerService) {
    return selectionManagerService.getSelectionRanges() || [];
  }
  function getRefRangId(unitId, subUnitId) {
    return `${unitId}_${subUnitId}`;
  }
  function createRangeSerializer() {
    const keyList = ["startRow", "startColumn", "endRow", "endColumn", "rangeType"];
    const SPLIT_CODE = "_";
    return {
      deserialize: (rangeString) => {
        const map2 = keyList.reduce(
          (preValue, currentValue, index) => {
            preValue[String(index)] = currentValue;
            return preValue;
          },
          {}
        );
        const res = rangeString.split(SPLIT_CODE).reduce(
          (preValue, currentValue, _index) => {
            const index = String(_index);
            if (currentValue && map2[index]) {
              preValue[map2[index]] = currentValue;
            }
            return preValue;
          },
          {}
        );
        return res;
      },
      serialize: (range) => keyList.reduce((preValue, currentValue, index) => {
        const value = range[currentValue];
        if (value !== void 0) {
          return `${preValue}${index > 0 ? SPLIT_CODE : ""}${value}`;
        }
        return `${preValue}`;
      }, "")
    };
  }

  // ../packages/sheets/src/services/ref-range/util.ts
  var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
  var handleRangeTypeInput = (range) => {
    const _range = { ...range };
    if (_range.rangeType === 2 /* COLUMN */) {
      _range.startRow = 0;
      _range.endRow = MAX_SAFE_INTEGER;
    }
    if (_range.rangeType === 1 /* ROW */) {
      _range.startColumn = 0;
      _range.endColumn = MAX_SAFE_INTEGER;
    }
    if (_range.rangeType === 3 /* ALL */) {
      _range.startColumn = 0;
      _range.endColumn = MAX_SAFE_INTEGER;
      _range.startRow = 0;
      _range.endRow = MAX_SAFE_INTEGER;
    }
    return _range;
  };
  var handleBaseMoveRowsCols = (fromRange, toRange, effectRange) => {
    const _effectRange = { ...effectRange };
    const _toRange = { ...toRange };
    const getIntersects = (line1, line2) => {
      const start = Math.max(line1.start, line2.start);
      const end = Math.min(line1.end, line2.end);
      if (end < start) {
        return null;
      }
      return { start, end };
    };
    const getLength = (line) => line.end - line.start + 1;
    const getRelative = (line, origin) => ({
      start: line.start - origin.start,
      end: line.start - origin.start + line.end - line.start
    });
    const getAbsolute = (line, origin) => ({
      start: origin.start + line.start,
      end: origin.start + line.start + line.end - line.start
    });
    const isToLargeFrom = toRange.start > fromRange.start;
    if (isToLargeFrom) {
      const step = Math.min(fromRange.end, toRange.start) - fromRange.start + 1;
      _toRange.start -= step;
      _toRange.end -= step;
    }
    const fromRangeStep = getLength(fromRange);
    const toRangeStep = fromRangeStep;
    const fromRangeIntersectsEffectRange = getIntersects(fromRange, _effectRange);
    const isFromRangeContainEffectRange = fromRangeIntersectsEffectRange && getLength(fromRangeIntersectsEffectRange) >= getLength(_effectRange);
    if (fromRange.end < _effectRange.start) {
      _effectRange.start -= fromRangeStep;
      _effectRange.end -= fromRangeStep;
    } else if (fromRangeIntersectsEffectRange) {
      const fromRangeIntersectsEffectRangeStep = getLength(fromRangeIntersectsEffectRange);
      if (isFromRangeContainEffectRange) {
        const relative = getRelative(_effectRange, fromRange);
        const newLine = getAbsolute(relative, _toRange);
        _effectRange.start = newLine.start;
        _effectRange.end = newLine.end;
      } else if (fromRangeIntersectsEffectRange.start > fromRange.start) {
        _effectRange.end -= fromRangeIntersectsEffectRangeStep;
      } else {
        if (isToLargeFrom) {
          _effectRange.end -= fromRangeIntersectsEffectRangeStep;
        } else {
          _effectRange.start -= fromRangeStep;
          _effectRange.end -= fromRangeStep + fromRangeIntersectsEffectRangeStep;
        }
      }
    }
    const toRangeIntersectsEffectRange = getIntersects(_toRange, _effectRange);
    if (_toRange.start <= _effectRange.start && !isFromRangeContainEffectRange) {
      _effectRange.start += toRangeStep;
      _effectRange.end += toRangeStep;
    } else if (toRangeIntersectsEffectRange) {
      const insertStart = _toRange.start;
      if (getLength(toRangeIntersectsEffectRange) <= getLength(_effectRange)) {
        return { step: _effectRange.start - effectRange.start, length: 0 };
      }
      if (insertStart < _effectRange.start) {
        _effectRange.start += toRangeStep;
        _effectRange.end += toRangeStep;
      } else if (insertStart >= _effectRange.start && insertStart <= _effectRange.end) {
        _effectRange.end += toRangeStep;
        _effectRange.start += toRangeStep;
      }
    }
    return {
      step: _effectRange.start - effectRange.start,
      length: getLength(_effectRange) - getLength(effectRange)
    };
  };
  var handleMoveRows = (params, targetRange) => {
    const { fromRange, toRange } = params.params || {};
    if (!toRange || !fromRange) {
      return [];
    }
    const _fromRange = handleRangeTypeInput(fromRange);
    const _toRange = handleRangeTypeInput(toRange);
    const _targetRange = handleRangeTypeInput(targetRange);
    const result = handleBaseMoveRowsCols(
      { start: _fromRange.startRow, end: _fromRange.endRow },
      { start: _toRange.startRow, end: _toRange.endRow },
      { start: _targetRange.startRow, end: _targetRange.endRow }
    );
    if (result === null) {
      return [
        {
          type: 1 /* Delete */
        }
      ];
    }
    return [
      {
        type: 3 /* VerticalMove */,
        step: result.step || 0,
        length: result.length || 0
      }
    ];
  };
  var handleMoveCols = (params, targetRange) => {
    const { fromRange, toRange } = params.params || {};
    if (!toRange || !fromRange) {
      return [];
    }
    const _fromRange = handleRangeTypeInput(fromRange);
    const _toRange = handleRangeTypeInput(toRange);
    const _targetRange = handleRangeTypeInput(targetRange);
    const result = handleBaseMoveRowsCols(
      { start: _fromRange.startColumn, end: _fromRange.endColumn },
      { start: _toRange.startColumn, end: _toRange.endColumn },
      { start: _targetRange.startColumn, end: _targetRange.endColumn }
    );
    if (result === null) {
      return [
        {
          type: 1 /* Delete */
        }
      ];
    }
    return [
      {
        type: 2 /* HorizontalMove */,
        step: result.step || 0,
        length: result.length || 0
      }
    ];
  };
  var runRefRangeMutations = (operators, range) => {
    let result = { ...range };
    operators.forEach((operator) => {
      switch (operator.type) {
        case 1 /* Delete */: {
          result = null;
          break;
        }
        case 2 /* HorizontalMove */: {
          if (!result) {
            return;
          }
          result.startColumn += operator.step;
          result.endColumn += operator.step + (operator.length || 0);
          break;
        }
        case 3 /* VerticalMove */: {
          if (!result) {
            return;
          }
          result.startRow += operator.step;
          result.endRow += operator.step + (operator.length || 0);
          break;
        }
        case 0 /* Set */: {
          result = operator.range;
          break;
        }
      }
    });
    if (result) {
      if (result.endColumn < result.startColumn || result.endRow < result.startRow) {
        return null;
      }
    }
    return result;
  };

  // ../packages/sheets/src/controllers/merge-cell.controller.ts
  var mutationIdByRowCol = [InsertColMutation.id, InsertRowMutation.id, RemoveColMutation.id, RemoveRowMutation.id];
  var mutationIdArrByMove = [MoveRowsMutation.id, MoveColsMutation.id];
  function getAddMergeMutationRangeByType(selection, type) {
    let ranges = selection;
    if (type !== void 0) {
      const rectangles = [];
      for (let i = 0; i < ranges.length; i++) {
        const { startRow, endRow, startColumn, endColumn } = ranges[i];
        if (type === 1 /* ROWS */) {
          for (let r = startRow; r <= endRow; r++) {
            const data = {
              startRow: r,
              endRow: r,
              startColumn,
              endColumn
            };
            rectangles.push(data);
          }
        } else if (type === 0 /* COLUMNS */) {
          for (let c = startColumn; c <= endColumn; c++) {
            const data = {
              startRow,
              endRow,
              startColumn: c,
              endColumn: c
            };
            rectangles.push(data);
          }
        }
      }
      ranges = rectangles;
    }
    return ranges;
  }
  var MergeCellController = class extends Disposable {
    constructor(_commandService, _refRangeService, _univerInstanceService, _injector, _sheetInterceptorService, _selectionManagerService) {
      super();
      this._commandService = _commandService;
      this._refRangeService = _refRangeService;
      this._univerInstanceService = _univerInstanceService;
      this._injector = _injector;
      this._sheetInterceptorService = _sheetInterceptorService;
      this._selectionManagerService = _selectionManagerService;
      __publicField(this, "disposableCollection", new DisposableCollection());
      this._onRefRangeChange();
      this._initCommandInterceptor();
      this._commandExecutedListener();
    }
    _initCommandInterceptor() {
      const self2 = this;
      this._sheetInterceptorService.interceptCommand({
        getMutations(commandInfo) {
          switch (commandInfo.id) {
            case ClearSelectionAllCommand.id:
            case ClearSelectionFormatCommand.id: {
              const workbook = self2._univerInstanceService.getCurrentUniverSheetInstance();
              const unitId = workbook.getUnitId();
              const worksheet = workbook.getActiveSheet();
              const subUnitId = worksheet.getSheetId();
              const mergeData = worksheet.getConfig().mergeData;
              const selections = self2._selectionManagerService.getSelectionRanges();
              if (selections && selections.length > 0) {
                const isHasMerge = selections.some(
                  (range) => mergeData.some((item) => Rectangle.intersects(item, range))
                );
                if (isHasMerge) {
                  const removeMergeParams = {
                    unitId,
                    subUnitId,
                    ranges: selections
                  };
                  const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(self2._injector, removeMergeParams);
                  const redos = [
                    { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams }
                  ];
                  const undos = [
                    { id: AddWorksheetMergeMutation.id, params: undoRemoveMergeParams }
                  ];
                  return { redos, undos };
                }
              }
            }
          }
          return { redos: [], undos: [] };
        }
      });
    }
    refRangeHandle(config2, unitId, subUnitId) {
      switch (config2.id) {
        case EffectRefRangId.MoveColsCommandId: {
          const params = config2.params;
          return this._handleMoveColsCommand(params, unitId, subUnitId);
        }
        case EffectRefRangId.MoveRowsCommandId: {
          const params = config2.params;
          return this._handleMoveRowsCommand(params, unitId, subUnitId);
        }
        case InsertRowCommand.id: {
          const params = config2.params;
          const _unitId = params.unitId || unitId;
          const _subUnitId = params.subUnitId || subUnitId;
          return this._handleInsertRowCommand(params, _unitId, _subUnitId);
        }
        case InsertColCommand.id: {
          const params = config2.params;
          const _unitId = params.unitId || unitId;
          const _subUnitId = params.subUnitId || subUnitId;
          return this._handleInsertColCommand(params, _unitId, _subUnitId);
        }
        case RemoveColCommand.id: {
          const params = config2.params;
          return this._handleRemoveColCommand(params, unitId, subUnitId);
        }
        case RemoveRowCommand.id: {
          const params = config2.params;
          return this._handleRemoveRowCommand(params, unitId, subUnitId);
        }
        case MoveRangeCommand.id: {
          const params = config2.params;
          return this._handleMoveRangeCommand(params, unitId, subUnitId);
        }
        case InsertRangeMoveRightCommand.id: {
          const params = config2.params;
          return this._handleInsertRangeMoveRightCommand(params, unitId, subUnitId);
        }
        case InsertRangeMoveDownCommand.id: {
          const params = config2.params;
          return this._handleInsertRangeMoveDownCommand(params, unitId, subUnitId);
        }
        case DeleteRangeMoveUpCommand.id: {
          const params = config2.params;
          return this._handleDeleteRangeMoveUpCommand(params, unitId, subUnitId);
        }
        case DeleteRangeMoveLeftCommand.id: {
          const params = config2.params;
          return this._handleDeleteRangeMoveLeftCommand(params, unitId, subUnitId);
        }
      }
      return { redos: [], undos: [] };
    }
    _onRefRangeChange() {
      const registerRefRange = (unitId, subUnitId) => {
        const workbook2 = this._univerInstanceService.getUniverSheetInstance(unitId);
        if (!workbook2) {
          return;
        }
        const workSheet = workbook2 == null ? void 0 : workbook2.getSheetBySheetId(subUnitId);
        if (!workSheet) {
          return;
        }
        this.disposableCollection.dispose();
        const mergeData = workSheet.getMergeData();
        const handler = (config2) => {
          return this.refRangeHandle(config2, unitId, subUnitId);
        };
        mergeData.forEach((range) => {
          this.disposableCollection.add(this._refRangeService.registerRefRange(range, handler, unitId, subUnitId));
        });
      };
      this.disposeWithMe(
        this._commandService.onCommandExecuted((commandInfo) => {
          if (commandInfo.id === SetWorksheetActivateCommand.id) {
            const params = commandInfo.params;
            const sheetId = params.subUnitId;
            const unitId = params.unitId;
            if (!sheetId || !unitId) {
              return;
            }
            registerRefRange(unitId, sheetId);
          }
          if (commandInfo.id === AddWorksheetMergeMutation.id) {
            const params = commandInfo.params;
            const sheetId = params.subUnitId;
            const unitId = params.unitId;
            if (!sheetId || !unitId) {
              return;
            }
            registerRefRange(params.unitId, params.subUnitId);
          }
        })
      );
      const workbook = this._univerInstanceService.getCurrentUniverSheetInstance();
      const sheet = workbook.getActiveSheet();
      registerRefRange(workbook.getUnitId(), sheet.getSheetId());
    }
    _handleMoveRowsCommand(params, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const mergeData = [...worksheet.getMergeData()];
      const removeParams = { unitId, subUnitId, ranges: [] };
      const addParams = { unitId, subUnitId, ranges: [] };
      const { fromRange } = params;
      const { startRow: sourceStart, endRow: sourceEnd } = fromRange;
      mergeData.forEach((range) => {
        if (sourceStart <= range.startRow && sourceEnd >= range.endRow) {
          removeParams.ranges.push(range);
          const operation = handleMoveRows({ id: EffectRefRangId.MoveRowsCommandId, params }, range);
          const result = runRefRangeMutations(operation, range);
          result && addParams.ranges.push(result);
        }
      });
      if (removeParams.ranges.length === 0) {
        return this._handleNull();
      }
      const removeUndo = RemoveMergeUndoMutationFactory(this._injector, removeParams);
      const addUndo = AddMergeUndoMutationFactory(this._injector, addParams);
      return {
        redos: [
          { id: RemoveWorksheetMergeMutation.id, params: removeParams },
          {
            id: AddWorksheetMergeMutation.id,
            params: addParams
          }
        ],
        undos: [
          { id: RemoveWorksheetMergeMutation.id, params: addUndo },
          {
            id: AddWorksheetMergeMutation.id,
            params: removeUndo
          }
        ]
      };
    }
    _handleMoveColsCommand(params, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const mergeData = [...worksheet.getMergeData()];
      const removeParams = { unitId, subUnitId, ranges: [] };
      const addParams = { unitId, subUnitId, ranges: [] };
      const { fromRange } = params;
      const { startColumn: sourceStart, endColumn: sourceEnd } = fromRange;
      mergeData.forEach((range) => {
        if (sourceStart <= range.startColumn && sourceEnd >= range.endColumn) {
          removeParams.ranges.push(range);
          const operation = handleMoveCols({ id: EffectRefRangId.MoveColsCommandId, params }, range);
          const result = runRefRangeMutations(operation, range);
          result && addParams.ranges.push(result);
        }
      });
      if (removeParams.ranges.length === 0) {
        return this._handleNull();
      }
      const removeUndo = RemoveMergeUndoMutationFactory(this._injector, removeParams);
      const addUndo = AddMergeUndoMutationFactory(this._injector, addParams);
      return {
        redos: [
          { id: RemoveWorksheetMergeMutation.id, params: removeParams },
          {
            id: AddWorksheetMergeMutation.id,
            params: addParams
          }
        ],
        undos: [
          { id: RemoveWorksheetMergeMutation.id, params: addUndo },
          {
            id: AddWorksheetMergeMutation.id,
            params: removeUndo
          }
        ]
      };
    }
    _handleMoveRangeCommand(params, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const mergeData = worksheet.getMergeData();
      const fromMergeRanges = mergeData.filter((item) => Rectangle.intersects(item, params.fromRange));
      const toMergeRanges = mergeData.filter((item) => Rectangle.intersects(item, params.toRange));
      const willMoveToMergeRanges = fromMergeRanges.map((mergeRange) => Rectangle.getRelativeRange(mergeRange, params.fromRange)).map((relativeRange) => Rectangle.getPositionRange(relativeRange, params.toRange));
      const addMergeCellRanges = getAddMergeMutationRangeByType(willMoveToMergeRanges).filter(
        (range) => !mergeData.some((mergeRange) => Rectangle.equals(range, mergeRange))
      );
      const redos = [
        {
          id: RemoveWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId,
            ranges: fromMergeRanges
          }
        },
        {
          id: RemoveWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId,
            ranges: toMergeRanges
          }
        },
        {
          id: AddWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId,
            ranges: addMergeCellRanges
          }
        }
      ];
      const undos = [
        {
          id: RemoveWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId,
            ranges: addMergeCellRanges
          }
        },
        {
          id: AddWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId,
            ranges: toMergeRanges
          }
        },
        {
          id: AddWorksheetMergeMutation.id,
          params: {
            unitId,
            subUnitId,
            ranges: fromMergeRanges
          }
        }
      ];
      return { redos, undos };
    }
    _handleInsertRowCommand(config2, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const { range } = config2;
      const { startRow, endRow } = range;
      const oldMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
        if (startRow > cell.startRow && startRow <= cell.endRow) {
          mergeCellsHasLapping.push(cell);
        }
        return mergeCellsHasLapping;
      }, []);
      if (oldMergeCells.length === 0) {
        return this._handleNull();
      }
      const newMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
        if (startRow > cell.startRow && startRow <= cell.endRow) {
          const count = endRow - startRow + 1;
          cell.endRow += count;
          if (this._checkIsMergeCell(cell)) {
            mergeCellsHasLapping.push(cell);
          }
        }
        return mergeCellsHasLapping;
      }, []);
      const removeMergeParams = {
        unitId,
        subUnitId,
        ranges: oldMergeCells
      };
      const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
        this._injector,
        removeMergeParams
      );
      const addMergeParams = {
        unitId,
        subUnitId,
        ranges: newMergeCells
      };
      const undoAddMergeParams = AddMergeUndoMutationFactory(
        this._injector,
        addMergeParams
      );
      const redos = [
        { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams },
        { id: AddWorksheetMergeMutation.id, params: addMergeParams }
      ];
      const undos = [
        { id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams },
        { id: AddWorksheetMergeMutation.id, params: undoRemoveMergeParams }
      ];
      return { redos, undos };
    }
    _handleInsertColCommand(config2, unitId, subUnitId) {
      const { range } = config2;
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const { startColumn, endColumn } = range;
      const oldMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
        if (startColumn > cell.startColumn && startColumn <= cell.endColumn) {
          mergeCellsHasLapping.push(cell);
        }
        return mergeCellsHasLapping;
      }, []);
      if (oldMergeCells.length === 0) {
        return this._handleNull();
      }
      const newMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
        if (startColumn > cell.startColumn && startColumn <= cell.endColumn) {
          const count = endColumn - startColumn + 1;
          cell.endColumn += count;
          if (this._checkIsMergeCell(cell)) {
            mergeCellsHasLapping.push(cell);
          }
        }
        return mergeCellsHasLapping;
      }, []);
      const removeMergeParams = {
        unitId,
        subUnitId,
        ranges: oldMergeCells
      };
      const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
        this._injector,
        removeMergeParams
      );
      const addMergeParams = {
        unitId,
        subUnitId,
        ranges: newMergeCells
      };
      const undoAddMergeParams = AddMergeUndoMutationFactory(
        this._injector,
        addMergeParams
      );
      const redos = [
        { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams },
        { id: AddWorksheetMergeMutation.id, params: addMergeParams }
      ];
      const undos = [
        { id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams },
        { id: AddWorksheetMergeMutation.id, params: undoRemoveMergeParams }
      ];
      return { redos, undos };
    }
    _handleRemoveColCommand(config2, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const { range } = config2;
      const { startColumn, endColumn } = range;
      const oldMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
        if (Rectangle.intersects(range, cell)) {
          mergeCellsHasLapping.push(cell);
        }
        return mergeCellsHasLapping;
      }, []);
      if (oldMergeCells.length === 0) {
        return this._handleNull();
      }
      const newMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
        if (Rectangle.intersects(range, cell)) {
          if (startColumn <= cell.startColumn && endColumn >= cell.endColumn) {
            return mergeCellsHasLapping;
          } else if (startColumn >= cell.startColumn && endColumn <= cell.endColumn) {
            cell.endColumn -= endColumn - startColumn + 1;
          } else if (startColumn < cell.startColumn) {
            cell.startColumn = startColumn;
            cell.endColumn -= endColumn - startColumn + 1;
          } else if (endColumn > cell.endColumn) {
            cell.endColumn = startColumn - 1;
          }
          if (this._checkIsMergeCell(cell)) {
            mergeCellsHasLapping.push(cell);
          }
        }
        return mergeCellsHasLapping;
      }, []);
      const removeMergeMutationParams = {
        unitId,
        subUnitId,
        ranges: oldMergeCells
      };
      const undoRemoveMergeMutationParams = RemoveMergeUndoMutationFactory(
        this._injector,
        removeMergeMutationParams
      );
      const addMergeMutationParams = {
        unitId,
        subUnitId,
        ranges: newMergeCells
      };
      const undoAddMergeParams = AddMergeUndoMutationFactory(
        this._injector,
        addMergeMutationParams
      );
      const preRedos = [{ id: RemoveWorksheetMergeMutation.id, params: removeMergeMutationParams }];
      const redos = [{ id: AddWorksheetMergeMutation.id, params: addMergeMutationParams }];
      const preUndos = [{ id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams }];
      const undos = [{ id: AddWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams }];
      return { preUndos, undos, preRedos, redos };
    }
    _handleRemoveRowCommand(config2, unitId, subUnitId) {
      const { range } = config2;
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const { startRow, endRow } = range;
      const oldMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
        if (Rectangle.intersects(range, cell)) {
          mergeCellsHasLapping.push(cell);
        }
        return mergeCellsHasLapping;
      }, []);
      if (oldMergeCells.length === 0) {
        return this._handleNull();
      }
      const newMergeCells = Tools.deepClone(worksheet.getMergeData()).reduce((mergeCellsHasLapping, cell) => {
        if (Rectangle.intersects(range, cell)) {
          if (startRow <= cell.startRow && endRow >= cell.endRow) {
            return mergeCellsHasLapping;
          } else if (startRow >= cell.startRow && endRow <= cell.endRow) {
            cell.endRow -= endRow - startRow + 1;
          } else if (startRow < cell.startRow) {
            cell.startRow = startRow;
            cell.endRow -= endRow - startRow + 1;
          } else if (endRow > cell.endRow) {
            cell.endRow = startRow - 1;
          }
          if (this._checkIsMergeCell(cell)) {
            mergeCellsHasLapping.push(cell);
          }
        }
        return mergeCellsHasLapping;
      }, []);
      const removeMergeMutationParams = {
        unitId,
        subUnitId,
        ranges: oldMergeCells
      };
      const undoRemoveMergeMutationParams = RemoveMergeUndoMutationFactory(
        this._injector,
        removeMergeMutationParams
      );
      const addMergeMutationParams = {
        unitId,
        subUnitId,
        ranges: newMergeCells
      };
      const undoAddMergeParams = AddMergeUndoMutationFactory(
        this._injector,
        addMergeMutationParams
      );
      const preRedos = [{ id: RemoveWorksheetMergeMutation.id, params: removeMergeMutationParams }];
      const redos = [{ id: AddWorksheetMergeMutation.id, params: addMergeMutationParams }];
      const preUndos = [{ id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams }];
      const undos = [{ id: AddWorksheetMergeMutation.id, params: undoRemoveMergeMutationParams }];
      return { preUndos, undos, preRedos, redos };
    }
    _handleInsertRangeMoveRightCommand(config2, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const range = config2.range;
      const maxCol = worksheet.getMaxColumns() - 1;
      const mergeData = worksheet.getMergeData();
      const removeMergeData = [];
      const addMergeData = [];
      mergeData.forEach((rect) => {
        const { startRow, endRow, startColumn, endColumn } = range;
        const intersects = Rectangle.intersects(
          {
            startRow,
            startColumn,
            endRow,
            endColumn: maxCol
          },
          rect
        );
        if (intersects) {
          removeMergeData.push(rect);
          const contains = Rectangle.contains(
            {
              startRow,
              startColumn,
              endRow,
              endColumn: maxCol
            },
            rect
          );
          if (contains) {
            const currentColumnsCount = endColumn - startColumn + 1;
            addMergeData.push({
              startRow: rect.startRow,
              startColumn: rect.startColumn + currentColumnsCount,
              endRow: rect.endRow,
              endColumn: rect.endColumn + currentColumnsCount
            });
          }
        }
      });
      const removeMergeParams = {
        unitId,
        subUnitId,
        ranges: removeMergeData
      };
      const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
        this._injector,
        removeMergeParams
      );
      const addMergeParams = {
        unitId,
        subUnitId,
        ranges: addMergeData
      };
      const undoAddMergeParams = AddMergeUndoMutationFactory(
        this._injector,
        addMergeParams
      );
      return {
        redos: [
          { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams },
          {
            id: AddWorksheetMergeMutation.id,
            params: addMergeParams
          }
        ],
        undos: [
          {
            id: AddWorksheetMergeMutation.id,
            params: undoRemoveMergeParams
          },
          { id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams }
        ]
      };
    }
    _handleInsertRangeMoveDownCommand(config2, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const range = config2.range;
      const maxRow = worksheet.getMaxRows() - 1;
      const mergeData = worksheet.getMergeData();
      const removeMergeData = [];
      const addMergeData = [];
      mergeData.forEach((rect) => {
        const { startRow, startColumn, endColumn, endRow } = range;
        const intersects = Rectangle.intersects({ startRow, startColumn, endRow: maxRow, endColumn }, rect);
        if (intersects) {
          removeMergeData.push(rect);
          const contains = Rectangle.contains({ startRow, startColumn, endRow: maxRow, endColumn }, rect);
          if (contains) {
            const rowCount = endRow - startRow + 1;
            addMergeData.push({
              startRow: rect.startRow + rowCount,
              startColumn: rect.startColumn,
              endRow: rect.endRow + rowCount,
              endColumn: rect.endColumn
            });
          }
        }
      });
      const removeMergeParams = {
        unitId,
        subUnitId,
        ranges: removeMergeData
      };
      const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
        this._injector,
        removeMergeParams
      );
      const addMergeParams = {
        unitId,
        subUnitId,
        ranges: addMergeData
      };
      const undoAddMergeParams = AddMergeUndoMutationFactory(
        this._injector,
        addMergeParams
      );
      const redos = [
        {
          id: RemoveWorksheetMergeMutation.id,
          params: removeMergeParams
        },
        {
          id: AddWorksheetMergeMutation.id,
          params: addMergeParams
        }
      ];
      const undos = [
        {
          id: AddWorksheetMergeMutation.id,
          params: undoRemoveMergeParams
        },
        {
          id: RemoveWorksheetMergeMutation.id,
          params: undoAddMergeParams
        }
      ];
      return { redos, undos };
    }
    _handleDeleteRangeMoveUpCommand(config2, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const range = config2.range;
      const maxRow = worksheet.getMaxRows() - 1;
      const mergeData = worksheet.getMergeData();
      const removeMergeData = [];
      const addMergeData = [];
      mergeData.forEach((rect) => {
        const { startRow, startColumn, endColumn, endRow } = range;
        const intersects = Rectangle.intersects({ startRow, startColumn, endRow: maxRow, endColumn }, rect);
        if (intersects) {
          removeMergeData.push(rect);
          const contains = Rectangle.contains({ startRow, startColumn, endRow: maxRow, endColumn }, rect);
          if (contains) {
            const rowCount = endRow - startRow + 1;
            const range2 = Rectangle.moveVertical(rect, -rowCount);
            addMergeData.push(range2);
          }
        }
      });
      const removeMergeParams = {
        unitId,
        subUnitId,
        ranges: removeMergeData
      };
      const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
        this._injector,
        removeMergeParams
      );
      const addMergeParams = {
        unitId,
        subUnitId,
        ranges: addMergeData
      };
      const undoAddMergeParams = AddMergeUndoMutationFactory(
        this._injector,
        addMergeParams
      );
      const redos = [
        {
          id: RemoveWorksheetMergeMutation.id,
          params: removeMergeParams
        },
        {
          id: AddWorksheetMergeMutation.id,
          params: addMergeParams
        }
      ];
      const undos = [
        {
          id: AddWorksheetMergeMutation.id,
          params: undoRemoveMergeParams
        },
        {
          id: RemoveWorksheetMergeMutation.id,
          params: undoAddMergeParams
        }
      ];
      return { redos, undos };
    }
    _handleDeleteRangeMoveLeftCommand(config2, unitId, subUnitId) {
      const workbook = getWorkbook(this._univerInstanceService, unitId);
      if (!workbook) {
        return this._handleNull();
      }
      const worksheet = getWorksheet(workbook, subUnitId);
      if (!worksheet) {
        return this._handleNull();
      }
      const range = config2.range;
      const maxCol = worksheet.getMaxColumns() - 1;
      const mergeData = worksheet.getMergeData();
      const removeMergeData = [];
      const addMergeData = [];
      mergeData.forEach((rect) => {
        const { startRow, endRow, startColumn, endColumn } = range;
        const intersects = Rectangle.intersects(
          {
            startRow,
            startColumn,
            endRow,
            endColumn: maxCol
          },
          rect
        );
        if (intersects) {
          removeMergeData.push(rect);
          const contains = Rectangle.contains(
            {
              startRow,
              startColumn,
              endRow,
              endColumn: maxCol
            },
            rect
          );
          if (contains) {
            const currentColumnsCount = endColumn - startColumn + 1;
            addMergeData.push({
              startRow: rect.startRow,
              startColumn: rect.startColumn - currentColumnsCount,
              endRow: rect.endRow,
              endColumn: rect.endColumn - currentColumnsCount
            });
          }
        }
      });
      const removeMergeParams = {
        unitId,
        subUnitId,
        ranges: removeMergeData
      };
      const undoRemoveMergeParams = RemoveMergeUndoMutationFactory(
        this._injector,
        removeMergeParams
      );
      const addMergeParams = {
        unitId,
        subUnitId,
        ranges: addMergeData
      };
      const undoAddMergeParams = AddMergeUndoMutationFactory(
        this._injector,
        addMergeParams
      );
      return {
        redos: [
          { id: RemoveWorksheetMergeMutation.id, params: removeMergeParams },
          {
            id: AddWorksheetMergeMutation.id,
            params: addMergeParams
          }
        ],
        undos: [
          {
            id: AddWorksheetMergeMutation.id,
            params: undoRemoveMergeParams
          },
          { id: RemoveWorksheetMergeMutation.id, params: undoAddMergeParams }
        ]
      };
    }
    _checkIsMergeCell(cell) {
      return !(cell.startRow === cell.endRow && cell.startColumn === cell.endColumn);
    }
    _handleNull() {
      return { redos: [], undos: [] };
    }
    _commandExecutedListener() {
      this.disposeWithMe(this._commandService.onCommandExecuted((command) => {
        if (mutationIdArrByMove.includes(command.id)) {
          if (!command.params)
            return;
          const workbook = this._univerInstanceService.getUniverSheetInstance(command.params.unitId);
          if (!workbook)
            return;
          const worksheet = workbook.getSheetBySheetId(command.params.subUnitId);
          if (!worksheet)
            return;
          const { sourceRange, targetRange } = command.params;
          const isRowMove = sourceRange.startColumn === targetRange.startColumn && sourceRange.endColumn === targetRange.endColumn;
          const moveLength = isRowMove ? sourceRange.endRow - sourceRange.startRow + 1 : sourceRange.endColumn - sourceRange.startColumn + 1;
          const sourceStart = isRowMove ? sourceRange.startRow : sourceRange.startColumn;
          const targetStart = isRowMove ? targetRange.startRow : targetRange.startColumn;
          const mergeData = worksheet.getConfig().mergeData;
          const adjustedMergedCells = [];
          mergeData.forEach((merge) => {
            let { startRow, endRow, startColumn, endColumn, rangeType } = merge;
            if (!Rectangle.intersects(merge, sourceRange)) {
              if (isRowMove) {
                if (sourceStart < startRow && targetStart > endRow) {
                  startRow -= moveLength;
                  endRow -= moveLength;
                } else if (sourceStart > endRow && targetStart <= startRow) {
                  startRow += moveLength;
                  endRow += moveLength;
                }
              } else {
                if (sourceStart < startColumn && targetStart > endColumn) {
                  startColumn -= moveLength;
                  endColumn -= moveLength;
                } else if (sourceStart > endColumn && targetStart <= startColumn) {
                  startColumn += moveLength;
                  endColumn += moveLength;
                }
              }
            }
            if (!(merge.startRow === merge.endRow && merge.startColumn === merge.endColumn)) {
              adjustedMergedCells.push({ startRow, endRow, startColumn, endColumn, rangeType });
            }
          });
          worksheet.getConfig().mergeData = adjustedMergedCells;
          this.disposableCollection.dispose();
          const { unitId, subUnitId } = command.params;
          const handler = (config2) => {
            return this.refRangeHandle(config2, unitId, subUnitId);
          };
          adjustedMergedCells.forEach((range) => {
            this.disposableCollection.add(this._refRangeService.registerRefRange(range, handler, unitId, subUnitId));
          });
        }
        if (mutationIdByRowCol.includes(command.id)) {
          const workbook = this._univerInstanceService.getUniverSheetInstance(command.params.unitId);
          if (!workbook)
            return;
          const worksheet = workbook.getSheetBySheetId(command.params.subUnitId);
          if (!worksheet)
            return;
          const mergeData = worksheet.getConfig().mergeData;
          const params = command.params;
          if (!params)
            return;
          const { range } = params;
          const isRowOperation = command.id.includes("row");
          const isAddOperation = command.id.includes("insert");
          const operationStart = isRowOperation ? range.startRow : range.startColumn;
          const operationEnd = isRowOperation ? range.endRow : range.endColumn;
          const operationCount = operationEnd - operationStart + 1;
          const adjustedMergedCells = [];
          mergeData.forEach((merge) => {
            let { startRow, endRow, startColumn, endColumn, rangeType } = merge;
            if (isAddOperation) {
              if (isRowOperation) {
                if (operationStart <= startRow) {
                  startRow += operationCount;
                  endRow += operationCount;
                }
              } else {
                if (operationStart <= startColumn) {
                  startColumn += operationCount;
                  endColumn += operationCount;
                }
              }
            } else {
              if (isRowOperation) {
                if (operationEnd < startRow) {
                  startRow -= operationCount;
                  endRow -= operationCount;
                }
              } else {
                if (operationEnd < startColumn) {
                  startColumn -= operationCount;
                  endColumn -= operationCount;
                }
              }
            }
            if (!(merge.startRow === merge.endRow && merge.startColumn === merge.endColumn)) {
              adjustedMergedCells.push({ startRow, endRow, startColumn, endColumn, rangeType });
            }
          });
          worksheet.getConfig().mergeData = adjustedMergedCells;
          this.disposableCollection.dispose();
          const { unitId, subUnitId } = command.params;
          const handler = (config2) => {
            return this.refRangeHandle(config2, unitId, subUnitId);
          };
          adjustedMergedCells.forEach((range2) => {
            this.disposableCollection.add(this._refRangeService.registerRefRange(range2, handler, unitId, subUnitId));
          });
        }
      }));
    }
  };
  MergeCellController = __decorateClass([
    OnLifecycle(3 /* Steady */, MergeCellController),
    __decorateParam(0, Inject(ICommandService)),
    __decorateParam(1, Inject(RefRangeService)),
    __decorateParam(2, Inject(IUniverInstanceService)),
    __decorateParam(3, Inject(Injector)),
    __decorateParam(4, Inject(SheetInterceptorService)),
    __decorateParam(5, Inject(SelectionManagerService))
  ], MergeCellController);
  function getWorkbook(univerInstanceService, unitId) {
    if (unitId) {
      return univerInstanceService.getUniverSheetInstance(unitId);
    }
    return univerInstanceService.getCurrentUniverSheetInstance();
  }
  function getWorksheet(workbook, subUnitId) {
    if (subUnitId) {
      return workbook.getSheetBySheetId(subUnitId);
    }
    return workbook.getActiveSheet();
  }

  // ../packages/sheets/src/locale/zh-CN.ts
  var locale = {
    sheets: {
      sheetCopy: "\uFF08\u526F\u672C\uFF09",
      sheet: "\u5DE5\u4F5C\u8868"
    }
  };
  var zh_CN_default = locale;

  // ../packages/sheets/src/services/numfmt/numfmt.service.ts
  var SHEET_NUMFMT_PLUGIN = "SHEET_NUMFMT_PLUGIN";
  var millisecondsPerDay = 24 * 60 * 60 * 1e3;
  var NumfmtService = class extends Disposable {
    constructor(_commandService, _resourceManagerService, _univerInstanceService, _logService) {
      super();
      this._commandService = _commandService;
      this._resourceManagerService = _resourceManagerService;
      this._univerInstanceService = _univerInstanceService;
      this._logService = _logService;
      /**
       * Map<unitID ,<sheetId ,ObjectMatrix>>
       * @type {Map<string, Map<string, ObjectMatrix<INumfmtItemWithCache>>>}
       * @memberof NumfmtService
       */
      __publicField(this, "_numfmtModel", /* @__PURE__ */ new Map());
      __publicField(this, "_refAliasModel", /* @__PURE__ */ new Map());
      __publicField(this, "_modelReplace$", new Subject());
      __publicField(this, "modelReplace$", this._modelReplace$.asObservable());
      this._initModel();
      this.disposeWithMe(
        toDisposable(() => {
          this._numfmtModel.clear();
          this._refAliasModel.clear();
        })
      );
    }
    _initModel() {
      const handleWorkbookAdd = (workbook) => {
        const unitID = workbook.getUnitId();
        this.disposeWithMe(
          this._resourceManagerService.registerPluginResource(unitID, SHEET_NUMFMT_PLUGIN, {
            toJson: (unitID2) => this._toJson(unitID2),
            parseJson: (json) => this._parseJson(json),
            onChange: (unitID2, value) => {
              const { model, refModel } = value;
              if (model) {
                const parseModel = Object.keys(model).reduce((result, sheetId) => {
                  result.set(sheetId, new ObjectMatrix(model[sheetId]));
                  return result;
                }, /* @__PURE__ */ new Map());
                this._numfmtModel.set(unitID2, parseModel);
              }
              if (refModel) {
                this._refAliasModel.set(
                  unitID2,
                  new RefAlias(refModel, ["pattern", "i"])
                );
              }
              this._modelReplace$.next(unitID2);
            }
          })
        );
      };
      this.disposeWithMe(toDisposable(this._univerInstanceService.sheetAdded$.subscribe(handleWorkbookAdd)));
      this.disposeWithMe(
        toDisposable(
          this._univerInstanceService.sheetDisposed$.subscribe((workbook) => {
            const unitID = workbook.getUnitId();
            const model = this._numfmtModel.get(unitID);
            if (model) {
              this._numfmtModel.delete(unitID);
            }
            const refModel = this._refAliasModel.get(unitID);
            if (refModel) {
              this._refAliasModel.delete(unitID);
            }
            this._resourceManagerService.disposePluginResource(unitID, SHEET_NUMFMT_PLUGIN);
          })
        )
      );
      const workbooks = this._univerInstanceService.getAllUniverSheetsInstance();
      workbooks.forEach((workbook) => handleWorkbookAdd(workbook));
    }
    _toJson(unitID) {
      const workbookModel = this._numfmtModel.get(unitID);
      const workbookRefModel = this._refAliasModel.get(unitID);
      if (!workbookModel || !workbookRefModel) {
        return "";
      }
      const model = [...workbookModel.keys()].reduce(
        (result, key) => {
          const object = workbookModel.get(key);
          result[key] = object.toJSON();
          return result;
        },
        {}
      );
      const refModel = workbookRefModel.getValues().filter((item) => item.count > 0);
      const obj = { model, refModel };
      return JSON.stringify(obj);
    }
    _parseJson(json) {
      try {
        const obj = JSON.parse(json);
        return obj;
      } catch (err) {
        return { model: {}, refModel: [] };
      }
    }
    _setValue(unitId, subUnitId, row, col, value) {
      let model = this.getModel(unitId, subUnitId);
      if (!model) {
        const worksheetMap = this._numfmtModel.get(unitId) || /* @__PURE__ */ new Map();
        const worksheetModel = worksheetMap.get(subUnitId) || new ObjectMatrix();
        worksheetMap.set(subUnitId, worksheetModel);
        this._numfmtModel.set(unitId, worksheetMap);
        model = worksheetModel;
      }
      if (value) {
        model.setValue(row, col, value);
      } else {
        model.realDeleteValue(row, col);
        const size = model.getSizeOf();
        if (!size) {
          const workbookModel = this._numfmtModel.get(unitId);
          workbookModel == null ? void 0 : workbookModel.delete(subUnitId);
        }
      }
    }
    _getUniqueRefId(unitID) {
      const refModel = this._refAliasModel.get(unitID);
      if (!refModel) {
        return "0";
      }
      const keyList = refModel.getKeyMap("i");
      const maxId = Math.max(...keyList.map((item) => Number(item || 0)), 0);
      return `${maxId + 1}`;
    }
    getValue(unitId, subUnitId, row, col, model) {
      const _model = model || this.getModel(unitId, subUnitId);
      if (!_model) {
        return null;
      }
      const refMode = this._refAliasModel.get(unitId);
      const value = _model.getValue(row, col);
      if (value && refMode) {
        const refValue = refMode.getValue(value == null ? void 0 : value.i, ["i"]);
        if (!refValue) {
          this._logService.error("[Numfmt Service]:", "RefAliasModel is not match model");
          return null;
        }
        return {
          pattern: refValue.pattern,
          type: refValue.type
        };
      }
      return null;
    }
    deleteValues(unitId, subUnitId, values) {
      let refModel = this._refAliasModel.get(unitId);
      const model = this.getModel(unitId, subUnitId);
      if (!refModel) {
        refModel = new RefAlias([], ["pattern", "i"]);
        this._refAliasModel.set(unitId, refModel);
      }
      values.forEach((range) => {
        Range.foreach(range, (row, col) => {
          const oldValue = this.getValue(unitId, subUnitId, row, col, model);
          if (oldValue && oldValue.pattern) {
            const oldRefPattern = refModel.getValue(oldValue.pattern, ["pattern"]);
            if (oldRefPattern) {
              oldRefPattern.count--;
            }
          }
          this._setValue(unitId, subUnitId, row, col, null);
        });
      });
    }
    setValues(unitId, subUnitId, values) {
      const model = this.getModel(unitId, subUnitId);
      let refModel = this._refAliasModel.get(unitId);
      if (!refModel) {
        refModel = new RefAlias([], ["pattern", "i"]);
        this._refAliasModel.set(unitId, refModel);
      }
      values.forEach((value) => {
        let refPattern = refModel.getValue(value.pattern, ["pattern"]);
        if (!refPattern) {
          refPattern = {
            count: 0,
            i: this._getUniqueRefId(unitId),
            pattern: value.pattern,
            type: values[0].type
          };
          refModel.addValue(refPattern);
        }
        value.ranges.forEach((range) => {
          Range.foreach(range, (row, col) => {
            if (model) {
              const oldValue = this.getValue(unitId, subUnitId, row, col, model);
              if (oldValue && oldValue.pattern) {
                const oldRefPattern = refModel.getValue(oldValue.pattern, ["pattern"]);
                if (oldRefPattern) {
                  oldRefPattern.count--;
                }
              }
            }
            this._setValue(unitId, subUnitId, row, col, {
              i: refPattern.i
            });
            refPattern.count++;
          });
        });
      });
    }
    getModel(unitId, subUnitId) {
      const workbookModel = this._numfmtModel.get(unitId);
      const sheetModel = workbookModel == null ? void 0 : workbookModel.get(subUnitId);
      return sheetModel;
    }
    getRefModel(unitId) {
      const refModel = this._refAliasModel.get(unitId);
      return refModel;
    }
    serialTimeToTimestamp(serialValue, is1900 = true) {
      const excelBaseDate = (/* @__PURE__ */ new Date("1900-01-01")).getTime();
      const timestamp = (serialValue - (is1900 ? 25569 : 24107)) * millisecondsPerDay + excelBaseDate;
      return timestamp;
    }
  };
  NumfmtService = __decorateClass([
    __decorateParam(0, Inject(ICommandService)),
    __decorateParam(1, Inject(IResourceManagerService)),
    __decorateParam(2, Inject(IUniverInstanceService)),
    __decorateParam(3, Inject(ILogService))
  ], NumfmtService);

  // ../packages/sheets/src/services/permission/permission-point.ts
  var SheetEditablePermissionPoint = "univer.sheet.editable";
  var SheetEditablePermission = class extends PermissionPoint {
    constructor(_unitId, _subUnitId) {
      super();
      this._unitId = _unitId;
      this._subUnitId = _subUnitId;
      __publicField(this, "id", SheetEditablePermissionPoint);
      __publicField(this, "value", true);
      __publicField(this, "unitID");
      this.unitID = _unitId;
      this.id = `${SheetEditablePermissionPoint}_${_unitId}_${_subUnitId}`;
    }
  };

  // ../packages/sheets/src/services/permission/sheet-permission.service.ts
  var SheetPermissionService = class extends Disposable {
    constructor(_permissionService, _univerInstanceService, _sheetInterceptorService) {
      super();
      this._permissionService = _permissionService;
      this._univerInstanceService = _univerInstanceService;
      this._sheetInterceptorService = _sheetInterceptorService;
      this._init();
      this._interceptCommandPermission();
    }
    _init() {
      const workbook = this._univerInstanceService.getCurrentUniverSheetInstance();
      const unitId = workbook.getUnitId();
      workbook.getSheets().forEach((worksheet) => {
        const subUnitId = worksheet.getSheetId();
        const sheetPermission = new SheetEditablePermission(unitId, subUnitId);
        this._permissionService.addPermissionPoint(workbook.getUnitId(), sheetPermission);
      });
      this.disposeWithMe(
        toDisposable(
          workbook.sheetCreated$.subscribe((worksheet) => {
            const subUnitId = worksheet.getSheetId();
            const sheetPermission = new SheetEditablePermission(unitId, subUnitId);
            this._permissionService.addPermissionPoint(workbook.getUnitId(), sheetPermission);
          })
        )
      );
      this.disposeWithMe(
        toDisposable(
          workbook.sheetDisposed$.subscribe((worksheet) => {
            const subUnitId = worksheet.getSheetId();
            const sheetPermission = new SheetEditablePermission(unitId, subUnitId);
            this._permissionService.deletePermissionPoint(workbook.getUnitId(), sheetPermission.id);
          })
        )
      );
    }
    _interceptCommandPermission() {
      this.disposeWithMe(
        this._sheetInterceptorService.intercept(INTERCEPTOR_POINT.PERMISSION, {
          priority: 99,
          handler: (_value, commandInfo, next) => {
            const workbook = this._univerInstanceService.getCurrentUniverSheetInstance();
            const sheet = workbook == null ? void 0 : workbook.getActiveSheet();
            const unitId = workbook == null ? void 0 : workbook.getUnitId();
            const sheetId = sheet == null ? void 0 : sheet.getSheetId();
            if (!unitId || !sheetId) {
              return false;
            }
            switch (commandInfo.id) {
              case SetRangeValuesCommand.id: {
                return this.getSheetEditable(unitId, sheetId);
              }
            }
            return next();
          }
        })
      );
    }
    getEditable$(unitId, sheetId) {
      const workbook = this._univerInstanceService.getCurrentUniverSheetInstance();
      const _unitId = unitId || workbook.getUnitId();
      const sheet = workbook.getActiveSheet();
      const _sheetId = sheetId || sheet.getSheetId();
      const sheetPermission = new SheetEditablePermission(_unitId, _sheetId);
      return this._permissionService.composePermission$(_unitId, [UniverEditablePermissionPoint, sheetPermission.id]).pipe(
        map(([univerEditable, sheetEditable]) => {
          const editable = univerEditable.value && sheetEditable.value;
          const status = getTypeFromPermissionItemList([univerEditable, sheetEditable]);
          return { value: editable, status };
        })
      );
    }
    getSheetEditable(unitId, sheetId) {
      const workbook = this._univerInstanceService.getCurrentUniverSheetInstance();
      const _unitId = unitId || workbook.getUnitId();
      const sheet = workbook.getActiveSheet();
      const _sheetId = sheetId || sheet.getSheetId();
      const sheetPermission = new SheetEditablePermission(_unitId, _sheetId);
      return this._permissionService.composePermission(_unitId, [UniverEditablePermissionPoint, sheetPermission.id]).every((item) => item.value);
    }
    setSheetEditable(v, unitId, sheetId) {
      const workbook = this._univerInstanceService.getCurrentUniverSheetInstance();
      const _unitId = unitId || workbook.getUnitId();
      const sheet = workbook.getActiveSheet();
      const _sheetId = sheetId || sheet.getSheetId();
      const sheetPermission = new SheetEditablePermission(_unitId, _sheetId);
      this._permissionService.updatePermissionPoint(_unitId, sheetPermission.id, v);
    }
  };
  SheetPermissionService = __decorateClass([
    OnLifecycle(1 /* Ready */, SheetPermissionService),
    __decorateParam(0, Inject(IPermissionService)),
    __decorateParam(1, Inject(IUniverInstanceService)),
    __decorateParam(2, Inject(SheetInterceptorService))
  ], SheetPermissionService);

  // ../packages/sheets/src/sheets-plugin.ts
  var PLUGIN_NAME2 = "sheet";
  var UniverSheetsPlugin = class extends Plugin {
    constructor(_config, _commandService, _localeService, _injector) {
      super(PLUGIN_NAME2);
      this._config = _config;
      this._commandService = _commandService;
      this._localeService = _localeService;
      this._injector = _injector;
      this._initializeDependencies(_injector);
    }
    onRendered() {
      this._localeService.load({
        zhCN: zh_CN_default
      });
    }
    _initializeDependencies(sheetInjector) {
      var _a2;
      const dependencies = [
        // services
        [BorderStyleManagerService],
        [SelectionManagerService],
        [RefRangeService],
        [SheetPermissionService],
        [INumfmtService, { useClass: NumfmtService }],
        [SheetInterceptorService],
        // controllers
        [BasicWorksheetController],
        [MergeCellController]
      ];
      if (!((_a2 = this._config) == null ? void 0 : _a2.notExecuteFormula)) {
        dependencies.push([CalculateResultApplyController], [FeatureCalculationController]);
      }
      dependencies.forEach((d) => {
        sheetInjector.add(d);
      });
    }
  };
  __publicField(UniverSheetsPlugin, "type", 2 /* Sheet */);
  UniverSheetsPlugin = __decorateClass([
    __decorateParam(1, ICommandService),
    __decorateParam(2, Inject(LocaleService)),
    __decorateParam(3, Inject(Injector))
  ], UniverSheetsPlugin);

  // ../packages/sheets/src/basics/const/command-listener-const.ts
  var COMMAND_LISTENER_SKELETON_CHANGE = [
    SetWorksheetRowHeightMutation.id,
    SetWorksheetRowIsAutoHeightMutation.id,
    SetWorksheetRowAutoHeightMutation.id,
    SetWorksheetColWidthMutation.id,
    SetWorksheetActiveOperation.id,
    MoveRowsMutation.id,
    MoveColsMutation.id,
    SetColHiddenMutation.id,
    SetColVisibleMutation.id,
    SetRowHiddenMutation.id,
    SetRowVisibleMutation.id,
    InsertColMutation.id,
    InsertRowMutation.id,
    RemoveColMutation.id,
    RemoveRowMutation.id
  ];
  var COMMAND_LISTENER_VALUE_CHANGE = [
    SetRangeValuesMutation.id,
    MoveRangeMutation.id,
    RemoveWorksheetMergeMutation.id,
    AddWorksheetMergeMutation.id
  ];

  // ../packages/engine-render/src/basics/const.ts
  var MIDDLE_CELL_POS_MAGIC_NUMBER = 1;
  var DEFAULT_FONTFACE_PLANE = '"Helvetica Neue", Helvetica, Arial, "PingFang SC", "Hiragino Sans GB", "Heiti SC", "Microsoft YaHei", "WenQuanYi Micro Hei", sans-serif';
  var DEFAULT_SKELETON_HEADER_FOOTER = {
    lines: [],
    drawings: /* @__PURE__ */ new Map(),
    height: 0,
    st: 0,
    ed: 0,
    marginLeft: 0
  };
  var DEFAULT_SKELETON_HEADER = {
    ...DEFAULT_SKELETON_HEADER_FOOTER,
    marginTop: 20
  };
  var DEFAULT_SKELETON_FOOTER = {
    ...DEFAULT_SKELETON_HEADER_FOOTER,
    marginBottom: 20
  };
  var DEFAULT_MEASURE_TEXT = "0";
  var DEFAULT_OFFSET_SPACING = 1;
  var DEFAULT_DOCUMENT_FONTSIZE = 14;
  var COLOR_BLACK_RGB = "rgb(0,0,0)";
  var MAXIMUM_ROW_HEIGHT2 = 2e3;
  var FIX_ONE_PIXEL_BLUR_OFFSET = 0.5;

  // ../node_modules/.pnpm/regexp-util@2.0.0/node_modules/regexp-util/lib/base.js
  var Base = class {
    isEmpty() {
      return this._isEmpty();
    }
    toString(flags) {
      if (this.isEmpty()) {
        throw new Error(`Output is empty.`);
      }
      return this._toString(flags);
    }
    toRegExp(flags) {
      return new RegExp(this.toString(flags), flags);
    }
  };

  // ../node_modules/.pnpm/regexp-util@2.0.0/node_modules/regexp-util/lib/charset.js
  var Charset = class _Charset extends Base {
    constructor(...inputs) {
      super();
      this.data = [];
      for (const input of inputs) {
        if (input instanceof _Charset) {
          this.data.push(...input.data);
        } else {
          this.data.push(normalize(input));
        }
      }
      this._unique();
    }
    union(...inputs) {
      return new _Charset(this, ...inputs);
    }
    subtract(...inputs) {
      const currentData = this.data.slice();
      const newData = [];
      let subtractIndex = 0;
      const { data: subtractData } = new _Charset(...inputs);
      while (currentData.length !== 0) {
        const dataUnit = currentData.shift();
        const [start, end] = dataUnit;
        let isDone;
        do {
          isDone = true;
          const subtractDataUnit = subtractData[subtractIndex];
          if (subtractDataUnit === void 0) {
            newData.push(dataUnit);
            break;
          }
          const [subtractStart, subtractEnd] = subtractDataUnit;
          if (subtractEnd < start) {
            isDone = false;
            subtractIndex++;
          } else if (end < subtractStart) {
            newData.push(dataUnit);
          } else if (subtractStart <= start && subtractEnd < end) {
            subtractIndex++;
            currentData.unshift([subtractEnd + 1, end]);
          } else if (start < subtractStart && subtractEnd < end) {
            subtractIndex++;
            newData.push([start, subtractStart - 1]);
            currentData.unshift([subtractEnd + 1, end]);
          } else if (start < subtractStart && end <= subtractEnd) {
            newData.push([start, subtractStart - 1]);
          }
        } while (!isDone);
      }
      return new _Charset(...newData);
    }
    intersect(...inputs) {
      return this.subtract(this.subtract(...inputs));
    }
    _isEmpty() {
      return this.data.length === 0;
    }
    _toString(flags) {
      return rangesToString(this.data, flags);
    }
    _unique() {
      this.data.sort(compare);
      const newData = [];
      let lastDataUnit = null;
      for (const dataUnit of this.data) {
        if (lastDataUnit === null || lastDataUnit[1] + 1 < dataUnit[0]) {
          newData.push(dataUnit);
          lastDataUnit = dataUnit;
        } else {
          newData.splice(-1, 1, [
            Math.min(dataUnit[0], lastDataUnit[0]),
            Math.max(dataUnit[1], lastDataUnit[1])
          ]);
          lastDataUnit = newData[newData.length - 1];
        }
      }
      this.data = newData;
    }
  };
  var charset = (...inputs) => new Charset(...inputs);
  function charCode(char) {
    if (char.length !== 1) {
      const display = `${char.length} (${JSON.stringify(char)})`;
      throw new Error(`Expected length = 1, but received ${display}.`);
    }
    return char.charCodeAt(0);
  }
  function normalize(rawInput) {
    if (typeof rawInput === "number" && (rawInput < 0 || rawInput > 1114111)) {
      throw new Error(`Invalid unicode code point detected: ${rawInput < 0 ? rawInput : `0x${rawInput.toString(16)}`}`);
    }
    const [normalized] = [rawInput].map((_820) => typeof _820 !== "object" ? [_820, _820] : _820).map((_820) => _820.map((u) => typeof u === "string" ? charCode(u) : u));
    return normalized;
  }
  function compare(a, b) {
    return a[0] - b[0];
  }
  function rangesToString(ranges, flags = "") {
    if (flags.includes("u")) {
      return normalToPattern(ranges, true);
    }
    const { normal, surrogate } = splitRanges(ranges);
    const patterns = [];
    if (normal.length !== 0) {
      patterns.push(normalToPattern(normal, false));
    }
    patterns.push(...surrogateToPatterns(surrogate));
    return patterns.join("|");
  }
  function normalToPattern(normal, hasUnicodeFlag) {
    const ranges = normal.map(([start, end]) => start === end ? unicode(start, hasUnicodeFlag) : `${unicode(start, hasUnicodeFlag)}-${unicode(end, hasUnicodeFlag)}`);
    return `[${ranges.join("")}]`;
  }
  function surrogateToPatterns(surrogate) {
    const patterns = [];
    if (surrogate.entire.data.length !== 0) {
      const h = surrogate.entire.toString();
      const l = `[${[
        56320,
        57343
        /* SurrogateLimit.MaxL */
      ].map((_820) => unicode(_820, false)).join("-")}]`;
      patterns.push(`${h}${l}`);
    }
    for (const { h: rawH, l: lCharset } of surrogate.partial) {
      const h = unicode(rawH, false);
      const l = lCharset.toString();
      patterns.push(`${h}${l}`);
    }
    return patterns;
  }
  function splitRanges(data) {
    const normal = [];
    const surrogateRanges = [];
    for (let i = 0; i < data.length; i++) {
      const dataUnit = data[i];
      const [start, end] = dataUnit;
      if (start >= 65536) {
        surrogateRanges.push(...data.slice(i));
        break;
      }
      if (end >= 65536) {
        normal.push([start, 65536 - 1]);
        surrogateRanges.push([65536, end], ...data.slice(i + 1));
        break;
      }
      normal.push(dataUnit);
    }
    return { normal, surrogate: splitSurrogateRanges(surrogateRanges) };
  }
  function splitSurrogateRanges(ranges) {
    const entire = [];
    const partial = [];
    for (const [start, end] of ranges) {
      const startPair = surrogatePair(start);
      const endPair = surrogatePair(end);
      if (startPair.h === endPair.h) {
        addPartialRange(startPair.h, startPair.l, endPair.l);
        continue;
      }
      if (startPair.l === 56320) {
        addEntireRange(startPair.h);
      } else {
        addPartialRange(
          startPair.h,
          startPair.l,
          57343
          /* SurrogateLimit.MaxL */
        );
      }
      for (let h = startPair.h + 1; h < endPair.h; h++) {
        addEntireRange(h);
      }
      if (endPair.l === 57343) {
        addEntireRange(endPair.h);
      } else {
        addPartialRange(endPair.h, 56320, endPair.l);
      }
    }
    return {
      entire: new Charset(...entire),
      partial: partial.map(({ h, l }) => ({ h, l: new Charset(...l) }))
    };
    function addEntireRange(h) {
      entire.push(h);
    }
    function addPartialRange(h, start, end) {
      const lastPartial = partial[partial.length - 1];
      if (lastPartial !== void 0 && lastPartial.h === h) {
        lastPartial.l.push([start, end]);
      } else {
        partial.push({ h, l: [[start, end]] });
      }
    }
  }
  function surrogatePair(codepoint) {
    return {
      h: Math.floor((codepoint - 65536) / 1024) + 55296,
      l: (codepoint - 65536) % 1024 + 56320
    };
  }
  function unicode(char, hasUnicodeFlag) {
    const hex = char.toString(16);
    return hasUnicodeFlag ? `\\u{${hex}}` : `\\u${"0".repeat(4 - hex.length)}${hex}`;
  }

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/index.js
  var data_exports = {};
  __export(data_exports, {
    Bidi_Class: () => Bidi_Class_exports,
    Bidi_Mirroring_Glyph: () => Bidi_Mirroring_Glyph_exports,
    Bidi_Paired_Bracket_Type: () => Bidi_Paired_Bracket_Type_exports,
    Binary_Property: () => Binary_Property_exports,
    Block: () => Block_exports,
    Case_Folding: () => Case_Folding_exports,
    General_Category: () => General_Category_exports,
    Line_Break: () => Line_Break_exports,
    Script: () => Script_exports,
    Script_Extensions: () => Script_Extensions_exports,
    Word_Break: () => Word_Break_exports
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/index.js
  var Binary_Property_exports = {};
  __export(Binary_Property_exports, {
    ASCII: () => ASCII_default,
    ASCII_Hex_Digit: () => ASCII_Hex_Digit_default,
    Alphabetic: () => Alphabetic_default,
    Any: () => Any_default,
    Assigned: () => Assigned_default,
    Bidi_Control: () => Bidi_Control_default,
    Bidi_Mirrored: () => Bidi_Mirrored_default,
    Case_Ignorable: () => Case_Ignorable_default,
    Cased: () => Cased_default,
    Changes_When_Casefolded: () => Changes_When_Casefolded_default,
    Changes_When_Casemapped: () => Changes_When_Casemapped_default,
    Changes_When_Lowercased: () => Changes_When_Lowercased_default,
    Changes_When_NFKC_Casefolded: () => Changes_When_NFKC_Casefolded_default,
    Changes_When_Titlecased: () => Changes_When_Titlecased_default,
    Changes_When_Uppercased: () => Changes_When_Uppercased_default,
    Composition_Exclusion: () => Composition_Exclusion_default,
    Dash: () => Dash_default,
    Default_Ignorable_Code_Point: () => Default_Ignorable_Code_Point_default,
    Deprecated: () => Deprecated_default,
    Diacritic: () => Diacritic_default,
    Emoji: () => Emoji_default,
    Emoji_Component: () => Emoji_Component_default,
    Emoji_Modifier: () => Emoji_Modifier_default,
    Emoji_Modifier_Base: () => Emoji_Modifier_Base_default,
    Emoji_Presentation: () => Emoji_Presentation_default,
    Expands_On_NFC: () => Expands_On_NFC_default,
    Expands_On_NFD: () => Expands_On_NFD_default,
    Expands_On_NFKC: () => Expands_On_NFKC_default,
    Expands_On_NFKD: () => Expands_On_NFKD_default,
    Extended_Pictographic: () => Extended_Pictographic_default,
    Extender: () => Extender_default,
    Full_Composition_Exclusion: () => Full_Composition_Exclusion_default,
    Grapheme_Base: () => Grapheme_Base_default,
    Grapheme_Extend: () => Grapheme_Extend_default,
    Grapheme_Link: () => Grapheme_Link_default,
    Hex_Digit: () => Hex_Digit_default,
    Hyphen: () => Hyphen_default,
    IDS_Binary_Operator: () => IDS_Binary_Operator_default,
    IDS_Trinary_Operator: () => IDS_Trinary_Operator_default,
    ID_Continue: () => ID_Continue_default,
    ID_Start: () => ID_Start_default,
    Ideographic: () => Ideographic_default,
    Join_Control: () => Join_Control_default,
    Logical_Order_Exception: () => Logical_Order_Exception_default,
    Lowercase: () => Lowercase_default,
    Math: () => Math_default,
    Noncharacter_Code_Point: () => Noncharacter_Code_Point_default,
    Other_Alphabetic: () => Other_Alphabetic_default,
    Other_Default_Ignorable_Code_Point: () => Other_Default_Ignorable_Code_Point_default,
    Other_Grapheme_Extend: () => Other_Grapheme_Extend_default,
    Other_ID_Continue: () => Other_ID_Continue_default,
    Other_ID_Start: () => Other_ID_Start_default,
    Other_Lowercase: () => Other_Lowercase_default,
    Other_Math: () => Other_Math_default,
    Other_Uppercase: () => Other_Uppercase_default,
    Pattern_Syntax: () => Pattern_Syntax_default,
    Pattern_White_Space: () => Pattern_White_Space_default,
    Prepended_Concatenation_Mark: () => Prepended_Concatenation_Mark_default,
    Quotation_Mark: () => Quotation_Mark_default,
    Radical: () => Radical_default,
    Regional_Indicator: () => Regional_Indicator_default,
    Sentence_Terminal: () => Sentence_Terminal_default,
    Soft_Dotted: () => Soft_Dotted_default,
    Terminal_Punctuation: () => Terminal_Punctuation_default,
    Unified_Ideograph: () => Unified_Ideograph_default,
    Uppercase: () => Uppercase_default,
    Variation_Selector: () => Variation_Selector_default,
    White_Space: () => White_Space_default,
    XID_Continue: () => XID_Continue_default,
    XID_Start: () => XID_Start_default
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/ASCII.js
  var _2 = [[0, 127]];
  var ASCII_default = _2;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/ASCII_Hex_Digit.js
  var _3 = [[48, 57], [65, 70], [97, 102]];
  var ASCII_Hex_Digit_default = _3;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Alphabetic.js
  var _4 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, 837, [880, 884], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1456, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1488, 1514], [1519, 1522], [1552, 1562], [1568, 1623], [1625, 1631], [1646, 1747], [1749, 1756], [1761, 1768], [1773, 1775], [1786, 1788], 1791, [1808, 1855], [1869, 1969], [1994, 2026], [2036, 2037], 2042, [2048, 2071], [2074, 2092], [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2260, 2271], [2275, 2281], [2288, 2363], [2365, 2380], [2382, 2384], [2389, 2403], [2417, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2493, 2500], [2503, 2504], [2507, 2508], 2510, 2519, [2524, 2525], [2527, 2531], [2544, 2545], 2556, [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2622, 2626], [2631, 2632], [2635, 2636], 2641, [2649, 2652], 2654, [2672, 2677], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2749, 2757], [2759, 2761], [2763, 2764], 2768, [2784, 2787], [2809, 2812], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2877, 2884], [2887, 2888], [2891, 2892], [2902, 2903], [2908, 2909], [2911, 2915], 2929, [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3020], 3024, 3031, [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3133, 3140], [3142, 3144], [3146, 3148], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3200, 3203], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3261, 3268], [3270, 3272], [3274, 3276], [3285, 3286], [3293, 3294], [3296, 3299], [3313, 3315], [3328, 3340], [3342, 3344], [3346, 3386], [3389, 3396], [3398, 3400], [3402, 3404], 3406, [3412, 3415], [3423, 3427], [3450, 3455], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3535, 3540], 3542, [3544, 3551], [3570, 3571], [3585, 3642], [3648, 3654], 3661, [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3769], [3771, 3773], [3776, 3780], 3782, 3789, [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3953, 3971], [3976, 3991], [3993, 4028], [4096, 4150], 4152, [4155, 4159], [4176, 4239], [4250, 4253], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5907], [5919, 5939], [5952, 5971], [5984, 5996], [5998, 6e3], [6002, 6003], [6016, 6067], [6070, 6088], 6103, 6108, [6176, 6264], [6272, 6314], [6320, 6389], [6400, 6430], [6432, 6443], [6448, 6456], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6683], [6688, 6750], [6753, 6772], 6823, [6847, 6848], [6860, 6862], [6912, 6963], [6965, 6979], [6981, 6988], [7040, 7081], [7084, 7087], [7098, 7141], [7143, 7153], [7168, 7222], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7655, 7668], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [9398, 9449], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11744, 11775], 11823, [12293, 12295], [12321, 12329], [12337, 12341], [12344, 12348], [12353, 12438], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42612, 42619], [42623, 42735], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43013], [43015, 43047], [43072, 43123], [43136, 43203], 43205, [43250, 43255], 43259, [43261, 43263], [43274, 43306], [43312, 43346], [43360, 43388], [43392, 43442], [43444, 43455], 43471, [43488, 43503], [43514, 43518], [43520, 43574], [43584, 43597], [43616, 43638], [43642, 43710], 43712, 43714, [43739, 43741], [43744, 43759], [43762, 43765], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44010], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [64285, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65313, 65338], [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66378], [66384, 66426], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], [68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68903], [69248, 69289], [69291, 69292], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69632, 69701], [69745, 69749], [69760, 69816], 69826, [69840, 69864], [69888, 69938], [69956, 69959], [69968, 70002], 70006, [70016, 70079], [70081, 70084], [70094, 70095], 70106, 70108, [70144, 70161], [70163, 70196], 70199, [70206, 70209], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70376], [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70461, 70468], [70471, 70472], [70475, 70476], 70480, 70487, [70493, 70499], [70656, 70721], [70723, 70725], [70727, 70730], [70751, 70753], [70784, 70849], [70852, 70853], 70855, [71040, 71093], [71096, 71102], [71128, 71133], [71168, 71230], 71232, 71236, [71296, 71349], 71352, [71424, 71450], [71453, 71466], [71488, 71494], [71680, 71736], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 71996], [71999, 72002], [72096, 72103], [72106, 72151], [72154, 72159], 72161, [72163, 72164], [72192, 72242], [72245, 72254], [72272, 72343], 72349, [72368, 72440], [72704, 72712], [72714, 72758], [72760, 72766], 72768, [72818, 72847], [72850, 72871], [72873, 72886], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73025], 73027, [73030, 73031], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73110], 73112, [73440, 73462], [73472, 73488], [73490, 73530], [73534, 73536], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], [94031, 94087], [94095, 94111], [94176, 94177], 94179, [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 113822, [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125255, 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [127280, 127305], [127312, 127337], [127344, 127369], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var Alphabetic_default = _4;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Any.js
  var _5 = [[0, 1114111]];
  var Any_default = _5;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Assigned.js
  var _6 = [[0, 887], [890, 895], [900, 906], 908, [910, 929], [931, 1327], [1329, 1366], [1369, 1418], [1421, 1423], [1425, 1479], [1488, 1514], [1519, 1524], [1536, 1805], [1807, 1866], [1869, 1969], [1984, 2042], [2045, 2093], [2096, 2110], [2112, 2139], 2142, [2144, 2154], [2160, 2190], [2192, 2193], [2200, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2558], [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2678], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2801], [2809, 2815], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2935], [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3066], [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3191, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315], [3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3407], [3412, 3427], [3430, 3455], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3572], [3585, 3642], [3647, 3675], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807], [3840, 3911], [3913, 3948], [3953, 3991], [3993, 4028], [4030, 4044], [4046, 4058], [4096, 4293], 4295, 4301, [4304, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4988], [4992, 5017], [5024, 5109], [5112, 5117], [5120, 5788], [5792, 5880], [5888, 5909], [5919, 5942], [5952, 5971], [5984, 5996], [5998, 6e3], [6002, 6003], [6016, 6109], [6112, 6121], [6128, 6137], [6144, 6169], [6176, 6264], [6272, 6314], [6320, 6389], [6400, 6430], [6432, 6443], [6448, 6459], 6464, [6468, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6622, 6683], [6686, 6750], [6752, 6780], [6783, 6793], [6800, 6809], [6816, 6829], [6832, 6862], [6912, 6988], [6992, 7038], [7040, 7155], [7164, 7223], [7227, 7241], [7245, 7304], [7312, 7354], [7357, 7367], [7376, 7418], [7424, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8190], [8192, 8292], [8294, 8305], [8308, 8334], [8336, 8348], [8352, 8384], [8400, 8432], [8448, 8587], [8592, 9254], [9280, 9290], [9312, 11123], [11126, 11157], [11159, 11507], [11513, 11557], 11559, 11565, [11568, 11623], [11631, 11632], [11647, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11744, 11869], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12288, 12351], [12353, 12438], [12441, 12543], [12549, 12591], [12593, 12686], [12688, 12771], [12784, 12830], [12832, 42124], [42128, 42182], [42192, 42539], [42560, 42743], [42752, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43052], [43056, 43065], [43072, 43127], [43136, 43205], [43214, 43225], [43232, 43347], [43359, 43388], [43392, 43469], [43471, 43481], [43486, 43518], [43520, 43574], [43584, 43597], [43600, 43609], [43612, 43714], [43739, 43766], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43883], [43888, 44013], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [55296, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [64285, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64450], [64467, 64911], [64914, 64967], 64975, [65008, 65049], [65056, 65106], [65108, 65126], [65128, 65131], [65136, 65140], [65142, 65276], 65279, [65281, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65504, 65510], [65512, 65518], [65529, 65533], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65792, 65794], [65799, 65843], [65847, 65934], [65936, 65948], 65952, [66e3, 66045], [66176, 66204], [66208, 66256], [66272, 66299], [66304, 66339], [66349, 66378], [66384, 66426], [66432, 66461], [66463, 66499], [66504, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66927, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67671, 67742], [67751, 67759], [67808, 67826], [67828, 67829], [67835, 67867], [67871, 67897], 67903, [67968, 68023], [68028, 68047], [68050, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], [68159, 68168], [68176, 68184], [68192, 68255], [68288, 68326], [68331, 68342], [68352, 68405], [68409, 68437], [68440, 68466], [68472, 68497], [68505, 68508], [68521, 68527], [68608, 68680], [68736, 68786], [68800, 68850], [68858, 68903], [68912, 68921], [69216, 69246], [69248, 69289], [69291, 69293], [69296, 69297], [69373, 69415], [69424, 69465], [69488, 69513], [69552, 69579], [69600, 69622], [69632, 69709], [69714, 69749], [69759, 69826], 69837, [69840, 69864], [69872, 69881], [69888, 69940], [69942, 69959], [69968, 70006], [70016, 70111], [70113, 70132], [70144, 70161], [70163, 70209], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313], [70320, 70378], [70384, 70393], [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70459, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516], [70656, 70747], [70749, 70753], [70784, 70855], [70864, 70873], [71040, 71093], [71096, 71133], [71168, 71236], [71248, 71257], [71264, 71276], [71296, 71353], [71360, 71369], [71424, 71450], [71453, 71467], [71472, 71494], [71680, 71739], [71840, 71922], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72006], [72016, 72025], [72096, 72103], [72106, 72151], [72154, 72164], [72192, 72263], [72272, 72354], [72368, 72440], [72448, 72457], [72704, 72712], [72714, 72758], [72760, 72773], [72784, 72812], [72816, 72847], [72850, 72871], [72873, 72886], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129], [73440, 73464], [73472, 73488], [73490, 73530], [73534, 73561], 73648, [73664, 73713], [73727, 74649], [74752, 74862], [74864, 74868], [74880, 75075], [77712, 77810], [77824, 78933], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92782, 92862], [92864, 92873], [92880, 92909], [92912, 92917], [92928, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071], [93760, 93850], [93952, 94026], [94031, 94087], [94095, 94111], [94176, 94180], [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113820, 113827], [118528, 118573], [118576, 118598], [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119274], [119296, 119365], [119488, 119507], [119520, 119539], [119552, 119638], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 121483], [121499, 121503], [121505, 121519], [122624, 122654], [122661, 122666], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123136, 123180], [123184, 123197], [123200, 123209], [123214, 123215], [123536, 123566], [123584, 123641], 123647, [124112, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125127, 125142], [125184, 125259], [125264, 125273], [125278, 125279], [126065, 126132], [126209, 126269], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127232, 127405], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994], [130032, 130041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743], 917505, [917536, 917631], [917760, 917999], [983040, 1048573], [1048576, 1114109]];
  var Assigned_default = _6;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Bidi_Control.js
  var _7 = [1564, [8206, 8207], [8234, 8238], [8294, 8297]];
  var Bidi_Control_default = _7;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Bidi_Mirrored.js
  var _8 = [[40, 41], 60, 62, 91, 93, 123, 125, 171, 187, [3898, 3901], [5787, 5788], [8249, 8250], [8261, 8262], [8317, 8318], [8333, 8334], 8512, [8705, 8708], [8712, 8717], 8721, [8725, 8726], [8730, 8733], [8735, 8738], 8740, 8742, [8747, 8755], 8761, [8763, 8780], [8786, 8789], [8799, 8800], 8802, [8804, 8811], [8814, 8844], [8847, 8850], 8856, [8866, 8867], [8870, 8888], [8894, 8895], [8905, 8909], [8912, 8913], [8918, 8941], [8944, 8959], [8968, 8971], [8992, 8993], [9001, 9002], [10088, 10101], 10176, [10179, 10182], [10184, 10185], [10187, 10189], [10195, 10198], [10204, 10206], [10210, 10223], [10627, 10648], [10651, 10656], [10658, 10671], 10680, [10688, 10693], 10697, [10702, 10706], [10708, 10709], [10712, 10716], 10721, [10723, 10725], [10728, 10729], [10740, 10745], [10748, 10749], [10762, 10780], [10782, 10785], 10788, 10790, 10793, [10795, 10798], [10804, 10805], [10812, 10814], [10839, 10840], [10852, 10853], [10858, 10861], [10863, 10864], [10867, 10868], [10873, 10915], [10918, 10925], [10927, 10966], 10972, 10974, [10978, 10982], [10988, 10990], 10995, [10999, 11003], 11005, 11262, [11778, 11781], [11785, 11786], [11788, 11789], [11804, 11805], [11808, 11817], [11861, 11868], [12296, 12305], [12308, 12315], [65113, 65118], [65124, 65125], [65288, 65289], 65308, 65310, 65339, 65341, 65371, 65373, [65375, 65376], [65378, 65379], 120539, 120597, 120655, 120713, 120771];
  var Bidi_Mirrored_default = _8;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Case_Ignorable.js
  var _9 = [39, 46, 58, 94, 96, 168, 173, 175, 180, [183, 184], [688, 879], [884, 885], 890, [900, 901], 903, [1155, 1161], 1369, 1375, [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, 1524, [1536, 1541], [1552, 1562], 1564, 1600, [1611, 1631], 1648, [1750, 1757], [1759, 1768], [1770, 1773], 1807, 1809, [1840, 1866], [1958, 1968], [2027, 2037], 2042, 2045, [2070, 2093], [2137, 2139], 2184, [2192, 2193], [2200, 2207], [2249, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2417, 2433, 2492, [2497, 2500], 2509, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, 2879, [2881, 2884], 2893, [2901, 2902], [2914, 2915], 2946, 3008, 3021, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, 3263, 3270, [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], 3405, [3426, 3427], 3457, 3530, [3538, 3540], 3542, 3633, [3636, 3642], [3654, 3662], 3761, [3764, 3772], 3782, [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, 4348, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6103, 6109, [6155, 6159], 6211, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, 6823, [6832, 6862], [6912, 6915], 6964, [6966, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7288, 7293], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7468, 7530], 7544, [7579, 7679], 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [8203, 8207], [8216, 8217], 8228, 8231, [8234, 8238], [8288, 8292], [8294, 8303], 8305, 8319, [8336, 8348], [8400, 8432], [11388, 11389], [11503, 11505], 11631, 11647, [11744, 11775], 11823, 12293, [12330, 12333], [12337, 12341], 12347, [12441, 12446], [12540, 12542], 40981, [42232, 42237], 42508, [42607, 42610], [42612, 42621], 42623, [42652, 42655], [42736, 42737], [42752, 42785], 42864, [42888, 42890], [42994, 42996], [43e3, 43001], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43471, [43493, 43494], [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43632, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, 43741, [43756, 43757], [43763, 43764], 43766, [43867, 43871], [43881, 43883], 44005, 44008, 44013, 64286, [64434, 64450], [65024, 65039], 65043, [65056, 65071], 65106, 65109, 65279, 65287, 65294, 65306, 65342, 65344, 65392, [65438, 65439], 65507, [65529, 65531], 66045, 66272, [66422, 66426], [67456, 67461], [67463, 67504], [67506, 67514], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69821, 69826, 69837, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70464, [70502, 70508], [70512, 70516], [70712, 70719], [70722, 70724], 70726, 70750, [70835, 70840], 70842, [70847, 70848], [70850, 70851], [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, [71453, 71455], [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], 72767, [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, [78896, 78912], [78919, 78933], [92912, 92916], [92976, 92982], [92992, 92995], 94031, [94095, 94111], [94176, 94177], [94179, 94180], [110576, 110579], [110581, 110587], [110589, 110590], [113821, 113822], [113824, 113827], [118528, 118573], [118576, 118598], [119143, 119145], [119155, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123184, 123197], 123566, [123628, 123631], [124139, 124143], [125136, 125142], [125252, 125259], [127995, 127999], 917505, [917536, 917631], [917760, 917999]];
  var Case_Ignorable_default = _9;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Cased.js
  var _10 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 442], [444, 447], [452, 659], [661, 696], [704, 705], [736, 740], 837, [880, 883], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], [1376, 1416], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4351], [5024, 5109], [5112, 5117], [7296, 7304], [7312, 7354], [7357, 7359], [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8500], 8505, [8508, 8511], [8517, 8521], 8526, [8544, 8575], [8579, 8580], [9398, 9449], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [42560, 42605], [42624, 42653], [42786, 42887], [42891, 42894], [42896, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 42998], [43e3, 43002], [43824, 43866], [43868, 43881], [43888, 43967], [64256, 64262], [64275, 64279], [65313, 65338], [65345, 65370], [66560, 66639], [66736, 66771], [66776, 66811], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], 67456, [67459, 67461], [67463, 67504], [67506, 67514], [68736, 68786], [68800, 68850], [71840, 71903], [93760, 93823], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122633], [122635, 122654], [122661, 122666], [122928, 122989], [125184, 125251], [127280, 127305], [127312, 127337], [127344, 127369]];
  var Cased_default = _10;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Casefolded.js
  var _11 = [[65, 90], 181, [192, 214], [216, 223], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, [329, 330], 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, 383, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, [452, 453], [455, 456], [458, 459], 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, [497, 498], 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 837, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 962, [975, 977], [981, 982], 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, [1008, 1009], [1012, 1013], 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], 1415, [4256, 4293], 4295, 4301, [5112, 5117], [7296, 7304], [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, [7834, 7835], 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8064, 8111], [8114, 8116], [8119, 8124], [8130, 8132], [8135, 8140], [8152, 8155], [8168, 8172], [8178, 8180], [8183, 8188], 8486, [8490, 8491], 8498, [8544, 8559], 8579, [9398, 9423], [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, 42997, [43888, 43967], [64256, 64262], [64275, 64279], [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [71840, 71871], [93760, 93791], [125184, 125217]];
  var Changes_When_Casefolded_default = _11;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Casemapped.js
  var _12 = [[65, 90], [97, 122], 181, [192, 214], [216, 246], [248, 311], [313, 396], [398, 410], [412, 425], [428, 441], [444, 445], 447, [452, 544], [546, 563], [570, 596], [598, 599], 601, [603, 604], [608, 609], 611, [613, 614], [616, 620], 623, [625, 626], 629, 637, 640, [642, 643], [647, 652], 658, [669, 670], 837, [880, 883], [886, 887], [891, 893], 895, 902, [904, 906], 908, [910, 929], [931, 977], [981, 1013], [1015, 1019], [1021, 1153], [1162, 1327], [1329, 1366], [1377, 1415], [4256, 4293], 4295, 4301, [4304, 4346], [4349, 4351], [5024, 5109], [5112, 5117], [7296, 7304], [7312, 7354], [7357, 7359], 7545, 7549, 7566, [7680, 7835], 7838, [7840, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8486, [8490, 8491], 8498, 8526, [8544, 8575], [8579, 8580], [9398, 9449], [11264, 11376], [11378, 11379], [11381, 11382], [11390, 11491], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [42560, 42605], [42624, 42651], [42786, 42799], [42802, 42863], [42873, 42887], [42891, 42893], [42896, 42900], [42902, 42926], [42928, 42954], [42960, 42961], [42966, 42969], [42997, 42998], 43859, [43888, 43967], [64256, 64262], [64275, 64279], [65313, 65338], [65345, 65370], [66560, 66639], [66736, 66771], [66776, 66811], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68736, 68786], [68800, 68850], [71840, 71903], [93760, 93823], [125184, 125251]];
  var Changes_When_Casemapped_default = _12;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Lowercased.js
  var _13 = [[65, 90], [192, 214], [216, 222], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, [452, 453], [455, 456], [458, 459], 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, [497, 498], 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 975, 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, 1012, 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], [4256, 4293], 4295, 4301, [5024, 5109], [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8072, 8079], [8088, 8095], [8104, 8111], [8120, 8124], [8136, 8140], [8152, 8155], [8168, 8172], [8184, 8188], 8486, [8490, 8491], 8498, [8544, 8559], 8579, [9398, 9423], [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, 42997, [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [71840, 71871], [93760, 93791], [125184, 125217]];
  var Changes_When_Lowercased_default = _13;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_NFKC_Casefolded.js
  var _14 = [[65, 90], 160, 168, 170, 173, 175, [178, 181], [184, 186], [188, 190], [192, 214], [216, 223], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, [306, 308], 310, 313, 315, 317, [319, 321], 323, 325, 327, [329, 330], 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, 383, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, [452, 461], 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, [497, 500], [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, [688, 696], [728, 733], [736, 740], [832, 833], [835, 837], 847, 880, 882, 884, 886, 890, [894, 895], [900, 906], 908, [910, 911], [913, 929], [931, 939], 962, [975, 982], 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, [1008, 1010], [1012, 1013], 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], 1415, 1564, [1653, 1656], [2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3635, 3763, [3804, 3805], 3852, 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3961], 3969, 3987, 3997, 4002, 4007, 4012, 4025, [4256, 4293], 4295, 4301, 4348, [4447, 4448], [5112, 5117], [6068, 6069], [6155, 6159], [7296, 7304], [7312, 7354], [7357, 7359], [7468, 7470], [7472, 7482], [7484, 7501], [7503, 7530], 7544, [7579, 7615], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, [7834, 7835], 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], 8049, 8051, 8053, 8055, 8057, 8059, 8061, [8064, 8111], [8114, 8116], [8119, 8132], [8135, 8143], 8147, [8152, 8155], [8157, 8159], 8163, [8168, 8175], [8178, 8180], [8183, 8190], [8192, 8207], 8209, 8215, [8228, 8230], [8234, 8239], [8243, 8244], [8246, 8247], 8252, 8254, [8263, 8265], 8279, [8287, 8305], [8308, 8334], [8336, 8348], 8360, [8448, 8451], [8453, 8455], [8457, 8467], [8469, 8470], [8473, 8477], [8480, 8482], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8507, 8512], [8517, 8521], [8528, 8575], 8579, 8585, [8748, 8749], [8751, 8752], [9001, 9002], [9312, 9450], 10764, [10868, 10870], 10972, [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11388, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 11631, 11935, 12019, [12032, 12245], 12288, 12342, [12344, 12346], [12443, 12444], 12447, 12543, [12593, 12686], [12690, 12703], [12800, 12830], [12832, 12871], [12880, 12926], [12928, 13311], 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, [42652, 42653], 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42864, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, [42994, 42997], [43e3, 43001], [43868, 43871], 43881, [43888, 43967], [63744, 64013], 64016, 64018, [64021, 64030], 64032, 64034, [64037, 64038], [64042, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65024, 65049], [65072, 65092], [65095, 65106], [65108, 65126], [65128, 65131], [65136, 65138], 65140, [65142, 65276], 65279, [65281, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65504, 65510], [65512, 65518], [65520, 65528], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [67457, 67461], [67463, 67504], [67506, 67514], [68736, 68786], [71840, 71871], [93760, 93791], [113824, 113827], [119134, 119140], [119155, 119162], [119227, 119232], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 120831], [122928, 122989], [125184, 125217], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [127232, 127242], [127248, 127278], [127280, 127311], [127338, 127340], 127376, [127488, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [130032, 130041], [194560, 195101], [917504, 921599]];
  var Changes_When_NFKC_Casefolded_default = _14;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Titlecased.js
  var _15 = [[97, 122], 181, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, 311, 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, 396, 402, 405, [409, 410], 414, 417, 419, 421, 424, 429, 432, 436, 438, 441, 445, 447, 452, [454, 455], [457, 458], 460, 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 497], 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 547, 549, 551, 553, 555, 557, 559, 561, 563, 572, [575, 576], 578, 583, 585, 587, 589, [591, 596], [598, 599], 601, [603, 604], [608, 609], 611, [613, 614], [616, 620], 623, [625, 626], 629, 637, 640, [642, 643], [647, 652], 658, [669, 670], 837, 881, 883, 887, [891, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, 1019, [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1377, 1415], [5112, 5117], [7296, 7304], 7545, 7549, 7566, 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7835], 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], 8126, [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8526, [8560, 8575], 8580, [9424, 9449], [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11379, 11382, 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, 11491, 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, 42799, 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42897, [42899, 42900], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42961, 42967, 42969, 42998, 43859, [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68800, 68850], [71872, 71903], [93792, 93823], [125218, 125251]];
  var Changes_When_Titlecased_default = _15;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Changes_When_Uppercased.js
  var _16 = [[97, 122], 181, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, 311, 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, 396, 402, 405, [409, 410], 414, 417, 419, 421, 424, 429, 432, 436, 438, 441, 445, 447, [453, 454], [456, 457], [459, 460], 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 496], [498, 499], 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 547, 549, 551, 553, 555, 557, 559, 561, 563, 572, [575, 576], 578, 583, 585, 587, 589, [591, 596], [598, 599], 601, [603, 604], [608, 609], 611, [613, 614], [616, 620], 623, [625, 626], 629, 637, 640, [642, 643], [647, 652], 658, [669, 670], 837, 881, 883, 887, [891, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, 1019, [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1377, 1415], [4304, 4346], [4349, 4351], [5112, 5117], [7296, 7304], 7545, 7549, 7566, 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7835], 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8116], [8118, 8119], 8124, 8126, [8130, 8132], [8134, 8135], 8140, [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8188, 8526, [8560, 8575], 8580, [9424, 9449], [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11379, 11382, 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, 11491, 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, 42799, 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42897, [42899, 42900], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42961, 42967, 42969, 42998, 43859, [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68800, 68850], [71872, 71903], [93792, 93823], [125218, 125251]];
  var Changes_When_Uppercased_default = _16;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Composition_Exclusion.js
  var _17 = [[2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3907, 3917, 3922, 3927, 3932, 3945, 3958, 3960, 3987, 3997, 4002, 4007, 4012, 4025, 10972, 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64334], [119134, 119140], [119227, 119232]];
  var Composition_Exclusion_default = _17;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Dash.js
  var _18 = [45, 1418, 1470, 5120, 6150, [8208, 8213], 8275, 8315, 8331, 8722, 11799, 11802, [11834, 11835], 11840, 11869, 12316, 12336, 12448, [65073, 65074], 65112, 65123, 65293, 69293];
  var Dash_default = _18;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Default_Ignorable_Code_Point.js
  var _19 = [173, 847, 1564, [4447, 4448], [6068, 6069], [6155, 6159], [8203, 8207], [8234, 8238], [8288, 8303], 12644, [65024, 65039], 65279, 65440, [65520, 65528], [113824, 113827], [119155, 119162], [917504, 921599]];
  var Default_Ignorable_Code_Point_default = _19;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Deprecated.js
  var _20 = [329, 1651, 3959, 3961, [6051, 6052], [8298, 8303], [9001, 9002], 917505];
  var Deprecated_default = _20;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Diacritic.js
  var _21 = [94, 96, 168, 175, 180, [183, 184], [688, 846], [848, 855], [861, 866], [884, 885], 890, [900, 901], [1155, 1159], 1369, [1425, 1441], [1443, 1469], 1471, [1473, 1474], 1476, [1611, 1618], [1623, 1624], [1759, 1760], [1765, 1766], [1770, 1772], [1840, 1866], [1958, 1968], [2027, 2037], [2072, 2073], [2200, 2207], [2249, 2258], [2275, 2302], 2364, 2381, [2385, 2388], 2417, 2492, 2509, 2620, 2637, 2748, 2765, [2813, 2815], 2876, 2893, 2901, 3021, 3132, 3149, 3260, 3277, [3387, 3388], 3405, 3530, [3655, 3660], 3662, 3770, [3784, 3788], [3864, 3865], 3893, 3895, 3897, [3902, 3903], [3970, 3972], [3974, 3975], 4038, 4151, [4153, 4154], [4195, 4196], [4201, 4205], [4231, 4237], 4239, [4250, 4251], [4957, 4959], [5908, 5909], [6089, 6099], 6109, [6457, 6459], [6773, 6780], 6783, [6832, 6846], [6849, 6859], 6964, 6980, [7019, 7027], [7082, 7083], [7222, 7223], [7288, 7293], [7376, 7400], 7405, 7412, [7415, 7417], [7468, 7530], [7620, 7631], [7669, 7679], 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [11503, 11505], 11823, [12330, 12335], [12441, 12444], 12540, 42607, [42620, 42621], 42623, [42652, 42653], [42736, 42737], [42752, 42785], [42888, 42890], [43e3, 43001], 43204, [43232, 43249], [43307, 43310], 43347, 43443, 43456, 43493, [43643, 43645], [43711, 43714], 43766, [43867, 43871], [43881, 43883], [44012, 44013], 64286, [65056, 65071], 65342, 65344, 65392, [65438, 65439], 65507, 66272, [67456, 67461], [67463, 67504], [67506, 67514], [68325, 68326], [68898, 68903], [69373, 69375], [69446, 69456], [69506, 69509], 69702, 69744, [69817, 69818], [69939, 69940], 70003, 70080, [70090, 70092], [70197, 70198], [70377, 70378], 70460, 70477, [70502, 70508], [70512, 70516], 70722, 70726, [70850, 70851], [71103, 71104], 71231, [71350, 71351], 71467, [71737, 71738], [71997, 71998], 72003, 72160, 72244, 72263, 72345, 72767, 73026, [73028, 73029], 73111, [78919, 78933], [92912, 92916], [92976, 92982], [94095, 94111], [94192, 94193], [110576, 110579], [110581, 110587], [110589, 110590], [118528, 118573], [118576, 118598], [119143, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [122928, 122989], [123184, 123190], 123566, [123628, 123631], [125136, 125142], [125252, 125254], [125256, 125258]];
  var Diacritic_default = _21;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji.js
  var _22 = [35, 42, [48, 57], 169, 174, 8252, 8265, 8482, 8505, [8596, 8601], [8617, 8618], [8986, 8987], 9e3, 9167, [9193, 9203], [9208, 9210], 9410, [9642, 9643], 9654, 9664, [9723, 9726], [9728, 9732], 9742, 9745, [9748, 9749], 9752, 9757, 9760, [9762, 9763], 9766, 9770, [9774, 9775], [9784, 9786], 9792, 9794, [9800, 9811], [9823, 9824], 9827, [9829, 9830], 9832, 9851, [9854, 9855], [9874, 9879], 9881, [9883, 9884], [9888, 9889], 9895, [9898, 9899], [9904, 9905], [9917, 9918], [9924, 9925], 9928, [9934, 9935], 9937, [9939, 9940], [9961, 9962], [9968, 9973], [9975, 9978], 9981, 9986, 9989, [9992, 9997], 9999, 10002, 10004, 10006, 10013, 10017, 10024, [10035, 10036], 10052, 10055, 10060, 10062, [10067, 10069], 10071, [10083, 10084], [10133, 10135], 10145, 10160, 10175, [10548, 10549], [11013, 11015], [11035, 11036], 11088, 11093, 12336, 12349, 12951, 12953, 126980, 127183, [127344, 127345], [127358, 127359], 127374, [127377, 127386], [127462, 127487], [127489, 127490], 127514, 127535, [127538, 127546], [127568, 127569], [127744, 127777], [127780, 127891], [127894, 127895], [127897, 127899], [127902, 127984], [127987, 127989], [127991, 128253], [128255, 128317], [128329, 128334], [128336, 128359], [128367, 128368], [128371, 128378], 128391, [128394, 128397], 128400, [128405, 128406], [128420, 128421], 128424, [128433, 128434], 128444, [128450, 128452], [128465, 128467], [128476, 128478], 128481, 128483, 128488, 128495, 128499, [128506, 128591], [128640, 128709], [128715, 128722], [128725, 128727], [128732, 128741], 128745, [128747, 128748], 128752, [128755, 128764], [128992, 129003], 129008, [129292, 129338], [129340, 129349], [129351, 129535], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784]];
  var Emoji_default = _22;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji_Component.js
  var _23 = [35, 42, [48, 57], 8205, 8419, 65039, [127462, 127487], [127995, 127999], [129456, 129459], [917536, 917631]];
  var Emoji_Component_default = _23;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji_Modifier.js
  var _24 = [[127995, 127999]];
  var Emoji_Modifier_default = _24;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji_Modifier_Base.js
  var _25 = [9757, 9977, [9994, 9997], 127877, [127938, 127940], 127943, [127946, 127948], [128066, 128067], [128070, 128080], [128102, 128120], 128124, [128129, 128131], [128133, 128135], 128143, 128145, 128170, [128372, 128373], 128378, 128400, [128405, 128406], [128581, 128583], [128587, 128591], 128675, [128692, 128694], 128704, 128716, 129292, 129295, [129304, 129311], 129318, [129328, 129337], [129340, 129342], 129399, [129461, 129462], [129464, 129465], 129467, [129485, 129487], [129489, 129501], [129731, 129733], [129776, 129784]];
  var Emoji_Modifier_Base_default = _25;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Emoji_Presentation.js
  var _26 = [[8986, 8987], [9193, 9196], 9200, 9203, [9725, 9726], [9748, 9749], [9800, 9811], 9855, 9875, 9889, [9898, 9899], [9917, 9918], [9924, 9925], 9934, 9940, 9962, [9970, 9971], 9973, 9978, 9981, 9989, [9994, 9995], 10024, 10060, 10062, [10067, 10069], 10071, [10133, 10135], 10160, 10175, [11035, 11036], 11088, 11093, 126980, 127183, 127374, [127377, 127386], [127462, 127487], 127489, 127514, 127535, [127538, 127542], [127544, 127546], [127568, 127569], [127744, 127776], [127789, 127797], [127799, 127868], [127870, 127891], [127904, 127946], [127951, 127955], [127968, 127984], 127988, [127992, 128062], 128064, [128066, 128252], [128255, 128317], [128331, 128334], [128336, 128359], 128378, [128405, 128406], 128420, [128507, 128591], [128640, 128709], 128716, [128720, 128722], [128725, 128727], [128732, 128735], [128747, 128748], [128756, 128764], [128992, 129003], 129008, [129292, 129338], [129340, 129349], [129351, 129535], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784]];
  var Emoji_Presentation_default = _26;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Expands_On_NFC.js
  var _27 = [836, [2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3958], 3960, 3969, 3987, 3997, 4002, 4007, 4012, 4025, 10972, 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64334], [119134, 119140], [119227, 119232]];
  var Expands_On_NFC_default = _27;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Expands_On_NFD.js
  var _28 = [[192, 197], [199, 207], [209, 214], [217, 221], [224, 229], [231, 239], [241, 246], [249, 253], [255, 271], [274, 293], [296, 304], [308, 311], [313, 318], [323, 328], [332, 337], [340, 357], [360, 382], [416, 417], [431, 432], [461, 476], [478, 483], [486, 496], [500, 501], [504, 539], [542, 543], [550, 563], 836, [901, 902], [904, 906], 908, [910, 912], [938, 944], [970, 974], [979, 980], [1024, 1025], 1027, 1031, [1036, 1038], 1049, 1081, [1104, 1105], 1107, 1111, [1116, 1118], [1142, 1143], [1217, 1218], [1232, 1235], [1238, 1239], [1242, 1247], [1250, 1255], [1258, 1269], [1272, 1273], [1570, 1574], 1728, 1730, 1747, 2345, 2353, 2356, [2392, 2399], [2507, 2508], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, 2888, [2891, 2892], [2908, 2909], 2964, [3018, 3020], 3144, 3264, [3271, 3272], [3274, 3275], [3402, 3404], 3546, [3548, 3550], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3958], 3960, 3969, 3987, 3997, 4002, 4007, 4012, 4025, 4134, 6918, 6920, 6922, 6924, 6926, 6930, 6971, 6973, [6976, 6977], 6979, [7680, 7833], 7835, [7840, 7929], [7936, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], [8129, 8132], [8134, 8147], [8150, 8155], [8157, 8174], [8178, 8180], [8182, 8188], 8491, [8602, 8603], 8622, [8653, 8655], 8708, 8713, 8716, 8740, 8742, 8769, 8772, 8775, 8777, 8800, 8802, [8813, 8817], [8820, 8821], [8824, 8825], [8832, 8833], [8836, 8837], [8840, 8841], [8876, 8879], [8928, 8931], [8938, 8941], 10972, 12364, 12366, 12368, 12370, 12372, 12374, 12376, 12378, 12380, 12382, 12384, 12386, 12389, 12391, 12393, [12400, 12401], [12403, 12404], [12406, 12407], [12409, 12410], [12412, 12413], 12436, 12446, 12460, 12462, 12464, 12466, 12468, 12470, 12472, 12474, 12476, 12478, 12480, 12482, 12485, 12487, 12489, [12496, 12497], [12499, 12500], [12502, 12503], [12505, 12506], [12508, 12509], 12532, [12535, 12538], 12542, [44032, 55203], 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64334], 69786, 69788, 69803, [69934, 69935], [70475, 70476], [70843, 70844], 70846, [71098, 71099], 71992, [119134, 119140], [119227, 119232]];
  var Expands_On_NFD_default = _28;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Expands_On_NFKC.js
  var _29 = [168, 175, 180, 184, [188, 190], [306, 307], [319, 320], 329, [452, 460], [497, 499], [728, 733], 836, 890, [900, 901], 1415, [1653, 1656], [2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3635, 3763, [3804, 3805], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3961], 3969, 3987, 3997, 4002, 4007, 4012, 4025, 7834, 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8174], [8189, 8190], 8215, [8229, 8230], [8243, 8244], [8246, 8247], 8252, 8254, [8263, 8265], 8279, 8360, [8448, 8449], 8451, [8453, 8454], 8457, 8470, [8480, 8482], 8507, [8528, 8543], [8545, 8547], [8549, 8552], [8554, 8555], [8561, 8563], [8565, 8568], [8570, 8571], 8585, [8748, 8749], [8751, 8752], [9321, 9397], 10764, [10868, 10870], 10972, [12443, 12444], 12447, 12543, [12800, 12830], [12832, 12867], [12880, 12895], [12924, 12925], [12977, 13007], [13055, 13311], [64256, 64262], [64275, 64279], 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335], 64477, [64490, 64507], [64512, 64829], [64848, 64911], [64914, 64967], [65008, 65020], 65049, 65072, [65097, 65100], [65136, 65138], 65140, [65142, 65151], [65269, 65276], 65507, [119134, 119140], [119227, 119232], [127232, 127242], [127248, 127274], [127277, 127278], [127306, 127311], [127338, 127340], 127376, [127488, 127489], [127552, 127560]];
  var Expands_On_NFKC_default = _29;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Expands_On_NFKD.js
  var _30 = [168, 175, 180, 184, [188, 190], [192, 197], [199, 207], [209, 214], [217, 221], [224, 229], [231, 239], [241, 246], [249, 253], [255, 271], [274, 293], [296, 304], [306, 311], [313, 320], [323, 329], [332, 337], [340, 357], [360, 382], [416, 417], [431, 432], [452, 476], [478, 483], [486, 501], [504, 539], [542, 543], [550, 563], [728, 733], 836, 890, [900, 902], [904, 906], 908, [910, 912], [938, 944], [970, 974], [979, 980], [1024, 1025], 1027, 1031, [1036, 1038], 1049, 1081, [1104, 1105], 1107, 1111, [1116, 1118], [1142, 1143], [1217, 1218], [1232, 1235], [1238, 1239], [1242, 1247], [1250, 1255], [1258, 1269], [1272, 1273], 1415, [1570, 1574], [1653, 1656], 1728, 1730, 1747, 2345, 2353, 2356, [2392, 2399], [2507, 2508], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, 2888, [2891, 2892], [2908, 2909], 2964, [3018, 3020], 3144, 3264, [3271, 3272], [3274, 3275], [3402, 3404], 3546, [3548, 3550], 3635, 3763, [3804, 3805], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3961], 3969, 3987, 3997, 4002, 4007, 4012, 4025, 4134, 6918, 6920, 6922, 6924, 6926, 6930, 6971, 6973, [6976, 6977], 6979, [7680, 7835], [7840, 7929], [7936, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8125], [8127, 8132], [8134, 8147], [8150, 8155], [8157, 8174], [8178, 8180], [8182, 8190], 8215, [8229, 8230], [8243, 8244], [8246, 8247], 8252, 8254, [8263, 8265], 8279, 8360, [8448, 8449], 8451, [8453, 8454], 8457, 8470, [8480, 8482], 8491, 8507, [8528, 8543], [8545, 8547], [8549, 8552], [8554, 8555], [8561, 8563], [8565, 8568], [8570, 8571], 8585, [8602, 8603], 8622, [8653, 8655], 8708, 8713, 8716, 8740, 8742, [8748, 8749], [8751, 8752], 8769, 8772, 8775, 8777, 8800, 8802, [8813, 8817], [8820, 8821], [8824, 8825], [8832, 8833], [8836, 8837], [8840, 8841], [8876, 8879], [8928, 8931], [8938, 8941], [9321, 9397], 10764, [10868, 10870], 10972, 12364, 12366, 12368, 12370, 12372, 12374, 12376, 12378, 12380, 12382, 12384, 12386, 12389, 12391, 12393, [12400, 12401], [12403, 12404], [12406, 12407], [12409, 12410], [12412, 12413], 12436, [12443, 12444], [12446, 12447], 12460, 12462, 12464, 12466, 12468, 12470, 12472, 12474, 12476, 12478, 12480, 12482, 12485, 12487, 12489, [12496, 12497], [12499, 12500], [12502, 12503], [12505, 12506], [12508, 12509], 12532, [12535, 12538], [12542, 12543], [12800, 12830], [12832, 12867], [12880, 12895], [12910, 12926], [12977, 13007], [13055, 13311], [44032, 55203], [64256, 64262], [64275, 64279], 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335], [64420, 64421], [64432, 64433], 64477, [64490, 64507], [64512, 64829], [64848, 64911], [64914, 64967], [65008, 65020], 65049, 65072, [65097, 65100], [65136, 65138], 65140, [65142, 65151], [65153, 65164], [65269, 65276], 65507, 69786, 69788, 69803, [69934, 69935], [70475, 70476], [70843, 70844], 70846, [71098, 71099], 71992, [119134, 119140], [119227, 119232], [127232, 127242], [127248, 127274], [127277, 127278], [127306, 127311], [127338, 127340], 127376, [127488, 127489], 127507, [127552, 127560]];
  var Expands_On_NFKD_default = _30;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Extended_Pictographic.js
  var _31 = [169, 174, 8252, 8265, 8482, 8505, [8596, 8601], [8617, 8618], [8986, 8987], 9e3, 9096, 9167, [9193, 9203], [9208, 9210], 9410, [9642, 9643], 9654, 9664, [9723, 9726], [9728, 9733], [9735, 9746], [9748, 9861], [9872, 9989], [9992, 10002], 10004, 10006, 10013, 10017, 10024, [10035, 10036], 10052, 10055, 10060, 10062, [10067, 10069], 10071, [10083, 10087], [10133, 10135], 10145, 10160, 10175, [10548, 10549], [11013, 11015], [11035, 11036], 11088, 11093, 12336, 12349, 12951, 12953, [126976, 127231], [127245, 127247], 127279, [127340, 127345], [127358, 127359], 127374, [127377, 127386], [127405, 127461], [127489, 127503], 127514, 127535, [127538, 127546], [127548, 127551], [127561, 127994], [128e3, 128317], [128326, 128591], [128640, 128767], [128884, 128895], [128981, 129023], [129036, 129039], [129096, 129103], [129114, 129119], [129160, 129167], [129198, 129279], [129292, 129338], [129340, 129349], [129351, 129791], [130048, 131069]];
  var Extended_Pictographic_default = _31;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Extender.js
  var _32 = [183, [720, 721], 1600, 2042, 2901, 3654, 3782, 6154, 6211, 6823, 7222, 7291, 12293, [12337, 12341], [12445, 12446], [12540, 12542], 40981, 42508, 43471, 43494, 43632, 43741, [43763, 43764], 65392, [67457, 67458], 70493, [71110, 71112], 72344, [92994, 92995], [94176, 94177], 94179, [123196, 123197], [125252, 125254]];
  var Extender_default = _32;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Full_Composition_Exclusion.js
  var _33 = [[832, 833], [835, 836], 884, 894, 903, [2392, 2399], [2524, 2525], 2527, 2611, 2614, [2649, 2651], 2654, [2908, 2909], 3907, 3917, 3922, 3927, 3932, 3945, 3955, [3957, 3958], 3960, 3969, 3987, 3997, 4002, 4007, 4012, 4025, 8049, 8051, 8053, 8055, 8057, 8059, 8061, 8123, 8126, 8137, 8139, 8147, 8155, 8163, 8171, [8174, 8175], 8185, 8187, 8189, [8192, 8193], 8486, [8490, 8491], [9001, 9002], 10972, [63744, 64013], 64016, 64018, [64021, 64030], 64032, 64034, [64037, 64038], [64042, 64109], [64112, 64217], 64285, 64287, [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64334], [119134, 119140], [119227, 119232], [194560, 195101]];
  var Full_Composition_Exclusion_default = _33;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Grapheme_Base.js
  var _34 = [[32, 126], [160, 172], [174, 767], [880, 887], [890, 895], [900, 906], 908, [910, 929], [931, 1154], [1162, 1327], [1329, 1366], [1369, 1418], [1421, 1423], 1470, 1472, 1475, 1478, [1488, 1514], [1519, 1524], [1542, 1551], 1563, [1565, 1610], [1632, 1647], [1649, 1749], 1758, [1765, 1766], 1769, [1774, 1805], 1808, [1810, 1839], [1869, 1957], 1969, [1984, 2026], [2036, 2042], [2046, 2069], 2074, 2084, 2088, [2096, 2110], [2112, 2136], 2142, [2144, 2154], [2160, 2190], [2208, 2249], [2307, 2361], 2363, [2365, 2368], [2377, 2380], [2382, 2384], [2392, 2401], [2404, 2432], [2434, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, [2495, 2496], [2503, 2504], [2507, 2508], 2510, [2524, 2525], [2527, 2529], [2534, 2557], 2563, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2622, 2624], [2649, 2652], 2654, [2662, 2671], [2674, 2676], 2678, 2691, [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2749, 2752], 2761, [2763, 2764], 2768, [2784, 2785], [2790, 2801], 2809, [2818, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, 2880, [2887, 2888], [2891, 2892], [2908, 2909], [2911, 2913], [2918, 2935], 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3007, [3009, 3010], [3014, 3016], [3018, 3020], 3024, [3046, 3066], [3073, 3075], [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3137, 3140], [3160, 3162], 3165, [3168, 3169], [3174, 3183], [3191, 3200], [3202, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3261, 3262], [3264, 3265], [3267, 3268], [3271, 3272], [3274, 3275], [3293, 3294], [3296, 3297], [3302, 3311], [3313, 3315], [3330, 3340], [3342, 3344], [3346, 3386], 3389, [3391, 3392], [3398, 3400], [3402, 3404], [3406, 3407], [3412, 3414], [3416, 3425], [3430, 3455], [3458, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3536, 3537], [3544, 3550], [3558, 3567], [3570, 3572], [3585, 3632], [3634, 3635], [3647, 3654], [3663, 3675], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], 3782, [3792, 3801], [3804, 3807], [3840, 3863], [3866, 3892], 3894, 3896, [3898, 3911], [3913, 3948], 3967, 3973, [3976, 3980], [4030, 4037], [4039, 4044], [4046, 4058], [4096, 4140], 4145, 4152, [4155, 4156], [4159, 4183], [4186, 4189], [4193, 4208], [4213, 4225], [4227, 4228], [4231, 4236], [4238, 4252], [4254, 4293], 4295, 4301, [4304, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4960, 4988], [4992, 5017], [5024, 5109], [5112, 5117], [5120, 5788], [5792, 5880], [5888, 5905], 5909, [5919, 5937], [5940, 5942], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6070, [6078, 6085], [6087, 6088], [6100, 6108], [6112, 6121], [6128, 6137], [6144, 6154], [6160, 6169], [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], 6464, [6468, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6622, 6678], [6681, 6682], [6686, 6741], 6743, 6753, [6755, 6756], [6765, 6770], [6784, 6793], [6800, 6809], [6816, 6829], [6916, 6963], 6971, [6973, 6977], [6979, 6988], [6992, 7018], [7028, 7038], [7042, 7073], [7078, 7079], 7082, [7086, 7141], 7143, [7146, 7148], 7150, [7154, 7155], [7164, 7211], [7220, 7221], [7227, 7241], [7245, 7304], [7312, 7354], [7357, 7367], 7379, 7393, [7401, 7404], [7406, 7411], [7413, 7415], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8190], [8192, 8202], [8208, 8231], [8239, 8287], [8304, 8305], [8308, 8334], [8336, 8348], [8352, 8384], [8448, 8587], [8592, 9254], [9280, 9290], [9312, 11123], [11126, 11157], [11159, 11502], [11506, 11507], [11513, 11557], 11559, 11565, [11568, 11623], [11631, 11632], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11776, 11869], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12288, 12329], [12336, 12351], [12353, 12438], [12443, 12543], [12549, 12591], [12593, 12686], [12688, 12771], [12784, 12830], [12832, 42124], [42128, 42182], [42192, 42539], [42560, 42606], 42611, [42622, 42653], [42656, 42735], [42738, 42743], [42752, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43044], [43047, 43051], [43056, 43065], [43072, 43127], [43136, 43203], [43214, 43225], [43250, 43262], [43264, 43301], [43310, 43334], [43346, 43347], [43359, 43388], [43395, 43442], [43444, 43445], [43450, 43451], [43454, 43469], [43471, 43481], [43486, 43492], [43494, 43518], [43520, 43560], [43567, 43568], [43571, 43572], [43584, 43586], [43588, 43595], 43597, [43600, 43609], [43612, 43643], [43645, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43755], [43758, 43765], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43883], [43888, 44004], [44006, 44007], [44009, 44012], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64450], [64467, 64911], [64914, 64967], 64975, [65008, 65023], [65040, 65049], [65072, 65106], [65108, 65126], [65128, 65131], [65136, 65140], [65142, 65276], [65281, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65504, 65510], [65512, 65518], [65532, 65533], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65792, 65794], [65799, 65843], [65847, 65934], [65936, 65948], 65952, [66e3, 66044], [66176, 66204], [66208, 66256], [66273, 66299], [66304, 66339], [66349, 66378], [66384, 66421], [66432, 66461], [66463, 66499], [66504, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66927, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67671, 67742], [67751, 67759], [67808, 67826], [67828, 67829], [67835, 67867], [67871, 67897], 67903, [67968, 68023], [68028, 68047], [68050, 68096], [68112, 68115], [68117, 68119], [68121, 68149], [68160, 68168], [68176, 68184], [68192, 68255], [68288, 68324], [68331, 68342], [68352, 68405], [68409, 68437], [68440, 68466], [68472, 68497], [68505, 68508], [68521, 68527], [68608, 68680], [68736, 68786], [68800, 68850], [68858, 68899], [68912, 68921], [69216, 69246], [69248, 69289], 69293, [69296, 69297], [69376, 69415], [69424, 69445], [69457, 69465], [69488, 69505], [69510, 69513], [69552, 69579], [69600, 69622], 69632, [69634, 69687], [69703, 69709], [69714, 69743], [69745, 69746], 69749, [69762, 69810], [69815, 69816], [69819, 69820], [69822, 69825], [69840, 69864], [69872, 69881], [69891, 69926], 69932, [69942, 69959], [69968, 70002], [70004, 70006], [70018, 70069], [70079, 70088], [70093, 70094], [70096, 70111], [70113, 70132], [70144, 70161], [70163, 70190], [70194, 70195], 70197, [70200, 70205], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313], [70320, 70366], [70368, 70370], [70384, 70393], [70402, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70463, [70465, 70468], [70471, 70472], [70475, 70477], 70480, [70493, 70499], [70656, 70711], [70720, 70721], 70725, [70727, 70747], 70749, [70751, 70753], [70784, 70831], [70833, 70834], 70841, [70843, 70844], 70846, 70849, [70852, 70855], [70864, 70873], [71040, 71086], [71088, 71089], [71096, 71099], 71102, [71105, 71131], [71168, 71218], [71227, 71228], 71230, [71233, 71236], [71248, 71257], [71264, 71276], [71296, 71338], 71340, [71342, 71343], 71350, [71352, 71353], [71360, 71369], [71424, 71450], [71456, 71457], 71462, [71472, 71494], [71680, 71726], 71736, 71739, [71840, 71922], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], [71985, 71989], [71991, 71992], 71997, [71999, 72002], [72004, 72006], [72016, 72025], [72096, 72103], [72106, 72147], [72156, 72159], [72161, 72164], 72192, [72203, 72242], [72249, 72250], [72255, 72262], 72272, [72279, 72280], [72284, 72329], 72343, [72346, 72354], [72368, 72440], [72448, 72457], [72704, 72712], [72714, 72751], 72766, [72768, 72773], [72784, 72812], [72816, 72847], 72873, 72881, 72884, [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73107, 73108], 73110, 73112, [73120, 73129], [73440, 73458], [73461, 73464], [73474, 73488], [73490, 73525], [73534, 73535], 73537, [73539, 73561], 73648, [73664, 73713], [73727, 74649], [74752, 74862], [74864, 74868], [74880, 75075], [77712, 77810], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92782, 92862], [92864, 92873], [92880, 92909], 92917, [92928, 92975], [92983, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071], [93760, 93850], [93952, 94026], [94032, 94087], [94099, 94111], [94176, 94179], [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 113820, 113823, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119140], 119142, [119146, 119149], [119171, 119172], [119180, 119209], [119214, 119274], [119296, 119361], 119365, [119488, 119507], [119520, 119539], [119552, 119638], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121483], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], [123200, 123209], [123214, 123215], [123536, 123565], [123584, 123627], [123632, 123641], 123647, [124112, 124139], [124144, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125127, 125135], [125184, 125251], 125259, [125264, 125273], [125278, 125279], [126065, 126132], [126209, 126269], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127232, 127405], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994], [130032, 130041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var Grapheme_Base_default = _34;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Grapheme_Extend.js
  var _35 = [[768, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2433, 2492, 2494, [2497, 2500], 2509, 2519, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, [2878, 2879], [2881, 2884], 2893, [2901, 2903], [2914, 2915], 2946, 3006, 3008, 3021, 3031, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, 3263, 3266, 3270, [3276, 3277], [3285, 3286], [3298, 3299], [3328, 3329], [3387, 3388], 3390, [3393, 3396], 3405, 3415, [3426, 3427], 3457, 3530, 3535, [3538, 3540], 3542, 3551, 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, [6832, 6862], [6912, 6915], [6964, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], 8204, [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12335], [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43493, [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43756, 43757], 43766, 44005, 44008, 44013, 64286, [65024, 65039], [65056, 65071], [65438, 65439], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69826, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70462, 70464, 70487, [70502, 70508], [70512, 70516], [70712, 70719], [70722, 70724], 70726, 70750, 70832, [70835, 70840], 70842, 70845, [70847, 70848], [70850, 70851], 71087, [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, [71453, 71455], [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], 71984, [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], 72767, [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94095, 94098], 94180, [113821, 113822], [118528, 118573], [118576, 118598], 119141, [119143, 119145], [119150, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [917536, 917631], [917760, 917999]];
  var Grapheme_Extend_default = _35;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Grapheme_Link.js
  var _36 = [2381, 2509, 2637, 2765, 2893, 3021, 3149, 3277, [3387, 3388], 3405, 3530, 3642, 3770, 3972, [4153, 4154], [5908, 5909], 5940, 6098, 6752, 6980, [7082, 7083], [7154, 7155], 11647, 43014, 43052, 43204, 43347, 43456, 43766, 44013, 68159, 69702, 69744, 69759, 69817, [69939, 69940], 70080, 70197, 70378, 70477, 70722, 70850, 71103, 71231, 71350, 71467, 71737, [71997, 71998], 72160, 72244, 72263, 72345, 72767, [73028, 73029], 73111, [73537, 73538]];
  var Grapheme_Link_default = _36;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Hex_Digit.js
  var _37 = [[48, 57], [65, 70], [97, 102], [65296, 65305], [65313, 65318], [65345, 65350]];
  var Hex_Digit_default = _37;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Hyphen.js
  var _38 = [45, 173, 1418, 6150, [8208, 8209], 11799, 12539, 65123, 65293, 65381];
  var Hyphen_default = _38;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/IDS_Binary_Operator.js
  var _39 = [[12272, 12273], [12276, 12283]];
  var IDS_Binary_Operator_default = _39;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/IDS_Trinary_Operator.js
  var _40 = [[12274, 12275]];
  var IDS_Trinary_Operator_default = _40;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/ID_Continue.js
  var _41 = [[48, 57], [65, 90], 95, [97, 122], 170, 181, 183, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [768, 884], [886, 887], [890, 893], 895, [902, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1155, 1159], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1488, 1514], [1519, 1522], [1552, 1562], [1568, 1641], [1646, 1747], [1749, 1756], [1759, 1768], [1770, 1788], 1791, [1808, 1866], [1869, 1969], [1984, 2037], 2042, 2045, [2048, 2093], [2112, 2139], [2144, 2154], [2160, 2183], [2185, 2190], [2200, 2273], [2275, 2403], [2406, 2415], [2417, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2545], 2556, 2558, [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2677], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2799], [2809, 2815], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2927], 2929, [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3055], [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3200, 3203], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315], [3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3406], [3412, 3415], [3423, 3427], [3430, 3439], [3450, 3455], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3571], [3585, 3642], [3648, 3662], [3664, 3673], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807], 3840, [3864, 3865], [3872, 3881], 3893, 3895, 3897, [3902, 3911], [3913, 3948], [3953, 3972], [3974, 3991], [3993, 4028], 4038, [4096, 4169], [4176, 4253], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4959], [4969, 4977], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5909], [5919, 5940], [5952, 5971], [5984, 5996], [5998, 6e3], [6002, 6003], [6016, 6099], 6103, [6108, 6109], [6112, 6121], [6155, 6157], [6159, 6169], [6176, 6264], [6272, 6314], [6320, 6389], [6400, 6430], [6432, 6443], [6448, 6459], [6470, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6656, 6683], [6688, 6750], [6752, 6780], [6783, 6793], [6800, 6809], 6823, [6832, 6845], [6847, 6862], [6912, 6988], [6992, 7001], [7019, 7027], [7040, 7155], [7168, 7223], [7232, 7241], [7245, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7376, 7378], [7380, 7418], [7424, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], [8255, 8256], 8276, 8305, 8319, [8336, 8348], [8400, 8412], 8417, [8421, 8432], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, 8486, 8488, [8490, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [11264, 11492], [11499, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11647, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11744, 11775], [12293, 12295], [12321, 12335], [12337, 12341], [12344, 12348], [12353, 12438], [12441, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42539], [42560, 42607], [42612, 42621], [42623, 42737], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43047], 43052, [43072, 43123], [43136, 43205], [43216, 43225], [43232, 43255], 43259, [43261, 43309], [43312, 43347], [43360, 43388], [43392, 43456], [43471, 43481], [43488, 43518], [43520, 43574], [43584, 43597], [43600, 43609], [43616, 43638], [43642, 43714], [43739, 43741], [43744, 43759], [43762, 43766], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44010], [44012, 44013], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [64285, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65024, 65039], [65056, 65071], [65075, 65076], [65101, 65103], [65136, 65140], [65142, 65276], [65296, 65305], [65313, 65338], 65343, [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], 66045, [66176, 66204], [66208, 66256], 66272, [66304, 66335], [66349, 66378], [66384, 66426], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], [68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], 68159, [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68326], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68903], [68912, 68921], [69248, 69289], [69291, 69292], [69296, 69297], [69373, 69404], 69415, [69424, 69456], [69488, 69509], [69552, 69572], [69600, 69622], [69632, 69702], [69734, 69749], [69759, 69818], 69826, [69840, 69864], [69872, 69881], [69888, 69940], [69942, 69951], [69956, 69959], [69968, 70003], 70006, [70016, 70084], [70089, 70092], [70094, 70106], 70108, [70144, 70161], [70163, 70199], [70206, 70209], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70378], [70384, 70393], [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70459, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516], [70656, 70730], [70736, 70745], [70750, 70753], [70784, 70853], 70855, [70864, 70873], [71040, 71093], [71096, 71104], [71128, 71133], [71168, 71232], 71236, [71248, 71257], [71296, 71352], [71360, 71369], [71424, 71450], [71453, 71467], [71472, 71481], [71488, 71494], [71680, 71738], [71840, 71913], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72003], [72016, 72025], [72096, 72103], [72106, 72151], [72154, 72161], [72163, 72164], [72192, 72254], 72263, [72272, 72345], 72349, [72368, 72440], [72704, 72712], [72714, 72758], [72760, 72768], [72784, 72793], [72818, 72847], [72850, 72871], [72873, 72886], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129], [73440, 73462], [73472, 73488], [73490, 73530], [73534, 73538], [73552, 73561], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78912, 78933], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92784, 92862], [92864, 92873], [92880, 92909], [92912, 92916], [92928, 92982], [92992, 92995], [93008, 93017], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], [94031, 94087], [94095, 94111], [94176, 94177], [94179, 94180], [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113821, 113822], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [120782, 120831], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122624, 122654], [122661, 122666], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123136, 123180], [123184, 123197], [123200, 123209], 123214, [123536, 123566], [123584, 123641], [124112, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125136, 125142], [125184, 125259], [125264, 125273], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [130032, 130041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743], [917760, 917999]];
  var ID_Continue_default = _41;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/ID_Start.js
  var _42 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [880, 884], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1488, 1514], [1519, 1522], [1568, 1610], [1646, 1647], [1649, 1747], 1749, [1765, 1766], [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2037], 2042, [2048, 2069], 2074, 2084, 2088, [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2308, 2361], 2365, 2384, [2392, 2401], [2417, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3654], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], 3782, [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6103, 6108, [6176, 6264], [6272, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], 6823, [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, 8486, 8488, [8490, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [12293, 12295], [12321, 12329], [12337, 12341], [12344, 12348], [12353, 12438], [12443, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42623, 42653], [42656, 42735], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], 43471, [43488, 43492], [43494, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43741], [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65313, 65338], [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66378], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], 94032, [94099, 94111], [94176, 94177], 94179, [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var ID_Start_default = _42;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Ideographic.js
  var _43 = [[12294, 12295], [12321, 12329], [12344, 12346], [13312, 19903], [19968, 40959], [63744, 64109], [64112, 64217], 94180, [94208, 100343], [100352, 101589], [101632, 101640], [110960, 111355], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var Ideographic_default = _43;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Join_Control.js
  var _44 = [[8204, 8205]];
  var Join_Control_default = _44;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Logical_Order_Exception.js
  var _45 = [[3648, 3652], [3776, 3780], [6581, 6583], 6586, [43701, 43702], 43705, [43707, 43708]];
  var Logical_Order_Exception_default = _45;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Lowercase.js
  var _46 = [[97, 122], 170, 181, 186, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, [311, 312], 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, [396, 397], 402, 405, [409, 411], 414, 417, 419, 421, 424, [426, 427], 429, 432, 436, 438, [441, 442], [445, 447], 454, 457, 460, 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 496], 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 557, 559, 561, [563, 569], 572, [575, 576], 578, 583, 585, 587, 589, [591, 659], [661, 696], [704, 705], [736, 740], 837, 881, 883, 887, [890, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, [1019, 1020], [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1376, 1416], [4304, 4346], [4348, 4351], [5112, 5117], [7296, 7304], [7424, 7615], 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7837], 7839, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], 8126, [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8305, 8319, [8336, 8348], 8458, [8462, 8463], 8467, 8495, 8500, 8505, [8508, 8509], [8518, 8521], 8526, [8560, 8575], 8580, [9424, 9449], [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11377, [11379, 11380], [11382, 11389], 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, [11491, 11492], 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, [42651, 42653], 42787, 42789, 42791, 42793, 42795, 42797, [42799, 42801], 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, [42863, 42872], 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42894, 42897, [42899, 42901], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42927, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42961, 42963, 42965, 42967, 42969, [42994, 42996], 42998, [43e3, 43002], [43824, 43866], [43868, 43881], [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], 67456, [67459, 67461], [67463, 67504], [67506, 67514], [68800, 68850], [71872, 71903], [93792, 93823], [119834, 119859], [119886, 119892], [119894, 119911], [119938, 119963], [119990, 119993], 119995, [119997, 120003], [120005, 120015], [120042, 120067], [120094, 120119], [120146, 120171], [120198, 120223], [120250, 120275], [120302, 120327], [120354, 120379], [120406, 120431], [120458, 120485], [120514, 120538], [120540, 120545], [120572, 120596], [120598, 120603], [120630, 120654], [120656, 120661], [120688, 120712], [120714, 120719], [120746, 120770], [120772, 120777], 120779, [122624, 122633], [122635, 122654], [122661, 122666], [122928, 122989], [125218, 125251]];
  var Lowercase_default = _46;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Math.js
  var _47 = [43, [60, 62], 94, 124, 126, 172, 177, 215, 247, [976, 978], 981, [1008, 1009], [1012, 1014], [1542, 1544], 8214, [8242, 8244], 8256, 8260, 8274, [8289, 8292], [8314, 8318], [8330, 8334], [8400, 8412], 8417, [8421, 8422], [8427, 8431], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, [8488, 8489], [8492, 8493], [8495, 8497], [8499, 8504], [8508, 8521], 8523, [8592, 8615], [8617, 8622], [8624, 8625], [8630, 8631], [8636, 8667], 8669, [8676, 8677], [8692, 8959], [8968, 8971], [8992, 8993], 9084, [9115, 9141], 9143, 9168, [9180, 9186], [9632, 9633], [9646, 9655], [9660, 9665], [9670, 9671], [9674, 9675], [9679, 9683], 9698, 9700, [9703, 9708], [9720, 9727], [9733, 9734], 9792, 9794, [9824, 9827], [9837, 9839], [10176, 10239], [10496, 11007], [11056, 11076], [11079, 11084], 64297, [65121, 65126], 65128, 65291, [65308, 65310], 65340, 65342, 65372, 65374, 65506, [65513, 65516], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 120831], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705]];
  var Math_default = _47;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Noncharacter_Code_Point.js
  var _48 = [[64976, 65007], [65534, 65535], [131070, 131071], [196606, 196607], [262142, 262143], [327678, 327679], [393214, 393215], [458750, 458751], [524286, 524287], [589822, 589823], [655358, 655359], [720894, 720895], [786430, 786431], [851966, 851967], [917502, 917503], [983038, 983039], [1048574, 1048575], [1114110, 1114111]];
  var Noncharacter_Code_Point_default = _48;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Alphabetic.js
  var _49 = [837, [1456, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1623], [1625, 1631], 1648, [1750, 1756], [1761, 1764], [1767, 1768], 1773, 1809, [1840, 1855], [1958, 1968], [2070, 2071], [2075, 2083], [2085, 2087], [2089, 2092], [2260, 2271], [2275, 2281], [2288, 2307], [2362, 2363], [2366, 2380], [2382, 2383], [2389, 2391], [2402, 2403], [2433, 2435], [2494, 2500], [2503, 2504], [2507, 2508], 2519, [2530, 2531], [2561, 2563], [2622, 2626], [2631, 2632], [2635, 2636], 2641, [2672, 2673], 2677, [2689, 2691], [2750, 2757], [2759, 2761], [2763, 2764], [2786, 2787], [2810, 2812], [2817, 2819], [2878, 2884], [2887, 2888], [2891, 2892], [2902, 2903], [2914, 2915], 2946, [3006, 3010], [3014, 3016], [3018, 3020], 3031, [3072, 3076], [3134, 3140], [3142, 3144], [3146, 3148], [3157, 3158], [3170, 3171], [3201, 3203], [3262, 3268], [3270, 3272], [3274, 3276], [3285, 3286], [3298, 3299], 3315, [3328, 3331], [3390, 3396], [3398, 3400], [3402, 3404], 3415, [3426, 3427], [3457, 3459], [3535, 3540], 3542, [3544, 3551], [3570, 3571], 3633, [3636, 3642], 3661, 3761, [3764, 3769], [3771, 3772], 3789, [3953, 3971], [3981, 3991], [3993, 4028], [4139, 4150], 4152, [4155, 4158], [4182, 4185], [4190, 4192], [4194, 4196], [4199, 4205], [4209, 4212], [4226, 4237], 4239, [4250, 4253], [5906, 5907], [5938, 5939], [5970, 5971], [6002, 6003], [6070, 6088], [6277, 6278], 6313, [6432, 6443], [6448, 6456], [6679, 6683], [6741, 6750], [6753, 6772], [6847, 6848], [6860, 6862], [6912, 6916], [6965, 6979], [7040, 7042], [7073, 7081], [7084, 7085], [7143, 7153], [7204, 7222], [7655, 7668], [9398, 9449], [11744, 11775], [42612, 42619], [42654, 42655], 43010, 43019, [43043, 43047], [43136, 43137], [43188, 43203], 43205, 43263, [43302, 43306], [43335, 43346], [43392, 43395], [43444, 43455], 43493, [43561, 43574], 43587, [43596, 43597], [43643, 43645], 43696, [43698, 43700], [43703, 43704], 43710, [43755, 43759], 43765, [44003, 44010], 64286, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68900, 68903], [69291, 69292], [69632, 69634], [69688, 69701], [69747, 69748], [69760, 69762], [69808, 69816], 69826, [69888, 69890], [69927, 69938], [69957, 69958], [70016, 70018], [70067, 70079], [70094, 70095], [70188, 70196], 70199, 70206, 70209, [70367, 70376], [70400, 70403], [70462, 70468], [70471, 70472], [70475, 70476], 70487, [70498, 70499], [70709, 70721], [70723, 70725], [70832, 70849], [71087, 71093], [71096, 71102], [71132, 71133], [71216, 71230], 71232, [71339, 71349], [71453, 71466], [71724, 71736], [71984, 71989], [71991, 71992], [71995, 71996], 72e3, 72002, [72145, 72151], [72154, 72159], 72164, [72193, 72202], [72245, 72249], [72251, 72254], [72273, 72283], [72330, 72343], [72751, 72758], [72760, 72766], [72850, 72871], [72873, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73025], 73027, 73031, [73098, 73102], [73104, 73105], [73107, 73110], [73459, 73462], [73472, 73473], 73475, [73524, 73530], [73534, 73536], 94031, [94033, 94087], [94095, 94098], [94192, 94193], 113822, [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, 125255, [127280, 127305], [127312, 127337], [127344, 127369]];
  var Other_Alphabetic_default = _49;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Default_Ignorable_Code_Point.js
  var _50 = [847, [4447, 4448], [6068, 6069], 8293, 12644, 65440, [65520, 65528], 917504, [917506, 917535], [917632, 917759], [918e3, 921599]];
  var Other_Default_Ignorable_Code_Point_default = _50;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Grapheme_Extend.js
  var _51 = [2494, 2519, 2878, 2903, 3006, 3031, 3266, [3285, 3286], 3390, 3415, 3535, 3551, 6965, 8204, [12334, 12335], [65438, 65439], 70462, 70487, 70832, 70845, 71087, 71984, 119141, [119150, 119154], [917536, 917631]];
  var Other_Grapheme_Extend_default = _51;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_ID_Continue.js
  var _52 = [183, 903, [4969, 4977], 6618];
  var Other_ID_Continue_default = _52;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_ID_Start.js
  var _53 = [[6277, 6278], 8472, 8494, [12443, 12444]];
  var Other_ID_Start_default = _53;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Lowercase.js
  var _54 = [170, 186, [688, 696], [704, 705], [736, 740], 837, 890, 4348, [7468, 7530], 7544, [7579, 7615], 8305, 8319, [8336, 8348], [8560, 8575], [9424, 9449], [11388, 11389], [42652, 42653], 42864, [42994, 42996], [43e3, 43001], [43868, 43871], 43881, 67456, [67459, 67461], [67463, 67504], [67506, 67514], [122928, 122989]];
  var Other_Lowercase_default = _54;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Math.js
  var _55 = [94, [976, 978], 981, [1008, 1009], [1012, 1013], 8214, [8242, 8244], 8256, [8289, 8292], [8317, 8318], [8333, 8334], [8400, 8412], 8417, [8421, 8422], [8427, 8431], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, [8488, 8489], [8492, 8493], [8495, 8497], [8499, 8504], [8508, 8511], [8517, 8521], [8597, 8601], [8604, 8607], [8609, 8610], [8612, 8613], 8615, [8617, 8621], [8624, 8625], [8630, 8631], [8636, 8653], [8656, 8657], 8659, [8661, 8667], 8669, [8676, 8677], [8968, 8971], [9140, 9141], 9143, 9168, 9186, [9632, 9633], [9646, 9654], [9660, 9664], [9670, 9671], [9674, 9675], [9679, 9683], 9698, 9700, [9703, 9708], [9733, 9734], 9792, 9794, [9824, 9827], [9837, 9838], [10181, 10182], [10214, 10223], [10627, 10648], [10712, 10715], [10748, 10749], 65121, 65123, 65128, 65340, 65342, [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [120782, 120831], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651]];
  var Other_Math_default = _55;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Other_Uppercase.js
  var _56 = [[8544, 8559], [9398, 9423], [127280, 127305], [127312, 127337], [127344, 127369]];
  var Other_Uppercase_default = _56;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Pattern_Syntax.js
  var _57 = [[33, 47], [58, 64], [91, 94], 96, [123, 126], [161, 167], 169, [171, 172], 174, [176, 177], 182, 187, 191, 215, 247, [8208, 8231], [8240, 8254], [8257, 8275], [8277, 8286], [8592, 9311], [9472, 10101], [10132, 11263], [11776, 11903], [12289, 12291], [12296, 12320], 12336, [64830, 64831], [65093, 65094]];
  var Pattern_Syntax_default = _57;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Pattern_White_Space.js
  var _58 = [[9, 13], 32, 133, [8206, 8207], [8232, 8233]];
  var Pattern_White_Space_default = _58;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Prepended_Concatenation_Mark.js
  var _59 = [[1536, 1541], 1757, 1807, [2192, 2193], 2274, 69821, 69837];
  var Prepended_Concatenation_Mark_default = _59;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Quotation_Mark.js
  var _60 = [34, 39, 171, 187, [8216, 8223], [8249, 8250], 11842, [12300, 12303], [12317, 12319], [65089, 65092], 65282, 65287, [65378, 65379]];
  var Quotation_Mark_default = _60;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Radical.js
  var _61 = [[11904, 11929], [11931, 12019], [12032, 12245]];
  var Radical_default = _61;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Regional_Indicator.js
  var _62 = [[127462, 127487]];
  var Regional_Indicator_default = _62;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Sentence_Terminal.js
  var _63 = [33, 46, 63, 1417, [1565, 1567], 1748, [1792, 1794], 2041, 2103, 2105, [2109, 2110], [2404, 2405], [4170, 4171], 4962, [4967, 4968], 5742, [5941, 5942], 6147, 6153, [6468, 6469], [6824, 6827], [7002, 7003], [7006, 7007], [7037, 7038], [7227, 7228], [7294, 7295], [8252, 8253], [8263, 8265], 11822, 11836, [11859, 11860], 12290, 42239, [42510, 42511], 42739, 42743, [43126, 43127], [43214, 43215], 43311, [43464, 43465], [43613, 43615], [43760, 43761], 44011, 65106, [65110, 65111], 65281, 65294, 65311, 65377, [68182, 68183], [69461, 69465], [69510, 69513], [69703, 69704], [69822, 69825], [69953, 69955], [70085, 70086], 70093, [70110, 70111], [70200, 70201], [70203, 70204], 70313, [70731, 70732], [71106, 71107], [71113, 71127], [71233, 71234], [71484, 71486], 72004, 72006, [72258, 72259], [72347, 72348], [72769, 72770], [73463, 73464], [73539, 73540], [92782, 92783], 92917, [92983, 92984], 92996, 93848, 113823, 121480];
  var Sentence_Terminal_default = _63;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Soft_Dotted.js
  var _64 = [[105, 106], 303, 585, 616, 669, 690, 1011, 1110, 1112, 7522, 7574, 7588, 7592, 7725, 7883, 8305, [8520, 8521], 11388, [119842, 119843], [119894, 119895], [119946, 119947], [119998, 119999], [120050, 120051], [120102, 120103], [120154, 120155], [120206, 120207], [120258, 120259], [120310, 120311], [120362, 120363], [120414, 120415], [120466, 120467], 122650, [122956, 122957], 122984];
  var Soft_Dotted_default = _64;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Terminal_Punctuation.js
  var _65 = [33, 44, 46, [58, 59], 63, 894, 903, 1417, 1475, 1548, 1563, [1565, 1567], 1748, [1792, 1802], 1804, [2040, 2041], [2096, 2110], 2142, [2404, 2405], [3674, 3675], 3848, [3853, 3858], [4170, 4171], [4961, 4968], 5742, [5867, 5869], [5941, 5942], [6100, 6102], 6106, [6146, 6149], [6152, 6153], [6468, 6469], [6824, 6827], [7002, 7003], [7005, 7007], [7037, 7038], [7227, 7231], [7294, 7295], [8252, 8253], [8263, 8265], 11822, 11836, 11841, 11852, [11854, 11855], [11859, 11860], [12289, 12290], [42238, 42239], [42509, 42511], [42739, 42743], [43126, 43127], [43214, 43215], 43311, [43463, 43465], [43613, 43615], 43743, [43760, 43761], 44011, [65104, 65106], [65108, 65111], 65281, 65292, 65294, [65306, 65307], 65311, 65377, 65380, 66463, 66512, 67671, 67871, [68182, 68183], [68336, 68341], [68410, 68415], [68505, 68508], [69461, 69465], [69510, 69513], [69703, 69709], [69822, 69825], [69953, 69955], [70085, 70086], 70093, [70110, 70111], [70200, 70204], 70313, [70731, 70733], [70746, 70747], [71106, 71109], [71113, 71127], [71233, 71234], [71484, 71486], 72004, 72006, [72258, 72259], [72347, 72348], [72353, 72354], [72769, 72771], 72817, [73463, 73464], [73539, 73540], [74864, 74868], [92782, 92783], 92917, [92983, 92985], 92996, [93847, 93848], 113823, [121479, 121482]];
  var Terminal_Punctuation_default = _65;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Unified_Ideograph.js
  var _66 = [[13312, 19903], [19968, 40959], [64014, 64015], 64017, [64019, 64020], 64031, 64033, [64035, 64036], [64039, 64041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [196608, 201546], [201552, 205743]];
  var Unified_Ideograph_default = _66;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Uppercase.js
  var _67 = [[65, 90], [192, 214], [216, 222], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, 452, 455, 458, 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, 497, 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 975, [978, 980], 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, 1012, 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], [4256, 4293], 4295, 4301, [5024, 5109], [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8120, 8123], [8136, 8139], [8152, 8155], [8168, 8172], [8184, 8187], 8450, 8455, [8459, 8461], [8464, 8466], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8496, 8499], [8510, 8511], 8517, [8544, 8559], 8579, [9398, 9423], [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, 42997, [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [71840, 71871], [93760, 93791], [119808, 119833], [119860, 119885], [119912, 119937], 119964, [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119989], [120016, 120041], [120068, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120120, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120172, 120197], [120224, 120249], [120276, 120301], [120328, 120353], [120380, 120405], [120432, 120457], [120488, 120512], [120546, 120570], [120604, 120628], [120662, 120686], [120720, 120744], 120778, [125184, 125217], [127280, 127305], [127312, 127337], [127344, 127369]];
  var Uppercase_default = _67;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/Variation_Selector.js
  var _68 = [[6155, 6157], 6159, [65024, 65039], [917760, 917999]];
  var Variation_Selector_default = _68;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/White_Space.js
  var _69 = [[9, 13], 32, 133, 160, 5760, [8192, 8202], [8232, 8233], 8239, 8287, 12288];
  var White_Space_default = _69;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/XID_Continue.js
  var _70 = [[48, 57], [65, 90], 95, [97, 122], 170, 181, 183, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [768, 884], [886, 887], [891, 893], 895, [902, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1155, 1159], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1488, 1514], [1519, 1522], [1552, 1562], [1568, 1641], [1646, 1747], [1749, 1756], [1759, 1768], [1770, 1788], 1791, [1808, 1866], [1869, 1969], [1984, 2037], 2042, 2045, [2048, 2093], [2112, 2139], [2144, 2154], [2160, 2183], [2185, 2190], [2200, 2273], [2275, 2403], [2406, 2415], [2417, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2545], 2556, 2558, [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2677], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2799], [2809, 2815], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2927], 2929, [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3055], [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3200, 3203], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315], [3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3406], [3412, 3415], [3423, 3427], [3430, 3439], [3450, 3455], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3571], [3585, 3642], [3648, 3662], [3664, 3673], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807], 3840, [3864, 3865], [3872, 3881], 3893, 3895, 3897, [3902, 3911], [3913, 3948], [3953, 3972], [3974, 3991], [3993, 4028], 4038, [4096, 4169], [4176, 4253], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4959], [4969, 4977], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5909], [5919, 5940], [5952, 5971], [5984, 5996], [5998, 6e3], [6002, 6003], [6016, 6099], 6103, [6108, 6109], [6112, 6121], [6155, 6157], [6159, 6169], [6176, 6264], [6272, 6314], [6320, 6389], [6400, 6430], [6432, 6443], [6448, 6459], [6470, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6656, 6683], [6688, 6750], [6752, 6780], [6783, 6793], [6800, 6809], 6823, [6832, 6845], [6847, 6862], [6912, 6988], [6992, 7001], [7019, 7027], [7040, 7155], [7168, 7223], [7232, 7241], [7245, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7376, 7378], [7380, 7418], [7424, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], [8255, 8256], 8276, 8305, 8319, [8336, 8348], [8400, 8412], 8417, [8421, 8432], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, 8486, 8488, [8490, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [11264, 11492], [11499, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11647, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [11744, 11775], [12293, 12295], [12321, 12335], [12337, 12341], [12344, 12348], [12353, 12438], [12441, 12442], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42539], [42560, 42607], [42612, 42621], [42623, 42737], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43047], 43052, [43072, 43123], [43136, 43205], [43216, 43225], [43232, 43255], 43259, [43261, 43309], [43312, 43347], [43360, 43388], [43392, 43456], [43471, 43481], [43488, 43518], [43520, 43574], [43584, 43597], [43600, 43609], [43616, 43638], [43642, 43714], [43739, 43741], [43744, 43759], [43762, 43766], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44010], [44012, 44013], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [64285, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64605], [64612, 64829], [64848, 64911], [64914, 64967], [65008, 65017], [65024, 65039], [65056, 65071], [65075, 65076], [65101, 65103], 65137, 65139, 65143, 65145, 65147, 65149, [65151, 65276], [65296, 65305], [65313, 65338], 65343, [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], 66045, [66176, 66204], [66208, 66256], 66272, [66304, 66335], [66349, 66378], [66384, 66426], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], [68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], 68159, [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68326], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68903], [68912, 68921], [69248, 69289], [69291, 69292], [69296, 69297], [69373, 69404], 69415, [69424, 69456], [69488, 69509], [69552, 69572], [69600, 69622], [69632, 69702], [69734, 69749], [69759, 69818], 69826, [69840, 69864], [69872, 69881], [69888, 69940], [69942, 69951], [69956, 69959], [69968, 70003], 70006, [70016, 70084], [70089, 70092], [70094, 70106], 70108, [70144, 70161], [70163, 70199], [70206, 70209], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70378], [70384, 70393], [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70459, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516], [70656, 70730], [70736, 70745], [70750, 70753], [70784, 70853], 70855, [70864, 70873], [71040, 71093], [71096, 71104], [71128, 71133], [71168, 71232], 71236, [71248, 71257], [71296, 71352], [71360, 71369], [71424, 71450], [71453, 71467], [71472, 71481], [71488, 71494], [71680, 71738], [71840, 71913], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72003], [72016, 72025], [72096, 72103], [72106, 72151], [72154, 72161], [72163, 72164], [72192, 72254], 72263, [72272, 72345], 72349, [72368, 72440], [72704, 72712], [72714, 72758], [72760, 72768], [72784, 72793], [72818, 72847], [72850, 72871], [72873, 72886], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129], [73440, 73462], [73472, 73488], [73490, 73530], [73534, 73538], [73552, 73561], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78912, 78933], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92784, 92862], [92864, 92873], [92880, 92909], [92912, 92916], [92928, 92982], [92992, 92995], [93008, 93017], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], [94031, 94087], [94095, 94111], [94176, 94177], [94179, 94180], [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113821, 113822], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [120782, 120831], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122624, 122654], [122661, 122666], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], [122928, 122989], 123023, [123136, 123180], [123184, 123197], [123200, 123209], 123214, [123536, 123566], [123584, 123641], [124112, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125136, 125142], [125184, 125259], [125264, 125273], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [130032, 130041], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743], [917760, 917999]];
  var XID_Continue_default = _70;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Binary_Property/XID_Start.js
  var _71 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [880, 884], [886, 887], [891, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1488, 1514], [1519, 1522], [1568, 1610], [1646, 1647], [1649, 1747], 1749, [1765, 1766], [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2037], 2042, [2048, 2069], 2074, 2084, 2088, [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2308, 2361], 2365, 2384, [2392, 2401], [2417, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], 3634, [3648, 3654], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], 3762, 3773, [3776, 3780], 3782, [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6103, 6108, [6176, 6264], [6272, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], 6823, [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8472, 8477], 8484, 8486, 8488, [8490, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [12293, 12295], [12321, 12329], [12337, 12341], [12344, 12348], [12353, 12438], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42623, 42653], [42656, 42735], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], 43471, [43488, 43492], [43494, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43741], [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64605], [64612, 64829], [64848, 64911], [64914, 64967], [65008, 65017], 65137, 65139, 65143, 65145, 65147, 65149, [65151, 65276], [65313, 65338], [65345, 65370], [65382, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66378], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], 94032, [94099, 94111], [94176, 94177], 94179, [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var XID_Start_default = _71;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/index.js
  var General_Category_exports = {};
  __export(General_Category_exports, {
    Cased_Letter: () => Cased_Letter_default,
    Close_Punctuation: () => Close_Punctuation_default,
    Connector_Punctuation: () => Connector_Punctuation_default,
    Control: () => Control_default,
    Currency_Symbol: () => Currency_Symbol_default,
    Dash_Punctuation: () => Dash_Punctuation_default,
    Decimal_Number: () => Decimal_Number_default,
    Enclosing_Mark: () => Enclosing_Mark_default,
    Final_Punctuation: () => Final_Punctuation_default,
    Format: () => Format_default,
    Initial_Punctuation: () => Initial_Punctuation_default,
    Letter: () => Letter_default,
    Letter_Number: () => Letter_Number_default,
    Line_Separator: () => Line_Separator_default,
    Lowercase_Letter: () => Lowercase_Letter_default,
    Mark: () => Mark_default,
    Math_Symbol: () => Math_Symbol_default,
    Modifier_Letter: () => Modifier_Letter_default,
    Modifier_Symbol: () => Modifier_Symbol_default,
    Nonspacing_Mark: () => Nonspacing_Mark_default,
    Number: () => Number_default,
    Open_Punctuation: () => Open_Punctuation_default,
    Other: () => Other_default,
    Other_Letter: () => Other_Letter_default,
    Other_Number: () => Other_Number_default,
    Other_Punctuation: () => Other_Punctuation_default,
    Other_Symbol: () => Other_Symbol_default,
    Paragraph_Separator: () => Paragraph_Separator_default,
    Private_Use: () => Private_Use_default,
    Punctuation: () => Punctuation_default,
    Separator: () => Separator_default,
    Space_Separator: () => Space_Separator_default,
    Spacing_Mark: () => Spacing_Mark_default,
    Surrogate: () => Surrogate_default,
    Symbol: () => Symbol_default,
    Titlecase_Letter: () => Titlecase_Letter_default,
    Unassigned: () => Unassigned_default,
    Uppercase_Letter: () => Uppercase_Letter_default
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Cased_Letter.js
  var _72 = [[65, 90], [97, 122], 181, [192, 214], [216, 246], [248, 442], [444, 447], [452, 659], [661, 687], [880, 883], [886, 887], [891, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], [1376, 1416], [4256, 4293], 4295, 4301, [4304, 4346], [4349, 4351], [5024, 5109], [5112, 5117], [7296, 7304], [7312, 7354], [7357, 7359], [7424, 7467], [7531, 7543], [7545, 7578], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8500], 8505, [8508, 8511], [8517, 8521], 8526, [8579, 8580], [11264, 11387], [11390, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [42560, 42605], [42624, 42651], [42786, 42863], [42865, 42887], [42891, 42894], [42896, 42954], [42960, 42961], 42963, [42965, 42969], [42997, 42998], 43002, [43824, 43866], [43872, 43880], [43888, 43967], [64256, 64262], [64275, 64279], [65313, 65338], [65345, 65370], [66560, 66639], [66736, 66771], [66776, 66811], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68736, 68786], [68800, 68850], [71840, 71903], [93760, 93823], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122633], [122635, 122654], [122661, 122666], [125184, 125251]];
  var Cased_Letter_default = _72;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Close_Punctuation.js
  var _73 = [41, 93, 125, 3899, 3901, 5788, 8262, 8318, 8334, 8969, 8971, 9002, 10089, 10091, 10093, 10095, 10097, 10099, 10101, 10182, 10215, 10217, 10219, 10221, 10223, 10628, 10630, 10632, 10634, 10636, 10638, 10640, 10642, 10644, 10646, 10648, 10713, 10715, 10749, 11811, 11813, 11815, 11817, 11862, 11864, 11866, 11868, 12297, 12299, 12301, 12303, 12305, 12309, 12311, 12313, 12315, [12318, 12319], 64830, 65048, 65078, 65080, 65082, 65084, 65086, 65088, 65090, 65092, 65096, 65114, 65116, 65118, 65289, 65341, 65373, 65376, 65379];
  var Close_Punctuation_default = _73;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Connector_Punctuation.js
  var _74 = [95, [8255, 8256], 8276, [65075, 65076], [65101, 65103], 65343];
  var Connector_Punctuation_default = _74;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Control.js
  var _75 = [[0, 31], [127, 159]];
  var Control_default = _75;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Currency_Symbol.js
  var _76 = [36, [162, 165], 1423, 1547, [2046, 2047], [2546, 2547], 2555, 2801, 3065, 3647, 6107, [8352, 8384], 43064, 65020, 65129, 65284, [65504, 65505], [65509, 65510], [73693, 73696], 123647, 126128];
  var Currency_Symbol_default = _76;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Dash_Punctuation.js
  var _77 = [45, 1418, 1470, 5120, 6150, [8208, 8213], 11799, 11802, [11834, 11835], 11840, 11869, 12316, 12336, 12448, [65073, 65074], 65112, 65123, 65293, 69293];
  var Dash_Punctuation_default = _77;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Decimal_Number.js
  var _78 = [[48, 57], [1632, 1641], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305], [66720, 66729], [68912, 68921], [69734, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71472, 71481], [71904, 71913], [72016, 72025], [72784, 72793], [73040, 73049], [73120, 73129], [73552, 73561], [92768, 92777], [92864, 92873], [93008, 93017], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [125264, 125273], [130032, 130041]];
  var Decimal_Number_default = _78;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Enclosing_Mark.js
  var _79 = [[1160, 1161], 6846, [8413, 8416], [8418, 8420], [42608, 42610]];
  var Enclosing_Mark_default = _79;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Final_Punctuation.js
  var _80 = [187, 8217, 8221, 8250, 11779, 11781, 11786, 11789, 11805, 11809];
  var Final_Punctuation_default = _80;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Format.js
  var _81 = [173, [1536, 1541], 1564, 1757, 1807, [2192, 2193], 2274, 6158, [8203, 8207], [8234, 8238], [8288, 8292], [8294, 8303], 65279, [65529, 65531], 69821, 69837, [78896, 78911], [113824, 113827], [119155, 119162], 917505, [917536, 917631]];
  var Format_default = _81;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Initial_Punctuation.js
  var _82 = [171, 8216, [8219, 8220], 8223, 8249, 11778, 11780, 11785, 11788, 11804, 11808];
  var Initial_Punctuation_default = _82;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Letter.js
  var _83 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 705], [710, 721], [736, 740], 748, 750, [880, 884], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], 1369, [1376, 1416], [1488, 1514], [1519, 1522], [1568, 1610], [1646, 1647], [1649, 1747], 1749, [1765, 1766], [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2037], 2042, [2048, 2069], 2074, 2084, 2088, [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2308, 2361], 2365, 2384, [2392, 2401], [2417, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3654], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], 3782, [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5873, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6103, 6108, [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], 6823, [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8508, 8511], [8517, 8521], 8526, [8579, 8580], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 11823, [12293, 12294], [12337, 12341], [12347, 12348], [12353, 12438], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42623, 42653], [42656, 42725], [42775, 42783], [42786, 42888], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], 43471, [43488, 43492], [43494, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43741], [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43866], [43868, 43881], [43888, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], [64256, 64262], [64275, 64279], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65313, 65338], [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66368], [66370, 66377], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], 94032, [94099, 94111], [94176, 94177], 94179, [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var Letter_default = _83;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Letter_Number.js
  var _84 = [[5870, 5872], [8544, 8578], [8581, 8584], 12295, [12321, 12329], [12344, 12346], [42726, 42735], [65856, 65908], 66369, 66378, [66513, 66517], [74752, 74862]];
  var Letter_Number_default = _84;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Line_Separator.js
  var _85 = [8232];
  var Line_Separator_default = _85;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Lowercase_Letter.js
  var _86 = [[97, 122], 181, [223, 246], [248, 255], 257, 259, 261, 263, 265, 267, 269, 271, 273, 275, 277, 279, 281, 283, 285, 287, 289, 291, 293, 295, 297, 299, 301, 303, 305, 307, 309, [311, 312], 314, 316, 318, 320, 322, 324, 326, [328, 329], 331, 333, 335, 337, 339, 341, 343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 378, 380, [382, 384], 387, 389, 392, [396, 397], 402, 405, [409, 411], 414, 417, 419, 421, 424, [426, 427], 429, 432, 436, 438, [441, 442], [445, 447], 454, 457, 460, 462, 464, 466, 468, 470, 472, 474, [476, 477], 479, 481, 483, 485, 487, 489, 491, 493, [495, 496], 499, 501, 505, 507, 509, 511, 513, 515, 517, 519, 521, 523, 525, 527, 529, 531, 533, 535, 537, 539, 541, 543, 545, 547, 549, 551, 553, 555, 557, 559, 561, [563, 569], 572, [575, 576], 578, 583, 585, 587, 589, [591, 659], [661, 687], 881, 883, 887, [891, 893], 912, [940, 974], [976, 977], [981, 983], 985, 987, 989, 991, 993, 995, 997, 999, 1001, 1003, 1005, [1007, 1011], 1013, 1016, [1019, 1020], [1072, 1119], 1121, 1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 1139, 1141, 1143, 1145, 1147, 1149, 1151, 1153, 1163, 1165, 1167, 1169, 1171, 1173, 1175, 1177, 1179, 1181, 1183, 1185, 1187, 1189, 1191, 1193, 1195, 1197, 1199, 1201, 1203, 1205, 1207, 1209, 1211, 1213, 1215, 1218, 1220, 1222, 1224, 1226, 1228, [1230, 1231], 1233, 1235, 1237, 1239, 1241, 1243, 1245, 1247, 1249, 1251, 1253, 1255, 1257, 1259, 1261, 1263, 1265, 1267, 1269, 1271, 1273, 1275, 1277, 1279, 1281, 1283, 1285, 1287, 1289, 1291, 1293, 1295, 1297, 1299, 1301, 1303, 1305, 1307, 1309, 1311, 1313, 1315, 1317, 1319, 1321, 1323, 1325, 1327, [1376, 1416], [4304, 4346], [4349, 4351], [5112, 5117], [7296, 7304], [7424, 7467], [7531, 7543], [7545, 7578], 7681, 7683, 7685, 7687, 7689, 7691, 7693, 7695, 7697, 7699, 7701, 7703, 7705, 7707, 7709, 7711, 7713, 7715, 7717, 7719, 7721, 7723, 7725, 7727, 7729, 7731, 7733, 7735, 7737, 7739, 7741, 7743, 7745, 7747, 7749, 7751, 7753, 7755, 7757, 7759, 7761, 7763, 7765, 7767, 7769, 7771, 7773, 7775, 7777, 7779, 7781, 7783, 7785, 7787, 7789, 7791, 7793, 7795, 7797, 7799, 7801, 7803, 7805, 7807, 7809, 7811, 7813, 7815, 7817, 7819, 7821, 7823, 7825, 7827, [7829, 7837], 7839, 7841, 7843, 7845, 7847, 7849, 7851, 7853, 7855, 7857, 7859, 7861, 7863, 7865, 7867, 7869, 7871, 7873, 7875, 7877, 7879, 7881, 7883, 7885, 7887, 7889, 7891, 7893, 7895, 7897, 7899, 7901, 7903, 7905, 7907, 7909, 7911, 7913, 7915, 7917, 7919, 7921, 7923, 7925, 7927, 7929, 7931, 7933, [7935, 7943], [7952, 7957], [7968, 7975], [7984, 7991], [8e3, 8005], [8016, 8023], [8032, 8039], [8048, 8061], [8064, 8071], [8080, 8087], [8096, 8103], [8112, 8116], [8118, 8119], 8126, [8130, 8132], [8134, 8135], [8144, 8147], [8150, 8151], [8160, 8167], [8178, 8180], [8182, 8183], 8458, [8462, 8463], 8467, 8495, 8500, 8505, [8508, 8509], [8518, 8521], 8526, 8580, [11312, 11359], 11361, [11365, 11366], 11368, 11370, 11372, 11377, [11379, 11380], [11382, 11387], 11393, 11395, 11397, 11399, 11401, 11403, 11405, 11407, 11409, 11411, 11413, 11415, 11417, 11419, 11421, 11423, 11425, 11427, 11429, 11431, 11433, 11435, 11437, 11439, 11441, 11443, 11445, 11447, 11449, 11451, 11453, 11455, 11457, 11459, 11461, 11463, 11465, 11467, 11469, 11471, 11473, 11475, 11477, 11479, 11481, 11483, 11485, 11487, 11489, [11491, 11492], 11500, 11502, 11507, [11520, 11557], 11559, 11565, 42561, 42563, 42565, 42567, 42569, 42571, 42573, 42575, 42577, 42579, 42581, 42583, 42585, 42587, 42589, 42591, 42593, 42595, 42597, 42599, 42601, 42603, 42605, 42625, 42627, 42629, 42631, 42633, 42635, 42637, 42639, 42641, 42643, 42645, 42647, 42649, 42651, 42787, 42789, 42791, 42793, 42795, 42797, [42799, 42801], 42803, 42805, 42807, 42809, 42811, 42813, 42815, 42817, 42819, 42821, 42823, 42825, 42827, 42829, 42831, 42833, 42835, 42837, 42839, 42841, 42843, 42845, 42847, 42849, 42851, 42853, 42855, 42857, 42859, 42861, 42863, [42865, 42872], 42874, 42876, 42879, 42881, 42883, 42885, 42887, 42892, 42894, 42897, [42899, 42901], 42903, 42905, 42907, 42909, 42911, 42913, 42915, 42917, 42919, 42921, 42927, 42933, 42935, 42937, 42939, 42941, 42943, 42945, 42947, 42952, 42954, 42961, 42963, 42965, 42967, 42969, 42998, 43002, [43824, 43866], [43872, 43880], [43888, 43967], [64256, 64262], [64275, 64279], [65345, 65370], [66600, 66639], [66776, 66811], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [68800, 68850], [71872, 71903], [93792, 93823], [119834, 119859], [119886, 119892], [119894, 119911], [119938, 119963], [119990, 119993], 119995, [119997, 120003], [120005, 120015], [120042, 120067], [120094, 120119], [120146, 120171], [120198, 120223], [120250, 120275], [120302, 120327], [120354, 120379], [120406, 120431], [120458, 120485], [120514, 120538], [120540, 120545], [120572, 120596], [120598, 120603], [120630, 120654], [120656, 120661], [120688, 120712], [120714, 120719], [120746, 120770], [120772, 120777], 120779, [122624, 122633], [122635, 122654], [122661, 122666], [125218, 125251]];
  var Lowercase_Letter_default = _86;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Mark.js
  var _87 = [[768, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2307], [2362, 2364], [2366, 2383], [2385, 2391], [2402, 2403], [2433, 2435], 2492, [2494, 2500], [2503, 2504], [2507, 2509], 2519, [2530, 2531], 2558, [2561, 2563], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2691], 2748, [2750, 2757], [2759, 2761], [2763, 2765], [2786, 2787], [2810, 2815], [2817, 2819], 2876, [2878, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2914, 2915], 2946, [3006, 3010], [3014, 3016], [3018, 3021], 3031, [3072, 3076], 3132, [3134, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], [3201, 3203], 3260, [3262, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3298, 3299], 3315, [3328, 3331], [3387, 3388], [3390, 3396], [3398, 3400], [3402, 3405], 3415, [3426, 3427], [3457, 3459], 3530, [3535, 3540], 3542, [3544, 3551], [3570, 3571], 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3902, 3903], [3953, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4139, 4158], [4182, 4185], [4190, 4192], [4194, 4196], [4199, 4205], [4209, 4212], [4226, 4237], 4239, [4250, 4253], [4957, 4959], [5906, 5909], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6443], [6448, 6459], [6679, 6683], [6741, 6750], [6752, 6780], 6783, [6832, 6862], [6912, 6916], [6964, 6980], [7019, 7027], [7040, 7042], [7073, 7085], [7142, 7155], [7204, 7223], [7376, 7378], [7380, 7400], 7405, 7412, [7415, 7417], [7616, 7679], [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12335], [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43043, 43047], 43052, [43136, 43137], [43188, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43347], [43392, 43395], [43443, 43456], 43493, [43561, 43574], 43587, [43596, 43597], [43643, 43645], 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43755, 43759], [43765, 43766], [44003, 44010], [44012, 44013], 64286, [65024, 65039], [65056, 65071], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], [69632, 69634], [69688, 69702], 69744, [69747, 69748], [69759, 69762], [69808, 69818], 69826, [69888, 69890], [69927, 69940], [69957, 69958], 70003, [70016, 70018], [70067, 70080], [70089, 70092], [70094, 70095], [70188, 70199], 70206, 70209, [70367, 70378], [70400, 70403], [70459, 70460], [70462, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70502, 70508], [70512, 70516], [70709, 70726], 70750, [70832, 70851], [71087, 71093], [71096, 71104], [71132, 71133], [71216, 71232], [71339, 71351], [71453, 71467], [71724, 71738], [71984, 71989], [71991, 71992], [71995, 71998], 72e3, [72002, 72003], [72145, 72151], [72154, 72160], 72164, [72193, 72202], [72243, 72249], [72251, 72254], 72263, [72273, 72283], [72330, 72345], [72751, 72758], [72760, 72767], [72850, 72871], [72873, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73098, 73102], [73104, 73105], [73107, 73111], [73459, 73462], [73472, 73473], 73475, [73524, 73530], [73534, 73538], 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94033, 94087], [94095, 94098], 94180, [94192, 94193], [113821, 113822], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [917760, 917999]];
  var Mark_default = _87;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Math_Symbol.js
  var _88 = [43, [60, 62], 124, 126, 172, 177, 215, 247, 1014, [1542, 1544], 8260, 8274, [8314, 8316], [8330, 8332], 8472, [8512, 8516], 8523, [8592, 8596], [8602, 8603], 8608, 8611, 8614, 8622, [8654, 8655], 8658, 8660, [8692, 8959], [8992, 8993], 9084, [9115, 9139], [9180, 9185], 9655, 9665, [9720, 9727], 9839, [10176, 10180], [10183, 10213], [10224, 10239], [10496, 10626], [10649, 10711], [10716, 10747], [10750, 11007], [11056, 11076], [11079, 11084], 64297, 65122, [65124, 65126], 65291, [65308, 65310], 65372, 65374, 65506, [65513, 65516], 120513, 120539, 120571, 120597, 120629, 120655, 120687, 120713, 120745, 120771, [126704, 126705]];
  var Math_Symbol_default = _88;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Modifier_Letter.js
  var _89 = [[688, 705], [710, 721], [736, 740], 748, 750, 884, 890, 1369, 1600, [1765, 1766], [2036, 2037], 2042, 2074, 2084, 2088, 2249, 2417, 3654, 3782, 4348, 6103, 6211, 6823, [7288, 7293], [7468, 7530], 7544, [7579, 7615], 8305, 8319, [8336, 8348], [11388, 11389], 11631, 11823, 12293, [12337, 12341], 12347, [12445, 12446], [12540, 12542], 40981, [42232, 42237], 42508, 42623, [42652, 42653], [42775, 42783], 42864, 42888, [42994, 42996], [43e3, 43001], 43471, 43494, 43632, 43741, [43763, 43764], [43868, 43871], 43881, 65392, [65438, 65439], [67456, 67461], [67463, 67504], [67506, 67514], [92992, 92995], [94099, 94111], [94176, 94177], 94179, [110576, 110579], [110581, 110587], [110589, 110590], [122928, 122989], [123191, 123197], 124139, 125259];
  var Modifier_Letter_default = _89;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Modifier_Symbol.js
  var _90 = [94, 96, 168, 175, 180, 184, [706, 709], [722, 735], [741, 747], 749, [751, 767], 885, [900, 901], 2184, 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [12443, 12444], [42752, 42774], [42784, 42785], [42889, 42890], 43867, [43882, 43883], [64434, 64450], 65342, 65344, 65507, [127995, 127999]];
  var Modifier_Symbol_default = _90;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Nonspacing_Mark.js
  var _91 = [[768, 879], [1155, 1159], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2433, 2492, [2497, 2500], 2509, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, 2879, [2881, 2884], 2893, [2901, 2902], [2914, 2915], 2946, 3008, 3021, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, 3263, 3270, [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], 3405, [3426, 3427], 3457, 3530, [3538, 3540], 3542, 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, [6832, 6845], [6847, 6862], [6912, 6915], 6964, [6966, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], [8400, 8412], 8417, [8421, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12333], [12441, 12442], 42607, [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43493, [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43756, 43757], 43766, 44005, 44008, 44013, 64286, [65024, 65039], [65056, 65071], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69826, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70464, [70502, 70508], [70512, 70516], [70712, 70719], [70722, 70724], 70726, 70750, [70835, 70840], 70842, [70847, 70848], [70850, 70851], [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, [71453, 71455], [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], 72767, [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94095, 94098], 94180, [113821, 113822], [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [917760, 917999]];
  var Nonspacing_Mark_default = _91;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Number.js
  var _92 = [[48, 57], [178, 179], 185, [188, 190], [1632, 1641], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2548, 2553], [2662, 2671], [2790, 2799], [2918, 2927], [2930, 2935], [3046, 3058], [3174, 3183], [3192, 3198], [3302, 3311], [3416, 3422], [3430, 3448], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3891], [4160, 4169], [4240, 4249], [4969, 4988], [5870, 5872], [6112, 6121], [6128, 6137], [6160, 6169], [6470, 6479], [6608, 6618], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], 8304, [8308, 8313], [8320, 8329], [8528, 8578], [8581, 8585], [9312, 9371], [9450, 9471], [10102, 10131], 11517, 12295, [12321, 12329], [12344, 12346], [12690, 12693], [12832, 12841], [12872, 12879], [12881, 12895], [12928, 12937], [12977, 12991], [42528, 42537], [42726, 42735], [43056, 43061], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305], [65799, 65843], [65856, 65912], [65930, 65931], [66273, 66299], [66336, 66339], 66369, 66378, [66513, 66517], [66720, 66729], [67672, 67679], [67705, 67711], [67751, 67759], [67835, 67839], [67862, 67867], [68028, 68029], [68032, 68047], [68050, 68095], [68160, 68168], [68221, 68222], [68253, 68255], [68331, 68335], [68440, 68447], [68472, 68479], [68521, 68527], [68858, 68863], [68912, 68921], [69216, 69246], [69405, 69414], [69457, 69460], [69573, 69579], [69714, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70113, 70132], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71472, 71483], [71904, 71922], [72016, 72025], [72784, 72812], [73040, 73049], [73120, 73129], [73552, 73561], [73664, 73684], [74752, 74862], [92768, 92777], [92864, 92873], [93008, 93017], [93019, 93025], [93824, 93846], [119488, 119507], [119520, 119539], [119648, 119672], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [125127, 125135], [125264, 125273], [126065, 126123], [126125, 126127], [126129, 126132], [126209, 126253], [126255, 126269], [127232, 127244], [130032, 130041]];
  var Number_default = _92;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Open_Punctuation.js
  var _93 = [40, 91, 123, 3898, 3900, 5787, 8218, 8222, 8261, 8317, 8333, 8968, 8970, 9001, 10088, 10090, 10092, 10094, 10096, 10098, 10100, 10181, 10214, 10216, 10218, 10220, 10222, 10627, 10629, 10631, 10633, 10635, 10637, 10639, 10641, 10643, 10645, 10647, 10712, 10714, 10748, 11810, 11812, 11814, 11816, 11842, 11861, 11863, 11865, 11867, 12296, 12298, 12300, 12302, 12304, 12308, 12310, 12312, 12314, 12317, 64831, 65047, 65077, 65079, 65081, 65083, 65085, 65087, 65089, 65091, 65095, 65113, 65115, 65117, 65288, 65339, 65371, 65375, 65378];
  var Open_Punctuation_default = _93;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other.js
  var _94 = [[0, 31], [127, 159], 173, [888, 889], [896, 899], 907, 909, 930, 1328, [1367, 1368], [1419, 1420], 1424, [1480, 1487], [1515, 1518], [1525, 1541], 1564, 1757, [1806, 1807], [1867, 1868], [1970, 1983], [2043, 2044], [2094, 2095], 2111, [2140, 2141], 2143, [2155, 2159], [2191, 2199], 2274, 2436, [2445, 2446], [2449, 2450], 2473, 2481, [2483, 2485], [2490, 2491], [2501, 2502], [2505, 2506], [2511, 2518], [2520, 2523], 2526, [2532, 2533], [2559, 2560], 2564, [2571, 2574], [2577, 2578], 2601, 2609, 2612, 2615, [2618, 2619], 2621, [2627, 2630], [2633, 2634], [2638, 2640], [2642, 2648], 2653, [2655, 2661], [2679, 2688], 2692, 2702, 2706, 2729, 2737, 2740, [2746, 2747], 2758, 2762, [2766, 2767], [2769, 2783], [2788, 2789], [2802, 2808], 2816, 2820, [2829, 2830], [2833, 2834], 2857, 2865, 2868, [2874, 2875], [2885, 2886], [2889, 2890], [2894, 2900], [2904, 2907], 2910, [2916, 2917], [2936, 2945], 2948, [2955, 2957], 2961, [2966, 2968], 2971, 2973, [2976, 2978], [2981, 2983], [2987, 2989], [3002, 3005], [3011, 3013], 3017, [3022, 3023], [3025, 3030], [3032, 3045], [3067, 3071], 3085, 3089, 3113, [3130, 3131], 3141, 3145, [3150, 3156], 3159, [3163, 3164], [3166, 3167], [3172, 3173], [3184, 3190], 3213, 3217, 3241, 3252, [3258, 3259], 3269, 3273, [3278, 3284], [3287, 3292], 3295, [3300, 3301], 3312, [3316, 3327], 3341, 3345, 3397, 3401, [3408, 3411], [3428, 3429], 3456, 3460, [3479, 3481], 3506, 3516, [3518, 3519], [3527, 3529], [3531, 3534], 3541, 3543, [3552, 3557], [3568, 3569], [3573, 3584], [3643, 3646], [3676, 3712], 3715, 3717, 3723, 3748, 3750, [3774, 3775], 3781, 3783, 3791, [3802, 3803], [3808, 3839], 3912, [3949, 3952], 3992, 4029, 4045, [4059, 4095], 4294, [4296, 4300], [4302, 4303], 4681, [4686, 4687], 4695, 4697, [4702, 4703], 4745, [4750, 4751], 4785, [4790, 4791], 4799, 4801, [4806, 4807], 4823, 4881, [4886, 4887], [4955, 4956], [4989, 4991], [5018, 5023], [5110, 5111], [5118, 5119], [5789, 5791], [5881, 5887], [5910, 5918], [5943, 5951], [5972, 5983], 5997, 6001, [6004, 6015], [6110, 6111], [6122, 6127], [6138, 6143], 6158, [6170, 6175], [6265, 6271], [6315, 6319], [6390, 6399], 6431, [6444, 6447], [6460, 6463], [6465, 6467], [6510, 6511], [6517, 6527], [6572, 6575], [6602, 6607], [6619, 6621], [6684, 6685], 6751, [6781, 6782], [6794, 6799], [6810, 6815], [6830, 6831], [6863, 6911], [6989, 6991], 7039, [7156, 7163], [7224, 7226], [7242, 7244], [7305, 7311], [7355, 7356], [7368, 7375], [7419, 7423], [7958, 7959], [7966, 7967], [8006, 8007], [8014, 8015], 8024, 8026, 8028, 8030, [8062, 8063], 8117, 8133, [8148, 8149], 8156, [8176, 8177], 8181, 8191, [8203, 8207], [8234, 8238], [8288, 8303], [8306, 8307], 8335, [8349, 8351], [8385, 8399], [8433, 8447], [8588, 8591], [9255, 9279], [9291, 9311], [11124, 11125], 11158, [11508, 11512], 11558, [11560, 11564], [11566, 11567], [11624, 11630], [11633, 11646], [11671, 11679], 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, [11870, 11903], 11930, [12020, 12031], [12246, 12271], [12284, 12287], 12352, [12439, 12440], [12544, 12548], 12592, 12687, [12772, 12783], 12831, [42125, 42127], [42183, 42191], [42540, 42559], [42744, 42751], [42955, 42959], 42962, 42964, [42970, 42993], [43053, 43055], [43066, 43071], [43128, 43135], [43206, 43213], [43226, 43231], [43348, 43358], [43389, 43391], 43470, [43482, 43485], 43519, [43575, 43583], [43598, 43599], [43610, 43611], [43715, 43738], [43767, 43776], [43783, 43784], [43791, 43792], [43799, 43807], 43815, 43823, [43884, 43887], [44014, 44015], [44026, 44031], [55204, 55215], [55239, 55242], [55292, 63743], [64110, 64111], [64218, 64255], [64263, 64274], [64280, 64284], 64311, 64317, 64319, 64322, 64325, [64451, 64466], [64912, 64913], [64968, 64974], [64976, 65007], [65050, 65055], 65107, 65127, [65132, 65135], 65141, [65277, 65280], [65471, 65473], [65480, 65481], [65488, 65489], [65496, 65497], [65501, 65503], 65511, [65519, 65531], [65534, 65535], 65548, 65575, 65595, 65598, [65614, 65615], [65630, 65663], [65787, 65791], [65795, 65798], [65844, 65846], 65935, [65949, 65951], [65953, 65999], [66046, 66175], [66205, 66207], [66257, 66271], [66300, 66303], [66340, 66348], [66379, 66383], [66427, 66431], 66462, [66500, 66503], [66518, 66559], [66718, 66719], [66730, 66735], [66772, 66775], [66812, 66815], [66856, 66863], [66916, 66926], 66939, 66955, 66963, 66966, 66978, 66994, 67002, [67005, 67071], [67383, 67391], [67414, 67423], [67432, 67455], 67462, 67505, [67515, 67583], [67590, 67591], 67593, 67638, [67641, 67643], [67645, 67646], 67670, [67743, 67750], [67760, 67807], 67827, [67830, 67834], [67868, 67870], [67898, 67902], [67904, 67967], [68024, 68027], [68048, 68049], 68100, [68103, 68107], 68116, 68120, [68150, 68151], [68155, 68158], [68169, 68175], [68185, 68191], [68256, 68287], [68327, 68330], [68343, 68351], [68406, 68408], [68438, 68439], [68467, 68471], [68498, 68504], [68509, 68520], [68528, 68607], [68681, 68735], [68787, 68799], [68851, 68857], [68904, 68911], [68922, 69215], 69247, 69290, [69294, 69295], [69298, 69372], [69416, 69423], [69466, 69487], [69514, 69551], [69580, 69599], [69623, 69631], [69710, 69713], [69750, 69758], 69821, [69827, 69839], [69865, 69871], [69882, 69887], 69941, [69960, 69967], [70007, 70015], 70112, [70133, 70143], 70162, [70210, 70271], 70279, 70281, 70286, 70302, [70314, 70319], [70379, 70383], [70394, 70399], 70404, [70413, 70414], [70417, 70418], 70441, 70449, 70452, 70458, [70469, 70470], [70473, 70474], [70478, 70479], [70481, 70486], [70488, 70492], [70500, 70501], [70509, 70511], [70517, 70655], 70748, [70754, 70783], [70856, 70863], [70874, 71039], [71094, 71095], [71134, 71167], [71237, 71247], [71258, 71263], [71277, 71295], [71354, 71359], [71370, 71423], [71451, 71452], [71468, 71471], [71495, 71679], [71740, 71839], [71923, 71934], [71943, 71944], [71946, 71947], 71956, 71959, 71990, [71993, 71994], [72007, 72015], [72026, 72095], [72104, 72105], [72152, 72153], [72165, 72191], [72264, 72271], [72355, 72367], [72441, 72447], [72458, 72703], 72713, 72759, [72774, 72783], [72813, 72815], [72848, 72849], 72872, [72887, 72959], 72967, 72970, [73015, 73017], 73019, 73022, [73032, 73039], [73050, 73055], 73062, 73065, 73103, 73106, [73113, 73119], [73130, 73439], [73465, 73471], 73489, [73531, 73533], [73562, 73647], [73649, 73663], [73714, 73726], [74650, 74751], 74863, [74869, 74879], [75076, 77711], [77811, 77823], [78896, 78911], [78934, 82943], [83527, 92159], [92729, 92735], 92767, [92778, 92781], 92863, [92874, 92879], [92910, 92911], [92918, 92927], [92998, 93007], 93018, 93026, [93048, 93052], [93072, 93759], [93851, 93951], [94027, 94030], [94088, 94094], [94112, 94175], [94181, 94191], [94194, 94207], [100344, 100351], [101590, 101631], [101641, 110575], 110580, 110588, 110591, [110883, 110897], [110899, 110927], [110931, 110932], [110934, 110947], [110952, 110959], [111356, 113663], [113771, 113775], [113789, 113791], [113801, 113807], [113818, 113819], [113824, 118527], [118574, 118575], [118599, 118607], [118724, 118783], [119030, 119039], [119079, 119080], [119155, 119162], [119275, 119295], [119366, 119487], [119508, 119519], [119540, 119551], [119639, 119647], [119673, 119807], 119893, 119965, [119968, 119969], [119971, 119972], [119975, 119976], 119981, 119994, 119996, 120004, 120070, [120075, 120076], 120085, 120093, 120122, 120127, 120133, [120135, 120137], 120145, [120486, 120487], [120780, 120781], [121484, 121498], 121504, [121520, 122623], [122655, 122660], [122667, 122879], 122887, [122905, 122906], 122914, 122917, [122923, 122927], [122990, 123022], [123024, 123135], [123181, 123183], [123198, 123199], [123210, 123213], [123216, 123535], [123567, 123583], [123642, 123646], [123648, 124111], [124154, 124895], 124903, 124908, 124911, 124927, [125125, 125126], [125143, 125183], [125260, 125263], [125274, 125277], [125280, 126064], [126133, 126208], [126270, 126463], 126468, 126496, 126499, [126501, 126502], 126504, 126515, 126520, 126522, [126524, 126529], [126531, 126534], 126536, 126538, 126540, 126544, 126547, [126549, 126550], 126552, 126554, 126556, 126558, 126560, 126563, [126565, 126566], 126571, 126579, 126584, 126589, 126591, 126602, [126620, 126624], 126628, 126634, [126652, 126703], [126706, 126975], [127020, 127023], [127124, 127135], [127151, 127152], 127168, 127184, [127222, 127231], [127406, 127461], [127491, 127503], [127548, 127551], [127561, 127567], [127570, 127583], [127590, 127743], [128728, 128731], [128749, 128751], [128765, 128767], [128887, 128890], [128986, 128991], [129004, 129007], [129009, 129023], [129036, 129039], [129096, 129103], [129114, 129119], [129160, 129167], [129198, 129199], [129202, 129279], [129620, 129631], [129646, 129647], [129661, 129663], [129673, 129679], 129726, [129734, 129741], [129756, 129759], [129769, 129775], [129785, 129791], 129939, [129995, 130031], [130042, 131071], [173792, 173823], [177978, 177983], [178206, 178207], [183970, 183983], [191457, 194559], [195102, 196607], [201547, 201551], [205744, 917759], [918e3, 1114111]];
  var Other_default = _94;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other_Letter.js
  var _95 = [170, 186, 443, [448, 451], 660, [1488, 1514], [1519, 1522], [1568, 1599], [1601, 1610], [1646, 1647], [1649, 1747], 1749, [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2048, 2069], [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2248], [2308, 2361], 2365, 2384, [2392, 2401], [2418, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3585, 3632], [3634, 3635], [3648, 3653], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], [3804, 3807], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4096, 4138], 4159, [4176, 4181], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4352, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5873, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6108, [6176, 6210], [6212, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6656, 6678], [6688, 6740], [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7287], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [8501, 8504], [11568, 11623], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 12294, 12348, [12353, 12438], 12447, [12449, 12538], 12543, [12549, 12591], [12593, 12686], [12704, 12735], [12784, 12799], [13312, 19903], [19968, 40980], [40982, 42124], [42192, 42231], [42240, 42507], [42512, 42527], [42538, 42539], 42606, [42656, 42725], 42895, 42999, [43003, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], [43488, 43492], [43495, 43503], [43514, 43518], [43520, 43560], [43584, 43586], [43588, 43595], [43616, 43631], [43633, 43638], 43642, [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43740], [43744, 43754], 43762, [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43968, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [63744, 64109], [64112, 64217], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65382, 65391], [65393, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66368], [66370, 66377], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66640, 66717], [66816, 66855], [66864, 66915], [67072, 67382], [67392, 67413], [67424, 67431], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71424, 71450], [71488, 71494], [71680, 71723], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [93027, 93047], [93053, 93071], [93952, 94026], 94032, [94208, 100343], [100352, 101589], [101632, 101640], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 122634, [123136, 123180], 123214, [123536, 123565], [123584, 123627], [124112, 124138], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var Other_Letter_default = _95;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other_Number.js
  var _96 = [[178, 179], 185, [188, 190], [2548, 2553], [2930, 2935], [3056, 3058], [3192, 3198], [3416, 3422], [3440, 3448], [3882, 3891], [4969, 4988], [6128, 6137], 6618, 8304, [8308, 8313], [8320, 8329], [8528, 8543], 8585, [9312, 9371], [9450, 9471], [10102, 10131], 11517, [12690, 12693], [12832, 12841], [12872, 12879], [12881, 12895], [12928, 12937], [12977, 12991], [43056, 43061], [65799, 65843], [65909, 65912], [65930, 65931], [66273, 66299], [66336, 66339], [67672, 67679], [67705, 67711], [67751, 67759], [67835, 67839], [67862, 67867], [68028, 68029], [68032, 68047], [68050, 68095], [68160, 68168], [68221, 68222], [68253, 68255], [68331, 68335], [68440, 68447], [68472, 68479], [68521, 68527], [68858, 68863], [69216, 69246], [69405, 69414], [69457, 69460], [69573, 69579], [69714, 69733], [70113, 70132], [71482, 71483], [71914, 71922], [72794, 72812], [73664, 73684], [93019, 93025], [93824, 93846], [119488, 119507], [119520, 119539], [119648, 119672], [125127, 125135], [126065, 126123], [126125, 126127], [126129, 126132], [126209, 126253], [126255, 126269], [127232, 127244]];
  var Other_Number_default = _96;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other_Punctuation.js
  var _97 = [[33, 35], [37, 39], 42, 44, [46, 47], [58, 59], [63, 64], 92, 161, 167, [182, 183], 191, 894, 903, [1370, 1375], 1417, 1472, 1475, 1478, [1523, 1524], [1545, 1546], [1548, 1549], 1563, [1565, 1567], [1642, 1645], 1748, [1792, 1805], [2039, 2041], [2096, 2110], 2142, [2404, 2405], 2416, 2557, 2678, 2800, 3191, 3204, 3572, 3663, [3674, 3675], [3844, 3858], 3860, 3973, [4048, 4052], [4057, 4058], [4170, 4175], 4347, [4960, 4968], 5742, [5867, 5869], [5941, 5942], [6100, 6102], [6104, 6106], [6144, 6149], [6151, 6154], [6468, 6469], [6686, 6687], [6816, 6822], [6824, 6829], [7002, 7008], [7037, 7038], [7164, 7167], [7227, 7231], [7294, 7295], [7360, 7367], 7379, [8214, 8215], [8224, 8231], [8240, 8248], [8251, 8254], [8257, 8259], [8263, 8273], 8275, [8277, 8286], [11513, 11516], [11518, 11519], 11632, [11776, 11777], [11782, 11784], 11787, [11790, 11798], [11800, 11801], 11803, [11806, 11807], [11818, 11822], [11824, 11833], [11836, 11839], 11841, [11843, 11855], [11858, 11860], [12289, 12291], 12349, 12539, [42238, 42239], [42509, 42511], 42611, 42622, [42738, 42743], [43124, 43127], [43214, 43215], [43256, 43258], 43260, [43310, 43311], 43359, [43457, 43469], [43486, 43487], [43612, 43615], [43742, 43743], [43760, 43761], 44011, [65040, 65046], 65049, 65072, [65093, 65094], [65097, 65100], [65104, 65106], [65108, 65111], [65119, 65121], 65128, [65130, 65131], [65281, 65283], [65285, 65287], 65290, 65292, [65294, 65295], [65306, 65307], [65311, 65312], 65340, 65377, [65380, 65381], [65792, 65794], 66463, 66512, 66927, 67671, 67871, 67903, [68176, 68184], 68223, [68336, 68342], [68409, 68415], [68505, 68508], [69461, 69465], [69510, 69513], [69703, 69709], [69819, 69820], [69822, 69825], [69952, 69955], [70004, 70005], [70085, 70088], 70093, 70107, [70109, 70111], [70200, 70205], 70313, [70731, 70735], [70746, 70747], 70749, 70854, [71105, 71127], [71233, 71235], [71264, 71276], 71353, [71484, 71486], 71739, [72004, 72006], 72162, [72255, 72262], [72346, 72348], [72350, 72354], [72448, 72457], [72769, 72773], [72816, 72817], [73463, 73464], [73539, 73551], 73727, [74864, 74868], [77809, 77810], [92782, 92783], 92917, [92983, 92987], 92996, [93847, 93850], 94178, 113823, [121479, 121483], [125278, 125279]];
  var Other_Punctuation_default = _97;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Other_Symbol.js
  var _98 = [166, 169, 174, 176, 1154, [1421, 1422], [1550, 1551], 1758, 1769, [1789, 1790], 2038, 2554, 2928, [3059, 3064], 3066, 3199, 3407, 3449, [3841, 3843], 3859, [3861, 3863], [3866, 3871], 3892, 3894, 3896, [4030, 4037], [4039, 4044], [4046, 4047], [4053, 4056], [4254, 4255], [5008, 5017], 5741, 6464, [6622, 6655], [7009, 7018], [7028, 7036], [8448, 8449], [8451, 8454], [8456, 8457], 8468, [8470, 8471], [8478, 8483], 8485, 8487, 8489, 8494, [8506, 8507], 8522, [8524, 8525], 8527, [8586, 8587], [8597, 8601], [8604, 8607], [8609, 8610], [8612, 8613], [8615, 8621], [8623, 8653], [8656, 8657], 8659, [8661, 8691], [8960, 8967], [8972, 8991], [8994, 9e3], [9003, 9083], [9085, 9114], [9140, 9179], [9186, 9254], [9280, 9290], [9372, 9449], [9472, 9654], [9656, 9664], [9666, 9719], [9728, 9838], [9840, 10087], [10132, 10175], [10240, 10495], [11008, 11055], [11077, 11078], [11085, 11123], [11126, 11157], [11159, 11263], [11493, 11498], [11856, 11857], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], 12292, [12306, 12307], 12320, [12342, 12343], [12350, 12351], [12688, 12689], [12694, 12703], [12736, 12771], [12800, 12830], [12842, 12871], 12880, [12896, 12927], [12938, 12976], [12992, 13311], [19904, 19967], [42128, 42182], [43048, 43051], [43062, 43063], 43065, [43639, 43641], [64832, 64847], 64975, [65021, 65023], 65508, 65512, [65517, 65518], [65532, 65533], [65847, 65855], [65913, 65929], [65932, 65934], [65936, 65948], 65952, [66e3, 66044], [67703, 67704], 68296, 71487, [73685, 73692], [73697, 73713], [92988, 92991], 92997, 113820, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119140], [119146, 119148], [119171, 119172], [119180, 119209], [119214, 119274], [119296, 119361], 119365, [119552, 119638], [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121478], 123215, 126124, 126254, [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127245, 127405], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 127994], [128e3, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994]];
  var Other_Symbol_default = _98;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Paragraph_Separator.js
  var _99 = [8233];
  var Paragraph_Separator_default = _99;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Private_Use.js
  var _100 = [[57344, 63743], [983040, 1048573], [1048576, 1114109]];
  var Private_Use_default = _100;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Punctuation.js
  var _101 = [[33, 35], [37, 42], [44, 47], [58, 59], [63, 64], [91, 93], 95, 123, 125, 161, 167, 171, [182, 183], 187, 191, 894, 903, [1370, 1375], [1417, 1418], 1470, 1472, 1475, 1478, [1523, 1524], [1545, 1546], [1548, 1549], 1563, [1565, 1567], [1642, 1645], 1748, [1792, 1805], [2039, 2041], [2096, 2110], 2142, [2404, 2405], 2416, 2557, 2678, 2800, 3191, 3204, 3572, 3663, [3674, 3675], [3844, 3858], 3860, [3898, 3901], 3973, [4048, 4052], [4057, 4058], [4170, 4175], 4347, [4960, 4968], 5120, 5742, [5787, 5788], [5867, 5869], [5941, 5942], [6100, 6102], [6104, 6106], [6144, 6154], [6468, 6469], [6686, 6687], [6816, 6822], [6824, 6829], [7002, 7008], [7037, 7038], [7164, 7167], [7227, 7231], [7294, 7295], [7360, 7367], 7379, [8208, 8231], [8240, 8259], [8261, 8273], [8275, 8286], [8317, 8318], [8333, 8334], [8968, 8971], [9001, 9002], [10088, 10101], [10181, 10182], [10214, 10223], [10627, 10648], [10712, 10715], [10748, 10749], [11513, 11516], [11518, 11519], 11632, [11776, 11822], [11824, 11855], [11858, 11869], [12289, 12291], [12296, 12305], [12308, 12319], 12336, 12349, 12448, 12539, [42238, 42239], [42509, 42511], 42611, 42622, [42738, 42743], [43124, 43127], [43214, 43215], [43256, 43258], 43260, [43310, 43311], 43359, [43457, 43469], [43486, 43487], [43612, 43615], [43742, 43743], [43760, 43761], 44011, [64830, 64831], [65040, 65049], [65072, 65106], [65108, 65121], 65123, 65128, [65130, 65131], [65281, 65283], [65285, 65290], [65292, 65295], [65306, 65307], [65311, 65312], [65339, 65341], 65343, 65371, 65373, [65375, 65381], [65792, 65794], 66463, 66512, 66927, 67671, 67871, 67903, [68176, 68184], 68223, [68336, 68342], [68409, 68415], [68505, 68508], 69293, [69461, 69465], [69510, 69513], [69703, 69709], [69819, 69820], [69822, 69825], [69952, 69955], [70004, 70005], [70085, 70088], 70093, 70107, [70109, 70111], [70200, 70205], 70313, [70731, 70735], [70746, 70747], 70749, 70854, [71105, 71127], [71233, 71235], [71264, 71276], 71353, [71484, 71486], 71739, [72004, 72006], 72162, [72255, 72262], [72346, 72348], [72350, 72354], [72448, 72457], [72769, 72773], [72816, 72817], [73463, 73464], [73539, 73551], 73727, [74864, 74868], [77809, 77810], [92782, 92783], 92917, [92983, 92987], 92996, [93847, 93850], 94178, 113823, [121479, 121483], [125278, 125279]];
  var Punctuation_default = _101;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Separator.js
  var _102 = [32, 160, 5760, [8192, 8202], [8232, 8233], 8239, 8287, 12288];
  var Separator_default = _102;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Space_Separator.js
  var _103 = [32, 160, 5760, [8192, 8202], 8239, 8287, 12288];
  var Space_Separator_default = _103;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Spacing_Mark.js
  var _104 = [2307, 2363, [2366, 2368], [2377, 2380], [2382, 2383], [2434, 2435], [2494, 2496], [2503, 2504], [2507, 2508], 2519, 2563, [2622, 2624], 2691, [2750, 2752], 2761, [2763, 2764], [2818, 2819], 2878, 2880, [2887, 2888], [2891, 2892], 2903, [3006, 3007], [3009, 3010], [3014, 3016], [3018, 3020], 3031, [3073, 3075], [3137, 3140], [3202, 3203], 3262, [3264, 3268], [3271, 3272], [3274, 3275], [3285, 3286], 3315, [3330, 3331], [3390, 3392], [3398, 3400], [3402, 3404], 3415, [3458, 3459], [3535, 3537], [3544, 3551], [3570, 3571], [3902, 3903], 3967, [4139, 4140], 4145, 4152, [4155, 4156], [4182, 4183], [4194, 4196], [4199, 4205], [4227, 4228], [4231, 4236], 4239, [4250, 4252], 5909, 5940, 6070, [6078, 6085], [6087, 6088], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], [6681, 6682], 6741, 6743, 6753, [6755, 6756], [6765, 6770], 6916, 6965, 6971, [6973, 6977], [6979, 6980], 7042, 7073, [7078, 7079], 7082, 7143, [7146, 7148], 7150, [7154, 7155], [7204, 7211], [7220, 7221], 7393, 7415, [12334, 12335], [43043, 43044], 43047, [43136, 43137], [43188, 43203], [43346, 43347], 43395, [43444, 43445], [43450, 43451], [43454, 43456], [43567, 43568], [43571, 43572], 43597, 43643, 43645, 43755, [43758, 43759], 43765, [44003, 44004], [44006, 44007], [44009, 44010], 44012, 69632, 69634, 69762, [69808, 69810], [69815, 69816], 69932, [69957, 69958], 70018, [70067, 70069], [70079, 70080], 70094, [70188, 70190], [70194, 70195], 70197, [70368, 70370], [70402, 70403], [70462, 70463], [70465, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70709, 70711], [70720, 70721], 70725, [70832, 70834], 70841, [70843, 70846], 70849, [71087, 71089], [71096, 71099], 71102, [71216, 71218], [71227, 71228], 71230, 71340, [71342, 71343], 71350, [71456, 71457], 71462, [71724, 71726], 71736, [71984, 71989], [71991, 71992], 71997, 72e3, 72002, [72145, 72147], [72156, 72159], 72164, 72249, [72279, 72280], 72343, 72751, 72766, 72873, 72881, 72884, [73098, 73102], [73107, 73108], 73110, [73461, 73462], 73475, [73524, 73525], [73534, 73535], 73537, [94033, 94087], [94192, 94193], [119141, 119142], [119149, 119154]];
  var Spacing_Mark_default = _104;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Surrogate.js
  var _105 = [[55296, 57343]];
  var Surrogate_default = _105;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Symbol.js
  var _106 = [36, 43, [60, 62], 94, 96, 124, 126, [162, 166], [168, 169], 172, [174, 177], 180, 184, 215, 247, [706, 709], [722, 735], [741, 747], 749, [751, 767], 885, [900, 901], 1014, 1154, [1421, 1423], [1542, 1544], 1547, [1550, 1551], 1758, 1769, [1789, 1790], 2038, [2046, 2047], 2184, [2546, 2547], [2554, 2555], 2801, 2928, [3059, 3066], 3199, 3407, 3449, 3647, [3841, 3843], 3859, [3861, 3863], [3866, 3871], 3892, 3894, 3896, [4030, 4037], [4039, 4044], [4046, 4047], [4053, 4056], [4254, 4255], [5008, 5017], 5741, 6107, 6464, [6622, 6655], [7009, 7018], [7028, 7036], 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], 8260, 8274, [8314, 8316], [8330, 8332], [8352, 8384], [8448, 8449], [8451, 8454], [8456, 8457], 8468, [8470, 8472], [8478, 8483], 8485, 8487, 8489, 8494, [8506, 8507], [8512, 8516], [8522, 8525], 8527, [8586, 8587], [8592, 8967], [8972, 9e3], [9003, 9254], [9280, 9290], [9372, 9449], [9472, 10087], [10132, 10180], [10183, 10213], [10224, 10626], [10649, 10711], [10716, 10747], [10750, 11123], [11126, 11157], [11159, 11263], [11493, 11498], [11856, 11857], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], 12292, [12306, 12307], 12320, [12342, 12343], [12350, 12351], [12443, 12444], [12688, 12689], [12694, 12703], [12736, 12771], [12800, 12830], [12842, 12871], 12880, [12896, 12927], [12938, 12976], [12992, 13311], [19904, 19967], [42128, 42182], [42752, 42774], [42784, 42785], [42889, 42890], [43048, 43051], [43062, 43065], [43639, 43641], 43867, [43882, 43883], 64297, [64434, 64450], [64832, 64847], 64975, [65020, 65023], 65122, [65124, 65126], 65129, 65284, 65291, [65308, 65310], 65342, 65344, 65372, 65374, [65504, 65510], [65512, 65518], [65532, 65533], [65847, 65855], [65913, 65929], [65932, 65934], [65936, 65948], 65952, [66e3, 66044], [67703, 67704], 68296, 71487, [73685, 73713], [92988, 92991], 92997, 113820, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119140], [119146, 119148], [119171, 119172], [119180, 119209], [119214, 119274], [119296, 119361], 119365, [119552, 119638], 120513, 120539, 120571, 120597, 120629, 120655, 120687, 120713, 120745, 120771, [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121478], 123215, 123647, 126124, 126128, 126254, [126704, 126705], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127245, 127405], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994]];
  var Symbol_default = _106;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Titlecase_Letter.js
  var _107 = [453, 456, 459, 498, [8072, 8079], [8088, 8095], [8104, 8111], 8124, 8140, 8188];
  var Titlecase_Letter_default = _107;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Unassigned.js
  var _108 = [[888, 889], [896, 899], 907, 909, 930, 1328, [1367, 1368], [1419, 1420], 1424, [1480, 1487], [1515, 1518], [1525, 1535], 1806, [1867, 1868], [1970, 1983], [2043, 2044], [2094, 2095], 2111, [2140, 2141], 2143, [2155, 2159], 2191, [2194, 2199], 2436, [2445, 2446], [2449, 2450], 2473, 2481, [2483, 2485], [2490, 2491], [2501, 2502], [2505, 2506], [2511, 2518], [2520, 2523], 2526, [2532, 2533], [2559, 2560], 2564, [2571, 2574], [2577, 2578], 2601, 2609, 2612, 2615, [2618, 2619], 2621, [2627, 2630], [2633, 2634], [2638, 2640], [2642, 2648], 2653, [2655, 2661], [2679, 2688], 2692, 2702, 2706, 2729, 2737, 2740, [2746, 2747], 2758, 2762, [2766, 2767], [2769, 2783], [2788, 2789], [2802, 2808], 2816, 2820, [2829, 2830], [2833, 2834], 2857, 2865, 2868, [2874, 2875], [2885, 2886], [2889, 2890], [2894, 2900], [2904, 2907], 2910, [2916, 2917], [2936, 2945], 2948, [2955, 2957], 2961, [2966, 2968], 2971, 2973, [2976, 2978], [2981, 2983], [2987, 2989], [3002, 3005], [3011, 3013], 3017, [3022, 3023], [3025, 3030], [3032, 3045], [3067, 3071], 3085, 3089, 3113, [3130, 3131], 3141, 3145, [3150, 3156], 3159, [3163, 3164], [3166, 3167], [3172, 3173], [3184, 3190], 3213, 3217, 3241, 3252, [3258, 3259], 3269, 3273, [3278, 3284], [3287, 3292], 3295, [3300, 3301], 3312, [3316, 3327], 3341, 3345, 3397, 3401, [3408, 3411], [3428, 3429], 3456, 3460, [3479, 3481], 3506, 3516, [3518, 3519], [3527, 3529], [3531, 3534], 3541, 3543, [3552, 3557], [3568, 3569], [3573, 3584], [3643, 3646], [3676, 3712], 3715, 3717, 3723, 3748, 3750, [3774, 3775], 3781, 3783, 3791, [3802, 3803], [3808, 3839], 3912, [3949, 3952], 3992, 4029, 4045, [4059, 4095], 4294, [4296, 4300], [4302, 4303], 4681, [4686, 4687], 4695, 4697, [4702, 4703], 4745, [4750, 4751], 4785, [4790, 4791], 4799, 4801, [4806, 4807], 4823, 4881, [4886, 4887], [4955, 4956], [4989, 4991], [5018, 5023], [5110, 5111], [5118, 5119], [5789, 5791], [5881, 5887], [5910, 5918], [5943, 5951], [5972, 5983], 5997, 6001, [6004, 6015], [6110, 6111], [6122, 6127], [6138, 6143], [6170, 6175], [6265, 6271], [6315, 6319], [6390, 6399], 6431, [6444, 6447], [6460, 6463], [6465, 6467], [6510, 6511], [6517, 6527], [6572, 6575], [6602, 6607], [6619, 6621], [6684, 6685], 6751, [6781, 6782], [6794, 6799], [6810, 6815], [6830, 6831], [6863, 6911], [6989, 6991], 7039, [7156, 7163], [7224, 7226], [7242, 7244], [7305, 7311], [7355, 7356], [7368, 7375], [7419, 7423], [7958, 7959], [7966, 7967], [8006, 8007], [8014, 8015], 8024, 8026, 8028, 8030, [8062, 8063], 8117, 8133, [8148, 8149], 8156, [8176, 8177], 8181, 8191, 8293, [8306, 8307], 8335, [8349, 8351], [8385, 8399], [8433, 8447], [8588, 8591], [9255, 9279], [9291, 9311], [11124, 11125], 11158, [11508, 11512], 11558, [11560, 11564], [11566, 11567], [11624, 11630], [11633, 11646], [11671, 11679], 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, [11870, 11903], 11930, [12020, 12031], [12246, 12271], [12284, 12287], 12352, [12439, 12440], [12544, 12548], 12592, 12687, [12772, 12783], 12831, [42125, 42127], [42183, 42191], [42540, 42559], [42744, 42751], [42955, 42959], 42962, 42964, [42970, 42993], [43053, 43055], [43066, 43071], [43128, 43135], [43206, 43213], [43226, 43231], [43348, 43358], [43389, 43391], 43470, [43482, 43485], 43519, [43575, 43583], [43598, 43599], [43610, 43611], [43715, 43738], [43767, 43776], [43783, 43784], [43791, 43792], [43799, 43807], 43815, 43823, [43884, 43887], [44014, 44015], [44026, 44031], [55204, 55215], [55239, 55242], [55292, 55295], [64110, 64111], [64218, 64255], [64263, 64274], [64280, 64284], 64311, 64317, 64319, 64322, 64325, [64451, 64466], [64912, 64913], [64968, 64974], [64976, 65007], [65050, 65055], 65107, 65127, [65132, 65135], 65141, [65277, 65278], 65280, [65471, 65473], [65480, 65481], [65488, 65489], [65496, 65497], [65501, 65503], 65511, [65519, 65528], [65534, 65535], 65548, 65575, 65595, 65598, [65614, 65615], [65630, 65663], [65787, 65791], [65795, 65798], [65844, 65846], 65935, [65949, 65951], [65953, 65999], [66046, 66175], [66205, 66207], [66257, 66271], [66300, 66303], [66340, 66348], [66379, 66383], [66427, 66431], 66462, [66500, 66503], [66518, 66559], [66718, 66719], [66730, 66735], [66772, 66775], [66812, 66815], [66856, 66863], [66916, 66926], 66939, 66955, 66963, 66966, 66978, 66994, 67002, [67005, 67071], [67383, 67391], [67414, 67423], [67432, 67455], 67462, 67505, [67515, 67583], [67590, 67591], 67593, 67638, [67641, 67643], [67645, 67646], 67670, [67743, 67750], [67760, 67807], 67827, [67830, 67834], [67868, 67870], [67898, 67902], [67904, 67967], [68024, 68027], [68048, 68049], 68100, [68103, 68107], 68116, 68120, [68150, 68151], [68155, 68158], [68169, 68175], [68185, 68191], [68256, 68287], [68327, 68330], [68343, 68351], [68406, 68408], [68438, 68439], [68467, 68471], [68498, 68504], [68509, 68520], [68528, 68607], [68681, 68735], [68787, 68799], [68851, 68857], [68904, 68911], [68922, 69215], 69247, 69290, [69294, 69295], [69298, 69372], [69416, 69423], [69466, 69487], [69514, 69551], [69580, 69599], [69623, 69631], [69710, 69713], [69750, 69758], [69827, 69836], [69838, 69839], [69865, 69871], [69882, 69887], 69941, [69960, 69967], [70007, 70015], 70112, [70133, 70143], 70162, [70210, 70271], 70279, 70281, 70286, 70302, [70314, 70319], [70379, 70383], [70394, 70399], 70404, [70413, 70414], [70417, 70418], 70441, 70449, 70452, 70458, [70469, 70470], [70473, 70474], [70478, 70479], [70481, 70486], [70488, 70492], [70500, 70501], [70509, 70511], [70517, 70655], 70748, [70754, 70783], [70856, 70863], [70874, 71039], [71094, 71095], [71134, 71167], [71237, 71247], [71258, 71263], [71277, 71295], [71354, 71359], [71370, 71423], [71451, 71452], [71468, 71471], [71495, 71679], [71740, 71839], [71923, 71934], [71943, 71944], [71946, 71947], 71956, 71959, 71990, [71993, 71994], [72007, 72015], [72026, 72095], [72104, 72105], [72152, 72153], [72165, 72191], [72264, 72271], [72355, 72367], [72441, 72447], [72458, 72703], 72713, 72759, [72774, 72783], [72813, 72815], [72848, 72849], 72872, [72887, 72959], 72967, 72970, [73015, 73017], 73019, 73022, [73032, 73039], [73050, 73055], 73062, 73065, 73103, 73106, [73113, 73119], [73130, 73439], [73465, 73471], 73489, [73531, 73533], [73562, 73647], [73649, 73663], [73714, 73726], [74650, 74751], 74863, [74869, 74879], [75076, 77711], [77811, 77823], [78934, 82943], [83527, 92159], [92729, 92735], 92767, [92778, 92781], 92863, [92874, 92879], [92910, 92911], [92918, 92927], [92998, 93007], 93018, 93026, [93048, 93052], [93072, 93759], [93851, 93951], [94027, 94030], [94088, 94094], [94112, 94175], [94181, 94191], [94194, 94207], [100344, 100351], [101590, 101631], [101641, 110575], 110580, 110588, 110591, [110883, 110897], [110899, 110927], [110931, 110932], [110934, 110947], [110952, 110959], [111356, 113663], [113771, 113775], [113789, 113791], [113801, 113807], [113818, 113819], [113828, 118527], [118574, 118575], [118599, 118607], [118724, 118783], [119030, 119039], [119079, 119080], [119275, 119295], [119366, 119487], [119508, 119519], [119540, 119551], [119639, 119647], [119673, 119807], 119893, 119965, [119968, 119969], [119971, 119972], [119975, 119976], 119981, 119994, 119996, 120004, 120070, [120075, 120076], 120085, 120093, 120122, 120127, 120133, [120135, 120137], 120145, [120486, 120487], [120780, 120781], [121484, 121498], 121504, [121520, 122623], [122655, 122660], [122667, 122879], 122887, [122905, 122906], 122914, 122917, [122923, 122927], [122990, 123022], [123024, 123135], [123181, 123183], [123198, 123199], [123210, 123213], [123216, 123535], [123567, 123583], [123642, 123646], [123648, 124111], [124154, 124895], 124903, 124908, 124911, 124927, [125125, 125126], [125143, 125183], [125260, 125263], [125274, 125277], [125280, 126064], [126133, 126208], [126270, 126463], 126468, 126496, 126499, [126501, 126502], 126504, 126515, 126520, 126522, [126524, 126529], [126531, 126534], 126536, 126538, 126540, 126544, 126547, [126549, 126550], 126552, 126554, 126556, 126558, 126560, 126563, [126565, 126566], 126571, 126579, 126584, 126589, 126591, 126602, [126620, 126624], 126628, 126634, [126652, 126703], [126706, 126975], [127020, 127023], [127124, 127135], [127151, 127152], 127168, 127184, [127222, 127231], [127406, 127461], [127491, 127503], [127548, 127551], [127561, 127567], [127570, 127583], [127590, 127743], [128728, 128731], [128749, 128751], [128765, 128767], [128887, 128890], [128986, 128991], [129004, 129007], [129009, 129023], [129036, 129039], [129096, 129103], [129114, 129119], [129160, 129167], [129198, 129199], [129202, 129279], [129620, 129631], [129646, 129647], [129661, 129663], [129673, 129679], 129726, [129734, 129741], [129756, 129759], [129769, 129775], [129785, 129791], 129939, [129995, 130031], [130042, 131071], [173792, 173823], [177978, 177983], [178206, 178207], [183970, 183983], [191457, 194559], [195102, 196607], [201547, 201551], [205744, 917504], [917506, 917535], [917632, 917759], [918e3, 983039], [1048574, 1048575], [1114110, 1114111]];
  var Unassigned_default = _108;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/General_Category/Uppercase_Letter.js
  var _109 = [[65, 90], [192, 214], [216, 222], 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308, 310, 313, 315, 317, 319, 321, 323, 325, 327, 330, 332, 334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368, 370, 372, 374, [376, 377], 379, 381, [385, 386], 388, [390, 391], [393, 395], [398, 401], [403, 404], [406, 408], [412, 413], [415, 416], 418, 420, [422, 423], 425, 428, [430, 431], [433, 435], 437, [439, 440], 444, 452, 455, 458, 461, 463, 465, 467, 469, 471, 473, 475, 478, 480, 482, 484, 486, 488, 490, 492, 494, 497, 500, [502, 504], 506, 508, 510, 512, 514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548, 550, 552, 554, 556, 558, 560, 562, [570, 571], [573, 574], 577, [579, 582], 584, 586, 588, 590, 880, 882, 886, 895, 902, [904, 906], 908, [910, 911], [913, 929], [931, 939], 975, [978, 980], 984, 986, 988, 990, 992, 994, 996, 998, 1e3, 1002, 1004, 1006, 1012, 1015, [1017, 1018], [1021, 1071], 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138, 1140, 1142, 1144, 1146, 1148, 1150, 1152, 1162, 1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186, 1188, 1190, 1192, 1194, 1196, 1198, 1200, 1202, 1204, 1206, 1208, 1210, 1212, 1214, [1216, 1217], 1219, 1221, 1223, 1225, 1227, 1229, 1232, 1234, 1236, 1238, 1240, 1242, 1244, 1246, 1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 1264, 1266, 1268, 1270, 1272, 1274, 1276, 1278, 1280, 1282, 1284, 1286, 1288, 1290, 1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 1324, 1326, [1329, 1366], [4256, 4293], 4295, 4301, [5024, 5109], [7312, 7354], [7357, 7359], 7680, 7682, 7684, 7686, 7688, 7690, 7692, 7694, 7696, 7698, 7700, 7702, 7704, 7706, 7708, 7710, 7712, 7714, 7716, 7718, 7720, 7722, 7724, 7726, 7728, 7730, 7732, 7734, 7736, 7738, 7740, 7742, 7744, 7746, 7748, 7750, 7752, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774, 7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798, 7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822, 7824, 7826, 7828, 7838, 7840, 7842, 7844, 7846, 7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870, 7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894, 7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918, 7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, [7944, 7951], [7960, 7965], [7976, 7983], [7992, 7999], [8008, 8013], 8025, 8027, 8029, 8031, [8040, 8047], [8120, 8123], [8136, 8139], [8152, 8155], [8168, 8172], [8184, 8187], 8450, 8455, [8459, 8461], [8464, 8466], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8496, 8499], [8510, 8511], 8517, 8579, [11264, 11311], 11360, [11362, 11364], 11367, 11369, 11371, [11373, 11376], 11378, 11381, [11390, 11392], 11394, 11396, 11398, 11400, 11402, 11404, 11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424, 11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444, 11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464, 11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484, 11486, 11488, 11490, 11499, 11501, 11506, 42560, 42562, 42564, 42566, 42568, 42570, 42572, 42574, 42576, 42578, 42580, 42582, 42584, 42586, 42588, 42590, 42592, 42594, 42596, 42598, 42600, 42602, 42604, 42624, 42626, 42628, 42630, 42632, 42634, 42636, 42638, 42640, 42642, 42644, 42646, 42648, 42650, 42786, 42788, 42790, 42792, 42794, 42796, 42798, 42802, 42804, 42806, 42808, 42810, 42812, 42814, 42816, 42818, 42820, 42822, 42824, 42826, 42828, 42830, 42832, 42834, 42836, 42838, 42840, 42842, 42844, 42846, 42848, 42850, 42852, 42854, 42856, 42858, 42860, 42862, 42873, 42875, [42877, 42878], 42880, 42882, 42884, 42886, 42891, 42893, 42896, 42898, 42902, 42904, 42906, 42908, 42910, 42912, 42914, 42916, 42918, 42920, [42922, 42926], [42928, 42932], 42934, 42936, 42938, 42940, 42942, 42944, 42946, [42948, 42951], 42953, 42960, 42966, 42968, 42997, [65313, 65338], [66560, 66599], [66736, 66771], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [68736, 68786], [71840, 71871], [93760, 93791], [119808, 119833], [119860, 119885], [119912, 119937], 119964, [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119989], [120016, 120041], [120068, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120120, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120172, 120197], [120224, 120249], [120276, 120301], [120328, 120353], [120380, 120405], [120432, 120457], [120488, 120512], [120546, 120570], [120604, 120628], [120662, 120686], [120720, 120744], 120778, [125184, 125217]];
  var Uppercase_Letter_default = _109;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/index.js
  var Bidi_Class_exports = {};
  __export(Bidi_Class_exports, {
    Arabic_Letter: () => Arabic_Letter_default,
    Arabic_Number: () => Arabic_Number_default,
    Boundary_Neutral: () => Boundary_Neutral_default,
    Common_Separator: () => Common_Separator_default,
    European_Number: () => European_Number_default,
    European_Separator: () => European_Separator_default,
    European_Terminator: () => European_Terminator_default,
    First_Strong_Isolate: () => First_Strong_Isolate_default,
    Left_To_Right: () => Left_To_Right_default,
    Left_To_Right_Embedding: () => Left_To_Right_Embedding_default,
    Left_To_Right_Isolate: () => Left_To_Right_Isolate_default,
    Left_To_Right_Override: () => Left_To_Right_Override_default,
    Nonspacing_Mark: () => Nonspacing_Mark_default2,
    Other_Neutral: () => Other_Neutral_default,
    Paragraph_Separator: () => Paragraph_Separator_default2,
    Pop_Directional_Format: () => Pop_Directional_Format_default,
    Pop_Directional_Isolate: () => Pop_Directional_Isolate_default,
    Right_To_Left: () => Right_To_Left_default,
    Right_To_Left_Embedding: () => Right_To_Left_Embedding_default,
    Right_To_Left_Isolate: () => Right_To_Left_Isolate_default,
    Right_To_Left_Override: () => Right_To_Left_Override_default,
    Segment_Separator: () => Segment_Separator_default,
    White_Space: () => White_Space_default2
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Arabic_Letter.js
  var _110 = [1544, 1547, 1549, [1563, 1610], [1645, 1647], [1649, 1749], [1765, 1766], [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], 1969, [2144, 2154], [2160, 2190], [2208, 2249], [64336, 64450], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65020], [65136, 65140], [65142, 65276], [68864, 68899], [69424, 69445], [69457, 69465], [126065, 126132], [126209, 126269], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651]];
  var Arabic_Letter_default = _110;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Arabic_Number.js
  var _111 = [[1536, 1541], [1632, 1641], [1643, 1644], 1757, [2192, 2193], 2274, [68912, 68921], [69216, 69246]];
  var Arabic_Number_default = _111;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Boundary_Neutral.js
  var _112 = [[0, 8], [14, 27], [127, 132], [134, 159], 173, 6158, [8203, 8205], [8288, 8292], [8298, 8303], 65279, [113824, 113827], [119155, 119162], 917505, [917536, 917631]];
  var Boundary_Neutral_default = _112;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Common_Separator.js
  var _113 = [44, [46, 47], 58, 160, 1548, 8239, 8260, 65104, 65106, 65109, 65292, [65294, 65295], 65306];
  var Common_Separator_default = _113;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/European_Number.js
  var _114 = [[48, 57], [178, 179], 185, [1776, 1785], 8304, [8308, 8313], [8320, 8329], [9352, 9371], [65296, 65305], [66273, 66299], [120782, 120831], [127232, 127242], [130032, 130041]];
  var European_Number_default = _114;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/European_Separator.js
  var _115 = [43, 45, [8314, 8315], [8330, 8331], 8722, 64297, [65122, 65123], 65291, 65293];
  var European_Separator_default = _115;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/European_Terminator.js
  var _116 = [[35, 37], [162, 165], [176, 177], 1423, [1545, 1546], 1642, [2546, 2547], 2555, 2801, 3065, 3647, 6107, [8240, 8244], [8352, 8384], 8494, 8723, [43064, 43065], 65119, [65129, 65130], [65283, 65285], [65504, 65505], [65509, 65510], [73693, 73696], 123647];
  var European_Terminator_default = _116;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/First_Strong_Isolate.js
  var _117 = [8296];
  var First_Strong_Isolate_default = _117;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Left_To_Right.js
  var _118 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 696], [699, 705], [720, 721], [736, 740], 750, [880, 883], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1154], [1162, 1327], [1329, 1366], [1369, 1417], [2307, 2361], 2363, [2365, 2368], [2377, 2380], [2382, 2384], [2392, 2401], [2404, 2432], [2434, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2493, 2496], [2503, 2504], [2507, 2508], 2510, 2519, [2524, 2525], [2527, 2529], [2534, 2545], [2548, 2554], [2556, 2557], 2563, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2622, 2624], [2649, 2652], 2654, [2662, 2671], [2674, 2676], 2678, 2691, [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2749, 2752], 2761, [2763, 2764], 2768, [2784, 2785], [2790, 2800], 2809, [2818, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2877, 2878], 2880, [2887, 2888], [2891, 2892], 2903, [2908, 2909], [2911, 2913], [2918, 2935], 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3007], [3009, 3010], [3014, 3016], [3018, 3020], 3024, 3031, [3046, 3058], [3073, 3075], [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3137, 3140], [3160, 3162], 3165, [3168, 3169], [3174, 3183], 3191, [3199, 3200], [3202, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3261, 3268], [3270, 3272], [3274, 3275], [3285, 3286], [3293, 3294], [3296, 3297], [3302, 3311], [3313, 3315], [3330, 3340], [3342, 3344], [3346, 3386], [3389, 3392], [3398, 3400], [3402, 3404], [3406, 3407], [3412, 3425], [3430, 3455], [3458, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], [3535, 3537], [3544, 3551], [3558, 3567], [3570, 3572], [3585, 3632], [3634, 3635], [3648, 3654], [3663, 3675], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3760], [3762, 3763], 3773, [3776, 3780], 3782, [3792, 3801], [3804, 3807], [3840, 3863], [3866, 3892], 3894, 3896, [3902, 3911], [3913, 3948], 3967, 3973, [3976, 3980], [4030, 4037], [4039, 4044], [4046, 4058], [4096, 4140], 4145, 4152, [4155, 4156], [4159, 4183], [4186, 4189], [4193, 4208], [4213, 4225], [4227, 4228], [4231, 4236], [4238, 4252], [4254, 4293], 4295, 4301, [4304, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4960, 4988], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5759], [5761, 5786], [5792, 5880], [5888, 5905], 5909, [5919, 5937], [5940, 5942], [5952, 5969], [5984, 5996], [5998, 6e3], [6016, 6067], 6070, [6078, 6085], [6087, 6088], [6100, 6106], 6108, [6112, 6121], [6160, 6169], [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6435, 6438], [6441, 6443], [6448, 6449], [6451, 6456], [6470, 6509], [6512, 6516], [6528, 6571], [6576, 6601], [6608, 6618], [6656, 6678], [6681, 6682], [6686, 6741], 6743, 6753, [6755, 6756], [6765, 6770], [6784, 6793], [6800, 6809], [6816, 6829], [6916, 6963], 6965, 6971, [6973, 6977], [6979, 6988], [6992, 7018], [7028, 7038], [7042, 7073], [7078, 7079], 7082, [7086, 7141], 7143, [7146, 7148], 7150, [7154, 7155], [7164, 7211], [7220, 7221], [7227, 7241], [7245, 7304], [7312, 7354], [7357, 7367], 7379, 7393, [7401, 7404], [7406, 7411], [7413, 7415], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8206, 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8508, 8511], [8517, 8521], [8526, 8527], [8544, 8584], [9014, 9082], 9109, [9372, 9449], 9900, [10240, 10495], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], [11631, 11632], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [12293, 12295], [12321, 12329], [12334, 12335], [12337, 12341], [12344, 12348], [12353, 12438], [12445, 12447], [12449, 12538], [12540, 12543], [12549, 12591], [12593, 12686], [12688, 12735], [12784, 12828], [12832, 12879], [12896, 12923], [12927, 12976], [12992, 13003], [13008, 13174], [13179, 13277], [13280, 13310], [13312, 19903], [19968, 42124], [42192, 42508], [42512, 42539], [42560, 42606], [42624, 42653], [42656, 42735], [42738, 42743], [42786, 42887], [42889, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43044], 43047, [43056, 43063], [43072, 43123], [43136, 43203], [43214, 43225], [43250, 43262], [43264, 43301], [43310, 43334], [43346, 43347], [43359, 43388], [43395, 43442], [43444, 43445], [43450, 43451], [43454, 43469], [43471, 43481], [43486, 43492], [43494, 43518], [43520, 43560], [43567, 43568], [43571, 43572], [43584, 43586], [43588, 43595], 43597, [43600, 43609], [43612, 43643], [43645, 43695], 43697, [43701, 43702], [43705, 43709], 43712, 43714, [43739, 43755], [43758, 43765], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43881], [43888, 44004], [44006, 44007], [44009, 44012], [44016, 44025], [44032, 55203], [55216, 55238], [55243, 55291], [55296, 64109], [64112, 64217], [64256, 64262], [64275, 64279], [65313, 65338], [65345, 65370], [65382, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], 65792, 65794, [65799, 65843], [65847, 65855], [65933, 65934], [66e3, 66044], [66176, 66204], [66208, 66256], [66304, 66339], [66349, 66378], [66384, 66421], [66432, 66461], [66463, 66499], [66504, 66517], [66560, 66717], [66720, 66729], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66927, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], 69632, [69634, 69687], [69703, 69709], [69734, 69743], [69745, 69746], 69749, [69762, 69810], [69815, 69816], [69819, 69825], 69837, [69840, 69864], [69872, 69881], [69891, 69926], 69932, [69942, 69959], [69968, 70002], [70004, 70006], [70018, 70069], [70079, 70088], [70093, 70094], [70096, 70111], [70113, 70132], [70144, 70161], [70163, 70190], [70194, 70195], 70197, [70200, 70205], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313], [70320, 70366], [70368, 70370], [70384, 70393], [70402, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70461, 70463], [70465, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70656, 70711], [70720, 70721], 70725, [70727, 70747], 70749, [70751, 70753], [70784, 70834], 70841, [70843, 70846], 70849, [70852, 70855], [70864, 70873], [71040, 71089], [71096, 71099], 71102, [71105, 71131], [71168, 71218], [71227, 71228], 71230, [71233, 71236], [71248, 71257], [71296, 71338], 71340, [71342, 71343], 71350, [71352, 71353], [71360, 71369], [71424, 71450], [71456, 71457], 71462, [71472, 71494], [71680, 71726], 71736, 71739, [71840, 71922], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], 71997, [71999, 72002], [72004, 72006], [72016, 72025], [72096, 72103], [72106, 72147], [72156, 72159], [72161, 72164], 72192, [72199, 72200], [72203, 72242], [72249, 72250], [72255, 72262], 72272, [72279, 72280], [72284, 72329], 72343, [72346, 72354], [72368, 72440], [72448, 72457], [72704, 72712], [72714, 72751], [72766, 72773], [72784, 72812], [72816, 72847], 72873, 72881, 72884, [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73040, 73049], [73056, 73061], [73063, 73064], [73066, 73102], [73107, 73108], 73110, 73112, [73120, 73129], [73440, 73458], [73461, 73464], [73474, 73488], [73490, 73525], [73534, 73535], 73537, [73539, 73561], 73648, [73664, 73684], [73727, 74649], [74752, 74862], [74864, 74868], [74880, 75075], [77712, 77810], [77824, 78911], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92768, 92777], [92782, 92862], [92864, 92873], [92880, 92909], 92917, [92928, 92975], [92983, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071], [93760, 93850], [93952, 94026], [94032, 94087], [94099, 94111], [94176, 94177], 94179, [94192, 94193], [94208, 100343], [100352, 101589], [101632, 101640], [110576, 110579], [110581, 110587], [110589, 110590], [110592, 110882], 110898, [110928, 110930], 110933, [110948, 110951], [110960, 111355], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 113820, 113823, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119142], [119146, 119154], [119171, 119172], [119180, 119209], [119214, 119272], [119488, 119507], [119520, 119539], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120538], [120540, 120596], [120598, 120654], [120656, 120712], [120714, 120770], [120772, 120779], [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121483], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], [123200, 123209], [123214, 123215], [123536, 123565], [123584, 123627], [123632, 123641], [124112, 124139], [124144, 124153], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [127248, 127278], [127280, 127337], [127344, 127404], [127462, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743], [983040, 1048573], [1048576, 1114109]];
  var Left_To_Right_default = _118;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Left_To_Right_Embedding.js
  var _119 = [8234];
  var Left_To_Right_Embedding_default = _119;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Left_To_Right_Isolate.js
  var _120 = [8294];
  var Left_To_Right_Isolate_default = _120;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Left_To_Right_Override.js
  var _121 = [8237];
  var Left_To_Right_Override_default = _121;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Nonspacing_Mark.js
  var _122 = [[768, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2306], 2362, 2364, [2369, 2376], 2381, [2385, 2391], [2402, 2403], 2433, 2492, [2497, 2500], 2509, [2530, 2531], 2558, [2561, 2562], 2620, [2625, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2690], 2748, [2753, 2757], [2759, 2760], 2765, [2786, 2787], [2810, 2815], 2817, 2876, 2879, [2881, 2884], 2893, [2901, 2902], [2914, 2915], 2946, 3008, 3021, 3072, 3076, 3132, [3134, 3136], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], 3201, 3260, [3276, 3277], [3298, 3299], [3328, 3329], [3387, 3388], [3393, 3396], 3405, [3426, 3427], 3457, 3530, [3538, 3540], 3542, 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4141, 4144], [4146, 4151], [4153, 4154], [4157, 4158], [4184, 4185], [4190, 4192], [4209, 4212], 4226, [4229, 4230], 4237, 4253, [4957, 4959], [5906, 5908], [5938, 5939], [5970, 5971], [6002, 6003], [6068, 6069], [6071, 6077], 6086, [6089, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6434], [6439, 6440], 6450, [6457, 6459], [6679, 6680], 6683, 6742, [6744, 6750], 6752, 6754, [6757, 6764], [6771, 6780], 6783, [6832, 6862], [6912, 6915], 6964, [6966, 6970], 6972, 6978, [7019, 7027], [7040, 7041], [7074, 7077], [7080, 7081], [7083, 7085], 7142, [7144, 7145], 7149, [7151, 7153], [7212, 7219], [7222, 7223], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12333], [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43045, 43046], 43052, [43204, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43345], [43392, 43394], 43443, [43446, 43449], [43452, 43453], 43493, [43561, 43566], [43569, 43570], [43573, 43574], 43587, 43596, 43644, 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43756, 43757], 43766, 44005, 44008, 44013, 64286, [65024, 65039], [65056, 65071], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], 69633, [69688, 69702], 69744, [69747, 69748], [69759, 69761], [69811, 69814], [69817, 69818], 69826, [69888, 69890], [69927, 69931], [69933, 69940], 70003, [70016, 70017], [70070, 70078], [70089, 70092], 70095, [70191, 70193], 70196, [70198, 70199], 70206, 70209, 70367, [70371, 70378], [70400, 70401], [70459, 70460], 70464, [70502, 70508], [70512, 70516], [70712, 70719], [70722, 70724], 70726, 70750, [70835, 70840], 70842, [70847, 70848], [70850, 70851], [71090, 71093], [71100, 71101], [71103, 71104], [71132, 71133], [71219, 71226], 71229, [71231, 71232], 71339, 71341, [71344, 71349], 71351, [71453, 71455], [71458, 71461], [71463, 71467], [71727, 71735], [71737, 71738], [71995, 71996], 71998, 72003, [72148, 72151], [72154, 72155], 72160, [72193, 72198], [72201, 72202], [72243, 72248], [72251, 72254], 72263, [72273, 72278], [72281, 72283], [72330, 72342], [72344, 72345], [72752, 72758], [72760, 72765], [72850, 72871], [72874, 72880], [72882, 72883], [72885, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73104, 73105], 73109, 73111, [73459, 73460], [73472, 73473], [73526, 73530], 73536, 73538, 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94095, 94098], 94180, [113821, 113822], [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [917760, 917999]];
  var Nonspacing_Mark_default2 = _122;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Other_Neutral.js
  var _123 = [[33, 34], [38, 42], [59, 64], [91, 96], [123, 126], 161, [166, 169], [171, 172], [174, 175], 180, [182, 184], [187, 191], 215, 247, [697, 698], [706, 719], [722, 735], [741, 749], [751, 767], [884, 885], 894, [900, 901], 903, 1014, 1418, [1421, 1422], [1542, 1543], [1550, 1551], 1758, 1769, [2038, 2041], [3059, 3064], 3066, [3192, 3198], [3898, 3901], [5008, 5017], 5120, [5787, 5788], [6128, 6137], [6144, 6154], 6464, [6468, 6469], [6622, 6655], 8125, [8127, 8129], [8141, 8143], [8157, 8159], [8173, 8175], [8189, 8190], [8208, 8231], [8245, 8259], [8261, 8286], [8316, 8318], [8332, 8334], [8448, 8449], [8451, 8454], [8456, 8457], 8468, [8470, 8472], [8478, 8483], 8485, 8487, 8489, [8506, 8507], [8512, 8516], [8522, 8525], [8528, 8543], [8585, 8587], [8592, 8721], [8724, 9013], [9083, 9108], [9110, 9254], [9280, 9290], [9312, 9351], [9450, 9899], [9901, 10239], [10496, 11123], [11126, 11157], [11159, 11263], [11493, 11498], [11513, 11519], [11776, 11869], [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12289, 12292], [12296, 12320], 12336, [12342, 12343], [12349, 12351], [12443, 12444], 12448, 12539, [12736, 12771], [12829, 12830], [12880, 12895], [12924, 12926], [12977, 12991], [13004, 13007], [13175, 13178], [13278, 13279], 13311, [19904, 19967], [42128, 42182], [42509, 42511], 42611, [42622, 42623], [42752, 42785], 42888, [43048, 43051], [43124, 43127], [43882, 43883], [64830, 64847], 64975, [65021, 65023], [65040, 65049], [65072, 65103], 65105, 65108, [65110, 65118], [65120, 65121], [65124, 65126], 65128, 65131, [65281, 65282], [65286, 65290], [65307, 65312], [65339, 65344], [65371, 65381], [65506, 65508], [65512, 65518], [65529, 65533], 65793, [65856, 65932], [65936, 65948], 65952, 67871, [68409, 68415], [69714, 69733], [71264, 71276], [73685, 73692], [73697, 73713], 94178, [119273, 119274], [119296, 119361], 119365, [119552, 119638], 120539, 120597, 120655, 120713, 120771, [126704, 126705], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127243, 127247], 127279, [127338, 127343], 127405, [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994]];
  var Other_Neutral_default = _123;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Paragraph_Separator.js
  var _124 = [10, 13, [28, 30], 133, 8233];
  var Paragraph_Separator_default2 = _124;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Pop_Directional_Format.js
  var _125 = [8236];
  var Pop_Directional_Format_default = _125;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Pop_Directional_Isolate.js
  var _126 = [8297];
  var Pop_Directional_Isolate_default = _126;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Right_To_Left.js
  var _127 = [1470, 1472, 1475, 1478, [1488, 1514], [1519, 1524], [1984, 2026], [2036, 2037], 2042, [2046, 2069], 2074, 2084, 2088, [2096, 2110], [2112, 2136], 2142, 8207, 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67671, 67742], [67751, 67759], [67808, 67826], [67828, 67829], [67835, 67867], [67872, 67897], 67903, [67968, 68023], [68028, 68047], [68050, 68096], [68112, 68115], [68117, 68119], [68121, 68149], [68160, 68168], [68176, 68184], [68192, 68255], [68288, 68324], [68331, 68342], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68497], [68505, 68508], [68521, 68527], [68608, 68680], [68736, 68786], [68800, 68850], [68858, 68863], [69248, 69289], 69293, [69296, 69297], [69376, 69415], [69488, 69505], [69510, 69513], [69552, 69579], [69600, 69622], [124928, 125124], [125127, 125135], [125184, 125251], 125259, [125264, 125273], [125278, 125279]];
  var Right_To_Left_default = _127;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Right_To_Left_Embedding.js
  var _128 = [8235];
  var Right_To_Left_Embedding_default = _128;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Right_To_Left_Isolate.js
  var _129 = [8295];
  var Right_To_Left_Isolate_default = _129;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Right_To_Left_Override.js
  var _130 = [8238];
  var Right_To_Left_Override_default = _130;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/Segment_Separator.js
  var _131 = [9, 11, 31];
  var Segment_Separator_default = _131;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Class/White_Space.js
  var _132 = [12, 32, 5760, [8192, 8202], 8232, 8287, 12288];
  var White_Space_default2 = _132;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/index.js
  var Script_exports = {};
  __export(Script_exports, {
    Adlam: () => Adlam_default,
    Ahom: () => Ahom_default,
    Anatolian_Hieroglyphs: () => Anatolian_Hieroglyphs_default,
    Arabic: () => Arabic_default,
    Armenian: () => Armenian_default,
    Avestan: () => Avestan_default,
    Balinese: () => Balinese_default,
    Bamum: () => Bamum_default,
    Bassa_Vah: () => Bassa_Vah_default,
    Batak: () => Batak_default,
    Bengali: () => Bengali_default,
    Bhaiksuki: () => Bhaiksuki_default,
    Bopomofo: () => Bopomofo_default,
    Brahmi: () => Brahmi_default,
    Braille: () => Braille_default,
    Buginese: () => Buginese_default,
    Buhid: () => Buhid_default,
    Canadian_Aboriginal: () => Canadian_Aboriginal_default,
    Carian: () => Carian_default,
    Caucasian_Albanian: () => Caucasian_Albanian_default,
    Chakma: () => Chakma_default,
    Cham: () => Cham_default,
    Cherokee: () => Cherokee_default,
    Chorasmian: () => Chorasmian_default,
    Common: () => Common_default,
    Coptic: () => Coptic_default,
    Cuneiform: () => Cuneiform_default,
    Cypriot: () => Cypriot_default,
    Cypro_Minoan: () => Cypro_Minoan_default,
    Cyrillic: () => Cyrillic_default,
    Deseret: () => Deseret_default,
    Devanagari: () => Devanagari_default,
    Dives_Akuru: () => Dives_Akuru_default,
    Dogra: () => Dogra_default,
    Duployan: () => Duployan_default,
    Egyptian_Hieroglyphs: () => Egyptian_Hieroglyphs_default,
    Elbasan: () => Elbasan_default,
    Elymaic: () => Elymaic_default,
    Ethiopic: () => Ethiopic_default,
    Georgian: () => Georgian_default,
    Glagolitic: () => Glagolitic_default,
    Gothic: () => Gothic_default,
    Grantha: () => Grantha_default,
    Greek: () => Greek_default,
    Gujarati: () => Gujarati_default,
    Gunjala_Gondi: () => Gunjala_Gondi_default,
    Gurmukhi: () => Gurmukhi_default,
    Han: () => Han_default,
    Hangul: () => Hangul_default,
    Hanifi_Rohingya: () => Hanifi_Rohingya_default,
    Hanunoo: () => Hanunoo_default,
    Hatran: () => Hatran_default,
    Hebrew: () => Hebrew_default,
    Hiragana: () => Hiragana_default,
    Imperial_Aramaic: () => Imperial_Aramaic_default,
    Inherited: () => Inherited_default,
    Inscriptional_Pahlavi: () => Inscriptional_Pahlavi_default,
    Inscriptional_Parthian: () => Inscriptional_Parthian_default,
    Javanese: () => Javanese_default,
    Kaithi: () => Kaithi_default,
    Kannada: () => Kannada_default,
    Katakana: () => Katakana_default,
    Kawi: () => Kawi_default,
    Kayah_Li: () => Kayah_Li_default,
    Kharoshthi: () => Kharoshthi_default,
    Khitan_Small_Script: () => Khitan_Small_Script_default,
    Khmer: () => Khmer_default,
    Khojki: () => Khojki_default,
    Khudawadi: () => Khudawadi_default,
    Lao: () => Lao_default,
    Latin: () => Latin_default,
    Lepcha: () => Lepcha_default,
    Limbu: () => Limbu_default,
    Linear_A: () => Linear_A_default,
    Linear_B: () => Linear_B_default,
    Lisu: () => Lisu_default,
    Lycian: () => Lycian_default,
    Lydian: () => Lydian_default,
    Mahajani: () => Mahajani_default,
    Makasar: () => Makasar_default,
    Malayalam: () => Malayalam_default,
    Mandaic: () => Mandaic_default,
    Manichaean: () => Manichaean_default,
    Marchen: () => Marchen_default,
    Masaram_Gondi: () => Masaram_Gondi_default,
    Medefaidrin: () => Medefaidrin_default,
    Meetei_Mayek: () => Meetei_Mayek_default,
    Mende_Kikakui: () => Mende_Kikakui_default,
    Meroitic_Cursive: () => Meroitic_Cursive_default,
    Meroitic_Hieroglyphs: () => Meroitic_Hieroglyphs_default,
    Miao: () => Miao_default,
    Modi: () => Modi_default,
    Mongolian: () => Mongolian_default,
    Mro: () => Mro_default,
    Multani: () => Multani_default,
    Myanmar: () => Myanmar_default,
    Nabataean: () => Nabataean_default,
    Nag_Mundari: () => Nag_Mundari_default,
    Nandinagari: () => Nandinagari_default,
    New_Tai_Lue: () => New_Tai_Lue_default,
    Newa: () => Newa_default,
    Nko: () => Nko_default,
    Nushu: () => Nushu_default,
    Nyiakeng_Puachue_Hmong: () => Nyiakeng_Puachue_Hmong_default,
    Ogham: () => Ogham_default,
    Ol_Chiki: () => Ol_Chiki_default,
    Old_Hungarian: () => Old_Hungarian_default,
    Old_Italic: () => Old_Italic_default,
    Old_North_Arabian: () => Old_North_Arabian_default,
    Old_Permic: () => Old_Permic_default,
    Old_Persian: () => Old_Persian_default,
    Old_Sogdian: () => Old_Sogdian_default,
    Old_South_Arabian: () => Old_South_Arabian_default,
    Old_Turkic: () => Old_Turkic_default,
    Old_Uyghur: () => Old_Uyghur_default,
    Oriya: () => Oriya_default,
    Osage: () => Osage_default,
    Osmanya: () => Osmanya_default,
    Pahawh_Hmong: () => Pahawh_Hmong_default,
    Palmyrene: () => Palmyrene_default,
    Pau_Cin_Hau: () => Pau_Cin_Hau_default,
    Phags_Pa: () => Phags_Pa_default,
    Phoenician: () => Phoenician_default,
    Psalter_Pahlavi: () => Psalter_Pahlavi_default,
    Rejang: () => Rejang_default,
    Runic: () => Runic_default,
    Samaritan: () => Samaritan_default,
    Saurashtra: () => Saurashtra_default,
    Sharada: () => Sharada_default,
    Shavian: () => Shavian_default,
    Siddham: () => Siddham_default,
    SignWriting: () => SignWriting_default,
    Sinhala: () => Sinhala_default,
    Sogdian: () => Sogdian_default,
    Sora_Sompeng: () => Sora_Sompeng_default,
    Soyombo: () => Soyombo_default,
    Sundanese: () => Sundanese_default,
    Syloti_Nagri: () => Syloti_Nagri_default,
    Syriac: () => Syriac_default,
    Tagalog: () => Tagalog_default,
    Tagbanwa: () => Tagbanwa_default,
    Tai_Le: () => Tai_Le_default,
    Tai_Tham: () => Tai_Tham_default,
    Tai_Viet: () => Tai_Viet_default,
    Takri: () => Takri_default,
    Tamil: () => Tamil_default,
    Tangsa: () => Tangsa_default,
    Tangut: () => Tangut_default,
    Telugu: () => Telugu_default,
    Thaana: () => Thaana_default,
    Thai: () => Thai_default,
    Tibetan: () => Tibetan_default,
    Tifinagh: () => Tifinagh_default,
    Tirhuta: () => Tirhuta_default,
    Toto: () => Toto_default,
    Ugaritic: () => Ugaritic_default,
    Vai: () => Vai_default,
    Vithkuqi: () => Vithkuqi_default,
    Wancho: () => Wancho_default,
    Warang_Citi: () => Warang_Citi_default,
    Yezidi: () => Yezidi_default,
    Yi: () => Yi_default,
    Zanabazar_Square: () => Zanabazar_Square_default
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Adlam.js
  var _133 = [[125184, 125259], [125264, 125273], [125278, 125279]];
  var Adlam_default = _133;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ahom.js
  var _134 = [[71424, 71450], [71453, 71467], [71472, 71494]];
  var Ahom_default = _134;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Anatolian_Hieroglyphs.js
  var _135 = [[82944, 83526]];
  var Anatolian_Hieroglyphs_default = _135;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Arabic.js
  var _136 = [[1536, 1540], [1542, 1547], [1549, 1562], [1564, 1566], [1568, 1599], [1601, 1610], [1622, 1647], [1649, 1756], [1758, 1791], [1872, 1919], [2160, 2190], [2192, 2193], [2200, 2273], [2275, 2303], [64336, 64450], [64467, 64829], [64832, 64911], [64914, 64967], 64975, [65008, 65023], [65136, 65140], [65142, 65276], [69216, 69246], [69373, 69375], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705]];
  var Arabic_default = _136;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Armenian.js
  var _137 = [[1329, 1366], [1369, 1418], [1421, 1423], [64275, 64279]];
  var Armenian_default = _137;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Avestan.js
  var _138 = [[68352, 68405], [68409, 68415]];
  var Avestan_default = _138;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Balinese.js
  var _139 = [[6912, 6988], [6992, 7038]];
  var Balinese_default = _139;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bamum.js
  var _140 = [[42656, 42743], [92160, 92728]];
  var Bamum_default = _140;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bassa_Vah.js
  var _141 = [[92880, 92909], [92912, 92917]];
  var Bassa_Vah_default = _141;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Batak.js
  var _142 = [[7104, 7155], [7164, 7167]];
  var Batak_default = _142;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bengali.js
  var _143 = [[2432, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2558]];
  var Bengali_default = _143;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bhaiksuki.js
  var _144 = [[72704, 72712], [72714, 72758], [72760, 72773], [72784, 72812]];
  var Bhaiksuki_default = _144;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Bopomofo.js
  var _145 = [[746, 747], [12549, 12591], [12704, 12735]];
  var Bopomofo_default = _145;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Brahmi.js
  var _146 = [[69632, 69709], [69714, 69749], 69759];
  var Brahmi_default = _146;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Braille.js
  var _147 = [[10240, 10495]];
  var Braille_default = _147;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Buginese.js
  var _148 = [[6656, 6683], [6686, 6687]];
  var Buginese_default = _148;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Buhid.js
  var _149 = [[5952, 5971]];
  var Buhid_default = _149;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Canadian_Aboriginal.js
  var _150 = [[5120, 5759], [6320, 6389], [72368, 72383]];
  var Canadian_Aboriginal_default = _150;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Carian.js
  var _151 = [[66208, 66256]];
  var Carian_default = _151;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Caucasian_Albanian.js
  var _152 = [[66864, 66915], 66927];
  var Caucasian_Albanian_default = _152;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Chakma.js
  var _153 = [[69888, 69940], [69942, 69959]];
  var Chakma_default = _153;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cham.js
  var _154 = [[43520, 43574], [43584, 43597], [43600, 43609], [43612, 43615]];
  var Cham_default = _154;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cherokee.js
  var _155 = [[5024, 5109], [5112, 5117], [43888, 43967]];
  var Cherokee_default = _155;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Chorasmian.js
  var _156 = [[69552, 69579]];
  var Chorasmian_default = _156;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Common.js
  var _157 = [[0, 64], [91, 96], [123, 169], [171, 185], [187, 191], 215, 247, [697, 735], [741, 745], [748, 767], 884, 894, 901, 903, 1541, 1548, 1563, 1567, 1600, 1757, 2274, [2404, 2405], 3647, [4053, 4056], 4347, [5867, 5869], [5941, 5942], [6146, 6147], 6149, 7379, 7393, [7401, 7404], [7406, 7411], [7413, 7415], 7418, [8192, 8203], [8206, 8292], [8294, 8304], [8308, 8318], [8320, 8334], [8352, 8384], [8448, 8485], [8487, 8489], [8492, 8497], [8499, 8525], [8527, 8543], [8585, 8587], [8592, 9254], [9280, 9290], [9312, 10239], [10496, 11123], [11126, 11157], [11159, 11263], [11776, 11869], [12272, 12283], [12288, 12292], 12294, [12296, 12320], [12336, 12343], [12348, 12351], [12443, 12444], 12448, [12539, 12540], [12688, 12703], [12736, 12771], [12832, 12895], [12927, 13007], 13055, [13144, 13311], [19904, 19967], [42752, 42785], [42888, 42890], [43056, 43065], 43310, 43471, 43867, [43882, 43883], [64830, 64831], [65040, 65049], [65072, 65106], [65108, 65126], [65128, 65131], 65279, [65281, 65312], [65339, 65344], [65371, 65381], 65392, [65438, 65439], [65504, 65510], [65512, 65518], [65529, 65533], [65792, 65794], [65799, 65843], [65847, 65855], [65936, 65948], [66e3, 66044], [66273, 66299], [113824, 113827], [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119142], [119146, 119162], [119171, 119172], [119180, 119209], [119214, 119274], [119488, 119507], [119520, 119539], [119552, 119638], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 120831], [126065, 126132], [126209, 126269], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127232, 127405], [127462, 127487], [127489, 127490], [127504, 127547], [127552, 127560], [127568, 127569], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994], [130032, 130041], 917505, [917536, 917631]];
  var Common_default = _157;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Coptic.js
  var _158 = [[994, 1007], [11392, 11507], [11513, 11519]];
  var Coptic_default = _158;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cuneiform.js
  var _159 = [[73728, 74649], [74752, 74862], [74864, 74868], [74880, 75075]];
  var Cuneiform_default = _159;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cypriot.js
  var _160 = [[67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, 67647];
  var Cypriot_default = _160;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cypro_Minoan.js
  var _161 = [[77712, 77810]];
  var Cypro_Minoan_default = _161;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Cyrillic.js
  var _162 = [[1024, 1156], [1159, 1327], [7296, 7304], 7467, 7544, [11744, 11775], [42560, 42655], [65070, 65071], [122928, 122989], 123023];
  var Cyrillic_default = _162;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Deseret.js
  var _163 = [[66560, 66639]];
  var Deseret_default = _163;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Devanagari.js
  var _164 = [[2304, 2384], [2389, 2403], [2406, 2431], [43232, 43263], [72448, 72457]];
  var Devanagari_default = _164;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Dives_Akuru.js
  var _165 = [[71936, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72006], [72016, 72025]];
  var Dives_Akuru_default = _165;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Dogra.js
  var _166 = [[71680, 71739]];
  var Dogra_default = _166;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Duployan.js
  var _167 = [[113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113820, 113823]];
  var Duployan_default = _167;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Egyptian_Hieroglyphs.js
  var _168 = [[77824, 78933]];
  var Egyptian_Hieroglyphs_default = _168;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Elbasan.js
  var _169 = [[66816, 66855]];
  var Elbasan_default = _169;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Elymaic.js
  var _170 = [[69600, 69622]];
  var Elymaic_default = _170;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ethiopic.js
  var _171 = [[4608, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4988], [4992, 5017], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926]];
  var Ethiopic_default = _171;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Georgian.js
  var _172 = [[4256, 4293], 4295, 4301, [4304, 4346], [4348, 4351], [7312, 7354], [7357, 7359], [11520, 11557], 11559, 11565];
  var Georgian_default = _172;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Glagolitic.js
  var _173 = [[11264, 11359], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922]];
  var Glagolitic_default = _173;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Gothic.js
  var _174 = [[66352, 66378]];
  var Gothic_default = _174;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Grantha.js
  var _175 = [[70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70460, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516]];
  var Grantha_default = _175;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Greek.js
  var _176 = [[880, 883], [885, 887], [890, 893], 895, 900, 902, [904, 906], 908, [910, 929], [931, 993], [1008, 1023], [7462, 7466], [7517, 7521], [7526, 7530], 7615, [7936, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8190], 8486, 43877, [65856, 65934], 65952, [119296, 119365]];
  var Greek_default = _176;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Gujarati.js
  var _177 = [[2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2801], [2809, 2815]];
  var Gujarati_default = _177;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Gunjala_Gondi.js
  var _178 = [[73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129]];
  var Gunjala_Gondi_default = _178;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Gurmukhi.js
  var _179 = [[2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2678]];
  var Gurmukhi_default = _179;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Han.js
  var _180 = [[11904, 11929], [11931, 12019], [12032, 12245], 12293, 12295, [12321, 12329], [12344, 12347], [13312, 19903], [19968, 40959], [63744, 64109], [64112, 64217], [94178, 94179], [94192, 94193], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var Han_default = _180;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hangul.js
  var _181 = [[4352, 4607], [12334, 12335], [12593, 12686], [12800, 12830], [12896, 12926], [43360, 43388], [44032, 55203], [55216, 55238], [55243, 55291], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500]];
  var Hangul_default = _181;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hanifi_Rohingya.js
  var _182 = [[68864, 68903], [68912, 68921]];
  var Hanifi_Rohingya_default = _182;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hanunoo.js
  var _183 = [[5920, 5940]];
  var Hanunoo_default = _183;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hatran.js
  var _184 = [[67808, 67826], [67828, 67829], [67835, 67839]];
  var Hatran_default = _184;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hebrew.js
  var _185 = [[1425, 1479], [1488, 1514], [1519, 1524], [64285, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335]];
  var Hebrew_default = _185;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Hiragana.js
  var _186 = [[12353, 12438], [12445, 12447], [110593, 110879], 110898, [110928, 110930], 127488];
  var Hiragana_default = _186;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Imperial_Aramaic.js
  var _187 = [[67648, 67669], [67671, 67679]];
  var Imperial_Aramaic_default = _187;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Inherited.js
  var _188 = [[768, 879], [1157, 1158], [1611, 1621], 1648, [2385, 2388], [6832, 6862], [7376, 7378], [7380, 7392], [7394, 7400], 7405, 7412, [7416, 7417], [7616, 7679], [8204, 8205], [8400, 8432], [12330, 12333], [12441, 12442], [65024, 65039], [65056, 65069], 66045, 66272, 70459, [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [917760, 917999]];
  var Inherited_default = _188;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Inscriptional_Pahlavi.js
  var _189 = [[68448, 68466], [68472, 68479]];
  var Inscriptional_Pahlavi_default = _189;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Inscriptional_Parthian.js
  var _190 = [[68416, 68437], [68440, 68447]];
  var Inscriptional_Parthian_default = _190;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Javanese.js
  var _191 = [[43392, 43469], [43472, 43481], [43486, 43487]];
  var Javanese_default = _191;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kaithi.js
  var _192 = [[69760, 69826], 69837];
  var Kaithi_default = _192;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kannada.js
  var _193 = [[3200, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315]];
  var Kannada_default = _193;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Katakana.js
  var _194 = [[12449, 12538], [12541, 12543], [12784, 12799], [13008, 13054], [13056, 13143], [65382, 65391], [65393, 65437], [110576, 110579], [110581, 110587], [110589, 110590], 110592, [110880, 110882], 110933, [110948, 110951]];
  var Katakana_default = _194;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kawi.js
  var _195 = [[73472, 73488], [73490, 73530], [73534, 73561]];
  var Kawi_default = _195;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kayah_Li.js
  var _196 = [[43264, 43309], 43311];
  var Kayah_Li_default = _196;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Kharoshthi.js
  var _197 = [[68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], [68159, 68168], [68176, 68184]];
  var Kharoshthi_default = _197;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Khitan_Small_Script.js
  var _198 = [94180, [101120, 101589]];
  var Khitan_Small_Script_default = _198;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Khmer.js
  var _199 = [[6016, 6109], [6112, 6121], [6128, 6137], [6624, 6655]];
  var Khmer_default = _199;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Khojki.js
  var _200 = [[70144, 70161], [70163, 70209]];
  var Khojki_default = _200;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Khudawadi.js
  var _201 = [[70320, 70378], [70384, 70393]];
  var Khudawadi_default = _201;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lao.js
  var _202 = [[3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807]];
  var Lao_default = _202;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Latin.js
  var _203 = [[65, 90], [97, 122], 170, 186, [192, 214], [216, 246], [248, 696], [736, 740], [7424, 7461], [7468, 7516], [7522, 7525], [7531, 7543], [7545, 7614], [7680, 7935], 8305, 8319, [8336, 8348], [8490, 8491], 8498, 8526, [8544, 8584], [11360, 11391], [42786, 42887], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43007], [43824, 43866], [43868, 43876], [43878, 43881], [64256, 64262], [65313, 65338], [65345, 65370], [67456, 67461], [67463, 67504], [67506, 67514], [122624, 122654], [122661, 122666]];
  var Latin_default = _203;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lepcha.js
  var _204 = [[7168, 7223], [7227, 7241], [7245, 7247]];
  var Lepcha_default = _204;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Limbu.js
  var _205 = [[6400, 6430], [6432, 6443], [6448, 6459], 6464, [6468, 6479]];
  var Limbu_default = _205;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Linear_A.js
  var _206 = [[67072, 67382], [67392, 67413], [67424, 67431]];
  var Linear_A_default = _206;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Linear_B.js
  var _207 = [[65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786]];
  var Linear_B_default = _207;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lisu.js
  var _208 = [[42192, 42239], 73648];
  var Lisu_default = _208;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lycian.js
  var _209 = [[66176, 66204]];
  var Lycian_default = _209;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Lydian.js
  var _210 = [[67872, 67897], 67903];
  var Lydian_default = _210;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mahajani.js
  var _211 = [[69968, 70006]];
  var Mahajani_default = _211;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Makasar.js
  var _212 = [[73440, 73464]];
  var Makasar_default = _212;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Malayalam.js
  var _213 = [[3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3407], [3412, 3427], [3430, 3455]];
  var Malayalam_default = _213;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mandaic.js
  var _214 = [[2112, 2139], 2142];
  var Mandaic_default = _214;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Manichaean.js
  var _215 = [[68288, 68326], [68331, 68342]];
  var Manichaean_default = _215;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Marchen.js
  var _216 = [[72816, 72847], [72850, 72871], [72873, 72886]];
  var Marchen_default = _216;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Masaram_Gondi.js
  var _217 = [[72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049]];
  var Masaram_Gondi_default = _217;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Medefaidrin.js
  var _218 = [[93760, 93850]];
  var Medefaidrin_default = _218;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Meetei_Mayek.js
  var _219 = [[43744, 43766], [43968, 44013], [44016, 44025]];
  var Meetei_Mayek_default = _219;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mende_Kikakui.js
  var _220 = [[124928, 125124], [125127, 125142]];
  var Mende_Kikakui_default = _220;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Meroitic_Cursive.js
  var _221 = [[68e3, 68023], [68028, 68047], [68050, 68095]];
  var Meroitic_Cursive_default = _221;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Meroitic_Hieroglyphs.js
  var _222 = [[67968, 67999]];
  var Meroitic_Hieroglyphs_default = _222;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Miao.js
  var _223 = [[93952, 94026], [94031, 94087], [94095, 94111]];
  var Miao_default = _223;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Modi.js
  var _224 = [[71168, 71236], [71248, 71257]];
  var Modi_default = _224;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mongolian.js
  var _225 = [[6144, 6145], 6148, [6150, 6169], [6176, 6264], [6272, 6314], [71264, 71276]];
  var Mongolian_default = _225;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Mro.js
  var _226 = [[92736, 92766], [92768, 92777], [92782, 92783]];
  var Mro_default = _226;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Multani.js
  var _227 = [[70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313]];
  var Multani_default = _227;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Myanmar.js
  var _228 = [[4096, 4255], [43488, 43518], [43616, 43647]];
  var Myanmar_default = _228;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nabataean.js
  var _229 = [[67712, 67742], [67751, 67759]];
  var Nabataean_default = _229;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nag_Mundari.js
  var _230 = [[124112, 124153]];
  var Nag_Mundari_default = _230;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nandinagari.js
  var _231 = [[72096, 72103], [72106, 72151], [72154, 72164]];
  var Nandinagari_default = _231;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/New_Tai_Lue.js
  var _232 = [[6528, 6571], [6576, 6601], [6608, 6618], [6622, 6623]];
  var New_Tai_Lue_default = _232;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Newa.js
  var _233 = [[70656, 70747], [70749, 70753]];
  var Newa_default = _233;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nko.js
  var _234 = [[1984, 2042], [2045, 2047]];
  var Nko_default = _234;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nushu.js
  var _235 = [94177, [110960, 111355]];
  var Nushu_default = _235;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Nyiakeng_Puachue_Hmong.js
  var _236 = [[123136, 123180], [123184, 123197], [123200, 123209], [123214, 123215]];
  var Nyiakeng_Puachue_Hmong_default = _236;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ogham.js
  var _237 = [[5760, 5788]];
  var Ogham_default = _237;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ol_Chiki.js
  var _238 = [[7248, 7295]];
  var Ol_Chiki_default = _238;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Hungarian.js
  var _239 = [[68736, 68786], [68800, 68850], [68858, 68863]];
  var Old_Hungarian_default = _239;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Italic.js
  var _240 = [[66304, 66339], [66349, 66351]];
  var Old_Italic_default = _240;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_North_Arabian.js
  var _241 = [[68224, 68255]];
  var Old_North_Arabian_default = _241;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Permic.js
  var _242 = [[66384, 66426]];
  var Old_Permic_default = _242;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Persian.js
  var _243 = [[66464, 66499], [66504, 66517]];
  var Old_Persian_default = _243;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Sogdian.js
  var _244 = [[69376, 69415]];
  var Old_Sogdian_default = _244;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_South_Arabian.js
  var _245 = [[68192, 68223]];
  var Old_South_Arabian_default = _245;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Turkic.js
  var _246 = [[68608, 68680]];
  var Old_Turkic_default = _246;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Old_Uyghur.js
  var _247 = [[69488, 69513]];
  var Old_Uyghur_default = _247;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Oriya.js
  var _248 = [[2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2935]];
  var Oriya_default = _248;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Osage.js
  var _249 = [[66736, 66771], [66776, 66811]];
  var Osage_default = _249;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Osmanya.js
  var _250 = [[66688, 66717], [66720, 66729]];
  var Osmanya_default = _250;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Pahawh_Hmong.js
  var _251 = [[92928, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071]];
  var Pahawh_Hmong_default = _251;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Palmyrene.js
  var _252 = [[67680, 67711]];
  var Palmyrene_default = _252;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Pau_Cin_Hau.js
  var _253 = [[72384, 72440]];
  var Pau_Cin_Hau_default = _253;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Phags_Pa.js
  var _254 = [[43072, 43127]];
  var Phags_Pa_default = _254;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Phoenician.js
  var _255 = [[67840, 67867], 67871];
  var Phoenician_default = _255;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Psalter_Pahlavi.js
  var _256 = [[68480, 68497], [68505, 68508], [68521, 68527]];
  var Psalter_Pahlavi_default = _256;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Rejang.js
  var _257 = [[43312, 43347], 43359];
  var Rejang_default = _257;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Runic.js
  var _258 = [[5792, 5866], [5870, 5880]];
  var Runic_default = _258;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Samaritan.js
  var _259 = [[2048, 2093], [2096, 2110]];
  var Samaritan_default = _259;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Saurashtra.js
  var _260 = [[43136, 43205], [43214, 43225]];
  var Saurashtra_default = _260;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sharada.js
  var _261 = [[70016, 70111]];
  var Sharada_default = _261;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Shavian.js
  var _262 = [[66640, 66687]];
  var Shavian_default = _262;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Siddham.js
  var _263 = [[71040, 71093], [71096, 71133]];
  var Siddham_default = _263;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/SignWriting.js
  var _264 = [[120832, 121483], [121499, 121503], [121505, 121519]];
  var SignWriting_default = _264;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sinhala.js
  var _265 = [[3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3572], [70113, 70132]];
  var Sinhala_default = _265;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sogdian.js
  var _266 = [[69424, 69465]];
  var Sogdian_default = _266;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sora_Sompeng.js
  var _267 = [[69840, 69864], [69872, 69881]];
  var Sora_Sompeng_default = _267;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Soyombo.js
  var _268 = [[72272, 72354]];
  var Soyombo_default = _268;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Sundanese.js
  var _269 = [[7040, 7103], [7360, 7367]];
  var Sundanese_default = _269;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Syloti_Nagri.js
  var _270 = [[43008, 43052]];
  var Syloti_Nagri_default = _270;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Syriac.js
  var _271 = [[1792, 1805], [1807, 1866], [1869, 1871], [2144, 2154]];
  var Syriac_default = _271;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tagalog.js
  var _272 = [[5888, 5909], 5919];
  var Tagalog_default = _272;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tagbanwa.js
  var _273 = [[5984, 5996], [5998, 6e3], [6002, 6003]];
  var Tagbanwa_default = _273;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tai_Le.js
  var _274 = [[6480, 6509], [6512, 6516]];
  var Tai_Le_default = _274;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tai_Tham.js
  var _275 = [[6688, 6750], [6752, 6780], [6783, 6793], [6800, 6809], [6816, 6829]];
  var Tai_Tham_default = _275;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tai_Viet.js
  var _276 = [[43648, 43714], [43739, 43743]];
  var Tai_Viet_default = _276;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Takri.js
  var _277 = [[71296, 71353], [71360, 71369]];
  var Takri_default = _277;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tamil.js
  var _278 = [[2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3066], [73664, 73713], 73727];
  var Tamil_default = _278;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tangsa.js
  var _279 = [[92784, 92862], [92864, 92873]];
  var Tangsa_default = _279;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tangut.js
  var _280 = [94176, [94208, 100343], [100352, 101119], [101632, 101640]];
  var Tangut_default = _280;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Telugu.js
  var _281 = [[3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3191, 3199]];
  var Telugu_default = _281;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Thaana.js
  var _282 = [[1920, 1969]];
  var Thaana_default = _282;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Thai.js
  var _283 = [[3585, 3642], [3648, 3675]];
  var Thai_default = _283;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tibetan.js
  var _284 = [[3840, 3911], [3913, 3948], [3953, 3991], [3993, 4028], [4030, 4044], [4046, 4052], [4057, 4058]];
  var Tibetan_default = _284;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tifinagh.js
  var _285 = [[11568, 11623], [11631, 11632], 11647];
  var Tifinagh_default = _285;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Tirhuta.js
  var _286 = [[70784, 70855], [70864, 70873]];
  var Tirhuta_default = _286;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Toto.js
  var _287 = [[123536, 123566]];
  var Toto_default = _287;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Ugaritic.js
  var _288 = [[66432, 66461], 66463];
  var Ugaritic_default = _288;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Vai.js
  var _289 = [[42240, 42539]];
  var Vai_default = _289;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Vithkuqi.js
  var _290 = [[66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004]];
  var Vithkuqi_default = _290;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Wancho.js
  var _291 = [[123584, 123641], 123647];
  var Wancho_default = _291;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Warang_Citi.js
  var _292 = [[71840, 71922], 71935];
  var Warang_Citi_default = _292;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Yezidi.js
  var _293 = [[69248, 69289], [69291, 69293], [69296, 69297]];
  var Yezidi_default = _293;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Yi.js
  var _294 = [[40960, 42124], [42128, 42182]];
  var Yi_default = _294;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script/Zanabazar_Square.js
  var _295 = [[72192, 72263]];
  var Zanabazar_Square_default = _295;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/index.js
  var Script_Extensions_exports = {};
  __export(Script_Extensions_exports, {
    Adlam: () => Adlam_default2,
    Ahom: () => Ahom_default2,
    Anatolian_Hieroglyphs: () => Anatolian_Hieroglyphs_default2,
    Arabic: () => Arabic_default2,
    Armenian: () => Armenian_default2,
    Avestan: () => Avestan_default2,
    Balinese: () => Balinese_default2,
    Bamum: () => Bamum_default2,
    Bassa_Vah: () => Bassa_Vah_default2,
    Batak: () => Batak_default2,
    Bengali: () => Bengali_default2,
    Bhaiksuki: () => Bhaiksuki_default2,
    Bopomofo: () => Bopomofo_default2,
    Brahmi: () => Brahmi_default2,
    Braille: () => Braille_default2,
    Buginese: () => Buginese_default2,
    Buhid: () => Buhid_default2,
    Canadian_Aboriginal: () => Canadian_Aboriginal_default2,
    Carian: () => Carian_default2,
    Caucasian_Albanian: () => Caucasian_Albanian_default2,
    Chakma: () => Chakma_default2,
    Cham: () => Cham_default2,
    Cherokee: () => Cherokee_default2,
    Chorasmian: () => Chorasmian_default2,
    Common: () => Common_default2,
    Coptic: () => Coptic_default2,
    Cuneiform: () => Cuneiform_default2,
    Cypriot: () => Cypriot_default2,
    Cypro_Minoan: () => Cypro_Minoan_default2,
    Cyrillic: () => Cyrillic_default2,
    Deseret: () => Deseret_default2,
    Devanagari: () => Devanagari_default2,
    Dives_Akuru: () => Dives_Akuru_default2,
    Dogra: () => Dogra_default2,
    Duployan: () => Duployan_default2,
    Egyptian_Hieroglyphs: () => Egyptian_Hieroglyphs_default2,
    Elbasan: () => Elbasan_default2,
    Elymaic: () => Elymaic_default2,
    Ethiopic: () => Ethiopic_default2,
    Georgian: () => Georgian_default2,
    Glagolitic: () => Glagolitic_default2,
    Gothic: () => Gothic_default2,
    Grantha: () => Grantha_default2,
    Greek: () => Greek_default2,
    Gujarati: () => Gujarati_default2,
    Gunjala_Gondi: () => Gunjala_Gondi_default2,
    Gurmukhi: () => Gurmukhi_default2,
    Han: () => Han_default2,
    Hangul: () => Hangul_default2,
    Hanifi_Rohingya: () => Hanifi_Rohingya_default2,
    Hanunoo: () => Hanunoo_default2,
    Hatran: () => Hatran_default2,
    Hebrew: () => Hebrew_default2,
    Hiragana: () => Hiragana_default2,
    Imperial_Aramaic: () => Imperial_Aramaic_default2,
    Inherited: () => Inherited_default2,
    Inscriptional_Pahlavi: () => Inscriptional_Pahlavi_default2,
    Inscriptional_Parthian: () => Inscriptional_Parthian_default2,
    Javanese: () => Javanese_default2,
    Kaithi: () => Kaithi_default2,
    Kannada: () => Kannada_default2,
    Katakana: () => Katakana_default2,
    Kawi: () => Kawi_default2,
    Kayah_Li: () => Kayah_Li_default2,
    Kharoshthi: () => Kharoshthi_default2,
    Khitan_Small_Script: () => Khitan_Small_Script_default2,
    Khmer: () => Khmer_default2,
    Khojki: () => Khojki_default2,
    Khudawadi: () => Khudawadi_default2,
    Lao: () => Lao_default2,
    Latin: () => Latin_default2,
    Lepcha: () => Lepcha_default2,
    Limbu: () => Limbu_default2,
    Linear_A: () => Linear_A_default2,
    Linear_B: () => Linear_B_default2,
    Lisu: () => Lisu_default2,
    Lycian: () => Lycian_default2,
    Lydian: () => Lydian_default2,
    Mahajani: () => Mahajani_default2,
    Makasar: () => Makasar_default2,
    Malayalam: () => Malayalam_default2,
    Mandaic: () => Mandaic_default2,
    Manichaean: () => Manichaean_default2,
    Marchen: () => Marchen_default2,
    Masaram_Gondi: () => Masaram_Gondi_default2,
    Medefaidrin: () => Medefaidrin_default2,
    Meetei_Mayek: () => Meetei_Mayek_default2,
    Mende_Kikakui: () => Mende_Kikakui_default2,
    Meroitic_Cursive: () => Meroitic_Cursive_default2,
    Meroitic_Hieroglyphs: () => Meroitic_Hieroglyphs_default2,
    Miao: () => Miao_default2,
    Modi: () => Modi_default2,
    Mongolian: () => Mongolian_default2,
    Mro: () => Mro_default2,
    Multani: () => Multani_default2,
    Myanmar: () => Myanmar_default2,
    Nabataean: () => Nabataean_default2,
    Nag_Mundari: () => Nag_Mundari_default2,
    Nandinagari: () => Nandinagari_default2,
    New_Tai_Lue: () => New_Tai_Lue_default2,
    Newa: () => Newa_default2,
    Nko: () => Nko_default2,
    Nushu: () => Nushu_default2,
    Nyiakeng_Puachue_Hmong: () => Nyiakeng_Puachue_Hmong_default2,
    Ogham: () => Ogham_default2,
    Ol_Chiki: () => Ol_Chiki_default2,
    Old_Hungarian: () => Old_Hungarian_default2,
    Old_Italic: () => Old_Italic_default2,
    Old_North_Arabian: () => Old_North_Arabian_default2,
    Old_Permic: () => Old_Permic_default2,
    Old_Persian: () => Old_Persian_default2,
    Old_Sogdian: () => Old_Sogdian_default2,
    Old_South_Arabian: () => Old_South_Arabian_default2,
    Old_Turkic: () => Old_Turkic_default2,
    Old_Uyghur: () => Old_Uyghur_default2,
    Oriya: () => Oriya_default2,
    Osage: () => Osage_default2,
    Osmanya: () => Osmanya_default2,
    Pahawh_Hmong: () => Pahawh_Hmong_default2,
    Palmyrene: () => Palmyrene_default2,
    Pau_Cin_Hau: () => Pau_Cin_Hau_default2,
    Phags_Pa: () => Phags_Pa_default2,
    Phoenician: () => Phoenician_default2,
    Psalter_Pahlavi: () => Psalter_Pahlavi_default2,
    Rejang: () => Rejang_default2,
    Runic: () => Runic_default2,
    Samaritan: () => Samaritan_default2,
    Saurashtra: () => Saurashtra_default2,
    Sharada: () => Sharada_default2,
    Shavian: () => Shavian_default2,
    Siddham: () => Siddham_default2,
    SignWriting: () => SignWriting_default2,
    Sinhala: () => Sinhala_default2,
    Sogdian: () => Sogdian_default2,
    Sora_Sompeng: () => Sora_Sompeng_default2,
    Soyombo: () => Soyombo_default2,
    Sundanese: () => Sundanese_default2,
    Syloti_Nagri: () => Syloti_Nagri_default2,
    Syriac: () => Syriac_default2,
    Tagalog: () => Tagalog_default2,
    Tagbanwa: () => Tagbanwa_default2,
    Tai_Le: () => Tai_Le_default2,
    Tai_Tham: () => Tai_Tham_default2,
    Tai_Viet: () => Tai_Viet_default2,
    Takri: () => Takri_default2,
    Tamil: () => Tamil_default2,
    Tangsa: () => Tangsa_default2,
    Tangut: () => Tangut_default2,
    Telugu: () => Telugu_default2,
    Thaana: () => Thaana_default2,
    Thai: () => Thai_default2,
    Tibetan: () => Tibetan_default2,
    Tifinagh: () => Tifinagh_default2,
    Tirhuta: () => Tirhuta_default2,
    Toto: () => Toto_default2,
    Ugaritic: () => Ugaritic_default2,
    Vai: () => Vai_default2,
    Vithkuqi: () => Vithkuqi_default2,
    Wancho: () => Wancho_default2,
    Warang_Citi: () => Warang_Citi_default2,
    Yezidi: () => Yezidi_default2,
    Yi: () => Yi_default2,
    Zanabazar_Square: () => Zanabazar_Square_default2
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Adlam.js
  var _296 = [1567, 1600, [125184, 125259], [125264, 125273], [125278, 125279]];
  var Adlam_default2 = _296;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ahom.js
  var _297 = [[71424, 71450], [71453, 71467], [71472, 71494]];
  var Ahom_default2 = _297;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Anatolian_Hieroglyphs.js
  var _298 = [[82944, 83526]];
  var Anatolian_Hieroglyphs_default2 = _298;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Arabic.js
  var _299 = [[1536, 1540], [1542, 1756], [1758, 1791], [1872, 1919], [2160, 2190], [2192, 2193], [2200, 2273], [2275, 2303], [64336, 64450], [64467, 64911], [64914, 64967], 64975, [65008, 65023], [65136, 65140], [65142, 65276], [66272, 66299], [69216, 69246], [69373, 69375], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705]];
  var Arabic_default2 = _299;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Armenian.js
  var _300 = [[1329, 1366], [1369, 1418], [1421, 1423], [64275, 64279]];
  var Armenian_default2 = _300;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Avestan.js
  var _301 = [[68352, 68405], [68409, 68415]];
  var Avestan_default2 = _301;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Balinese.js
  var _302 = [[6912, 6988], [6992, 7038]];
  var Balinese_default2 = _302;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bamum.js
  var _303 = [[42656, 42743], [92160, 92728]];
  var Bamum_default2 = _303;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bassa_Vah.js
  var _304 = [[92880, 92909], [92912, 92917]];
  var Bassa_Vah_default2 = _304;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Batak.js
  var _305 = [[7104, 7155], [7164, 7167]];
  var Batak_default2 = _305;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bengali.js
  var _306 = [[2385, 2386], [2404, 2405], [2432, 2435], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], [2492, 2500], [2503, 2504], [2507, 2510], 2519, [2524, 2525], [2527, 2531], [2534, 2558], 7376, 7378, [7381, 7382], 7384, 7393, 7402, 7405, 7410, [7413, 7415], 43249];
  var Bengali_default2 = _306;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bhaiksuki.js
  var _307 = [[72704, 72712], [72714, 72758], [72760, 72773], [72784, 72812]];
  var Bhaiksuki_default2 = _307;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Bopomofo.js
  var _308 = [[746, 747], [12289, 12291], [12296, 12305], [12307, 12319], [12330, 12333], 12336, 12343, 12539, [12549, 12591], [12704, 12735], [65093, 65094], [65377, 65381]];
  var Bopomofo_default2 = _308;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Brahmi.js
  var _309 = [[69632, 69709], [69714, 69749], 69759];
  var Brahmi_default2 = _309;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Braille.js
  var _310 = [[10240, 10495]];
  var Braille_default2 = _310;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Buginese.js
  var _311 = [[6656, 6683], [6686, 6687], 43471];
  var Buginese_default2 = _311;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Buhid.js
  var _312 = [[5941, 5942], [5952, 5971]];
  var Buhid_default2 = _312;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Canadian_Aboriginal.js
  var _313 = [[5120, 5759], [6320, 6389], [72368, 72383]];
  var Canadian_Aboriginal_default2 = _313;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Carian.js
  var _314 = [[66208, 66256]];
  var Carian_default2 = _314;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Caucasian_Albanian.js
  var _315 = [[66864, 66915], 66927];
  var Caucasian_Albanian_default2 = _315;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Chakma.js
  var _316 = [[2534, 2543], [4160, 4169], [69888, 69940], [69942, 69959]];
  var Chakma_default2 = _316;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cham.js
  var _317 = [[43520, 43574], [43584, 43597], [43600, 43609], [43612, 43615]];
  var Cham_default2 = _317;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cherokee.js
  var _318 = [[5024, 5109], [5112, 5117], [43888, 43967]];
  var Cherokee_default2 = _318;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Chorasmian.js
  var _319 = [[69552, 69579]];
  var Chorasmian_default2 = _319;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Common.js
  var _320 = [[0, 64], [91, 96], [123, 169], [171, 185], [187, 191], 215, 247, [697, 735], [741, 745], [748, 767], 884, 894, 901, 903, 1541, 1757, 2274, 3647, [4053, 4056], [5867, 5869], [8192, 8203], [8206, 8238], [8240, 8292], [8294, 8304], [8308, 8318], [8320, 8334], [8352, 8384], [8448, 8485], [8487, 8489], [8492, 8497], [8499, 8525], [8527, 8543], [8585, 8587], [8592, 9254], [9280, 9290], [9312, 10239], [10496, 11123], [11126, 11157], [11159, 11263], [11776, 11842], [11844, 11869], [12272, 12283], 12288, 12292, 12306, 12320, 12342, [12872, 12895], 12927, [12977, 12991], [13004, 13007], [13169, 13178], [13184, 13279], 13311, [19904, 19967], [42760, 42785], [42888, 42890], 43867, [43882, 43883], [65040, 65049], [65072, 65092], [65095, 65106], [65108, 65126], [65128, 65131], 65279, [65281, 65312], [65339, 65344], [65371, 65376], [65504, 65510], [65512, 65518], [65529, 65533], [65936, 65948], [66e3, 66044], [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119142], [119146, 119162], [119171, 119172], [119180, 119209], [119214, 119274], [119488, 119507], [119520, 119539], [119552, 119638], [119666, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120782, 120831], [126065, 126132], [126209, 126269], [126976, 127019], [127024, 127123], [127136, 127150], [127153, 127167], [127169, 127183], [127185, 127221], [127232, 127405], [127462, 127487], [127489, 127490], [127504, 127547], [127552, 127560], [127584, 127589], [127744, 128727], [128732, 128748], [128752, 128764], [128768, 128886], [128891, 128985], [128992, 129003], 129008, [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129200, 129201], [129280, 129619], [129632, 129645], [129648, 129660], [129664, 129672], [129680, 129725], [129727, 129733], [129742, 129755], [129760, 129768], [129776, 129784], [129792, 129938], [129940, 129994], [130032, 130041], 917505, [917536, 917631]];
  var Common_default2 = _320;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Coptic.js
  var _321 = [[994, 1007], [11392, 11507], [11513, 11519], [66272, 66299]];
  var Coptic_default2 = _321;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cuneiform.js
  var _322 = [[73728, 74649], [74752, 74862], [74864, 74868], [74880, 75075]];
  var Cuneiform_default2 = _322;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cypriot.js
  var _323 = [[65792, 65794], [65799, 65843], [65847, 65855], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, 67647];
  var Cypriot_default2 = _323;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cypro_Minoan.js
  var _324 = [[65792, 65793], [77712, 77810]];
  var Cypro_Minoan_default2 = _324;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Cyrillic.js
  var _325 = [[1024, 1327], [7296, 7304], 7467, 7544, 7672, [11744, 11775], 11843, [42560, 42655], [65070, 65071], [122928, 122989], 123023];
  var Cyrillic_default2 = _325;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Deseret.js
  var _326 = [[66560, 66639]];
  var Deseret_default2 = _326;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Devanagari.js
  var _327 = [[2304, 2386], [2389, 2431], [7376, 7414], [7416, 7417], 8432, [43056, 43065], [43232, 43263], [72448, 72457]];
  var Devanagari_default2 = _327;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Dives_Akuru.js
  var _328 = [[71936, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71989], [71991, 71992], [71995, 72006], [72016, 72025]];
  var Dives_Akuru_default2 = _328;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Dogra.js
  var _329 = [[2404, 2415], [43056, 43065], [71680, 71739]];
  var Dogra_default2 = _329;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Duployan.js
  var _330 = [[113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [113820, 113827]];
  var Duployan_default2 = _330;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Egyptian_Hieroglyphs.js
  var _331 = [[77824, 78933]];
  var Egyptian_Hieroglyphs_default2 = _331;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Elbasan.js
  var _332 = [[66816, 66855]];
  var Elbasan_default2 = _332;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Elymaic.js
  var _333 = [[69600, 69622]];
  var Elymaic_default2 = _333;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ethiopic.js
  var _334 = [[4608, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4957, 4988], [4992, 5017], [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926]];
  var Ethiopic_default2 = _334;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Georgian.js
  var _335 = [[4256, 4293], 4295, 4301, [4304, 4351], [7312, 7354], [7357, 7359], [11520, 11557], 11559, 11565];
  var Georgian_default2 = _335;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Glagolitic.js
  var _336 = [1156, 1159, [11264, 11359], 11843, 42607, [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922]];
  var Glagolitic_default2 = _336;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Gothic.js
  var _337 = [[66352, 66378]];
  var Gothic_default2 = _337;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Grantha.js
  var _338 = [[2385, 2386], [2404, 2405], [3046, 3059], 7376, [7378, 7379], [7410, 7412], [7416, 7417], 8432, [70400, 70403], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], [70459, 70468], [70471, 70472], [70475, 70477], 70480, 70487, [70493, 70499], [70502, 70508], [70512, 70516], [73680, 73681], 73683];
  var Grantha_default2 = _338;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Greek.js
  var _339 = [834, 837, [880, 883], [885, 887], [890, 893], 895, 900, 902, [904, 906], 908, [910, 929], [931, 993], [1008, 1023], [7462, 7466], [7517, 7521], [7526, 7530], [7615, 7617], [7936, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8190], 8486, 43877, [65856, 65934], 65952, [119296, 119365]];
  var Greek_default2 = _339;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Gujarati.js
  var _340 = [[2385, 2386], [2404, 2405], [2689, 2691], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], [2748, 2757], [2759, 2761], [2763, 2765], 2768, [2784, 2787], [2790, 2801], [2809, 2815], [43056, 43065]];
  var Gujarati_default2 = _340;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Gunjala_Gondi.js
  var _341 = [[2404, 2405], [73056, 73061], [73063, 73064], [73066, 73102], [73104, 73105], [73107, 73112], [73120, 73129]];
  var Gunjala_Gondi_default2 = _341;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Gurmukhi.js
  var _342 = [[2385, 2386], [2404, 2405], [2561, 2563], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2649, 2652], 2654, [2662, 2678], [43056, 43065]];
  var Gurmukhi_default2 = _342;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Han.js
  var _343 = [[11904, 11929], [11931, 12019], [12032, 12245], [12289, 12291], [12293, 12305], [12307, 12319], [12321, 12333], 12336, [12343, 12351], 12539, [12688, 12703], [12736, 12771], [12832, 12871], [12928, 12976], [12992, 13003], 13055, [13144, 13168], [13179, 13183], [13280, 13310], [13312, 19903], [19968, 40959], [42752, 42759], [63744, 64109], [64112, 64217], [65093, 65094], [65377, 65381], [94178, 94179], [94192, 94193], [119648, 119665], [127568, 127569], [131072, 173791], [173824, 177977], [177984, 178205], [178208, 183969], [183984, 191456], [194560, 195101], [196608, 201546], [201552, 205743]];
  var Han_default2 = _343;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hangul.js
  var _344 = [[4352, 4607], [12289, 12291], [12296, 12305], [12307, 12319], [12334, 12336], 12343, 12539, [12593, 12686], [12800, 12830], [12896, 12926], [43360, 43388], [44032, 55203], [55216, 55238], [55243, 55291], [65093, 65094], [65377, 65381], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500]];
  var Hangul_default2 = _344;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hanifi_Rohingya.js
  var _345 = [1548, 1563, 1567, 1600, 1748, [68864, 68903], [68912, 68921]];
  var Hanifi_Rohingya_default2 = _345;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hanunoo.js
  var _346 = [[5920, 5942]];
  var Hanunoo_default2 = _346;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hatran.js
  var _347 = [[67808, 67826], [67828, 67829], [67835, 67839]];
  var Hatran_default2 = _347;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hebrew.js
  var _348 = [[1425, 1479], [1488, 1514], [1519, 1524], [64285, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335]];
  var Hebrew_default2 = _348;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Hiragana.js
  var _349 = [[12289, 12291], [12296, 12305], [12307, 12319], [12336, 12341], 12343, [12348, 12349], [12353, 12438], [12441, 12448], [12539, 12540], [65093, 65094], [65377, 65381], 65392, [65438, 65439], [110593, 110879], 110898, [110928, 110930], 127488];
  var Hiragana_default2 = _349;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Imperial_Aramaic.js
  var _350 = [[67648, 67669], [67671, 67679]];
  var Imperial_Aramaic_default2 = _350;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Inherited.js
  var _351 = [[768, 833], [835, 836], [838, 866], [2387, 2388], [6832, 6862], [7618, 7671], 7673, [7675, 7679], [8204, 8205], [8400, 8431], [65024, 65039], [65056, 65069], 66045, [118528, 118573], [118576, 118598], [119143, 119145], [119163, 119170], [119173, 119179], [119210, 119213], [917760, 917999]];
  var Inherited_default2 = _351;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Inscriptional_Pahlavi.js
  var _352 = [[68448, 68466], [68472, 68479]];
  var Inscriptional_Pahlavi_default2 = _352;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Inscriptional_Parthian.js
  var _353 = [[68416, 68437], [68440, 68447]];
  var Inscriptional_Parthian_default2 = _353;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Javanese.js
  var _354 = [[43392, 43469], [43471, 43481], [43486, 43487]];
  var Javanese_default2 = _354;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kaithi.js
  var _355 = [[2406, 2415], [43056, 43065], [69760, 69826], 69837];
  var Kaithi_default2 = _355;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kannada.js
  var _356 = [[2385, 2386], [2404, 2405], [3200, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], [3260, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3293, 3294], [3296, 3299], [3302, 3311], [3313, 3315], 7376, 7378, 7386, 7410, 7412, [43056, 43061]];
  var Kannada_default2 = _356;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Katakana.js
  var _357 = [[12289, 12291], [12296, 12305], [12307, 12319], [12336, 12341], 12343, [12348, 12349], [12441, 12444], [12448, 12543], [12784, 12799], [13008, 13054], [13056, 13143], [65093, 65094], [65377, 65439], [110576, 110579], [110581, 110587], [110589, 110590], 110592, [110880, 110882], 110933, [110948, 110951]];
  var Katakana_default2 = _357;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kawi.js
  var _358 = [[73472, 73488], [73490, 73530], [73534, 73561]];
  var Kawi_default2 = _358;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kayah_Li.js
  var _359 = [[43264, 43311]];
  var Kayah_Li_default2 = _359;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Kharoshthi.js
  var _360 = [[68096, 68099], [68101, 68102], [68108, 68115], [68117, 68119], [68121, 68149], [68152, 68154], [68159, 68168], [68176, 68184]];
  var Kharoshthi_default2 = _360;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Khitan_Small_Script.js
  var _361 = [94180, [101120, 101589]];
  var Khitan_Small_Script_default2 = _361;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Khmer.js
  var _362 = [[6016, 6109], [6112, 6121], [6128, 6137], [6624, 6655]];
  var Khmer_default2 = _362;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Khojki.js
  var _363 = [[2790, 2799], [43056, 43065], [70144, 70161], [70163, 70209]];
  var Khojki_default2 = _363;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Khudawadi.js
  var _364 = [[2404, 2405], [43056, 43065], [70320, 70378], [70384, 70393]];
  var Khudawadi_default2 = _364;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lao.js
  var _365 = [[3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3792, 3801], [3804, 3807]];
  var Lao_default2 = _365;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Latin.js
  var _366 = [[65, 90], [97, 122], 170, 186, [192, 214], [216, 246], [248, 696], [736, 740], [867, 879], [1157, 1158], [2385, 2386], 4347, [7424, 7461], [7468, 7516], [7522, 7525], [7531, 7543], [7545, 7614], [7680, 7935], 8239, 8305, 8319, [8336, 8348], 8432, [8490, 8491], 8498, 8526, [8544, 8584], [11360, 11391], [42752, 42759], [42786, 42887], [42891, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43007], 43310, [43824, 43866], [43868, 43876], [43878, 43881], [64256, 64262], [65313, 65338], [65345, 65370], [67456, 67461], [67463, 67504], [67506, 67514], [122624, 122654], [122661, 122666]];
  var Latin_default2 = _366;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lepcha.js
  var _367 = [[7168, 7223], [7227, 7241], [7245, 7247]];
  var Lepcha_default2 = _367;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Limbu.js
  var _368 = [2405, [6400, 6430], [6432, 6443], [6448, 6459], 6464, [6468, 6479]];
  var Limbu_default2 = _368;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Linear_A.js
  var _369 = [[65799, 65843], [67072, 67382], [67392, 67413], [67424, 67431]];
  var Linear_A_default2 = _369;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Linear_B.js
  var _370 = [[65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65792, 65794], [65799, 65843], [65847, 65855]];
  var Linear_B_default2 = _370;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lisu.js
  var _371 = [[42192, 42239], 73648];
  var Lisu_default2 = _371;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lycian.js
  var _372 = [[66176, 66204]];
  var Lycian_default2 = _372;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Lydian.js
  var _373 = [[67872, 67897], 67903];
  var Lydian_default2 = _373;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mahajani.js
  var _374 = [[2404, 2415], [43056, 43065], [69968, 70006]];
  var Mahajani_default2 = _374;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Makasar.js
  var _375 = [[73440, 73464]];
  var Makasar_default2 = _375;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Malayalam.js
  var _376 = [[2385, 2386], [2404, 2405], [3328, 3340], [3342, 3344], [3346, 3396], [3398, 3400], [3402, 3407], [3412, 3427], [3430, 3455], 7386, [43056, 43058]];
  var Malayalam_default2 = _376;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mandaic.js
  var _377 = [1600, [2112, 2139], 2142];
  var Mandaic_default2 = _377;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Manichaean.js
  var _378 = [1600, [68288, 68326], [68331, 68342]];
  var Manichaean_default2 = _378;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Marchen.js
  var _379 = [[72816, 72847], [72850, 72871], [72873, 72886]];
  var Marchen_default2 = _379;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Masaram_Gondi.js
  var _380 = [[2404, 2405], [72960, 72966], [72968, 72969], [72971, 73014], 73018, [73020, 73021], [73023, 73031], [73040, 73049]];
  var Masaram_Gondi_default2 = _380;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Medefaidrin.js
  var _381 = [[93760, 93850]];
  var Medefaidrin_default2 = _381;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Meetei_Mayek.js
  var _382 = [[43744, 43766], [43968, 44013], [44016, 44025]];
  var Meetei_Mayek_default2 = _382;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mende_Kikakui.js
  var _383 = [[124928, 125124], [125127, 125142]];
  var Mende_Kikakui_default2 = _383;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Meroitic_Cursive.js
  var _384 = [[68e3, 68023], [68028, 68047], [68050, 68095]];
  var Meroitic_Cursive_default2 = _384;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Meroitic_Hieroglyphs.js
  var _385 = [[67968, 67999]];
  var Meroitic_Hieroglyphs_default2 = _385;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Miao.js
  var _386 = [[93952, 94026], [94031, 94087], [94095, 94111]];
  var Miao_default2 = _386;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Modi.js
  var _387 = [[43056, 43065], [71168, 71236], [71248, 71257]];
  var Modi_default2 = _387;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mongolian.js
  var _388 = [[6144, 6169], [6176, 6264], [6272, 6314], 8239, [71264, 71276]];
  var Mongolian_default2 = _388;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Mro.js
  var _389 = [[92736, 92766], [92768, 92777], [92782, 92783]];
  var Mro_default2 = _389;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Multani.js
  var _390 = [[2662, 2671], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70313]];
  var Multani_default2 = _390;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Myanmar.js
  var _391 = [[4096, 4255], 43310, [43488, 43518], [43616, 43647]];
  var Myanmar_default2 = _391;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nabataean.js
  var _392 = [[67712, 67742], [67751, 67759]];
  var Nabataean_default2 = _392;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nag_Mundari.js
  var _393 = [[124112, 124153]];
  var Nag_Mundari_default2 = _393;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nandinagari.js
  var _394 = [[2404, 2405], [3302, 3311], 7401, 7410, 7418, [43056, 43061], [72096, 72103], [72106, 72151], [72154, 72164]];
  var Nandinagari_default2 = _394;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/New_Tai_Lue.js
  var _395 = [[6528, 6571], [6576, 6601], [6608, 6618], [6622, 6623]];
  var New_Tai_Lue_default2 = _395;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Newa.js
  var _396 = [[70656, 70747], [70749, 70753]];
  var Newa_default2 = _396;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nko.js
  var _397 = [1548, 1563, 1567, [1984, 2042], [2045, 2047], [64830, 64831]];
  var Nko_default2 = _397;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nushu.js
  var _398 = [94177, [110960, 111355]];
  var Nushu_default2 = _398;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Nyiakeng_Puachue_Hmong.js
  var _399 = [[123136, 123180], [123184, 123197], [123200, 123209], [123214, 123215]];
  var Nyiakeng_Puachue_Hmong_default2 = _399;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ogham.js
  var _400 = [[5760, 5788]];
  var Ogham_default2 = _400;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ol_Chiki.js
  var _401 = [[7248, 7295]];
  var Ol_Chiki_default2 = _401;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Hungarian.js
  var _402 = [[68736, 68786], [68800, 68850], [68858, 68863]];
  var Old_Hungarian_default2 = _402;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Italic.js
  var _403 = [[66304, 66339], [66349, 66351]];
  var Old_Italic_default2 = _403;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_North_Arabian.js
  var _404 = [[68224, 68255]];
  var Old_North_Arabian_default2 = _404;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Permic.js
  var _405 = [1155, [66384, 66426]];
  var Old_Permic_default2 = _405;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Persian.js
  var _406 = [[66464, 66499], [66504, 66517]];
  var Old_Persian_default2 = _406;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Sogdian.js
  var _407 = [[69376, 69415]];
  var Old_Sogdian_default2 = _407;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_South_Arabian.js
  var _408 = [[68192, 68223]];
  var Old_South_Arabian_default2 = _408;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Turkic.js
  var _409 = [[68608, 68680]];
  var Old_Turkic_default2 = _409;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Old_Uyghur.js
  var _410 = [1600, 68338, [69488, 69513]];
  var Old_Uyghur_default2 = _410;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Oriya.js
  var _411 = [[2385, 2386], [2404, 2405], [2817, 2819], [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], [2876, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2908, 2909], [2911, 2915], [2918, 2935], 7386, 7410];
  var Oriya_default2 = _411;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Osage.js
  var _412 = [[66736, 66771], [66776, 66811]];
  var Osage_default2 = _412;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Osmanya.js
  var _413 = [[66688, 66717], [66720, 66729]];
  var Osmanya_default2 = _413;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Pahawh_Hmong.js
  var _414 = [[92928, 92997], [93008, 93017], [93019, 93025], [93027, 93047], [93053, 93071]];
  var Pahawh_Hmong_default2 = _414;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Palmyrene.js
  var _415 = [[67680, 67711]];
  var Palmyrene_default2 = _415;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Pau_Cin_Hau.js
  var _416 = [[72384, 72440]];
  var Pau_Cin_Hau_default2 = _416;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Phags_Pa.js
  var _417 = [[6146, 6147], 6149, [43072, 43127]];
  var Phags_Pa_default2 = _417;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Phoenician.js
  var _418 = [[67840, 67867], 67871];
  var Phoenician_default2 = _418;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Psalter_Pahlavi.js
  var _419 = [1600, [68480, 68497], [68505, 68508], [68521, 68527]];
  var Psalter_Pahlavi_default2 = _419;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Rejang.js
  var _420 = [[43312, 43347], 43359];
  var Rejang_default2 = _420;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Runic.js
  var _421 = [[5792, 5866], [5870, 5880]];
  var Runic_default2 = _421;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Samaritan.js
  var _422 = [[2048, 2093], [2096, 2110]];
  var Samaritan_default2 = _422;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Saurashtra.js
  var _423 = [[43136, 43205], [43214, 43225]];
  var Saurashtra_default2 = _423;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sharada.js
  var _424 = [2385, 7383, 7385, [7388, 7389], 7392, [70016, 70111]];
  var Sharada_default2 = _424;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Shavian.js
  var _425 = [[66640, 66687]];
  var Shavian_default2 = _425;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Siddham.js
  var _426 = [[71040, 71093], [71096, 71133]];
  var Siddham_default2 = _426;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/SignWriting.js
  var _427 = [[120832, 121483], [121499, 121503], [121505, 121519]];
  var SignWriting_default2 = _427;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sinhala.js
  var _428 = [[2404, 2405], [3457, 3459], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3530, [3535, 3540], 3542, [3544, 3551], [3558, 3567], [3570, 3572], [70113, 70132]];
  var Sinhala_default2 = _428;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sogdian.js
  var _429 = [1600, [69424, 69465]];
  var Sogdian_default2 = _429;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sora_Sompeng.js
  var _430 = [[69840, 69864], [69872, 69881]];
  var Sora_Sompeng_default2 = _430;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Soyombo.js
  var _431 = [[72272, 72354]];
  var Soyombo_default2 = _431;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Sundanese.js
  var _432 = [[7040, 7103], [7360, 7367]];
  var Sundanese_default2 = _432;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Syloti_Nagri.js
  var _433 = [[2404, 2405], [2534, 2543], [43008, 43052]];
  var Syloti_Nagri_default2 = _433;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Syriac.js
  var _434 = [1548, [1563, 1564], 1567, 1600, [1611, 1621], 1648, [1792, 1805], [1807, 1866], [1869, 1871], [2144, 2154], 7672, 7674];
  var Syriac_default2 = _434;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tagalog.js
  var _435 = [[5888, 5909], 5919, [5941, 5942]];
  var Tagalog_default2 = _435;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tagbanwa.js
  var _436 = [[5941, 5942], [5984, 5996], [5998, 6e3], [6002, 6003]];
  var Tagbanwa_default2 = _436;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tai_Le.js
  var _437 = [[4160, 4169], [6480, 6509], [6512, 6516]];
  var Tai_Le_default2 = _437;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tai_Tham.js
  var _438 = [[6688, 6750], [6752, 6780], [6783, 6793], [6800, 6809], [6816, 6829]];
  var Tai_Tham_default2 = _438;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tai_Viet.js
  var _439 = [[43648, 43714], [43739, 43743]];
  var Tai_Viet_default2 = _439;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Takri.js
  var _440 = [[2404, 2405], [43056, 43065], [71296, 71353], [71360, 71369]];
  var Takri_default2 = _440;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tamil.js
  var _441 = [[2385, 2386], [2404, 2405], [2946, 2947], [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], [3006, 3010], [3014, 3016], [3018, 3021], 3024, 3031, [3046, 3066], 7386, 43251, 70401, 70403, [70459, 70460], [73664, 73713], 73727];
  var Tamil_default2 = _441;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tangsa.js
  var _442 = [[92784, 92862], [92864, 92873]];
  var Tangsa_default2 = _442;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tangut.js
  var _443 = [94176, [94208, 100343], [100352, 101119], [101632, 101640]];
  var Tangut_default2 = _443;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Telugu.js
  var _444 = [[2385, 2386], [2404, 2405], [3072, 3084], [3086, 3088], [3090, 3112], [3114, 3129], [3132, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3160, 3162], 3165, [3168, 3171], [3174, 3183], [3191, 3199], 7386, 7410];
  var Telugu_default2 = _444;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Thaana.js
  var _445 = [1548, [1563, 1564], 1567, [1632, 1641], [1920, 1969], 65010, 65021];
  var Thaana_default2 = _445;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Thai.js
  var _446 = [[3585, 3642], [3648, 3675]];
  var Thai_default2 = _446;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tibetan.js
  var _447 = [[3840, 3911], [3913, 3948], [3953, 3991], [3993, 4028], [4030, 4044], [4046, 4052], [4057, 4058]];
  var Tibetan_default2 = _447;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tifinagh.js
  var _448 = [[11568, 11623], [11631, 11632], 11647];
  var Tifinagh_default2 = _448;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Tirhuta.js
  var _449 = [[2385, 2386], [2404, 2405], 7410, [43056, 43065], [70784, 70855], [70864, 70873]];
  var Tirhuta_default2 = _449;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Toto.js
  var _450 = [[123536, 123566]];
  var Toto_default2 = _450;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Ugaritic.js
  var _451 = [[66432, 66461], 66463];
  var Ugaritic_default2 = _451;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Vai.js
  var _452 = [[42240, 42539]];
  var Vai_default2 = _452;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Vithkuqi.js
  var _453 = [[66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004]];
  var Vithkuqi_default2 = _453;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Wancho.js
  var _454 = [[123584, 123641], 123647];
  var Wancho_default2 = _454;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Warang_Citi.js
  var _455 = [[71840, 71922], 71935];
  var Warang_Citi_default2 = _455;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Yezidi.js
  var _456 = [1548, 1563, 1567, [1632, 1641], [69248, 69289], [69291, 69293], [69296, 69297]];
  var Yezidi_default2 = _456;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Yi.js
  var _457 = [[12289, 12290], [12296, 12305], [12308, 12315], 12539, [40960, 42124], [42128, 42182], [65377, 65381]];
  var Yi_default2 = _457;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Script_Extensions/Zanabazar_Square.js
  var _458 = [[72192, 72263]];
  var Zanabazar_Square_default2 = _458;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/index.js
  var Case_Folding_exports = {};
  __export(Case_Folding_exports, {
    C: () => C_default,
    F: () => F_default,
    S: () => S_default,
    T: () => T_default
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/C.js
  var _459 = [];
  var C_default = _459;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/F.js
  var _460 = [];
  var F_default = _460;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/S.js
  var _461 = [];
  var S_default = _461;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Case_Folding/T.js
  var _462 = [];
  var T_default = _462;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/index.js
  var Block_exports = {};
  __export(Block_exports, {
    Adlam: () => Adlam_default3,
    Aegean_Numbers: () => Aegean_Numbers_default,
    Ahom: () => Ahom_default3,
    Alchemical_Symbols: () => Alchemical_Symbols_default,
    Alphabetic_Presentation_Forms: () => Alphabetic_Presentation_Forms_default,
    Anatolian_Hieroglyphs: () => Anatolian_Hieroglyphs_default3,
    Ancient_Greek_Musical_Notation: () => Ancient_Greek_Musical_Notation_default,
    Ancient_Greek_Numbers: () => Ancient_Greek_Numbers_default,
    Ancient_Symbols: () => Ancient_Symbols_default,
    Arabic: () => Arabic_default3,
    Arabic_Extended_A: () => Arabic_Extended_A_default,
    Arabic_Mathematical_Alphabetic_Symbols: () => Arabic_Mathematical_Alphabetic_Symbols_default,
    Arabic_Presentation_Forms_A: () => Arabic_Presentation_Forms_A_default,
    Arabic_Presentation_Forms_B: () => Arabic_Presentation_Forms_B_default,
    Arabic_Supplement: () => Arabic_Supplement_default,
    Armenian: () => Armenian_default3,
    Arrows: () => Arrows_default,
    Avestan: () => Avestan_default3,
    Balinese: () => Balinese_default3,
    Bamum: () => Bamum_default3,
    Bamum_Supplement: () => Bamum_Supplement_default,
    Basic_Latin: () => Basic_Latin_default,
    Bassa_Vah: () => Bassa_Vah_default3,
    Batak: () => Batak_default3,
    Bengali: () => Bengali_default3,
    Bhaiksuki: () => Bhaiksuki_default3,
    Block_Elements: () => Block_Elements_default,
    Bopomofo: () => Bopomofo_default3,
    Bopomofo_Extended: () => Bopomofo_Extended_default,
    Box_Drawing: () => Box_Drawing_default,
    Brahmi: () => Brahmi_default3,
    Braille_Patterns: () => Braille_Patterns_default,
    Buginese: () => Buginese_default3,
    Buhid: () => Buhid_default3,
    Byzantine_Musical_Symbols: () => Byzantine_Musical_Symbols_default,
    CJK_Compatibility: () => CJK_Compatibility_default,
    CJK_Compatibility_Forms: () => CJK_Compatibility_Forms_default,
    CJK_Compatibility_Ideographs: () => CJK_Compatibility_Ideographs_default,
    CJK_Compatibility_Ideographs_Supplement: () => CJK_Compatibility_Ideographs_Supplement_default,
    CJK_Radicals_Supplement: () => CJK_Radicals_Supplement_default,
    CJK_Strokes: () => CJK_Strokes_default,
    CJK_Symbols_And_Punctuation: () => CJK_Symbols_And_Punctuation_default,
    CJK_Unified_Ideographs: () => CJK_Unified_Ideographs_default,
    CJK_Unified_Ideographs_Extension_A: () => CJK_Unified_Ideographs_Extension_A_default,
    CJK_Unified_Ideographs_Extension_B: () => CJK_Unified_Ideographs_Extension_B_default,
    CJK_Unified_Ideographs_Extension_C: () => CJK_Unified_Ideographs_Extension_C_default,
    CJK_Unified_Ideographs_Extension_D: () => CJK_Unified_Ideographs_Extension_D_default,
    CJK_Unified_Ideographs_Extension_E: () => CJK_Unified_Ideographs_Extension_E_default,
    CJK_Unified_Ideographs_Extension_F: () => CJK_Unified_Ideographs_Extension_F_default,
    Carian: () => Carian_default3,
    Caucasian_Albanian: () => Caucasian_Albanian_default3,
    Chakma: () => Chakma_default3,
    Cham: () => Cham_default3,
    Cherokee: () => Cherokee_default3,
    Cherokee_Supplement: () => Cherokee_Supplement_default,
    Chess_Symbols: () => Chess_Symbols_default,
    Combining_Diacritical_Marks: () => Combining_Diacritical_Marks_default,
    Combining_Diacritical_Marks_Extended: () => Combining_Diacritical_Marks_Extended_default,
    Combining_Diacritical_Marks_For_Symbols: () => Combining_Diacritical_Marks_For_Symbols_default,
    Combining_Diacritical_Marks_Supplement: () => Combining_Diacritical_Marks_Supplement_default,
    Combining_Half_Marks: () => Combining_Half_Marks_default,
    Common_Indic_Number_Forms: () => Common_Indic_Number_Forms_default,
    Control_Pictures: () => Control_Pictures_default,
    Coptic: () => Coptic_default3,
    Coptic_Epact_Numbers: () => Coptic_Epact_Numbers_default,
    Counting_Rod_Numerals: () => Counting_Rod_Numerals_default,
    Cuneiform: () => Cuneiform_default3,
    Cuneiform_Numbers_And_Punctuation: () => Cuneiform_Numbers_And_Punctuation_default,
    Currency_Symbols: () => Currency_Symbols_default,
    Cypriot_Syllabary: () => Cypriot_Syllabary_default,
    Cyrillic: () => Cyrillic_default3,
    Cyrillic_Extended_A: () => Cyrillic_Extended_A_default,
    Cyrillic_Extended_B: () => Cyrillic_Extended_B_default,
    Cyrillic_Extended_C: () => Cyrillic_Extended_C_default,
    Cyrillic_Supplement: () => Cyrillic_Supplement_default,
    Deseret: () => Deseret_default3,
    Devanagari: () => Devanagari_default3,
    Devanagari_Extended: () => Devanagari_Extended_default,
    Dingbats: () => Dingbats_default,
    Dogra: () => Dogra_default3,
    Domino_Tiles: () => Domino_Tiles_default,
    Duployan: () => Duployan_default3,
    Early_Dynastic_Cuneiform: () => Early_Dynastic_Cuneiform_default,
    Egyptian_Hieroglyphs: () => Egyptian_Hieroglyphs_default3,
    Elbasan: () => Elbasan_default3,
    Emoticons: () => Emoticons_default,
    Enclosed_Alphanumeric_Supplement: () => Enclosed_Alphanumeric_Supplement_default,
    Enclosed_Alphanumerics: () => Enclosed_Alphanumerics_default,
    Enclosed_CJK_Letters_And_Months: () => Enclosed_CJK_Letters_And_Months_default,
    Enclosed_Ideographic_Supplement: () => Enclosed_Ideographic_Supplement_default,
    Ethiopic: () => Ethiopic_default3,
    Ethiopic_Extended: () => Ethiopic_Extended_default,
    Ethiopic_Extended_A: () => Ethiopic_Extended_A_default,
    Ethiopic_Supplement: () => Ethiopic_Supplement_default,
    General_Punctuation: () => General_Punctuation_default,
    Geometric_Shapes: () => Geometric_Shapes_default,
    Geometric_Shapes_Extended: () => Geometric_Shapes_Extended_default,
    Georgian: () => Georgian_default3,
    Georgian_Extended: () => Georgian_Extended_default,
    Georgian_Supplement: () => Georgian_Supplement_default,
    Glagolitic: () => Glagolitic_default3,
    Glagolitic_Supplement: () => Glagolitic_Supplement_default,
    Gothic: () => Gothic_default3,
    Grantha: () => Grantha_default3,
    Greek_And_Coptic: () => Greek_And_Coptic_default,
    Greek_Extended: () => Greek_Extended_default,
    Gujarati: () => Gujarati_default3,
    Gunjala_Gondi: () => Gunjala_Gondi_default3,
    Gurmukhi: () => Gurmukhi_default3,
    Halfwidth_And_Fullwidth_Forms: () => Halfwidth_And_Fullwidth_Forms_default,
    Hangul_Compatibility_Jamo: () => Hangul_Compatibility_Jamo_default,
    Hangul_Jamo: () => Hangul_Jamo_default,
    Hangul_Jamo_Extended_A: () => Hangul_Jamo_Extended_A_default,
    Hangul_Jamo_Extended_B: () => Hangul_Jamo_Extended_B_default,
    Hangul_Syllables: () => Hangul_Syllables_default,
    Hanifi_Rohingya: () => Hanifi_Rohingya_default3,
    Hanunoo: () => Hanunoo_default3,
    Hatran: () => Hatran_default3,
    Hebrew: () => Hebrew_default3,
    High_Private_Use_Surrogates: () => High_Private_Use_Surrogates_default,
    High_Surrogates: () => High_Surrogates_default,
    Hiragana: () => Hiragana_default3,
    IPA_Extensions: () => IPA_Extensions_default,
    Ideographic_Description_Characters: () => Ideographic_Description_Characters_default,
    Ideographic_Symbols_And_Punctuation: () => Ideographic_Symbols_And_Punctuation_default,
    Imperial_Aramaic: () => Imperial_Aramaic_default3,
    Indic_Siyaq_Numbers: () => Indic_Siyaq_Numbers_default,
    Inscriptional_Pahlavi: () => Inscriptional_Pahlavi_default3,
    Inscriptional_Parthian: () => Inscriptional_Parthian_default3,
    Javanese: () => Javanese_default3,
    Kaithi: () => Kaithi_default3,
    Kana_Extended_A: () => Kana_Extended_A_default,
    Kana_Supplement: () => Kana_Supplement_default,
    Kanbun: () => Kanbun_default,
    Kangxi_Radicals: () => Kangxi_Radicals_default,
    Kannada: () => Kannada_default3,
    Katakana: () => Katakana_default3,
    Katakana_Phonetic_Extensions: () => Katakana_Phonetic_Extensions_default,
    Kayah_Li: () => Kayah_Li_default3,
    Kharoshthi: () => Kharoshthi_default3,
    Khmer: () => Khmer_default3,
    Khmer_Symbols: () => Khmer_Symbols_default,
    Khojki: () => Khojki_default3,
    Khudawadi: () => Khudawadi_default3,
    Lao: () => Lao_default3,
    Latin_1_Supplement: () => Latin_1_Supplement_default,
    Latin_Extended_A: () => Latin_Extended_A_default,
    Latin_Extended_Additional: () => Latin_Extended_Additional_default,
    Latin_Extended_B: () => Latin_Extended_B_default,
    Latin_Extended_C: () => Latin_Extended_C_default,
    Latin_Extended_D: () => Latin_Extended_D_default,
    Latin_Extended_E: () => Latin_Extended_E_default,
    Lepcha: () => Lepcha_default3,
    Letterlike_Symbols: () => Letterlike_Symbols_default,
    Limbu: () => Limbu_default3,
    Linear_A: () => Linear_A_default3,
    Linear_B_Ideograms: () => Linear_B_Ideograms_default,
    Linear_B_Syllabary: () => Linear_B_Syllabary_default,
    Lisu: () => Lisu_default3,
    Low_Surrogates: () => Low_Surrogates_default,
    Lycian: () => Lycian_default3,
    Lydian: () => Lydian_default3,
    Mahajani: () => Mahajani_default3,
    Mahjong_Tiles: () => Mahjong_Tiles_default,
    Makasar: () => Makasar_default3,
    Malayalam: () => Malayalam_default3,
    Mandaic: () => Mandaic_default3,
    Manichaean: () => Manichaean_default3,
    Marchen: () => Marchen_default3,
    Masaram_Gondi: () => Masaram_Gondi_default3,
    Mathematical_Alphanumeric_Symbols: () => Mathematical_Alphanumeric_Symbols_default,
    Mathematical_Operators: () => Mathematical_Operators_default,
    Mayan_Numerals: () => Mayan_Numerals_default,
    Medefaidrin: () => Medefaidrin_default3,
    Meetei_Mayek: () => Meetei_Mayek_default3,
    Meetei_Mayek_Extensions: () => Meetei_Mayek_Extensions_default,
    Mende_Kikakui: () => Mende_Kikakui_default3,
    Meroitic_Cursive: () => Meroitic_Cursive_default3,
    Meroitic_Hieroglyphs: () => Meroitic_Hieroglyphs_default3,
    Miao: () => Miao_default3,
    Miscellaneous_Mathematical_Symbols_A: () => Miscellaneous_Mathematical_Symbols_A_default,
    Miscellaneous_Mathematical_Symbols_B: () => Miscellaneous_Mathematical_Symbols_B_default,
    Miscellaneous_Symbols: () => Miscellaneous_Symbols_default,
    Miscellaneous_Symbols_And_Arrows: () => Miscellaneous_Symbols_And_Arrows_default,
    Miscellaneous_Symbols_And_Pictographs: () => Miscellaneous_Symbols_And_Pictographs_default,
    Miscellaneous_Technical: () => Miscellaneous_Technical_default,
    Modi: () => Modi_default3,
    Modifier_Tone_Letters: () => Modifier_Tone_Letters_default,
    Mongolian: () => Mongolian_default3,
    Mongolian_Supplement: () => Mongolian_Supplement_default,
    Mro: () => Mro_default3,
    Multani: () => Multani_default3,
    Musical_Symbols: () => Musical_Symbols_default,
    Myanmar: () => Myanmar_default3,
    Myanmar_Extended_A: () => Myanmar_Extended_A_default,
    Myanmar_Extended_B: () => Myanmar_Extended_B_default,
    NKo: () => NKo_default,
    Nabataean: () => Nabataean_default3,
    New_Tai_Lue: () => New_Tai_Lue_default3,
    Newa: () => Newa_default3,
    Number_Forms: () => Number_Forms_default,
    Nushu: () => Nushu_default3,
    Ogham: () => Ogham_default3,
    Ol_Chiki: () => Ol_Chiki_default3,
    Old_Hungarian: () => Old_Hungarian_default3,
    Old_Italic: () => Old_Italic_default3,
    Old_North_Arabian: () => Old_North_Arabian_default3,
    Old_Permic: () => Old_Permic_default3,
    Old_Persian: () => Old_Persian_default3,
    Old_Sogdian: () => Old_Sogdian_default3,
    Old_South_Arabian: () => Old_South_Arabian_default3,
    Old_Turkic: () => Old_Turkic_default3,
    Optical_Character_Recognition: () => Optical_Character_Recognition_default,
    Oriya: () => Oriya_default3,
    Ornamental_Dingbats: () => Ornamental_Dingbats_default,
    Osage: () => Osage_default3,
    Osmanya: () => Osmanya_default3,
    Pahawh_Hmong: () => Pahawh_Hmong_default3,
    Palmyrene: () => Palmyrene_default3,
    Pau_Cin_Hau: () => Pau_Cin_Hau_default3,
    Phags_Pa: () => Phags_Pa_default3,
    Phaistos_Disc: () => Phaistos_Disc_default,
    Phoenician: () => Phoenician_default3,
    Phonetic_Extensions: () => Phonetic_Extensions_default,
    Phonetic_Extensions_Supplement: () => Phonetic_Extensions_Supplement_default,
    Playing_Cards: () => Playing_Cards_default,
    Private_Use_Area: () => Private_Use_Area_default,
    Psalter_Pahlavi: () => Psalter_Pahlavi_default3,
    Rejang: () => Rejang_default3,
    Rumi_Numeral_Symbols: () => Rumi_Numeral_Symbols_default,
    Runic: () => Runic_default3,
    Samaritan: () => Samaritan_default3,
    Saurashtra: () => Saurashtra_default3,
    Sharada: () => Sharada_default3,
    Shavian: () => Shavian_default3,
    Shorthand_Format_Controls: () => Shorthand_Format_Controls_default,
    Siddham: () => Siddham_default3,
    Sinhala: () => Sinhala_default3,
    Sinhala_Archaic_Numbers: () => Sinhala_Archaic_Numbers_default,
    Small_Form_Variants: () => Small_Form_Variants_default,
    Sogdian: () => Sogdian_default3,
    Sora_Sompeng: () => Sora_Sompeng_default3,
    Soyombo: () => Soyombo_default3,
    Spacing_Modifier_Letters: () => Spacing_Modifier_Letters_default,
    Specials: () => Specials_default,
    Sundanese: () => Sundanese_default3,
    Sundanese_Supplement: () => Sundanese_Supplement_default,
    Superscripts_And_Subscripts: () => Superscripts_And_Subscripts_default,
    Supplemental_Arrows_A: () => Supplemental_Arrows_A_default,
    Supplemental_Arrows_B: () => Supplemental_Arrows_B_default,
    Supplemental_Arrows_C: () => Supplemental_Arrows_C_default,
    Supplemental_Mathematical_Operators: () => Supplemental_Mathematical_Operators_default,
    Supplemental_Punctuation: () => Supplemental_Punctuation_default,
    Supplemental_Symbols_And_Pictographs: () => Supplemental_Symbols_And_Pictographs_default,
    Supplementary_Private_Use_Area_A: () => Supplementary_Private_Use_Area_A_default,
    Supplementary_Private_Use_Area_B: () => Supplementary_Private_Use_Area_B_default,
    Sutton_SignWriting: () => Sutton_SignWriting_default,
    Syloti_Nagri: () => Syloti_Nagri_default3,
    Syriac: () => Syriac_default3,
    Syriac_Supplement: () => Syriac_Supplement_default,
    Tagalog: () => Tagalog_default3,
    Tagbanwa: () => Tagbanwa_default3,
    Tags: () => Tags_default,
    Tai_Le: () => Tai_Le_default3,
    Tai_Tham: () => Tai_Tham_default3,
    Tai_Viet: () => Tai_Viet_default3,
    Tai_Xuan_Jing_Symbols: () => Tai_Xuan_Jing_Symbols_default,
    Takri: () => Takri_default3,
    Tamil: () => Tamil_default3,
    Tangut: () => Tangut_default3,
    Tangut_Components: () => Tangut_Components_default,
    Telugu: () => Telugu_default3,
    Thaana: () => Thaana_default3,
    Thai: () => Thai_default3,
    Tibetan: () => Tibetan_default3,
    Tifinagh: () => Tifinagh_default3,
    Tirhuta: () => Tirhuta_default3,
    Transport_And_Map_Symbols: () => Transport_And_Map_Symbols_default,
    Ugaritic: () => Ugaritic_default3,
    Unified_Canadian_Aboriginal_Syllabics: () => Unified_Canadian_Aboriginal_Syllabics_default,
    Unified_Canadian_Aboriginal_Syllabics_Extended: () => Unified_Canadian_Aboriginal_Syllabics_Extended_default,
    Vai: () => Vai_default3,
    Variation_Selectors: () => Variation_Selectors_default,
    Variation_Selectors_Supplement: () => Variation_Selectors_Supplement_default,
    Vedic_Extensions: () => Vedic_Extensions_default,
    Vertical_Forms: () => Vertical_Forms_default,
    Warang_Citi: () => Warang_Citi_default3,
    Yi_Radicals: () => Yi_Radicals_default,
    Yi_Syllables: () => Yi_Syllables_default,
    Yijing_Hexagram_Symbols: () => Yijing_Hexagram_Symbols_default,
    Zanabazar_Square: () => Zanabazar_Square_default3,
    undefined: () => undefined_default
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Adlam.js
  var _463 = [[125184, 125279]];
  var Adlam_default3 = _463;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Aegean_Numbers.js
  var _464 = [[65792, 65855]];
  var Aegean_Numbers_default = _464;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ahom.js
  var _465 = [[71424, 71503]];
  var Ahom_default3 = _465;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Alchemical_Symbols.js
  var _466 = [[128768, 128895]];
  var Alchemical_Symbols_default = _466;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Alphabetic_Presentation_Forms.js
  var _467 = [[64256, 64335]];
  var Alphabetic_Presentation_Forms_default = _467;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Anatolian_Hieroglyphs.js
  var _468 = [[82944, 83583]];
  var Anatolian_Hieroglyphs_default3 = _468;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ancient_Greek_Musical_Notation.js
  var _469 = [[119296, 119375]];
  var Ancient_Greek_Musical_Notation_default = _469;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ancient_Greek_Numbers.js
  var _470 = [[65856, 65935]];
  var Ancient_Greek_Numbers_default = _470;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ancient_Symbols.js
  var _471 = [[65936, 65999]];
  var Ancient_Symbols_default = _471;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic.js
  var _472 = [[1536, 1791]];
  var Arabic_default3 = _472;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Extended_A.js
  var _473 = [[2208, 2303]];
  var Arabic_Extended_A_default = _473;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Mathematical_Alphabetic_Symbols.js
  var _474 = [[126464, 126719]];
  var Arabic_Mathematical_Alphabetic_Symbols_default = _474;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Presentation_Forms_A.js
  var _475 = [[64336, 65023]];
  var Arabic_Presentation_Forms_A_default = _475;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Presentation_Forms_B.js
  var _476 = [[65136, 65279]];
  var Arabic_Presentation_Forms_B_default = _476;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arabic_Supplement.js
  var _477 = [[1872, 1919]];
  var Arabic_Supplement_default = _477;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Armenian.js
  var _478 = [[1328, 1423]];
  var Armenian_default3 = _478;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Arrows.js
  var _479 = [[8592, 8703]];
  var Arrows_default = _479;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Avestan.js
  var _480 = [[68352, 68415]];
  var Avestan_default3 = _480;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Balinese.js
  var _481 = [[6912, 7039]];
  var Balinese_default3 = _481;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bamum.js
  var _482 = [[42656, 42751]];
  var Bamum_default3 = _482;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bamum_Supplement.js
  var _483 = [[92160, 92735]];
  var Bamum_Supplement_default = _483;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Basic_Latin.js
  var _484 = [[0, 127]];
  var Basic_Latin_default = _484;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bassa_Vah.js
  var _485 = [[92880, 92927]];
  var Bassa_Vah_default3 = _485;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Batak.js
  var _486 = [[7104, 7167]];
  var Batak_default3 = _486;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bengali.js
  var _487 = [[2432, 2559]];
  var Bengali_default3 = _487;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bhaiksuki.js
  var _488 = [[72704, 72815]];
  var Bhaiksuki_default3 = _488;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Block_Elements.js
  var _489 = [[9600, 9631]];
  var Block_Elements_default = _489;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bopomofo.js
  var _490 = [[12544, 12591]];
  var Bopomofo_default3 = _490;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Bopomofo_Extended.js
  var _491 = [[12704, 12735]];
  var Bopomofo_Extended_default = _491;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Box_Drawing.js
  var _492 = [[9472, 9599]];
  var Box_Drawing_default = _492;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Brahmi.js
  var _493 = [[69632, 69759]];
  var Brahmi_default3 = _493;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Braille_Patterns.js
  var _494 = [[10240, 10495]];
  var Braille_Patterns_default = _494;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Buginese.js
  var _495 = [[6656, 6687]];
  var Buginese_default3 = _495;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Buhid.js
  var _496 = [[5952, 5983]];
  var Buhid_default3 = _496;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Byzantine_Musical_Symbols.js
  var _497 = [[118784, 119039]];
  var Byzantine_Musical_Symbols_default = _497;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Compatibility.js
  var _498 = [[13056, 13311]];
  var CJK_Compatibility_default = _498;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Compatibility_Forms.js
  var _499 = [[65072, 65103]];
  var CJK_Compatibility_Forms_default = _499;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Compatibility_Ideographs.js
  var _500 = [[63744, 64255]];
  var CJK_Compatibility_Ideographs_default = _500;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Compatibility_Ideographs_Supplement.js
  var _501 = [[194560, 195103]];
  var CJK_Compatibility_Ideographs_Supplement_default = _501;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Radicals_Supplement.js
  var _502 = [[11904, 12031]];
  var CJK_Radicals_Supplement_default = _502;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Strokes.js
  var _503 = [[12736, 12783]];
  var CJK_Strokes_default = _503;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Symbols_And_Punctuation.js
  var _504 = [[12288, 12351]];
  var CJK_Symbols_And_Punctuation_default = _504;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs.js
  var _505 = [[19968, 40959]];
  var CJK_Unified_Ideographs_default = _505;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_A.js
  var _506 = [[13312, 19903]];
  var CJK_Unified_Ideographs_Extension_A_default = _506;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_B.js
  var _507 = [[131072, 173791]];
  var CJK_Unified_Ideographs_Extension_B_default = _507;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_C.js
  var _508 = [[173824, 177983]];
  var CJK_Unified_Ideographs_Extension_C_default = _508;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_D.js
  var _509 = [[177984, 178207]];
  var CJK_Unified_Ideographs_Extension_D_default = _509;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_E.js
  var _510 = [[178208, 183983]];
  var CJK_Unified_Ideographs_Extension_E_default = _510;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/CJK_Unified_Ideographs_Extension_F.js
  var _511 = [[183984, 191471]];
  var CJK_Unified_Ideographs_Extension_F_default = _511;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Carian.js
  var _512 = [[66208, 66271]];
  var Carian_default3 = _512;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Caucasian_Albanian.js
  var _513 = [[66864, 66927]];
  var Caucasian_Albanian_default3 = _513;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Chakma.js
  var _514 = [[69888, 69967]];
  var Chakma_default3 = _514;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cham.js
  var _515 = [[43520, 43615]];
  var Cham_default3 = _515;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cherokee.js
  var _516 = [[5024, 5119]];
  var Cherokee_default3 = _516;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cherokee_Supplement.js
  var _517 = [[43888, 43967]];
  var Cherokee_Supplement_default = _517;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Chess_Symbols.js
  var _518 = [[129536, 129647]];
  var Chess_Symbols_default = _518;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Diacritical_Marks.js
  var _519 = [[768, 879]];
  var Combining_Diacritical_Marks_default = _519;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Diacritical_Marks_Extended.js
  var _520 = [[6832, 6911]];
  var Combining_Diacritical_Marks_Extended_default = _520;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Diacritical_Marks_For_Symbols.js
  var _521 = [[8400, 8447]];
  var Combining_Diacritical_Marks_For_Symbols_default = _521;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Diacritical_Marks_Supplement.js
  var _522 = [[7616, 7679]];
  var Combining_Diacritical_Marks_Supplement_default = _522;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Combining_Half_Marks.js
  var _523 = [[65056, 65071]];
  var Combining_Half_Marks_default = _523;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Common_Indic_Number_Forms.js
  var _524 = [[43056, 43071]];
  var Common_Indic_Number_Forms_default = _524;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Control_Pictures.js
  var _525 = [[9216, 9279]];
  var Control_Pictures_default = _525;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Coptic.js
  var _526 = [[11392, 11519]];
  var Coptic_default3 = _526;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Coptic_Epact_Numbers.js
  var _527 = [[66272, 66303]];
  var Coptic_Epact_Numbers_default = _527;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Counting_Rod_Numerals.js
  var _528 = [[119648, 119679]];
  var Counting_Rod_Numerals_default = _528;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cuneiform.js
  var _529 = [[73728, 74751]];
  var Cuneiform_default3 = _529;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cuneiform_Numbers_And_Punctuation.js
  var _530 = [[74752, 74879]];
  var Cuneiform_Numbers_And_Punctuation_default = _530;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Currency_Symbols.js
  var _531 = [[8352, 8399]];
  var Currency_Symbols_default = _531;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cypriot_Syllabary.js
  var _532 = [[67584, 67647]];
  var Cypriot_Syllabary_default = _532;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic.js
  var _533 = [[1024, 1279]];
  var Cyrillic_default3 = _533;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic_Extended_A.js
  var _534 = [[11744, 11775]];
  var Cyrillic_Extended_A_default = _534;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic_Extended_B.js
  var _535 = [[42560, 42655]];
  var Cyrillic_Extended_B_default = _535;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic_Extended_C.js
  var _536 = [[7296, 7311]];
  var Cyrillic_Extended_C_default = _536;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Cyrillic_Supplement.js
  var _537 = [[1280, 1327]];
  var Cyrillic_Supplement_default = _537;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Deseret.js
  var _538 = [[66560, 66639]];
  var Deseret_default3 = _538;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Devanagari.js
  var _539 = [[2304, 2431]];
  var Devanagari_default3 = _539;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Devanagari_Extended.js
  var _540 = [[43232, 43263]];
  var Devanagari_Extended_default = _540;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Dingbats.js
  var _541 = [[9984, 10175]];
  var Dingbats_default = _541;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Dogra.js
  var _542 = [[71680, 71759]];
  var Dogra_default3 = _542;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Domino_Tiles.js
  var _543 = [[127024, 127135]];
  var Domino_Tiles_default = _543;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Duployan.js
  var _544 = [[113664, 113823]];
  var Duployan_default3 = _544;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Early_Dynastic_Cuneiform.js
  var _545 = [[74880, 75087]];
  var Early_Dynastic_Cuneiform_default = _545;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Egyptian_Hieroglyphs.js
  var _546 = [[77824, 78895]];
  var Egyptian_Hieroglyphs_default3 = _546;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Elbasan.js
  var _547 = [[66816, 66863]];
  var Elbasan_default3 = _547;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Emoticons.js
  var _548 = [[128512, 128591]];
  var Emoticons_default = _548;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Enclosed_Alphanumeric_Supplement.js
  var _549 = [[127232, 127487]];
  var Enclosed_Alphanumeric_Supplement_default = _549;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Enclosed_Alphanumerics.js
  var _550 = [[9312, 9471]];
  var Enclosed_Alphanumerics_default = _550;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Enclosed_CJK_Letters_And_Months.js
  var _551 = [[12800, 13055]];
  var Enclosed_CJK_Letters_And_Months_default = _551;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Enclosed_Ideographic_Supplement.js
  var _552 = [[127488, 127743]];
  var Enclosed_Ideographic_Supplement_default = _552;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ethiopic.js
  var _553 = [[4608, 4991]];
  var Ethiopic_default3 = _553;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ethiopic_Extended.js
  var _554 = [[11648, 11743]];
  var Ethiopic_Extended_default = _554;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ethiopic_Extended_A.js
  var _555 = [[43776, 43823]];
  var Ethiopic_Extended_A_default = _555;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ethiopic_Supplement.js
  var _556 = [[4992, 5023]];
  var Ethiopic_Supplement_default = _556;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/General_Punctuation.js
  var _557 = [[8192, 8303]];
  var General_Punctuation_default = _557;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Geometric_Shapes.js
  var _558 = [[9632, 9727]];
  var Geometric_Shapes_default = _558;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Geometric_Shapes_Extended.js
  var _559 = [[128896, 129023]];
  var Geometric_Shapes_Extended_default = _559;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Georgian.js
  var _560 = [[4256, 4351]];
  var Georgian_default3 = _560;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Georgian_Extended.js
  var _561 = [[7312, 7359]];
  var Georgian_Extended_default = _561;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Georgian_Supplement.js
  var _562 = [[11520, 11567]];
  var Georgian_Supplement_default = _562;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Glagolitic.js
  var _563 = [[11264, 11359]];
  var Glagolitic_default3 = _563;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Glagolitic_Supplement.js
  var _564 = [[122880, 122927]];
  var Glagolitic_Supplement_default = _564;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Gothic.js
  var _565 = [[66352, 66383]];
  var Gothic_default3 = _565;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Grantha.js
  var _566 = [[70400, 70527]];
  var Grantha_default3 = _566;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Greek_And_Coptic.js
  var _567 = [[880, 1023]];
  var Greek_And_Coptic_default = _567;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Greek_Extended.js
  var _568 = [[7936, 8191]];
  var Greek_Extended_default = _568;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Gujarati.js
  var _569 = [[2688, 2815]];
  var Gujarati_default3 = _569;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Gunjala_Gondi.js
  var _570 = [[73056, 73135]];
  var Gunjala_Gondi_default3 = _570;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Gurmukhi.js
  var _571 = [[2560, 2687]];
  var Gurmukhi_default3 = _571;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Halfwidth_And_Fullwidth_Forms.js
  var _572 = [[65280, 65519]];
  var Halfwidth_And_Fullwidth_Forms_default = _572;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Compatibility_Jamo.js
  var _573 = [[12592, 12687]];
  var Hangul_Compatibility_Jamo_default = _573;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Jamo.js
  var _574 = [[4352, 4607]];
  var Hangul_Jamo_default = _574;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Jamo_Extended_A.js
  var _575 = [[43360, 43391]];
  var Hangul_Jamo_Extended_A_default = _575;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Jamo_Extended_B.js
  var _576 = [[55216, 55295]];
  var Hangul_Jamo_Extended_B_default = _576;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hangul_Syllables.js
  var _577 = [[44032, 55215]];
  var Hangul_Syllables_default = _577;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hanifi_Rohingya.js
  var _578 = [[68864, 68927]];
  var Hanifi_Rohingya_default3 = _578;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hanunoo.js
  var _579 = [[5920, 5951]];
  var Hanunoo_default3 = _579;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hatran.js
  var _580 = [[67808, 67839]];
  var Hatran_default3 = _580;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hebrew.js
  var _581 = [[1424, 1535]];
  var Hebrew_default3 = _581;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/High_Private_Use_Surrogates.js
  var _582 = [[56192, 56319]];
  var High_Private_Use_Surrogates_default = _582;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/High_Surrogates.js
  var _583 = [[55296, 56191]];
  var High_Surrogates_default = _583;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Hiragana.js
  var _584 = [[12352, 12447]];
  var Hiragana_default3 = _584;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/IPA_Extensions.js
  var _585 = [[592, 687]];
  var IPA_Extensions_default = _585;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ideographic_Description_Characters.js
  var _586 = [[12272, 12287]];
  var Ideographic_Description_Characters_default = _586;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ideographic_Symbols_And_Punctuation.js
  var _587 = [[94176, 94207]];
  var Ideographic_Symbols_And_Punctuation_default = _587;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Imperial_Aramaic.js
  var _588 = [[67648, 67679]];
  var Imperial_Aramaic_default3 = _588;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Indic_Siyaq_Numbers.js
  var _589 = [[126064, 126143]];
  var Indic_Siyaq_Numbers_default = _589;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Inscriptional_Pahlavi.js
  var _590 = [[68448, 68479]];
  var Inscriptional_Pahlavi_default3 = _590;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Inscriptional_Parthian.js
  var _591 = [[68416, 68447]];
  var Inscriptional_Parthian_default3 = _591;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Javanese.js
  var _592 = [[43392, 43487]];
  var Javanese_default3 = _592;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kaithi.js
  var _593 = [[69760, 69839]];
  var Kaithi_default3 = _593;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kana_Extended_A.js
  var _594 = [[110848, 110895]];
  var Kana_Extended_A_default = _594;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kana_Supplement.js
  var _595 = [[110592, 110847]];
  var Kana_Supplement_default = _595;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kanbun.js
  var _596 = [[12688, 12703]];
  var Kanbun_default = _596;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kangxi_Radicals.js
  var _597 = [[12032, 12255]];
  var Kangxi_Radicals_default = _597;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kannada.js
  var _598 = [[3200, 3327]];
  var Kannada_default3 = _598;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Katakana.js
  var _599 = [[12448, 12543]];
  var Katakana_default3 = _599;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Katakana_Phonetic_Extensions.js
  var _600 = [[12784, 12799]];
  var Katakana_Phonetic_Extensions_default = _600;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kayah_Li.js
  var _601 = [[43264, 43311]];
  var Kayah_Li_default3 = _601;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Kharoshthi.js
  var _602 = [[68096, 68191]];
  var Kharoshthi_default3 = _602;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Khmer.js
  var _603 = [[6016, 6143]];
  var Khmer_default3 = _603;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Khmer_Symbols.js
  var _604 = [[6624, 6655]];
  var Khmer_Symbols_default = _604;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Khojki.js
  var _605 = [[70144, 70223]];
  var Khojki_default3 = _605;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Khudawadi.js
  var _606 = [[70320, 70399]];
  var Khudawadi_default3 = _606;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lao.js
  var _607 = [[3712, 3839]];
  var Lao_default3 = _607;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_1_Supplement.js
  var _608 = [[128, 255]];
  var Latin_1_Supplement_default = _608;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_A.js
  var _609 = [[256, 383]];
  var Latin_Extended_A_default = _609;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_Additional.js
  var _610 = [[7680, 7935]];
  var Latin_Extended_Additional_default = _610;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_B.js
  var _611 = [[384, 591]];
  var Latin_Extended_B_default = _611;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_C.js
  var _612 = [[11360, 11391]];
  var Latin_Extended_C_default = _612;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_D.js
  var _613 = [[42784, 43007]];
  var Latin_Extended_D_default = _613;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Latin_Extended_E.js
  var _614 = [[43824, 43887]];
  var Latin_Extended_E_default = _614;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lepcha.js
  var _615 = [[7168, 7247]];
  var Lepcha_default3 = _615;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Letterlike_Symbols.js
  var _616 = [[8448, 8527]];
  var Letterlike_Symbols_default = _616;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Limbu.js
  var _617 = [[6400, 6479]];
  var Limbu_default3 = _617;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Linear_A.js
  var _618 = [[67072, 67455]];
  var Linear_A_default3 = _618;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Linear_B_Ideograms.js
  var _619 = [[65664, 65791]];
  var Linear_B_Ideograms_default = _619;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Linear_B_Syllabary.js
  var _620 = [[65536, 65663]];
  var Linear_B_Syllabary_default = _620;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lisu.js
  var _621 = [[42192, 42239]];
  var Lisu_default3 = _621;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Low_Surrogates.js
  var _622 = [[56320, 57343]];
  var Low_Surrogates_default = _622;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lycian.js
  var _623 = [[66176, 66207]];
  var Lycian_default3 = _623;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Lydian.js
  var _624 = [[67872, 67903]];
  var Lydian_default3 = _624;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mahajani.js
  var _625 = [[69968, 70015]];
  var Mahajani_default3 = _625;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mahjong_Tiles.js
  var _626 = [[126976, 127023]];
  var Mahjong_Tiles_default = _626;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Makasar.js
  var _627 = [[73440, 73471]];
  var Makasar_default3 = _627;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Malayalam.js
  var _628 = [[3328, 3455]];
  var Malayalam_default3 = _628;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mandaic.js
  var _629 = [[2112, 2143]];
  var Mandaic_default3 = _629;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Manichaean.js
  var _630 = [[68288, 68351]];
  var Manichaean_default3 = _630;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Marchen.js
  var _631 = [[72816, 72895]];
  var Marchen_default3 = _631;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Masaram_Gondi.js
  var _632 = [[72960, 73055]];
  var Masaram_Gondi_default3 = _632;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mathematical_Alphanumeric_Symbols.js
  var _633 = [[119808, 120831]];
  var Mathematical_Alphanumeric_Symbols_default = _633;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mathematical_Operators.js
  var _634 = [[8704, 8959]];
  var Mathematical_Operators_default = _634;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mayan_Numerals.js
  var _635 = [[119520, 119551]];
  var Mayan_Numerals_default = _635;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Medefaidrin.js
  var _636 = [[93760, 93855]];
  var Medefaidrin_default3 = _636;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Meetei_Mayek.js
  var _637 = [[43968, 44031]];
  var Meetei_Mayek_default3 = _637;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Meetei_Mayek_Extensions.js
  var _638 = [[43744, 43775]];
  var Meetei_Mayek_Extensions_default = _638;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mende_Kikakui.js
  var _639 = [[124928, 125151]];
  var Mende_Kikakui_default3 = _639;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Meroitic_Cursive.js
  var _640 = [[68e3, 68095]];
  var Meroitic_Cursive_default3 = _640;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Meroitic_Hieroglyphs.js
  var _641 = [[67968, 67999]];
  var Meroitic_Hieroglyphs_default3 = _641;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miao.js
  var _642 = [[93952, 94111]];
  var Miao_default3 = _642;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Mathematical_Symbols_A.js
  var _643 = [[10176, 10223]];
  var Miscellaneous_Mathematical_Symbols_A_default = _643;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Mathematical_Symbols_B.js
  var _644 = [[10624, 10751]];
  var Miscellaneous_Mathematical_Symbols_B_default = _644;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Symbols.js
  var _645 = [[9728, 9983]];
  var Miscellaneous_Symbols_default = _645;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Symbols_And_Arrows.js
  var _646 = [[11008, 11263]];
  var Miscellaneous_Symbols_And_Arrows_default = _646;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Symbols_And_Pictographs.js
  var _647 = [[127744, 128511]];
  var Miscellaneous_Symbols_And_Pictographs_default = _647;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Miscellaneous_Technical.js
  var _648 = [[8960, 9215]];
  var Miscellaneous_Technical_default = _648;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Modi.js
  var _649 = [[71168, 71263]];
  var Modi_default3 = _649;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Modifier_Tone_Letters.js
  var _650 = [[42752, 42783]];
  var Modifier_Tone_Letters_default = _650;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mongolian.js
  var _651 = [[6144, 6319]];
  var Mongolian_default3 = _651;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mongolian_Supplement.js
  var _652 = [[71264, 71295]];
  var Mongolian_Supplement_default = _652;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Mro.js
  var _653 = [[92736, 92783]];
  var Mro_default3 = _653;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Multani.js
  var _654 = [[70272, 70319]];
  var Multani_default3 = _654;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Musical_Symbols.js
  var _655 = [[119040, 119295]];
  var Musical_Symbols_default = _655;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Myanmar.js
  var _656 = [[4096, 4255]];
  var Myanmar_default3 = _656;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Myanmar_Extended_A.js
  var _657 = [[43616, 43647]];
  var Myanmar_Extended_A_default = _657;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Myanmar_Extended_B.js
  var _658 = [[43488, 43519]];
  var Myanmar_Extended_B_default = _658;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/NKo.js
  var _659 = [[1984, 2047]];
  var NKo_default = _659;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Nabataean.js
  var _660 = [[67712, 67759]];
  var Nabataean_default3 = _660;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/New_Tai_Lue.js
  var _661 = [[6528, 6623]];
  var New_Tai_Lue_default3 = _661;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Newa.js
  var _662 = [[70656, 70783]];
  var Newa_default3 = _662;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Number_Forms.js
  var _663 = [[8528, 8591]];
  var Number_Forms_default = _663;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Nushu.js
  var _664 = [[110960, 111359]];
  var Nushu_default3 = _664;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ogham.js
  var _665 = [[5760, 5791]];
  var Ogham_default3 = _665;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ol_Chiki.js
  var _666 = [[7248, 7295]];
  var Ol_Chiki_default3 = _666;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Hungarian.js
  var _667 = [[68736, 68863]];
  var Old_Hungarian_default3 = _667;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Italic.js
  var _668 = [[66304, 66351]];
  var Old_Italic_default3 = _668;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_North_Arabian.js
  var _669 = [[68224, 68255]];
  var Old_North_Arabian_default3 = _669;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Permic.js
  var _670 = [[66384, 66431]];
  var Old_Permic_default3 = _670;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Persian.js
  var _671 = [[66464, 66527]];
  var Old_Persian_default3 = _671;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Sogdian.js
  var _672 = [[69376, 69423]];
  var Old_Sogdian_default3 = _672;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_South_Arabian.js
  var _673 = [[68192, 68223]];
  var Old_South_Arabian_default3 = _673;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Old_Turkic.js
  var _674 = [[68608, 68687]];
  var Old_Turkic_default3 = _674;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Optical_Character_Recognition.js
  var _675 = [[9280, 9311]];
  var Optical_Character_Recognition_default = _675;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Oriya.js
  var _676 = [[2816, 2943]];
  var Oriya_default3 = _676;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ornamental_Dingbats.js
  var _677 = [[128592, 128639]];
  var Ornamental_Dingbats_default = _677;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Osage.js
  var _678 = [[66736, 66815]];
  var Osage_default3 = _678;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Osmanya.js
  var _679 = [[66688, 66735]];
  var Osmanya_default3 = _679;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Pahawh_Hmong.js
  var _680 = [[92928, 93071]];
  var Pahawh_Hmong_default3 = _680;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Palmyrene.js
  var _681 = [[67680, 67711]];
  var Palmyrene_default3 = _681;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Pau_Cin_Hau.js
  var _682 = [[72384, 72447]];
  var Pau_Cin_Hau_default3 = _682;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phags_Pa.js
  var _683 = [[43072, 43135]];
  var Phags_Pa_default3 = _683;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phaistos_Disc.js
  var _684 = [[66e3, 66047]];
  var Phaistos_Disc_default = _684;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phoenician.js
  var _685 = [[67840, 67871]];
  var Phoenician_default3 = _685;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phonetic_Extensions.js
  var _686 = [[7424, 7551]];
  var Phonetic_Extensions_default = _686;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Phonetic_Extensions_Supplement.js
  var _687 = [[7552, 7615]];
  var Phonetic_Extensions_Supplement_default = _687;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Playing_Cards.js
  var _688 = [[127136, 127231]];
  var Playing_Cards_default = _688;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Private_Use_Area.js
  var _689 = [[57344, 63743]];
  var Private_Use_Area_default = _689;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Psalter_Pahlavi.js
  var _690 = [[68480, 68527]];
  var Psalter_Pahlavi_default3 = _690;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Rejang.js
  var _691 = [[43312, 43359]];
  var Rejang_default3 = _691;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Rumi_Numeral_Symbols.js
  var _692 = [[69216, 69247]];
  var Rumi_Numeral_Symbols_default = _692;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Runic.js
  var _693 = [[5792, 5887]];
  var Runic_default3 = _693;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Samaritan.js
  var _694 = [[2048, 2111]];
  var Samaritan_default3 = _694;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Saurashtra.js
  var _695 = [[43136, 43231]];
  var Saurashtra_default3 = _695;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sharada.js
  var _696 = [[70016, 70111]];
  var Sharada_default3 = _696;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Shavian.js
  var _697 = [[66640, 66687]];
  var Shavian_default3 = _697;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Shorthand_Format_Controls.js
  var _698 = [[113824, 113839]];
  var Shorthand_Format_Controls_default = _698;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Siddham.js
  var _699 = [[71040, 71167]];
  var Siddham_default3 = _699;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sinhala.js
  var _700 = [[3456, 3583]];
  var Sinhala_default3 = _700;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sinhala_Archaic_Numbers.js
  var _701 = [[70112, 70143]];
  var Sinhala_Archaic_Numbers_default = _701;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Small_Form_Variants.js
  var _702 = [[65104, 65135]];
  var Small_Form_Variants_default = _702;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sogdian.js
  var _703 = [[69424, 69487]];
  var Sogdian_default3 = _703;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sora_Sompeng.js
  var _704 = [[69840, 69887]];
  var Sora_Sompeng_default3 = _704;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Soyombo.js
  var _705 = [[72272, 72367]];
  var Soyombo_default3 = _705;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Spacing_Modifier_Letters.js
  var _706 = [[688, 767]];
  var Spacing_Modifier_Letters_default = _706;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Specials.js
  var _707 = [[65520, 65535]];
  var Specials_default = _707;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sundanese.js
  var _708 = [[7040, 7103]];
  var Sundanese_default3 = _708;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sundanese_Supplement.js
  var _709 = [[7360, 7375]];
  var Sundanese_Supplement_default = _709;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Superscripts_And_Subscripts.js
  var _710 = [[8304, 8351]];
  var Superscripts_And_Subscripts_default = _710;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Arrows_A.js
  var _711 = [[10224, 10239]];
  var Supplemental_Arrows_A_default = _711;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Arrows_B.js
  var _712 = [[10496, 10623]];
  var Supplemental_Arrows_B_default = _712;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Arrows_C.js
  var _713 = [[129024, 129279]];
  var Supplemental_Arrows_C_default = _713;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Mathematical_Operators.js
  var _714 = [[10752, 11007]];
  var Supplemental_Mathematical_Operators_default = _714;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Punctuation.js
  var _715 = [[11776, 11903]];
  var Supplemental_Punctuation_default = _715;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplemental_Symbols_And_Pictographs.js
  var _716 = [[129280, 129535]];
  var Supplemental_Symbols_And_Pictographs_default = _716;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplementary_Private_Use_Area_A.js
  var _717 = [[983040, 1048575]];
  var Supplementary_Private_Use_Area_A_default = _717;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Supplementary_Private_Use_Area_B.js
  var _718 = [[1048576, 1114111]];
  var Supplementary_Private_Use_Area_B_default = _718;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Sutton_SignWriting.js
  var _719 = [[120832, 121519]];
  var Sutton_SignWriting_default = _719;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Syloti_Nagri.js
  var _720 = [[43008, 43055]];
  var Syloti_Nagri_default3 = _720;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Syriac.js
  var _721 = [[1792, 1871]];
  var Syriac_default3 = _721;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Syriac_Supplement.js
  var _722 = [[2144, 2159]];
  var Syriac_Supplement_default = _722;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tagalog.js
  var _723 = [[5888, 5919]];
  var Tagalog_default3 = _723;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tagbanwa.js
  var _724 = [[5984, 6015]];
  var Tagbanwa_default3 = _724;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tags.js
  var _725 = [[917504, 917631]];
  var Tags_default = _725;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tai_Le.js
  var _726 = [[6480, 6527]];
  var Tai_Le_default3 = _726;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tai_Tham.js
  var _727 = [[6688, 6831]];
  var Tai_Tham_default3 = _727;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tai_Viet.js
  var _728 = [[43648, 43743]];
  var Tai_Viet_default3 = _728;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tai_Xuan_Jing_Symbols.js
  var _729 = [[119552, 119647]];
  var Tai_Xuan_Jing_Symbols_default = _729;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Takri.js
  var _730 = [[71296, 71375]];
  var Takri_default3 = _730;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tamil.js
  var _731 = [[2944, 3071]];
  var Tamil_default3 = _731;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tangut.js
  var _732 = [[94208, 100351]];
  var Tangut_default3 = _732;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tangut_Components.js
  var _733 = [[100352, 101119]];
  var Tangut_Components_default = _733;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Telugu.js
  var _734 = [[3072, 3199]];
  var Telugu_default3 = _734;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Thaana.js
  var _735 = [[1920, 1983]];
  var Thaana_default3 = _735;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Thai.js
  var _736 = [[3584, 3711]];
  var Thai_default3 = _736;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tibetan.js
  var _737 = [[3840, 4095]];
  var Tibetan_default3 = _737;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tifinagh.js
  var _738 = [[11568, 11647]];
  var Tifinagh_default3 = _738;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Tirhuta.js
  var _739 = [[70784, 70879]];
  var Tirhuta_default3 = _739;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Transport_And_Map_Symbols.js
  var _740 = [[128640, 128767]];
  var Transport_And_Map_Symbols_default = _740;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Ugaritic.js
  var _741 = [[66432, 66463]];
  var Ugaritic_default3 = _741;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Unified_Canadian_Aboriginal_Syllabics.js
  var _742 = [[5120, 5759]];
  var Unified_Canadian_Aboriginal_Syllabics_default = _742;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Unified_Canadian_Aboriginal_Syllabics_Extended.js
  var _743 = [[6320, 6399]];
  var Unified_Canadian_Aboriginal_Syllabics_Extended_default = _743;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Vai.js
  var _744 = [[42240, 42559]];
  var Vai_default3 = _744;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Variation_Selectors.js
  var _745 = [[65024, 65039]];
  var Variation_Selectors_default = _745;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Variation_Selectors_Supplement.js
  var _746 = [[917760, 917999]];
  var Variation_Selectors_Supplement_default = _746;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Vedic_Extensions.js
  var _747 = [[7376, 7423]];
  var Vedic_Extensions_default = _747;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Vertical_Forms.js
  var _748 = [[65040, 65055]];
  var Vertical_Forms_default = _748;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Warang_Citi.js
  var _749 = [[71840, 71935]];
  var Warang_Citi_default3 = _749;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Yi_Radicals.js
  var _750 = [[42128, 42191]];
  var Yi_Radicals_default = _750;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Yi_Syllables.js
  var _751 = [[40960, 42127]];
  var Yi_Syllables_default = _751;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Yijing_Hexagram_Symbols.js
  var _752 = [[19904, 19967]];
  var Yijing_Hexagram_Symbols_default = _752;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/Zanabazar_Square.js
  var _753 = [[72192, 72271]];
  var Zanabazar_Square_default3 = _753;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Block/undefined.js
  var _754 = [[2160, 2207], [66928, 67007], [67456, 67519], [69248, 69375], [69488, 69631], [71936, 72031], [72096, 72191], [72368, 72383], [72448, 72543], [73472, 73567], [73648, 73727], [77712, 77823], [78896, 78943], [92784, 92879], [101120, 101759], [110576, 110591], [110896, 110959], [118528, 118735], [119488, 119519], [122624, 122879], [122928, 123023], [123136, 123215], [123536, 123647], [124112, 124159], [124896, 124927], [126208, 126287], [129648, 130047], [196608, 205743]];
  var undefined_default = _754;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Mirroring_Glyph/index.js
  var Bidi_Mirroring_Glyph_exports = {};

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Paired_Bracket_Type/index.js
  var Bidi_Paired_Bracket_Type_exports = {};
  __export(Bidi_Paired_Bracket_Type_exports, {
    Close: () => Close_default,
    None: () => None_default,
    Open: () => Open_default
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Paired_Bracket_Type/Close.js
  var _755 = [41, 93, 125, 3899, 3901, 5788, 8262, 8318, 8334, 8969, 8971, 9002, 10089, 10091, 10093, 10095, 10097, 10099, 10101, 10182, 10215, 10217, 10219, 10221, 10223, 10628, 10630, 10632, 10634, 10636, 10638, 10640, 10642, 10644, 10646, 10648, 10713, 10715, 10749, 11811, 11813, 11815, 11817, 11862, 11864, 11866, 11868, 12297, 12299, 12301, 12303, 12305, 12309, 12311, 12313, 12315, 65114, 65116, 65118, 65289, 65341, 65373, 65376, 65379];
  var Close_default = _755;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Paired_Bracket_Type/None.js
  var _756 = [[0, 39], [42, 90], 92, [94, 122], 124, [126, 3897], [3902, 5786], [5789, 8260], [8263, 8316], [8319, 8332], [8335, 8967], [8972, 9e3], [9003, 10087], [10102, 10180], [10183, 10213], [10224, 10626], [10649, 10711], [10716, 10747], [10750, 11809], [11818, 11860], [11869, 12295], [12306, 12307], [12316, 65112], [65119, 65287], [65290, 65338], 65340, [65342, 65370], 65372, 65374, 65377, [65380, 1114111]];
  var None_default = _756;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Bidi_Paired_Bracket_Type/Open.js
  var _757 = [40, 91, 123, 3898, 3900, 5787, 8261, 8317, 8333, 8968, 8970, 9001, 10088, 10090, 10092, 10094, 10096, 10098, 10100, 10181, 10214, 10216, 10218, 10220, 10222, 10627, 10629, 10631, 10633, 10635, 10637, 10639, 10641, 10643, 10645, 10647, 10712, 10714, 10748, 11810, 11812, 11814, 11816, 11861, 11863, 11865, 11867, 12296, 12298, 12300, 12302, 12304, 12308, 12310, 12312, 12314, 65113, 65115, 65117, 65288, 65339, 65371, 65375, 65378];
  var Open_default = _757;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/index.js
  var Line_Break_exports = {};
  __export(Line_Break_exports, {
    Alphabetic: () => Alphabetic_default2,
    Ambiguous: () => Ambiguous_default,
    Break_After: () => Break_After_default,
    Break_Before: () => Break_Before_default,
    Break_Both: () => Break_Both_default,
    Break_Symbols: () => Break_Symbols_default,
    Carriage_Return: () => Carriage_Return_default,
    Close_Parenthesis: () => Close_Parenthesis_default,
    Close_Punctuation: () => Close_Punctuation_default2,
    Combining_Mark: () => Combining_Mark_default,
    Complex_Context: () => Complex_Context_default,
    Conditional_Japanese_Starter: () => Conditional_Japanese_Starter_default,
    Contingent_Break: () => Contingent_Break_default,
    E_Base: () => E_Base_default,
    E_Modifier: () => E_Modifier_default,
    Exclamation: () => Exclamation_default,
    Glue: () => Glue_default,
    H2: () => H2_default,
    H3: () => H3_default,
    Hebrew_Letter: () => Hebrew_Letter_default,
    Hyphen: () => Hyphen_default2,
    Ideographic: () => Ideographic_default2,
    Infix_Numeric: () => Infix_Numeric_default,
    Inseparable: () => Inseparable_default,
    JL: () => JL_default,
    JT: () => JT_default,
    JV: () => JV_default,
    Line_Feed: () => Line_Feed_default,
    Mandatory_Break: () => Mandatory_Break_default,
    Next_Line: () => Next_Line_default,
    Nonstarter: () => Nonstarter_default,
    Numeric: () => Numeric_default,
    Open_Punctuation: () => Open_Punctuation_default2,
    Postfix_Numeric: () => Postfix_Numeric_default,
    Prefix_Numeric: () => Prefix_Numeric_default,
    Quotation: () => Quotation_default,
    Regional_Indicator: () => Regional_Indicator_default2,
    Space: () => Space_default,
    Surrogate: () => Surrogate_default2,
    Unknown: () => Unknown_default,
    Word_Joiner: () => Word_Joiner_default,
    ZWJ: () => ZWJ_default,
    ZWSpace: () => ZWSpace_default
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Alphabetic.js
  var _758 = [35, 38, 42, [60, 62], [64, 90], [94, 122], 126, 166, 169, 172, [174, 175], 181, [192, 214], [216, 246], [248, 710], [718, 719], [721, 727], 732, 734, [736, 767], [880, 887], [890, 893], 895, [900, 906], 908, [910, 929], [931, 1154], [1162, 1327], [1329, 1366], [1369, 1416], [1421, 1422], 1472, 1475, [1523, 1524], [1536, 1544], [1550, 1551], [1568, 1610], [1645, 1647], [1649, 1747], 1749, [1757, 1758], [1765, 1766], 1769, [1774, 1775], [1786, 1805], [1807, 1808], [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2039], 2042, [2048, 2069], 2074, 2084, 2088, [2096, 2110], [2112, 2136], 2142, [2144, 2154], [2160, 2190], [2192, 2193], [2208, 2249], 2274, [2308, 2361], 2365, 2384, [2392, 2401], [2416, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], [2548, 2552], 2554, [2556, 2557], [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], 2678, [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2800, 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], [2928, 2935], 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3056, 3064], 3066, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], [3192, 3200], [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, [3406, 3407], [3412, 3414], [3416, 3425], [3440, 3448], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3572, 3663, 3840, 3845, 3859, [3861, 3863], [3866, 3871], [3882, 3891], 3894, 3896, [3904, 3911], [3913, 3948], [3976, 3980], [4032, 4037], [4039, 4044], [4046, 4047], [4052, 4056], [4172, 4175], [4256, 4293], 4295, 4301, [4304, 4351], [4608, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], 4960, [4962, 4988], [4992, 5017], [5024, 5109], [5112, 5117], [5121, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], 6105, [6128, 6137], [6144, 6145], 6151, 6154, [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], 6464, [6624, 6678], [6686, 6687], [6917, 6963], [6981, 6988], 7004, [7009, 7018], [7028, 7036], [7043, 7072], [7086, 7087], [7098, 7141], [7164, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7367], 7379, [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8132], [8134, 8147], [8150, 8155], [8157, 8175], [8178, 8180], [8182, 8188], 8190, 8215, [8226, 8227], 8248, [8254, 8259], [8266, 8277], 8284, [8289, 8292], [8304, 8305], [8309, 8316], 8320, [8325, 8332], [8336, 8348], [8448, 8450], 8452, [8454, 8456], [8458, 8466], [8468, 8469], [8471, 8480], [8483, 8490], [8492, 8531], [8534, 8538], [8540, 8541], 8543, [8556, 8559], [8570, 8584], [8586, 8587], [8602, 8657], 8659, [8661, 8703], 8705, [8708, 8710], [8713, 8714], [8716, 8718], 8720, 8724, [8726, 8729], [8731, 8732], [8737, 8738], 8740, 8742, 8749, [8751, 8755], [8760, 8763], [8766, 8775], [8777, 8779], [8781, 8785], [8787, 8799], [8802, 8803], [8808, 8809], [8812, 8813], [8816, 8833], [8836, 8837], [8840, 8852], [8854, 8856], [8858, 8868], [8870, 8894], [8896, 8942], [8944, 8967], [8972, 8977], [8979, 8985], [8988, 9e3], [9003, 9199], [9204, 9254], [9280, 9290], 9471, [9548, 9551], [9589, 9599], [9616, 9617], [9622, 9631], 9634, [9642, 9649], [9652, 9653], [9656, 9659], [9662, 9663], [9666, 9669], [9673, 9674], [9676, 9677], [9682, 9697], [9702, 9710], [9712, 9727], 9732, [9735, 9736], [9738, 9741], [9744, 9747], 9753, [9760, 9784], [9788, 9791], 9793, [9795, 9823], 9826, 9830, 9835, 9838, [9840, 9854], [9856, 9885], [9888, 9916], 9934, 9954, [9956, 9959], [9989, 9991], [9998, 10070], [10072, 10074], 10081, [10085, 10087], [10132, 10180], [10183, 10213], [10224, 10626], [10649, 10711], [10716, 10747], [10750, 11092], [11098, 11123], [11126, 11157], [11159, 11502], [11506, 11507], 11517, [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 11798, [11802, 11803], [11806, 11807], 11823, 11826, [11829, 11833], 11839, 11851, 11853, [11856, 11858], [19904, 19967], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], 42611, [42622, 42653], [42656, 42735], 42738, [42752, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43048, 43051], [43056, 43063], 43065, [43072, 43123], [43138, 43187], [43250, 43259], [43261, 43262], [43274, 43301], [43312, 43334], 43359, [43396, 43442], [43457, 43462], [43466, 43469], 43471, [43486, 43487], [43520, 43560], [43584, 43586], [43588, 43595], 43612, [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43883], [43888, 44002], [64256, 64262], [64275, 64279], 64297, [64336, 64450], [64467, 64829], [64832, 64911], [64914, 64967], 64975, [65008, 65019], [65021, 65023], [65136, 65140], [65142, 65276], [65512, 65518], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65799, 65843], [65847, 65934], [65936, 65948], 65952, [66e3, 66044], [66176, 66204], [66208, 66256], [66273, 66299], [66304, 66339], [66349, 66378], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66927, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67672, 67742], [67751, 67759], [67808, 67826], [67828, 67829], [67835, 67867], [67872, 67897], 67903, [67968, 68023], [68028, 68047], [68050, 68096], [68112, 68115], [68117, 68119], [68121, 68149], [68160, 68168], 68184, [68192, 68255], [68288, 68324], [68331, 68335], [68352, 68405], [68416, 68437], [68440, 68466], [68472, 68497], [68505, 68508], [68521, 68527], [68608, 68680], [68736, 68786], [68800, 68850], [68858, 68899], [69216, 69246], [69248, 69289], [69296, 69297], [69376, 69415], [69424, 69445], [69457, 69465], [69488, 69505], [69510, 69513], [69552, 69579], [69600, 69622], [69635, 69687], [69705, 69709], [69714, 69733], [69745, 69746], 69749, [69763, 69807], [69819, 69821], 69837, [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70004, 70006, [70019, 70066], [70081, 70084], 70087, 70093, 70106, 70108, [70113, 70132], [70144, 70161], [70163, 70187], 70202, 70205, [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], 70735, 70749, [70751, 70753], [70784, 70831], [70852, 70855], [71040, 71086], [71110, 71112], [71128, 71131], [71168, 71215], [71235, 71236], [71296, 71338], [71352, 71353], [71680, 71723], 71739, [71840, 71903], [71914, 71922], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72256, 72262, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72794, 72812], [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], [73463, 73464], 73474, [73476, 73488], [73490, 73523], 73648, [73664, 73692], [73697, 73713], [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77810], [77824, 78423], [78430, 78465], [78467, 78469], [78474, 78712], [78716, 78895], [78913, 78918], [82944, 83405], [83408, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92986, 92995], 92997, [93019, 93025], [93027, 93047], [93053, 93071], [93760, 93846], [93849, 93850], [93952, 94026], 94032, [94099, 94111], [101120, 101589], [110576, 110579], [110581, 110587], [110589, 110590], [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], 113820, [118608, 118723], [118784, 119029], [119040, 119078], [119081, 119140], [119146, 119148], [119171, 119172], [119180, 119209], [119214, 119274], [119296, 119361], 119365, [119488, 119507], [119520, 119539], [119552, 119638], [119648, 119672], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120779], [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121478], 121483, [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], [123214, 123215], [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125127, 125135], [125184, 125251], 125259, [126065, 126123], [126125, 126127], [126129, 126132], [126209, 126269], [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [126704, 126705], [127278, 127279], [127338, 127340], [127900, 127901], [127925, 127926], 127932, 128160, 128162, 128164, 128175, [128177, 128178], [128256, 128262], [128279, 128292], [128306, 128329], [128468, 128475], [128500, 128505], [128592, 128629], [128636, 128639], [128768, 128883], [128896, 128980], [129024, 129035], [129040, 129095], [129104, 129113], [129120, 129159], [129168, 129197], [129280, 129291], [129536, 129619], [129792, 129938], [129940, 129994]];
  var Alphabetic_default2 = _758;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Ambiguous.js
  var _759 = [[167, 168], 170, [178, 179], [182, 186], [188, 190], 215, 247, 711, [713, 715], 717, 720, [728, 731], 733, [8213, 8214], [8224, 8225], 8251, 8308, 8319, [8321, 8324], 8453, 8467, [8481, 8482], 8491, [8532, 8533], 8539, 8542, [8544, 8555], [8560, 8569], 8585, [8592, 8601], 8658, 8660, 8704, [8706, 8707], [8711, 8712], 8715, 8719, 8721, 8725, 8730, [8733, 8736], 8739, 8741, [8743, 8748], 8750, [8756, 8759], [8764, 8765], 8776, 8780, 8786, [8800, 8801], [8804, 8807], [8810, 8811], [8814, 8815], [8834, 8835], [8838, 8839], 8853, 8857, 8869, 8895, 8978, [9312, 9470], [9472, 9547], [9552, 9588], [9600, 9615], [9618, 9621], [9632, 9633], [9635, 9641], [9650, 9651], [9654, 9655], [9660, 9661], [9664, 9665], [9670, 9672], 9675, [9678, 9681], [9698, 9701], 9711, [9733, 9734], 9737, [9742, 9743], [9750, 9751], 9792, 9794, [9824, 9825], [9827, 9829], 9831, [9833, 9834], [9836, 9837], 9839, [9886, 9887], [9929, 9932], 9938, [9941, 9943], [9946, 9947], [9949, 9950], 9955, [9960, 9961], [9963, 9968], 9974, [9979, 9980], 10071, [10102, 10131], [11093, 11097], [12872, 12879], 65533, [127232, 127244], [127248, 127277], [127280, 127337], [127344, 127404]];
  var Ambiguous_default = _759;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Break_After.js
  var _760 = [9, 124, 173, 1418, 1470, [2404, 2405], [3674, 3675], 3851, 3892, 3967, 3973, [4030, 4031], 4050, [4170, 4171], 4961, 5120, 5760, [5867, 5869], [5941, 5942], [6100, 6101], 6104, 6106, [6148, 6149], [7002, 7003], [7005, 7008], [7037, 7038], [7227, 7231], [7294, 7295], [8192, 8198], [8200, 8202], 8208, [8210, 8211], 8231, 8278, [8280, 8283], [8285, 8287], [11514, 11516], 11519, 11632, [11790, 11797], 11799, 11801, [11818, 11821], [11824, 11825], [11827, 11828], [11836, 11838], [11840, 11841], [11843, 11850], 11852, [11854, 11855], 11869, 12288, [42238, 42239], 42509, 42511, [42739, 42743], [43214, 43215], [43310, 43311], [43463, 43465], [43613, 43615], [43760, 43761], 44011, [65792, 65794], 66463, 66512, 67671, 67871, [68176, 68183], [68336, 68341], [68409, 68415], 69293, [69703, 69704], [69822, 69825], [69952, 69955], [70085, 70086], 70088, [70109, 70111], [70200, 70201], [70203, 70204], 70313, [70731, 70734], [70746, 70747], [71106, 71107], [71113, 71127], [71233, 71234], [71484, 71486], [72004, 72006], [72257, 72260], [72346, 72348], [72353, 72354], [72769, 72773], [73539, 73540], 73727, [74864, 74868], [92782, 92783], 92917, [92983, 92985], 92996, [93847, 93848], 113823, [121479, 121482]];
  var Break_After_default = _760;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Break_Before.js
  var _761 = [180, 712, 716, 735, 3191, 3204, [3841, 3844], [3846, 3847], [3849, 3850], [4048, 4049], 4051, 6150, 8189, [43124, 43125], 43260, 70005, 70107, 71105, [71264, 71276], 72162, 72255, 72261, [72350, 72352], [72448, 72457], 72816];
  var Break_Before_default = _761;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Break_Both.js
  var _762 = [8212, [11834, 11835]];
  var Break_Both_default = _762;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Break_Symbols.js
  var _763 = [47];
  var Break_Symbols_default = _763;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Carriage_Return.js
  var _764 = [13];
  var Carriage_Return_default = _764;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Close_Parenthesis.js
  var _765 = [41, 93];
  var Close_Parenthesis_default = _765;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Close_Punctuation.js
  var _766 = [125, 3899, 3901, 5788, 8262, 8318, 8334, 8969, 8971, 9002, 10089, 10091, 10093, 10095, 10097, 10099, 10101, 10182, 10215, 10217, 10219, 10221, 10223, 10628, 10630, 10632, 10634, 10636, 10638, 10640, 10642, 10644, 10646, 10648, 10713, 10715, 10749, 11811, 11813, 11815, 11817, 11862, 11864, 11866, 11868, [12289, 12290], 12297, 12299, 12301, 12303, 12305, 12309, 12311, 12313, 12315, [12318, 12319], 64830, [65041, 65042], 65048, 65078, 65080, 65082, 65084, 65086, 65088, 65090, 65092, 65096, 65104, 65106, 65114, 65116, 65118, 65289, 65292, 65294, 65341, 65373, [65376, 65377], [65379, 65380], [78427, 78429], 78466, 78471, 78473, [78714, 78715], 78904, 78909, 78911, 83407];
  var Close_Punctuation_default2 = _766;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Combining_Mark.js
  var _767 = [[0, 8], [14, 31], [127, 132], [134, 159], [768, 846], [848, 859], [867, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], 1564, [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2307], [2362, 2364], [2366, 2383], [2385, 2391], [2402, 2403], [2433, 2435], 2492, [2494, 2500], [2503, 2504], [2507, 2509], 2519, [2530, 2531], 2558, [2561, 2563], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2691], 2748, [2750, 2757], [2759, 2761], [2763, 2765], [2786, 2787], [2810, 2815], [2817, 2819], 2876, [2878, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2914, 2915], 2946, [3006, 3010], [3014, 3016], [3018, 3021], 3031, [3072, 3076], 3132, [3134, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], [3201, 3203], 3260, [3262, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3298, 3299], 3315, [3328, 3331], [3387, 3388], [3390, 3396], [3398, 3400], [3402, 3405], 3415, [3426, 3427], [3457, 3459], 3530, [3535, 3540], 3542, [3544, 3551], [3570, 3571], [3864, 3865], 3893, 3895, 3897, [3902, 3903], [3953, 3966], [3968, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4957, 4959], [5906, 5909], [5938, 5940], [5970, 5971], [6002, 6003], [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6443], [6448, 6459], [6679, 6683], 6783, [6832, 6862], [6912, 6916], [6964, 6980], [7019, 7027], [7040, 7042], [7073, 7085], [7142, 7155], [7204, 7223], [7376, 7378], [7380, 7400], 7405, 7412, [7415, 7417], [7616, 7628], [7630, 7675], [7677, 7679], 8204, [8206, 8207], [8234, 8238], [8294, 8303], [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12335], 12341, [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43043, 43047], 43052, [43136, 43137], [43188, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43347], [43392, 43395], [43443, 43456], [43561, 43574], 43587, [43596, 43597], [43755, 43759], [43765, 43766], [44003, 44010], [44012, 44013], 64286, [65024, 65039], [65056, 65071], [65529, 65531], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], [69632, 69634], [69688, 69702], 69744, [69747, 69748], [69759, 69762], [69808, 69818], 69826, [69888, 69890], [69927, 69940], [69957, 69958], 70003, [70016, 70018], [70067, 70080], [70089, 70092], [70094, 70095], [70188, 70199], 70206, 70209, [70367, 70378], [70400, 70403], [70459, 70460], [70462, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70502, 70508], [70512, 70516], [70709, 70726], 70750, [70832, 70851], [71087, 71093], [71096, 71104], [71132, 71133], [71216, 71232], [71339, 71351], [71724, 71738], [71984, 71989], [71991, 71992], [71995, 71998], 72e3, [72002, 72003], [72145, 72151], [72154, 72160], 72164, [72193, 72202], [72243, 72249], [72251, 72254], 72263, [72273, 72283], [72330, 72345], [72751, 72758], [72760, 72767], [72850, 72871], [72873, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73098, 73102], [73104, 73105], [73107, 73111], [73459, 73462], [73472, 73473], 73475, [73524, 73530], [73534, 73538], 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94033, 94087], [94095, 94098], [94192, 94193], [113821, 113822], [113824, 113827], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], 917505, [917536, 917631], [917760, 917999]];
  var Combining_Mark_default = _767;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Complex_Context.js
  var _768 = [[3585, 3642], [3648, 3662], [3713, 3714], 3716, [3718, 3722], [3724, 3747], 3749, [3751, 3773], [3776, 3780], 3782, [3784, 3790], [3804, 3807], [4096, 4159], [4176, 4239], [4250, 4255], [6016, 6099], 6103, [6108, 6109], [6480, 6509], [6512, 6516], [6528, 6571], [6576, 6601], 6618, [6622, 6623], [6688, 6750], [6752, 6780], [6816, 6829], [43488, 43503], [43514, 43518], [43616, 43714], [43739, 43743], [71424, 71450], [71453, 71467], [71482, 71483], [71487, 71494]];
  var Complex_Context_default = _768;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Conditional_Japanese_Starter.js
  var _769 = [12353, 12355, 12357, 12359, 12361, 12387, 12419, 12421, 12423, 12430, [12437, 12438], 12449, 12451, 12453, 12455, 12457, 12483, 12515, 12517, 12519, 12526, [12533, 12534], 12540, [12784, 12799], [65383, 65392], 110898, [110928, 110930], 110933, [110948, 110951]];
  var Conditional_Japanese_Starter_default = _769;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Contingent_Break.js
  var _770 = [65532];
  var Contingent_Break_default = _770;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/E_Base.js
  var _771 = [9757, 9977, [9994, 9997], 127877, [127938, 127940], 127943, [127946, 127948], [128066, 128067], [128070, 128080], [128102, 128120], 128124, [128129, 128131], [128133, 128135], 128143, 128145, 128170, [128372, 128373], 128378, 128400, [128405, 128406], [128581, 128583], [128587, 128591], 128675, [128692, 128694], 128704, 128716, 129292, 129295, [129304, 129311], 129318, [129328, 129337], [129340, 129342], 129399, [129461, 129462], [129464, 129465], 129467, [129485, 129487], [129489, 129501], [129731, 129733], [129776, 129784]];
  var E_Base_default = _771;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/E_Modifier.js
  var _772 = [[127995, 127999]];
  var E_Modifier_default = _772;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Exclamation.js
  var _773 = [33, 63, 1478, 1563, [1565, 1567], 1748, 2041, [3853, 3857], 3860, [6146, 6147], [6152, 6153], [6468, 6469], [10082, 10083], 11513, 11518, 11822, [11859, 11860], 42510, [43126, 43127], [65045, 65046], [65110, 65111], 65281, 65311, [71108, 71109], 72817];
  var Exclamation_default = _773;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Glue.js
  var _774 = [160, 847, [860, 866], 3848, 3852, 3858, [4057, 4058], 6158, 7629, 7676, 8199, 8209, 8239, [78896, 78902], [78905, 78907], 94180];
  var Glue_default = _774;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/H2.js
  var _775 = [44032, 44060, 44088, 44116, 44144, 44172, 44200, 44228, 44256, 44284, 44312, 44340, 44368, 44396, 44424, 44452, 44480, 44508, 44536, 44564, 44592, 44620, 44648, 44676, 44704, 44732, 44760, 44788, 44816, 44844, 44872, 44900, 44928, 44956, 44984, 45012, 45040, 45068, 45096, 45124, 45152, 45180, 45208, 45236, 45264, 45292, 45320, 45348, 45376, 45404, 45432, 45460, 45488, 45516, 45544, 45572, 45600, 45628, 45656, 45684, 45712, 45740, 45768, 45796, 45824, 45852, 45880, 45908, 45936, 45964, 45992, 46020, 46048, 46076, 46104, 46132, 46160, 46188, 46216, 46244, 46272, 46300, 46328, 46356, 46384, 46412, 46440, 46468, 46496, 46524, 46552, 46580, 46608, 46636, 46664, 46692, 46720, 46748, 46776, 46804, 46832, 46860, 46888, 46916, 46944, 46972, 47e3, 47028, 47056, 47084, 47112, 47140, 47168, 47196, 47224, 47252, 47280, 47308, 47336, 47364, 47392, 47420, 47448, 47476, 47504, 47532, 47560, 47588, 47616, 47644, 47672, 47700, 47728, 47756, 47784, 47812, 47840, 47868, 47896, 47924, 47952, 47980, 48008, 48036, 48064, 48092, 48120, 48148, 48176, 48204, 48232, 48260, 48288, 48316, 48344, 48372, 48400, 48428, 48456, 48484, 48512, 48540, 48568, 48596, 48624, 48652, 48680, 48708, 48736, 48764, 48792, 48820, 48848, 48876, 48904, 48932, 48960, 48988, 49016, 49044, 49072, 49100, 49128, 49156, 49184, 49212, 49240, 49268, 49296, 49324, 49352, 49380, 49408, 49436, 49464, 49492, 49520, 49548, 49576, 49604, 49632, 49660, 49688, 49716, 49744, 49772, 49800, 49828, 49856, 49884, 49912, 49940, 49968, 49996, 50024, 50052, 50080, 50108, 50136, 50164, 50192, 50220, 50248, 50276, 50304, 50332, 50360, 50388, 50416, 50444, 50472, 50500, 50528, 50556, 50584, 50612, 50640, 50668, 50696, 50724, 50752, 50780, 50808, 50836, 50864, 50892, 50920, 50948, 50976, 51004, 51032, 51060, 51088, 51116, 51144, 51172, 51200, 51228, 51256, 51284, 51312, 51340, 51368, 51396, 51424, 51452, 51480, 51508, 51536, 51564, 51592, 51620, 51648, 51676, 51704, 51732, 51760, 51788, 51816, 51844, 51872, 51900, 51928, 51956, 51984, 52012, 52040, 52068, 52096, 52124, 52152, 52180, 52208, 52236, 52264, 52292, 52320, 52348, 52376, 52404, 52432, 52460, 52488, 52516, 52544, 52572, 52600, 52628, 52656, 52684, 52712, 52740, 52768, 52796, 52824, 52852, 52880, 52908, 52936, 52964, 52992, 53020, 53048, 53076, 53104, 53132, 53160, 53188, 53216, 53244, 53272, 53300, 53328, 53356, 53384, 53412, 53440, 53468, 53496, 53524, 53552, 53580, 53608, 53636, 53664, 53692, 53720, 53748, 53776, 53804, 53832, 53860, 53888, 53916, 53944, 53972, 54e3, 54028, 54056, 54084, 54112, 54140, 54168, 54196, 54224, 54252, 54280, 54308, 54336, 54364, 54392, 54420, 54448, 54476, 54504, 54532, 54560, 54588, 54616, 54644, 54672, 54700, 54728, 54756, 54784, 54812, 54840, 54868, 54896, 54924, 54952, 54980, 55008, 55036, 55064, 55092, 55120, 55148, 55176];
  var H2_default = _775;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/H3.js
  var _776 = [[44033, 44059], [44061, 44087], [44089, 44115], [44117, 44143], [44145, 44171], [44173, 44199], [44201, 44227], [44229, 44255], [44257, 44283], [44285, 44311], [44313, 44339], [44341, 44367], [44369, 44395], [44397, 44423], [44425, 44451], [44453, 44479], [44481, 44507], [44509, 44535], [44537, 44563], [44565, 44591], [44593, 44619], [44621, 44647], [44649, 44675], [44677, 44703], [44705, 44731], [44733, 44759], [44761, 44787], [44789, 44815], [44817, 44843], [44845, 44871], [44873, 44899], [44901, 44927], [44929, 44955], [44957, 44983], [44985, 45011], [45013, 45039], [45041, 45067], [45069, 45095], [45097, 45123], [45125, 45151], [45153, 45179], [45181, 45207], [45209, 45235], [45237, 45263], [45265, 45291], [45293, 45319], [45321, 45347], [45349, 45375], [45377, 45403], [45405, 45431], [45433, 45459], [45461, 45487], [45489, 45515], [45517, 45543], [45545, 45571], [45573, 45599], [45601, 45627], [45629, 45655], [45657, 45683], [45685, 45711], [45713, 45739], [45741, 45767], [45769, 45795], [45797, 45823], [45825, 45851], [45853, 45879], [45881, 45907], [45909, 45935], [45937, 45963], [45965, 45991], [45993, 46019], [46021, 46047], [46049, 46075], [46077, 46103], [46105, 46131], [46133, 46159], [46161, 46187], [46189, 46215], [46217, 46243], [46245, 46271], [46273, 46299], [46301, 46327], [46329, 46355], [46357, 46383], [46385, 46411], [46413, 46439], [46441, 46467], [46469, 46495], [46497, 46523], [46525, 46551], [46553, 46579], [46581, 46607], [46609, 46635], [46637, 46663], [46665, 46691], [46693, 46719], [46721, 46747], [46749, 46775], [46777, 46803], [46805, 46831], [46833, 46859], [46861, 46887], [46889, 46915], [46917, 46943], [46945, 46971], [46973, 46999], [47001, 47027], [47029, 47055], [47057, 47083], [47085, 47111], [47113, 47139], [47141, 47167], [47169, 47195], [47197, 47223], [47225, 47251], [47253, 47279], [47281, 47307], [47309, 47335], [47337, 47363], [47365, 47391], [47393, 47419], [47421, 47447], [47449, 47475], [47477, 47503], [47505, 47531], [47533, 47559], [47561, 47587], [47589, 47615], [47617, 47643], [47645, 47671], [47673, 47699], [47701, 47727], [47729, 47755], [47757, 47783], [47785, 47811], [47813, 47839], [47841, 47867], [47869, 47895], [47897, 47923], [47925, 47951], [47953, 47979], [47981, 48007], [48009, 48035], [48037, 48063], [48065, 48091], [48093, 48119], [48121, 48147], [48149, 48175], [48177, 48203], [48205, 48231], [48233, 48259], [48261, 48287], [48289, 48315], [48317, 48343], [48345, 48371], [48373, 48399], [48401, 48427], [48429, 48455], [48457, 48483], [48485, 48511], [48513, 48539], [48541, 48567], [48569, 48595], [48597, 48623], [48625, 48651], [48653, 48679], [48681, 48707], [48709, 48735], [48737, 48763], [48765, 48791], [48793, 48819], [48821, 48847], [48849, 48875], [48877, 48903], [48905, 48931], [48933, 48959], [48961, 48987], [48989, 49015], [49017, 49043], [49045, 49071], [49073, 49099], [49101, 49127], [49129, 49155], [49157, 49183], [49185, 49211], [49213, 49239], [49241, 49267], [49269, 49295], [49297, 49323], [49325, 49351], [49353, 49379], [49381, 49407], [49409, 49435], [49437, 49463], [49465, 49491], [49493, 49519], [49521, 49547], [49549, 49575], [49577, 49603], [49605, 49631], [49633, 49659], [49661, 49687], [49689, 49715], [49717, 49743], [49745, 49771], [49773, 49799], [49801, 49827], [49829, 49855], [49857, 49883], [49885, 49911], [49913, 49939], [49941, 49967], [49969, 49995], [49997, 50023], [50025, 50051], [50053, 50079], [50081, 50107], [50109, 50135], [50137, 50163], [50165, 50191], [50193, 50219], [50221, 50247], [50249, 50275], [50277, 50303], [50305, 50331], [50333, 50359], [50361, 50387], [50389, 50415], [50417, 50443], [50445, 50471], [50473, 50499], [50501, 50527], [50529, 50555], [50557, 50583], [50585, 50611], [50613, 50639], [50641, 50667], [50669, 50695], [50697, 50723], [50725, 50751], [50753, 50779], [50781, 50807], [50809, 50835], [50837, 50863], [50865, 50891], [50893, 50919], [50921, 50947], [50949, 50975], [50977, 51003], [51005, 51031], [51033, 51059], [51061, 51087], [51089, 51115], [51117, 51143], [51145, 51171], [51173, 51199], [51201, 51227], [51229, 51255], [51257, 51283], [51285, 51311], [51313, 51339], [51341, 51367], [51369, 51395], [51397, 51423], [51425, 51451], [51453, 51479], [51481, 51507], [51509, 51535], [51537, 51563], [51565, 51591], [51593, 51619], [51621, 51647], [51649, 51675], [51677, 51703], [51705, 51731], [51733, 51759], [51761, 51787], [51789, 51815], [51817, 51843], [51845, 51871], [51873, 51899], [51901, 51927], [51929, 51955], [51957, 51983], [51985, 52011], [52013, 52039], [52041, 52067], [52069, 52095], [52097, 52123], [52125, 52151], [52153, 52179], [52181, 52207], [52209, 52235], [52237, 52263], [52265, 52291], [52293, 52319], [52321, 52347], [52349, 52375], [52377, 52403], [52405, 52431], [52433, 52459], [52461, 52487], [52489, 52515], [52517, 52543], [52545, 52571], [52573, 52599], [52601, 52627], [52629, 52655], [52657, 52683], [52685, 52711], [52713, 52739], [52741, 52767], [52769, 52795], [52797, 52823], [52825, 52851], [52853, 52879], [52881, 52907], [52909, 52935], [52937, 52963], [52965, 52991], [52993, 53019], [53021, 53047], [53049, 53075], [53077, 53103], [53105, 53131], [53133, 53159], [53161, 53187], [53189, 53215], [53217, 53243], [53245, 53271], [53273, 53299], [53301, 53327], [53329, 53355], [53357, 53383], [53385, 53411], [53413, 53439], [53441, 53467], [53469, 53495], [53497, 53523], [53525, 53551], [53553, 53579], [53581, 53607], [53609, 53635], [53637, 53663], [53665, 53691], [53693, 53719], [53721, 53747], [53749, 53775], [53777, 53803], [53805, 53831], [53833, 53859], [53861, 53887], [53889, 53915], [53917, 53943], [53945, 53971], [53973, 53999], [54001, 54027], [54029, 54055], [54057, 54083], [54085, 54111], [54113, 54139], [54141, 54167], [54169, 54195], [54197, 54223], [54225, 54251], [54253, 54279], [54281, 54307], [54309, 54335], [54337, 54363], [54365, 54391], [54393, 54419], [54421, 54447], [54449, 54475], [54477, 54503], [54505, 54531], [54533, 54559], [54561, 54587], [54589, 54615], [54617, 54643], [54645, 54671], [54673, 54699], [54701, 54727], [54729, 54755], [54757, 54783], [54785, 54811], [54813, 54839], [54841, 54867], [54869, 54895], [54897, 54923], [54925, 54951], [54953, 54979], [54981, 55007], [55009, 55035], [55037, 55063], [55065, 55091], [55093, 55119], [55121, 55147], [55149, 55175], [55177, 55203]];
  var H3_default = _776;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Hebrew_Letter.js
  var _777 = [[1488, 1514], [1519, 1522], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335]];
  var Hebrew_Letter_default = _777;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Hyphen.js
  var _778 = [45];
  var Hyphen_default2 = _778;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Ideographic.js
  var _779 = [[8986, 8987], [9200, 9203], [9728, 9731], [9748, 9749], 9752, [9754, 9756], [9758, 9759], [9785, 9787], 9832, 9855, [9917, 9928], 9933, [9935, 9937], [9939, 9940], [9944, 9945], 9948, [9951, 9953], 9962, [9969, 9973], [9975, 9976], 9978, [9981, 9988], [9992, 9993], 10084, [11904, 11929], [11931, 12019], [12032, 12245], [12272, 12283], [12291, 12292], [12294, 12295], [12306, 12307], [12320, 12329], [12336, 12340], [12342, 12346], [12349, 12351], 12354, 12356, 12358, 12360, [12362, 12386], [12388, 12418], 12420, 12422, [12424, 12429], [12431, 12436], 12447, 12450, 12452, 12454, 12456, [12458, 12482], [12484, 12514], 12516, 12518, [12520, 12525], [12527, 12532], [12535, 12538], 12543, [12549, 12591], [12593, 12686], [12688, 12771], [12800, 12830], [12832, 12871], [12880, 19903], [19968, 40980], [40982, 42124], [42128, 42182], [63744, 64255], [65072, 65076], [65093, 65094], [65097, 65103], 65105, 65112, [65119, 65126], 65128, 65131, [65282, 65283], [65286, 65287], [65290, 65291], 65293, [65295, 65305], [65308, 65310], [65312, 65338], 65340, [65342, 65370], 65372, 65374, 65382, [65393, 65437], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65506, 65508], [73541, 73551], [94208, 100343], [100352, 101119], [101632, 101640], [110592, 110882], [110960, 111355], [126976, 127231], [127245, 127247], [127341, 127343], [127405, 127461], [127488, 127876], [127878, 127899], [127902, 127924], [127927, 127931], [127933, 127937], [127941, 127942], [127944, 127945], [127949, 127994], [128e3, 128065], [128068, 128069], [128081, 128101], [128121, 128123], [128125, 128128], 128132, [128136, 128142], 128144, [128146, 128159], 128161, 128163, [128165, 128169], [128171, 128174], 128176, [128179, 128255], [128263, 128278], [128293, 128305], [128330, 128371], [128374, 128377], [128379, 128399], [128401, 128404], [128407, 128467], [128476, 128499], [128506, 128580], [128584, 128586], [128640, 128674], [128676, 128691], [128695, 128703], [128705, 128715], [128717, 128767], [128884, 128895], [128981, 129023], [129036, 129039], [129096, 129103], [129114, 129119], [129160, 129167], [129198, 129279], [129293, 129294], [129296, 129303], [129312, 129317], [129319, 129327], [129338, 129339], [129343, 129398], [129400, 129460], 129463, 129466, [129468, 129484], 129488, [129502, 129535], [129620, 129730], [129734, 129775], [129785, 129791], [130048, 131069], [131072, 196605], [196608, 262141]];
  var Ideographic_default2 = _779;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Infix_Numeric.js
  var _780 = [44, 46, [58, 59], 894, 1417, [1548, 1549], 2040, 8260, 65040, [65043, 65044]];
  var Infix_Numeric_default = _780;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Inseparable.js
  var _781 = [[8228, 8230], 8943, 65049, 68342];
  var Inseparable_default = _781;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/JL.js
  var _782 = [[4352, 4447], [43360, 43388]];
  var JL_default = _782;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/JT.js
  var _783 = [[4520, 4607], [55243, 55291]];
  var JT_default = _783;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/JV.js
  var _784 = [[4448, 4519], [55216, 55238]];
  var JV_default = _784;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Line_Feed.js
  var _785 = [10];
  var Line_Feed_default = _785;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Mandatory_Break.js
  var _786 = [[11, 12], [8232, 8233]];
  var Mandatory_Break_default = _786;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Next_Line.js
  var _787 = [133];
  var Next_Line_default = _787;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Nonstarter.js
  var _788 = [6102, [8252, 8253], [8263, 8265], 12293, 12316, [12347, 12348], [12443, 12446], 12448, 12539, [12541, 12542], 40981, [65108, 65109], [65306, 65307], 65381, [65438, 65439], [94176, 94179], [128633, 128635]];
  var Nonstarter_default = _788;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Numeric.js
  var _789 = [[48, 57], [1632, 1641], [1643, 1644], [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [66720, 66729], [68912, 68921], [69734, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71472, 71481], [71904, 71913], [72016, 72025], [72784, 72793], [73040, 73049], [73120, 73129], [73552, 73561], [92768, 92777], [92864, 92873], [93008, 93017], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [125264, 125273], [130032, 130041]];
  var Numeric_default = _789;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Open_Punctuation.js
  var _790 = [40, 91, 123, 161, 191, 3898, 3900, 5787, 8218, 8222, 8261, 8317, 8333, 8968, 8970, 9001, 10088, 10090, 10092, 10094, 10096, 10098, 10100, 10181, 10214, 10216, 10218, 10220, 10222, 10627, 10629, 10631, 10633, 10635, 10637, 10639, 10641, 10643, 10645, 10647, 10712, 10714, 10748, 11800, 11810, 11812, 11814, 11816, 11842, 11861, 11863, 11865, 11867, 12296, 12298, 12300, 12302, 12304, 12308, 12310, 12312, 12314, 12317, 64831, 65047, 65077, 65079, 65081, 65083, 65085, 65087, 65089, 65091, 65095, 65113, 65115, 65117, 65288, 65339, 65371, 65375, 65378, [78424, 78426], 78470, 78472, 78713, 78903, 78908, 78910, 83406, [125278, 125279]];
  var Open_Punctuation_default2 = _790;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Postfix_Numeric.js
  var _791 = [37, 162, 176, [1545, 1547], 1642, [2546, 2547], 2553, 3449, [8240, 8247], 8279, 8359, 8374, 8379, 8382, 8384, 8451, 8457, 43064, 65020, 65130, 65285, 65504, [73693, 73696], 126124, 126128];
  var Postfix_Numeric_default = _791;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Prefix_Numeric.js
  var _792 = [36, 43, 92, [163, 165], 177, 1423, [2046, 2047], 2555, 2801, 3065, 3647, 6107, [8352, 8358], [8360, 8373], [8375, 8378], [8380, 8381], 8383, [8385, 8399], 8470, [8722, 8723], 65129, 65284, 65505, [65509, 65510], 123647];
  var Prefix_Numeric_default = _792;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Quotation.js
  var _793 = [34, 39, 171, 187, [8216, 8217], [8219, 8221], 8223, [8249, 8250], [10075, 10080], [11776, 11789], [11804, 11805], [11808, 11809], [128630, 128632]];
  var Quotation_default = _793;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Regional_Indicator.js
  var _794 = [[127462, 127487]];
  var Regional_Indicator_default2 = _794;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Space.js
  var _795 = [32];
  var Space_default = _795;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Surrogate.js
  var _796 = [[55296, 57343]];
  var Surrogate_default2 = _796;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Unknown.js
  var _797 = [[888, 889], [896, 899], 907, 909, 930, 1328, [1367, 1368], [1419, 1420], 1424, [1480, 1487], [1515, 1518], [1525, 1535], 1806, [1867, 1868], [1970, 1983], [2043, 2044], [2094, 2095], 2111, [2140, 2141], 2143, [2155, 2159], 2191, [2194, 2199], 2436, [2445, 2446], [2449, 2450], 2473, 2481, [2483, 2485], [2490, 2491], [2501, 2502], [2505, 2506], [2511, 2518], [2520, 2523], 2526, [2532, 2533], [2559, 2560], 2564, [2571, 2574], [2577, 2578], 2601, 2609, 2612, 2615, [2618, 2619], 2621, [2627, 2630], [2633, 2634], [2638, 2640], [2642, 2648], 2653, [2655, 2661], [2679, 2688], 2692, 2702, 2706, 2729, 2737, 2740, [2746, 2747], 2758, 2762, [2766, 2767], [2769, 2783], [2788, 2789], [2802, 2808], 2816, 2820, [2829, 2830], [2833, 2834], 2857, 2865, 2868, [2874, 2875], [2885, 2886], [2889, 2890], [2894, 2900], [2904, 2907], 2910, [2916, 2917], [2936, 2945], 2948, [2955, 2957], 2961, [2966, 2968], 2971, 2973, [2976, 2978], [2981, 2983], [2987, 2989], [3002, 3005], [3011, 3013], 3017, [3022, 3023], [3025, 3030], [3032, 3045], [3067, 3071], 3085, 3089, 3113, [3130, 3131], 3141, 3145, [3150, 3156], 3159, [3163, 3164], [3166, 3167], [3172, 3173], [3184, 3190], 3213, 3217, 3241, 3252, [3258, 3259], 3269, 3273, [3278, 3284], [3287, 3292], 3295, [3300, 3301], 3312, [3316, 3327], 3341, 3345, 3397, 3401, [3408, 3411], [3428, 3429], 3456, 3460, [3479, 3481], 3506, 3516, [3518, 3519], [3527, 3529], [3531, 3534], 3541, 3543, [3552, 3557], [3568, 3569], [3573, 3584], [3643, 3646], [3676, 3712], 3715, 3717, 3723, 3748, 3750, [3774, 3775], 3781, 3783, 3791, [3802, 3803], [3808, 3839], 3912, [3949, 3952], 3992, 4029, 4045, [4059, 4095], 4294, [4296, 4300], [4302, 4303], 4681, [4686, 4687], 4695, 4697, [4702, 4703], 4745, [4750, 4751], 4785, [4790, 4791], 4799, 4801, [4806, 4807], 4823, 4881, [4886, 4887], [4955, 4956], [4989, 4991], [5018, 5023], [5110, 5111], [5118, 5119], [5789, 5791], [5881, 5887], [5910, 5918], [5943, 5951], [5972, 5983], 5997, 6001, [6004, 6015], [6110, 6111], [6122, 6127], [6138, 6143], [6170, 6175], [6265, 6271], [6315, 6319], [6390, 6399], 6431, [6444, 6447], [6460, 6463], [6465, 6467], [6510, 6511], [6517, 6527], [6572, 6575], [6602, 6607], [6619, 6621], [6684, 6685], 6751, [6781, 6782], [6794, 6799], [6810, 6815], [6830, 6831], [6863, 6911], [6989, 6991], 7039, [7156, 7163], [7224, 7226], [7242, 7244], [7305, 7311], [7355, 7356], [7368, 7375], [7419, 7423], [7958, 7959], [7966, 7967], [8006, 8007], [8014, 8015], 8024, 8026, 8028, 8030, [8062, 8063], 8117, 8133, [8148, 8149], 8156, [8176, 8177], 8181, 8191, 8293, [8306, 8307], 8335, [8349, 8351], [8433, 8447], [8588, 8591], [9255, 9279], [9291, 9311], [11124, 11125], 11158, [11508, 11512], 11558, [11560, 11564], [11566, 11567], [11624, 11630], [11633, 11646], [11671, 11679], 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, [11870, 11903], 11930, [12020, 12031], [12246, 12271], [12284, 12287], 12352, [12439, 12440], [12544, 12548], 12592, 12687, [12772, 12783], 12831, [42125, 42127], [42183, 42191], [42540, 42559], [42744, 42751], [42955, 42959], 42962, 42964, [42970, 42993], [43053, 43055], [43066, 43071], [43128, 43135], [43206, 43213], [43226, 43231], [43348, 43358], [43389, 43391], 43470, [43482, 43485], 43519, [43575, 43583], [43598, 43599], [43610, 43611], [43715, 43738], [43767, 43776], [43783, 43784], [43791, 43792], [43799, 43807], 43815, 43823, [43884, 43887], [44014, 44015], [44026, 44031], [55204, 55215], [55239, 55242], [55292, 55295], [57344, 63743], [64263, 64274], [64280, 64284], 64311, 64317, 64319, 64322, 64325, [64451, 64466], [64912, 64913], [64968, 64974], [64976, 65007], [65050, 65055], 65107, 65127, [65132, 65135], 65141, [65277, 65278], 65280, [65471, 65473], [65480, 65481], [65488, 65489], [65496, 65497], [65501, 65503], 65511, [65519, 65528], [65534, 65535], 65548, 65575, 65595, 65598, [65614, 65615], [65630, 65663], [65787, 65791], [65795, 65798], [65844, 65846], 65935, [65949, 65951], [65953, 65999], [66046, 66175], [66205, 66207], [66257, 66271], [66300, 66303], [66340, 66348], [66379, 66383], [66427, 66431], 66462, [66500, 66503], [66518, 66559], [66718, 66719], [66730, 66735], [66772, 66775], [66812, 66815], [66856, 66863], [66916, 66926], 66939, 66955, 66963, 66966, 66978, 66994, 67002, [67005, 67071], [67383, 67391], [67414, 67423], [67432, 67455], 67462, 67505, [67515, 67583], [67590, 67591], 67593, 67638, [67641, 67643], [67645, 67646], 67670, [67743, 67750], [67760, 67807], 67827, [67830, 67834], [67868, 67870], [67898, 67902], [67904, 67967], [68024, 68027], [68048, 68049], 68100, [68103, 68107], 68116, 68120, [68150, 68151], [68155, 68158], [68169, 68175], [68185, 68191], [68256, 68287], [68327, 68330], [68343, 68351], [68406, 68408], [68438, 68439], [68467, 68471], [68498, 68504], [68509, 68520], [68528, 68607], [68681, 68735], [68787, 68799], [68851, 68857], [68904, 68911], [68922, 69215], 69247, 69290, [69294, 69295], [69298, 69372], [69416, 69423], [69466, 69487], [69514, 69551], [69580, 69599], [69623, 69631], [69710, 69713], [69750, 69758], [69827, 69836], [69838, 69839], [69865, 69871], [69882, 69887], 69941, [69960, 69967], [70007, 70015], 70112, [70133, 70143], 70162, [70210, 70271], 70279, 70281, 70286, 70302, [70314, 70319], [70379, 70383], [70394, 70399], 70404, [70413, 70414], [70417, 70418], 70441, 70449, 70452, 70458, [70469, 70470], [70473, 70474], [70478, 70479], [70481, 70486], [70488, 70492], [70500, 70501], [70509, 70511], [70517, 70655], 70748, [70754, 70783], [70856, 70863], [70874, 71039], [71094, 71095], [71134, 71167], [71237, 71247], [71258, 71263], [71277, 71295], [71354, 71359], [71370, 71423], [71451, 71452], [71468, 71471], [71495, 71679], [71740, 71839], [71923, 71934], [71943, 71944], [71946, 71947], 71956, 71959, 71990, [71993, 71994], [72007, 72015], [72026, 72095], [72104, 72105], [72152, 72153], [72165, 72191], [72264, 72271], [72355, 72367], [72441, 72447], [72458, 72703], 72713, 72759, [72774, 72783], [72813, 72815], [72848, 72849], 72872, [72887, 72959], 72967, 72970, [73015, 73017], 73019, 73022, [73032, 73039], [73050, 73055], 73062, 73065, 73103, 73106, [73113, 73119], [73130, 73439], [73465, 73471], 73489, [73531, 73533], [73562, 73647], [73649, 73663], [73714, 73726], [74650, 74751], 74863, [74869, 74879], [75076, 77711], [77811, 77823], [78934, 82943], [83527, 92159], [92729, 92735], 92767, [92778, 92781], 92863, [92874, 92879], [92910, 92911], [92918, 92927], [92998, 93007], 93018, 93026, [93048, 93052], [93072, 93759], [93851, 93951], [94027, 94030], [94088, 94094], [94112, 94175], [94181, 94191], [94194, 94207], [100344, 100351], [101590, 101631], [101641, 110575], 110580, 110588, 110591, [110883, 110897], [110899, 110927], [110931, 110932], [110934, 110947], [110952, 110959], [111356, 113663], [113771, 113775], [113789, 113791], [113801, 113807], [113818, 113819], [113828, 118527], [118574, 118575], [118599, 118607], [118724, 118783], [119030, 119039], [119079, 119080], [119275, 119295], [119366, 119487], [119508, 119519], [119540, 119551], [119639, 119647], [119673, 119807], 119893, 119965, [119968, 119969], [119971, 119972], [119975, 119976], 119981, 119994, 119996, 120004, 120070, [120075, 120076], 120085, 120093, 120122, 120127, 120133, [120135, 120137], 120145, [120486, 120487], [120780, 120781], [121484, 121498], 121504, [121520, 122623], [122655, 122660], [122667, 122879], 122887, [122905, 122906], 122914, 122917, [122923, 122927], [122990, 123022], [123024, 123135], [123181, 123183], [123198, 123199], [123210, 123213], [123216, 123535], [123567, 123583], [123642, 123646], [123648, 124111], [124154, 124895], 124903, 124908, 124911, 124927, [125125, 125126], [125143, 125183], [125260, 125263], [125274, 125277], [125280, 126064], [126133, 126208], [126270, 126463], 126468, 126496, 126499, [126501, 126502], 126504, 126515, 126520, 126522, [126524, 126529], [126531, 126534], 126536, 126538, 126540, 126544, 126547, [126549, 126550], 126552, 126554, 126556, 126558, 126560, 126563, [126565, 126566], 126571, 126579, 126584, 126589, 126591, 126602, [126620, 126624], 126628, 126634, [126652, 126703], [126706, 126975], [131070, 131071], [196606, 196607], [262142, 917504], [917506, 917535], [917632, 917759], [918e3, 1114111]];
  var Unknown_default = _797;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/Word_Joiner.js
  var _798 = [8288, 65279];
  var Word_Joiner_default = _798;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/ZWJ.js
  var _799 = [8205];
  var ZWJ_default = _799;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Line_Break/ZWSpace.js
  var _800 = [8203];
  var ZWSpace_default = _800;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/index.js
  var Word_Break_exports = {};
  __export(Word_Break_exports, {
    ALetter: () => ALetter_default,
    CR: () => CR_default,
    Double_Quote: () => Double_Quote_default,
    Extend: () => Extend_default,
    ExtendNumLet: () => ExtendNumLet_default,
    Format: () => Format_default2,
    Hebrew_Letter: () => Hebrew_Letter_default2,
    Katakana: () => Katakana_default4,
    LF: () => LF_default,
    MidLetter: () => MidLetter_default,
    MidNum: () => MidNum_default,
    MidNumLet: () => MidNumLet_default,
    Newline: () => Newline_default,
    Numeric: () => Numeric_default2,
    Other: () => Other_default2,
    Regional_Indicator: () => Regional_Indicator_default3,
    Single_Quote: () => Single_Quote_default,
    WSegSpace: () => WSegSpace_default,
    ZWJ: () => ZWJ_default2
  });

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/ALetter.js
  var _801 = [[65, 90], [97, 122], 170, 181, 186, [192, 214], [216, 246], [248, 727], [734, 767], [880, 884], [886, 887], [890, 893], 895, 902, [904, 906], 908, [910, 929], [931, 1013], [1015, 1153], [1162, 1327], [1329, 1366], [1369, 1372], 1374, [1376, 1416], 1418, 1523, [1568, 1610], [1646, 1647], [1649, 1747], 1749, [1765, 1766], [1774, 1775], [1786, 1788], 1791, 1808, [1810, 1839], [1869, 1957], 1969, [1994, 2026], [2036, 2037], 2042, [2048, 2069], 2074, 2084, 2088, [2112, 2136], [2144, 2154], [2160, 2183], [2185, 2190], [2208, 2249], [2308, 2361], 2365, 2384, [2392, 2401], [2417, 2432], [2437, 2444], [2447, 2448], [2451, 2472], [2474, 2480], 2482, [2486, 2489], 2493, 2510, [2524, 2525], [2527, 2529], [2544, 2545], 2556, [2565, 2570], [2575, 2576], [2579, 2600], [2602, 2608], [2610, 2611], [2613, 2614], [2616, 2617], [2649, 2652], 2654, [2674, 2676], [2693, 2701], [2703, 2705], [2707, 2728], [2730, 2736], [2738, 2739], [2741, 2745], 2749, 2768, [2784, 2785], 2809, [2821, 2828], [2831, 2832], [2835, 2856], [2858, 2864], [2866, 2867], [2869, 2873], 2877, [2908, 2909], [2911, 2913], 2929, 2947, [2949, 2954], [2958, 2960], [2962, 2965], [2969, 2970], 2972, [2974, 2975], [2979, 2980], [2984, 2986], [2990, 3001], 3024, [3077, 3084], [3086, 3088], [3090, 3112], [3114, 3129], 3133, [3160, 3162], 3165, [3168, 3169], 3200, [3205, 3212], [3214, 3216], [3218, 3240], [3242, 3251], [3253, 3257], 3261, [3293, 3294], [3296, 3297], [3313, 3314], [3332, 3340], [3342, 3344], [3346, 3386], 3389, 3406, [3412, 3414], [3423, 3425], [3450, 3455], [3461, 3478], [3482, 3505], [3507, 3515], 3517, [3520, 3526], 3840, [3904, 3911], [3913, 3948], [3976, 3980], [4256, 4293], 4295, 4301, [4304, 4346], [4348, 4680], [4682, 4685], [4688, 4694], 4696, [4698, 4701], [4704, 4744], [4746, 4749], [4752, 4784], [4786, 4789], [4792, 4798], 4800, [4802, 4805], [4808, 4822], [4824, 4880], [4882, 4885], [4888, 4954], [4992, 5007], [5024, 5109], [5112, 5117], [5121, 5740], [5743, 5759], [5761, 5786], [5792, 5866], [5870, 5880], [5888, 5905], [5919, 5937], [5952, 5969], [5984, 5996], [5998, 6e3], [6176, 6264], [6272, 6276], [6279, 6312], 6314, [6320, 6389], [6400, 6430], [6656, 6678], [6917, 6963], [6981, 6988], [7043, 7072], [7086, 7087], [7098, 7141], [7168, 7203], [7245, 7247], [7258, 7293], [7296, 7304], [7312, 7354], [7357, 7359], [7401, 7404], [7406, 7411], [7413, 7414], 7418, [7424, 7615], [7680, 7957], [7960, 7965], [7968, 8005], [8008, 8013], [8016, 8023], 8025, 8027, 8029, [8031, 8061], [8064, 8116], [8118, 8124], 8126, [8130, 8132], [8134, 8140], [8144, 8147], [8150, 8155], [8160, 8172], [8178, 8180], [8182, 8188], 8305, 8319, [8336, 8348], 8450, 8455, [8458, 8467], 8469, [8473, 8477], 8484, 8486, 8488, [8490, 8493], [8495, 8505], [8508, 8511], [8517, 8521], 8526, [8544, 8584], [9398, 9449], [11264, 11492], [11499, 11502], [11506, 11507], [11520, 11557], 11559, 11565, [11568, 11623], 11631, [11648, 11670], [11680, 11686], [11688, 11694], [11696, 11702], [11704, 11710], [11712, 11718], [11720, 11726], [11728, 11734], [11736, 11742], 11823, 12293, [12347, 12348], [12549, 12591], [12593, 12686], [12704, 12735], [40960, 42124], [42192, 42237], [42240, 42508], [42512, 42527], [42538, 42539], [42560, 42606], [42623, 42653], [42656, 42735], [42760, 42954], [42960, 42961], 42963, [42965, 42969], [42994, 43009], [43011, 43013], [43015, 43018], [43020, 43042], [43072, 43123], [43138, 43187], [43250, 43255], 43259, [43261, 43262], [43274, 43301], [43312, 43334], [43360, 43388], [43396, 43442], 43471, [43520, 43560], [43584, 43586], [43588, 43595], [43744, 43754], [43762, 43764], [43777, 43782], [43785, 43790], [43793, 43798], [43808, 43814], [43816, 43822], [43824, 43881], [43888, 44002], [44032, 55203], [55216, 55238], [55243, 55291], [64256, 64262], [64275, 64279], [64336, 64433], [64467, 64829], [64848, 64911], [64914, 64967], [65008, 65019], [65136, 65140], [65142, 65276], [65313, 65338], [65345, 65370], [65440, 65470], [65474, 65479], [65482, 65487], [65490, 65495], [65498, 65500], [65536, 65547], [65549, 65574], [65576, 65594], [65596, 65597], [65599, 65613], [65616, 65629], [65664, 65786], [65856, 65908], [66176, 66204], [66208, 66256], [66304, 66335], [66349, 66378], [66384, 66421], [66432, 66461], [66464, 66499], [66504, 66511], [66513, 66517], [66560, 66717], [66736, 66771], [66776, 66811], [66816, 66855], [66864, 66915], [66928, 66938], [66940, 66954], [66956, 66962], [66964, 66965], [66967, 66977], [66979, 66993], [66995, 67001], [67003, 67004], [67072, 67382], [67392, 67413], [67424, 67431], [67456, 67461], [67463, 67504], [67506, 67514], [67584, 67589], 67592, [67594, 67637], [67639, 67640], 67644, [67647, 67669], [67680, 67702], [67712, 67742], [67808, 67826], [67828, 67829], [67840, 67861], [67872, 67897], [67968, 68023], [68030, 68031], 68096, [68112, 68115], [68117, 68119], [68121, 68149], [68192, 68220], [68224, 68252], [68288, 68295], [68297, 68324], [68352, 68405], [68416, 68437], [68448, 68466], [68480, 68497], [68608, 68680], [68736, 68786], [68800, 68850], [68864, 68899], [69248, 69289], [69296, 69297], [69376, 69404], 69415, [69424, 69445], [69488, 69505], [69552, 69572], [69600, 69622], [69635, 69687], [69745, 69746], 69749, [69763, 69807], [69840, 69864], [69891, 69926], 69956, 69959, [69968, 70002], 70006, [70019, 70066], [70081, 70084], 70106, 70108, [70144, 70161], [70163, 70187], [70207, 70208], [70272, 70278], 70280, [70282, 70285], [70287, 70301], [70303, 70312], [70320, 70366], [70405, 70412], [70415, 70416], [70419, 70440], [70442, 70448], [70450, 70451], [70453, 70457], 70461, 70480, [70493, 70497], [70656, 70708], [70727, 70730], [70751, 70753], [70784, 70831], [70852, 70853], 70855, [71040, 71086], [71128, 71131], [71168, 71215], 71236, [71296, 71338], 71352, [71680, 71723], [71840, 71903], [71935, 71942], 71945, [71948, 71955], [71957, 71958], [71960, 71983], 71999, 72001, [72096, 72103], [72106, 72144], 72161, 72163, 72192, [72203, 72242], 72250, 72272, [72284, 72329], 72349, [72368, 72440], [72704, 72712], [72714, 72750], 72768, [72818, 72847], [72960, 72966], [72968, 72969], [72971, 73008], 73030, [73056, 73061], [73063, 73064], [73066, 73097], 73112, [73440, 73458], 73474, [73476, 73488], [73490, 73523], 73648, [73728, 74649], [74752, 74862], [74880, 75075], [77712, 77808], [77824, 78895], [78913, 78918], [82944, 83526], [92160, 92728], [92736, 92766], [92784, 92862], [92880, 92909], [92928, 92975], [92992, 92995], [93027, 93047], [93053, 93071], [93760, 93823], [93952, 94026], 94032, [94099, 94111], [94176, 94177], 94179, [113664, 113770], [113776, 113788], [113792, 113800], [113808, 113817], [119808, 119892], [119894, 119964], [119966, 119967], 119970, [119973, 119974], [119977, 119980], [119982, 119993], 119995, [119997, 120003], [120005, 120069], [120071, 120074], [120077, 120084], [120086, 120092], [120094, 120121], [120123, 120126], [120128, 120132], 120134, [120138, 120144], [120146, 120485], [120488, 120512], [120514, 120538], [120540, 120570], [120572, 120596], [120598, 120628], [120630, 120654], [120656, 120686], [120688, 120712], [120714, 120744], [120746, 120770], [120772, 120779], [122624, 122654], [122661, 122666], [122928, 122989], [123136, 123180], [123191, 123197], 123214, [123536, 123565], [123584, 123627], [124112, 124139], [124896, 124902], [124904, 124907], [124909, 124910], [124912, 124926], [124928, 125124], [125184, 125251], 125259, [126464, 126467], [126469, 126495], [126497, 126498], 126500, 126503, [126505, 126514], [126516, 126519], 126521, 126523, 126530, 126535, 126537, 126539, [126541, 126543], [126545, 126546], 126548, 126551, 126553, 126555, 126557, 126559, [126561, 126562], 126564, [126567, 126570], [126572, 126578], [126580, 126583], [126585, 126588], 126590, [126592, 126601], [126603, 126619], [126625, 126627], [126629, 126633], [126635, 126651], [127280, 127305], [127312, 127337], [127344, 127369]];
  var ALetter_default = _801;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/CR.js
  var _802 = [13];
  var CR_default = _802;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Double_Quote.js
  var _803 = [34];
  var Double_Quote_default = _803;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Extend.js
  var _804 = [[768, 879], [1155, 1161], [1425, 1469], 1471, [1473, 1474], [1476, 1477], 1479, [1552, 1562], [1611, 1631], 1648, [1750, 1756], [1759, 1764], [1767, 1768], [1770, 1773], 1809, [1840, 1866], [1958, 1968], [2027, 2035], 2045, [2070, 2073], [2075, 2083], [2085, 2087], [2089, 2093], [2137, 2139], [2200, 2207], [2250, 2273], [2275, 2307], [2362, 2364], [2366, 2383], [2385, 2391], [2402, 2403], [2433, 2435], 2492, [2494, 2500], [2503, 2504], [2507, 2509], 2519, [2530, 2531], 2558, [2561, 2563], 2620, [2622, 2626], [2631, 2632], [2635, 2637], 2641, [2672, 2673], 2677, [2689, 2691], 2748, [2750, 2757], [2759, 2761], [2763, 2765], [2786, 2787], [2810, 2815], [2817, 2819], 2876, [2878, 2884], [2887, 2888], [2891, 2893], [2901, 2903], [2914, 2915], 2946, [3006, 3010], [3014, 3016], [3018, 3021], 3031, [3072, 3076], 3132, [3134, 3140], [3142, 3144], [3146, 3149], [3157, 3158], [3170, 3171], [3201, 3203], 3260, [3262, 3268], [3270, 3272], [3274, 3277], [3285, 3286], [3298, 3299], 3315, [3328, 3331], [3387, 3388], [3390, 3396], [3398, 3400], [3402, 3405], 3415, [3426, 3427], [3457, 3459], 3530, [3535, 3540], 3542, [3544, 3551], [3570, 3571], 3633, [3636, 3642], [3655, 3662], 3761, [3764, 3772], [3784, 3790], [3864, 3865], 3893, 3895, 3897, [3902, 3903], [3953, 3972], [3974, 3975], [3981, 3991], [3993, 4028], 4038, [4139, 4158], [4182, 4185], [4190, 4192], [4194, 4196], [4199, 4205], [4209, 4212], [4226, 4237], 4239, [4250, 4253], [4957, 4959], [5906, 5909], [5938, 5940], [5970, 5971], [6002, 6003], [6068, 6099], 6109, [6155, 6157], 6159, [6277, 6278], 6313, [6432, 6443], [6448, 6459], [6679, 6683], [6741, 6750], [6752, 6780], 6783, [6832, 6862], [6912, 6916], [6964, 6980], [7019, 7027], [7040, 7042], [7073, 7085], [7142, 7155], [7204, 7223], [7376, 7378], [7380, 7400], 7405, 7412, [7415, 7417], [7616, 7679], 8204, [8400, 8432], [11503, 11505], 11647, [11744, 11775], [12330, 12335], [12441, 12442], [42607, 42610], [42612, 42621], [42654, 42655], [42736, 42737], 43010, 43014, 43019, [43043, 43047], 43052, [43136, 43137], [43188, 43205], [43232, 43249], 43263, [43302, 43309], [43335, 43347], [43392, 43395], [43443, 43456], 43493, [43561, 43574], 43587, [43596, 43597], [43643, 43645], 43696, [43698, 43700], [43703, 43704], [43710, 43711], 43713, [43755, 43759], [43765, 43766], [44003, 44010], [44012, 44013], 64286, [65024, 65039], [65056, 65071], [65438, 65439], 66045, 66272, [66422, 66426], [68097, 68099], [68101, 68102], [68108, 68111], [68152, 68154], 68159, [68325, 68326], [68900, 68903], [69291, 69292], [69373, 69375], [69446, 69456], [69506, 69509], [69632, 69634], [69688, 69702], 69744, [69747, 69748], [69759, 69762], [69808, 69818], 69826, [69888, 69890], [69927, 69940], [69957, 69958], 70003, [70016, 70018], [70067, 70080], [70089, 70092], [70094, 70095], [70188, 70199], 70206, 70209, [70367, 70378], [70400, 70403], [70459, 70460], [70462, 70468], [70471, 70472], [70475, 70477], 70487, [70498, 70499], [70502, 70508], [70512, 70516], [70709, 70726], 70750, [70832, 70851], [71087, 71093], [71096, 71104], [71132, 71133], [71216, 71232], [71339, 71351], [71453, 71467], [71724, 71738], [71984, 71989], [71991, 71992], [71995, 71998], 72e3, [72002, 72003], [72145, 72151], [72154, 72160], 72164, [72193, 72202], [72243, 72249], [72251, 72254], 72263, [72273, 72283], [72330, 72345], [72751, 72758], [72760, 72767], [72850, 72871], [72873, 72886], [73009, 73014], 73018, [73020, 73021], [73023, 73029], 73031, [73098, 73102], [73104, 73105], [73107, 73111], [73459, 73462], [73472, 73473], 73475, [73524, 73530], [73534, 73538], 78912, [78919, 78933], [92912, 92916], [92976, 92982], 94031, [94033, 94087], [94095, 94098], 94180, [94192, 94193], [113821, 113822], [118528, 118573], [118576, 118598], [119141, 119145], [119149, 119154], [119163, 119170], [119173, 119179], [119210, 119213], [119362, 119364], [121344, 121398], [121403, 121452], 121461, 121476, [121499, 121503], [121505, 121519], [122880, 122886], [122888, 122904], [122907, 122913], [122915, 122916], [122918, 122922], 123023, [123184, 123190], 123566, [123628, 123631], [124140, 124143], [125136, 125142], [125252, 125258], [127995, 127999], [917536, 917631], [917760, 917999]];
  var Extend_default = _804;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/ExtendNumLet.js
  var _805 = [95, 8239, [8255, 8256], 8276, [65075, 65076], [65101, 65103], 65343];
  var ExtendNumLet_default = _805;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Format.js
  var _806 = [173, [1536, 1541], 1564, 1757, 1807, [2192, 2193], 2274, 6158, [8206, 8207], [8234, 8238], [8288, 8292], [8294, 8303], 65279, [65529, 65531], 69821, 69837, [78896, 78911], [113824, 113827], [119155, 119162], 917505];
  var Format_default2 = _806;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Hebrew_Letter.js
  var _807 = [[1488, 1514], [1519, 1522], 64285, [64287, 64296], [64298, 64310], [64312, 64316], 64318, [64320, 64321], [64323, 64324], [64326, 64335]];
  var Hebrew_Letter_default2 = _807;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Katakana.js
  var _808 = [[12337, 12341], [12443, 12444], [12448, 12538], [12540, 12543], [12784, 12799], [13008, 13054], [13056, 13143], [65382, 65437], [110576, 110579], [110581, 110587], [110589, 110590], 110592, [110880, 110882], 110933, [110948, 110951]];
  var Katakana_default4 = _808;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/LF.js
  var _809 = [10];
  var LF_default = _809;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/MidLetter.js
  var _810 = [58, 183, 903, 1375, 1524, 8231, 65043, 65109, 65306];
  var MidLetter_default = _810;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/MidNum.js
  var _811 = [44, 59, 894, 1417, [1548, 1549], 1644, 2040, 8260, 65040, 65044, 65104, 65108, 65292, 65307];
  var MidNum_default = _811;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/MidNumLet.js
  var _812 = [46, [8216, 8217], 8228, 65106, 65287, 65294];
  var MidNumLet_default = _812;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Newline.js
  var _813 = [[11, 12], 133, [8232, 8233]];
  var Newline_default = _813;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Numeric.js
  var _814 = [[48, 57], [1632, 1641], 1643, [1776, 1785], [1984, 1993], [2406, 2415], [2534, 2543], [2662, 2671], [2790, 2799], [2918, 2927], [3046, 3055], [3174, 3183], [3302, 3311], [3430, 3439], [3558, 3567], [3664, 3673], [3792, 3801], [3872, 3881], [4160, 4169], [4240, 4249], [6112, 6121], [6160, 6169], [6470, 6479], [6608, 6617], [6784, 6793], [6800, 6809], [6992, 7001], [7088, 7097], [7232, 7241], [7248, 7257], [42528, 42537], [43216, 43225], [43264, 43273], [43472, 43481], [43504, 43513], [43600, 43609], [44016, 44025], [65296, 65305], [66720, 66729], [68912, 68921], [69734, 69743], [69872, 69881], [69942, 69951], [70096, 70105], [70384, 70393], [70736, 70745], [70864, 70873], [71248, 71257], [71360, 71369], [71472, 71481], [71904, 71913], [72016, 72025], [72784, 72793], [73040, 73049], [73120, 73129], [73552, 73561], [92768, 92777], [92864, 92873], [93008, 93017], [120782, 120831], [123200, 123209], [123632, 123641], [124144, 124153], [125264, 125273], [130032, 130041]];
  var Numeric_default2 = _814;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Other.js
  var _815 = [[0, 9], [14, 31], 33, [35, 38], [40, 43], 45, 47, [60, 64], [91, 94], 96, [123, 132], [134, 159], [161, 169], [171, 172], [174, 180], 182, [184, 185], [187, 191], 215, 247, [728, 733], 885, [888, 889], [896, 901], 907, 909, 930, 1014, 1154, 1328, [1367, 1368], 1373, [1419, 1424], 1470, 1472, 1475, 1478, [1480, 1487], [1515, 1518], [1525, 1535], [1542, 1547], [1550, 1551], 1563, [1565, 1567], 1642, 1645, 1748, 1769, [1789, 1790], [1792, 1806], [1867, 1868], [1970, 1983], [2038, 2039], 2041, [2043, 2044], [2046, 2047], [2094, 2111], [2140, 2143], [2155, 2159], 2184, 2191, [2194, 2199], [2404, 2405], 2416, 2436, [2445, 2446], [2449, 2450], 2473, 2481, [2483, 2485], [2490, 2491], [2501, 2502], [2505, 2506], [2511, 2518], [2520, 2523], 2526, [2532, 2533], [2546, 2555], 2557, [2559, 2560], 2564, [2571, 2574], [2577, 2578], 2601, 2609, 2612, 2615, [2618, 2619], 2621, [2627, 2630], [2633, 2634], [2638, 2640], [2642, 2648], 2653, [2655, 2661], [2678, 2688], 2692, 2702, 2706, 2729, 2737, 2740, [2746, 2747], 2758, 2762, [2766, 2767], [2769, 2783], [2788, 2789], [2800, 2808], 2816, 2820, [2829, 2830], [2833, 2834], 2857, 2865, 2868, [2874, 2875], [2885, 2886], [2889, 2890], [2894, 2900], [2904, 2907], 2910, [2916, 2917], 2928, [2930, 2945], 2948, [2955, 2957], 2961, [2966, 2968], 2971, 2973, [2976, 2978], [2981, 2983], [2987, 2989], [3002, 3005], [3011, 3013], 3017, [3022, 3023], [3025, 3030], [3032, 3045], [3056, 3071], 3085, 3089, 3113, [3130, 3131], 3141, 3145, [3150, 3156], 3159, [3163, 3164], [3166, 3167], [3172, 3173], [3184, 3199], 3204, 3213, 3217, 3241, 3252, [3258, 3259], 3269, 3273, [3278, 3284], [3287, 3292], 3295, [3300, 3301], 3312, [3316, 3327], 3341, 3345, 3397, 3401, [3407, 3411], [3416, 3422], [3428, 3429], [3440, 3449], 3456, 3460, [3479, 3481], 3506, 3516, [3518, 3519], [3527, 3529], [3531, 3534], 3541, 3543, [3552, 3557], [3568, 3569], [3572, 3632], [3634, 3635], [3643, 3654], 3663, [3674, 3760], [3762, 3763], [3773, 3783], 3791, [3802, 3839], [3841, 3863], [3866, 3871], [3882, 3892], 3894, 3896, [3898, 3901], 3912, [3949, 3952], 3973, 3992, [4029, 4037], [4039, 4095], 4130, 4136, 4159, [4170, 4175], [4186, 4189], 4193, [4197, 4198], [4206, 4208], [4213, 4225], 4238, [4254, 4255], 4294, [4296, 4300], [4302, 4303], 4347, 4681, [4686, 4687], 4695, 4697, [4702, 4703], 4745, [4750, 4751], 4785, [4790, 4791], 4799, 4801, [4806, 4807], 4823, 4881, [4886, 4887], [4955, 4956], [4960, 4991], [5008, 5023], [5110, 5111], [5118, 5120], [5741, 5742], [5787, 5791], [5867, 5869], [5881, 5887], [5910, 5918], [5941, 5951], [5972, 5983], 5997, 6001, [6004, 6015], [6100, 6102], [6104, 6107], [6110, 6111], [6122, 6154], [6170, 6175], [6265, 6271], [6315, 6319], [6390, 6399], 6431, [6444, 6447], [6460, 6469], [6510, 6511], [6517, 6527], [6570, 6575], [6602, 6607], [6619, 6655], [6684, 6740], 6751, [6781, 6782], [6794, 6799], [6810, 6831], [6863, 6911], [6989, 6991], [7002, 7018], [7028, 7039], [7156, 7167], [7224, 7231], [7242, 7244], [7294, 7295], [7305, 7311], [7355, 7356], [7360, 7375], 7379, [7419, 7423], [7958, 7959], [7966, 7967], [8006, 8007], [8014, 8015], 8024, 8026, 8028, 8030, [8062, 8063], 8117, 8125, [8127, 8129], 8133, [8141, 8143], [8148, 8149], [8156, 8159], [8173, 8177], 8181, [8189, 8191], 8199, [8208, 8215], [8218, 8227], [8229, 8230], [8240, 8254], [8257, 8259], [8261, 8275], [8277, 8286], 8293, 8304, [8306, 8318], [8320, 8335], [8349, 8399], [8433, 8449], [8451, 8454], [8456, 8457], 8468, [8470, 8472], [8478, 8483], 8485, 8487, 8489, 8494, [8506, 8507], [8512, 8516], [8522, 8525], [8527, 8543], [8585, 9397], [9450, 9756], [9758, 9791], 9793, [9795, 9876], [9879, 9976], [9978, 9991], 9993, [9998, 10083], [10085, 11263], [11493, 11498], [11508, 11519], 11558, [11560, 11564], [11566, 11567], [11624, 11630], [11632, 11646], [11671, 11679], 11687, 11695, 11703, 11711, 11719, 11727, 11735, 11743, [11776, 11822], [11824, 12287], [12289, 12292], [12294, 12329], 12336, [12342, 12346], [12349, 12440], [12445, 12447], 12539, [12544, 12548], 12592, [12687, 12703], [12736, 12783], [12800, 13007], 13055, [13144, 40959], [42125, 42191], [42238, 42239], [42509, 42511], [42540, 42559], 42611, 42622, [42738, 42759], [42955, 42959], 42962, 42964, [42970, 42993], [43048, 43051], [43053, 43071], [43124, 43135], [43206, 43215], [43226, 43231], [43256, 43258], 43260, [43310, 43311], [43348, 43359], [43389, 43391], [43457, 43470], [43482, 43492], [43494, 43503], [43514, 43519], [43575, 43583], [43598, 43599], [43610, 43642], [43646, 43695], 43697, [43701, 43702], [43705, 43709], 43712, [43714, 43743], [43760, 43761], [43767, 43776], [43783, 43784], [43791, 43792], [43799, 43807], 43815, 43823, [43882, 43887], 44011, [44014, 44015], [44026, 44031], [55204, 55215], [55239, 55242], [55292, 64047], [64107, 64255], [64263, 64274], [64280, 64284], 64297, 64311, 64317, 64319, 64322, 64325, [64434, 64466], [64830, 64847], [64912, 64913], [64968, 65007], [65020, 65023], [65041, 65042], [65045, 65055], [65072, 65074], [65077, 65100], 65105, 65107, [65110, 65135], 65141, [65277, 65278], [65280, 65286], [65288, 65291], 65293, 65295, [65308, 65312], [65339, 65342], 65344, [65371, 65381], [65471, 65473], [65480, 65481], [65488, 65489], [65496, 65497], [65501, 65528], [65532, 65535], 65548, 65575, 65595, 65598, [65614, 65615], [65630, 65663], [65787, 65855], [65909, 66044], [66046, 66175], [66205, 66207], [66257, 66271], [66273, 66303], [66336, 66348], [66379, 66383], [66427, 66431], [66462, 66463], [66500, 66503], 66512, [66518, 66559], [66718, 66719], [66730, 66735], [66772, 66775], [66812, 66815], [66856, 66863], [66916, 66927], 66939, 66955, 66963, 66966, 66978, 66994, 67002, [67005, 67071], [67383, 67391], [67414, 67423], [67432, 67455], 67462, 67505, [67515, 67583], [67590, 67591], 67593, 67638, [67641, 67643], [67645, 67646], [67670, 67679], [67703, 67711], [67743, 67807], 67827, [67830, 67839], [67862, 67871], [67898, 67967], [68024, 68029], [68032, 68095], 68100, [68103, 68107], 68116, 68120, [68150, 68151], [68155, 68158], [68160, 68191], [68221, 68223], [68253, 68287], 68296, [68327, 68351], [68406, 68415], [68438, 68447], [68467, 68479], [68498, 68607], [68681, 68735], [68787, 68799], [68851, 68863], [68904, 68911], [68922, 69247], 69290, [69293, 69295], [69298, 69372], [69405, 69414], [69416, 69423], [69457, 69487], [69510, 69551], [69573, 69599], [69623, 69631], [69703, 69733], [69750, 69758], [69819, 69820], [69822, 69825], [69827, 69836], [69838, 69839], [69865, 69871], [69882, 69887], 69941, [69952, 69955], [69960, 69967], [70004, 70005], [70007, 70015], [70085, 70088], 70093, 70107, [70109, 70143], 70162, [70200, 70205], [70210, 70271], 70279, 70281, 70286, 70302, [70313, 70319], [70379, 70383], [70394, 70399], 70404, [70413, 70414], [70417, 70418], 70441, 70449, 70452, 70458, [70469, 70470], [70473, 70474], [70478, 70479], [70481, 70486], [70488, 70492], [70500, 70501], [70509, 70511], [70517, 70655], [70731, 70735], [70746, 70749], [70754, 70783], 70854, [70856, 70863], [70874, 71039], [71094, 71095], [71105, 71127], [71134, 71167], [71233, 71235], [71237, 71247], [71258, 71295], [71353, 71359], [71370, 71452], [71468, 71471], [71482, 71679], [71739, 71839], [71914, 71934], [71943, 71944], [71946, 71947], 71956, 71959, 71990, [71993, 71994], [72004, 72015], [72026, 72095], [72104, 72105], [72152, 72153], 72162, [72165, 72191], [72255, 72262], [72264, 72271], [72346, 72348], [72350, 72367], [72441, 72703], 72713, 72759, [72769, 72783], [72794, 72817], [72848, 72849], 72872, [72887, 72959], 72967, 72970, [73015, 73017], 73019, 73022, [73032, 73039], [73050, 73055], 73062, 73065, 73103, 73106, [73113, 73119], [73130, 73439], [73463, 73471], 73489, [73531, 73533], [73539, 73551], [73562, 73647], [73649, 73727], [74650, 74751], [74863, 74879], [75076, 77711], [77809, 77823], [78934, 82943], [83527, 92159], [92729, 92735], 92767, [92778, 92783], 92863, [92874, 92879], [92910, 92911], [92917, 92927], [92983, 92991], [92996, 93007], [93018, 93026], [93048, 93052], [93072, 93759], [93824, 93951], [94027, 94030], [94088, 94094], [94112, 94175], 94178, [94181, 94191], [94194, 110575], 110580, 110588, 110591, [110593, 110879], [110883, 110932], [110934, 110947], [110952, 113663], [113771, 113775], [113789, 113791], [113801, 113807], [113818, 113820], 113823, [113828, 118527], [118574, 118575], [118599, 119140], [119146, 119148], [119171, 119172], [119180, 119209], [119214, 119361], [119365, 119807], 119893, 119965, [119968, 119969], [119971, 119972], [119975, 119976], 119981, 119994, 119996, 120004, 120070, [120075, 120076], 120085, 120093, 120122, 120127, 120133, [120135, 120137], 120145, [120486, 120487], 120513, 120539, 120571, 120597, 120629, 120655, 120687, 120713, 120745, 120771, [120780, 120781], [120832, 121343], [121399, 121402], [121453, 121460], [121462, 121475], [121477, 121498], 121504, [121520, 122623], [122655, 122660], [122667, 122879], 122887, [122905, 122906], 122914, 122917, [122923, 122927], [122990, 123022], [123024, 123135], [123181, 123183], [123198, 123199], [123210, 123213], [123215, 123535], [123567, 123583], [123642, 124111], [124154, 124895], 124903, 124908, 124911, 124927, [125125, 125135], [125143, 125183], [125260, 125263], [125274, 126463], 126468, 126496, 126499, [126501, 126502], 126504, 126515, 126520, 126522, [126524, 126529], [126531, 126534], 126536, 126538, 126540, 126544, 126547, [126549, 126550], 126552, 126554, 126556, 126558, 126560, 126563, [126565, 126566], 126571, 126579, 126584, 126589, 126591, 126602, [126620, 126624], 126628, 126634, [126652, 127279], [127306, 127311], [127338, 127343], [127370, 127461], [127488, 127751], [127753, 127805], [127807, 127858], [127860, 127876], [127878, 127890], [127892, 127907], [127909, 127911], [127913, 127937], [127941, 127942], [127944, 127945], [127949, 127978], 127980, [127982, 127994], [128e3, 128065], [128068, 128069], [128081, 128101], [128106, 128109], 128111, [128121, 128123], [128125, 128128], 128132, [128136, 128138], [128140, 128169], [128171, 128186], [128189, 128294], [128296, 128299], [128301, 128371], [128374, 128377], [128379, 128399], [128401, 128404], [128407, 128487], [128489, 128580], [128584, 128586], [128592, 128639], [128641, 128657], [128659, 128674], [128676, 128691], [128695, 128703], [128705, 128715], [128717, 129303], [129312, 129317], [129319, 129327], [129338, 129339], [129343, 129488], [129502, 130031], [130042, 917504], [917506, 917535], [917632, 917759], [918e3, 1114111]];
  var Other_default2 = _815;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Regional_Indicator.js
  var _816 = [[127462, 127487]];
  var Regional_Indicator_default3 = _816;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/Single_Quote.js
  var _817 = [39];
  var Single_Quote_default = _817;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/WSegSpace.js
  var _818 = [32, 5760, [8192, 8198], [8200, 8202], 8287, 12288];
  var WSegSpace_default = _818;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/data.generated/Word_Break/ZWJ.js
  var _819 = [8205];
  var ZWJ_default2 = _819;

  // ../node_modules/.pnpm/unicode-regex@4.0.0/node_modules/unicode-regex/lib/index.js
  function unicode2(categories) {
    const keys = Object.keys(categories);
    if (keys.length === 0) {
      throw new Error(`Expected at least one category, but received 0.`);
    }
    if (keys.some((key) => {
      const subCategories = categories[key];
      return subCategories === void 0 || subCategories.length === 0;
    })) {
      throw new Error(`Expected at least one sub category, but received 0.`);
    }
    const charsets = keys.map((key) => {
      const subCategories = categories[key];
      const subCharsets = subCategories.map((_820) => getCharset(key, _820));
      return new Charset().union(...subCharsets);
    });
    return charsets.reduce((a, b) => a.intersect(b));
  }
  function getCharset(category, subCategory) {
    const categoryData = data_exports[category];
    const charsetInputs = categoryData[subCategory];
    return new Charset().union(...charsetInputs);
  }

  // ../node_modules/.pnpm/cjk-regex@3.1.0/node_modules/cjk-regex/lib/index.js
  var cjkLetters = unicode2({
    Script: ["Han", "Katakana", "Hiragana", "Hangul", "Bopomofo"],
    General_Category: [
      "Other_Letter",
      "Letter_Number",
      "Other_Symbol",
      "Modifier_Letter"
    ]
  });
  var cjkPunctuations = unicode2({
    Block: [
      "CJK_Compatibility",
      "CJK_Symbols_And_Punctuation",
      "Vertical_Forms",
      "CJK_Compatibility_Forms",
      "Small_Form_Variants",
      "Halfwidth_And_Fullwidth_Forms",
      "Ideographic_Description_Characters",
      "Kanbun",
      "CJK_Strokes",
      "Enclosed_CJK_Letters_And_Months"
    ]
  }).subtract(cjkLetters);
  var cjkAll = charset(cjkLetters, cjkPunctuations);
  function all() {
    return charset(cjkAll);
  }
  function letters() {
    return charset(cjkLetters);
  }
  function punctuations() {
    return charset(cjkPunctuations);
  }

  // ../packages/engine-render/src/basics/font-cache.ts
  var getDefaultBaselineOffset = (fontSize) => ({
    sbr: 0.5,
    sbo: fontSize,
    spr: 0.5,
    spo: fontSize
  });
  var FontCache = class {
    static get globalFontMeasureCache() {
      return this._globalFontMeasureCache;
    }
    static setFontMeasureCache(fontStyle, content, tm) {
      if (!this._globalFontMeasureCache.has(fontStyle)) {
        this._globalFontMeasureCache.set(fontStyle, /* @__PURE__ */ new Map());
      }
      const fontMeasureCache = this._globalFontMeasureCache.get(fontStyle);
      if (fontMeasureCache) {
        fontMeasureCache.set(content, tm);
      }
    }
    static clearFontMeasureCache(path) {
      var _a2;
      const pathArr = path.split("/");
      if (pathArr.length === 1) {
        const fontStyle = pathArr[0];
        this._globalFontMeasureCache.delete(fontStyle);
      } else if (pathArr.length === 2) {
        const fontStyle = pathArr[0];
        const content = pathArr[1];
        (_a2 = this._globalFontMeasureCache.get(fontStyle)) == null ? void 0 : _a2.delete(content);
      } else {
        return false;
      }
      return true;
    }
    static getFontMeasureCache(fontStyle, content) {
      var _a2;
      return (_a2 = this._globalFontMeasureCache.get(fontStyle)) == null ? void 0 : _a2.get(content);
    }
    // 自动清除文字缓存，阈值可调整，清除规则是触发上限后删除一半的缓存
    static autoCleanFontMeasureCache(cacheLimit = 1e6) {
      let allSize = 0;
      let isDelete = false;
      let i = 0;
      for (const item of this._globalFontMeasureCache) {
        const [, values] = item;
        allSize += values.size;
        if (allSize > cacheLimit) {
          isDelete = true;
          break;
        }
        i++;
      }
      if (isDelete) {
        let deleteAllSize = 0;
        for (const item of this._globalFontMeasureCache) {
          const [key, values] = item;
          deleteAllSize += values.size;
          if (deleteAllSize > cacheLimit / 2) {
            const limit = deleteAllSize - cacheLimit / 2;
            this._clearMeasureCache(limit, values);
            break;
          }
          this._globalFontMeasureCache.delete(key);
        }
        return true;
      }
      return false;
    }
    static getBaselineOffsetInfo(fontFamily, fontSize) {
      if (this._fontDataMap.size === 0) {
        return getDefaultBaselineOffset(fontSize);
      }
      const fontFamilyList = fontFamily.split(",");
      for (let ff of fontFamilyList) {
        ff = ff.replace(/'/g, "");
        const fontData = this._fontDataMap.get(ff);
        if (!fontData) {
          continue;
        }
        const { subscriptSizeRatio, subscriptOffset, superscriptSizeRatio, superscriptOffset } = fontData;
        return {
          sbr: subscriptSizeRatio,
          sbo: subscriptOffset * fontSize,
          spr: superscriptSizeRatio,
          spo: superscriptOffset * fontSize
        };
      }
      return getDefaultBaselineOffset(fontSize);
    }
    static getTextSizeByDom(text, fontStyle) {
      if (fontStyle in this._getTextHeightCache) {
        return this._getTextHeightCache[fontStyle];
      }
      let dom = document.getElementById("universheetTextSizeTest");
      const defaultStyle = "float:left;white-space:nowrap;visibility:hidden;margin:0;padding:0;";
      if (!dom) {
        dom = document.createElement("span");
        dom.id = "universheetTextSizeTest";
        document.getElementsByTagName("body")[0].appendChild(dom);
      }
      dom.style.cssText += `${defaultStyle};${fontStyle}`;
      dom.textContent = text;
      const rect = dom.getBoundingClientRect();
      const result = { width: rect.width, height: rect.height };
      this._getTextHeightCache[fontStyle] = result;
      return result;
    }
    static getTextSize(content, fontStyle) {
      const { fontString, fontSize, fontFamily } = fontStyle;
      let bBox = this._getBoundingBoxByFont(fontFamily, fontSize);
      if (!bBox) {
        const measureText = this.getMeasureText(content, fontString);
        bBox = this._calculateBoundingBoxByMeasureText(measureText, fontSize);
      }
      return bBox;
    }
    // 获取有值单元格文本大小
    // let measureTextCache = {}, measureTextCacheTimeOut = null;
    static getMeasureText(content, fontString) {
      if (!this._context) {
        const canvas = document.createElement("canvas");
        this._context = canvas.getContext("2d");
      }
      const ctx = this._context;
      const mtc = this.getFontMeasureCache(fontString, content);
      if (mtc != null) {
        return mtc;
      }
      ctx.font = fontString;
      const textMetrics = ctx.measureText(content);
      const {
        width,
        fontBoundingBoxAscent,
        fontBoundingBoxDescent,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent
      } = textMetrics;
      const cache = {
        width,
        fontBoundingBoxAscent,
        fontBoundingBoxDescent,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent
      };
      if (fontBoundingBoxAscent == null || fontBoundingBoxDescent == null || Number.isNaN(fontBoundingBoxAscent) || Number.isNaN(fontBoundingBoxDescent)) {
        const oneLineTextHeight = this.getTextSizeByDom(DEFAULT_MEASURE_TEXT, fontString).height;
        if (ctx.textBaseline === "top") {
          cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight;
          cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = 0;
        } else if (ctx.textBaseline === "middle") {
          cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = oneLineTextHeight / 2;
          cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight / 2;
        } else {
          cache.fontBoundingBoxDescent = cache.actualBoundingBoxDescent = 0;
          cache.fontBoundingBoxAscent = cache.actualBoundingBoxAscent = oneLineTextHeight;
        }
      }
      this.setFontMeasureCache(fontString, content, cache);
      return cache;
    }
    static _clearMeasureCache(limit, values) {
      let valueIndex = 0;
      for (const txtItem of values) {
        const [txtKey] = txtItem;
        if (valueIndex > limit) {
          break;
        }
        values.delete(txtKey);
        valueIndex++;
      }
      return true;
    }
    /**
     * Vertical Metrics https://glyphsapp.com/learn/vertical-metrics
     * @param fontFamily
     * @param fontSize
     * @param content
     * @returns
     */
    static _getBoundingBoxByFont(fontFamily, fontSize = 28, content = "") {
      const fontData = this._fontDataMap.get(fontFamily);
      if (!fontData) {
        return;
      }
      const {
        notDefWidth,
        ascender,
        descender,
        typoAscender,
        typoDescender,
        strikeoutPosition,
        subscriptSizeRatio,
        subscriptOffset,
        superscriptSizeRatio,
        superscriptOffset,
        hdmxData,
        glyphHorizonMap
      } = fontData;
      const pixelsPerEmIndex = hdmxData == null ? void 0 : hdmxData.indexOf(Math.floor(fontSize));
      const glyph = glyphHorizonMap.get(content.charCodeAt(0));
      let widthResult = notDefWidth;
      if (glyph) {
        const { width, pixelsPerEm = [] } = glyph;
        if (pixelsPerEmIndex) {
          widthResult = pixelsPerEm[pixelsPerEmIndex];
        } else {
          widthResult = width;
        }
      }
      return {
        width: widthResult * fontSize,
        ba: ascender * fontSize,
        bd: descender * fontSize,
        aba: typoAscender * fontSize,
        abd: typoDescender * fontSize,
        sp: strikeoutPosition * fontSize,
        sbr: subscriptSizeRatio,
        sbo: subscriptOffset * fontSize,
        spr: superscriptSizeRatio,
        spo: superscriptOffset * fontSize
      };
    }
    static _calculateBoundingBoxByMeasureText(textCache, fontSize) {
      const {
        width,
        fontBoundingBoxAscent,
        fontBoundingBoxDescent,
        actualBoundingBoxAscent,
        actualBoundingBoxDescent
      } = textCache;
      return {
        width,
        ba: fontBoundingBoxAscent,
        bd: fontBoundingBoxDescent,
        aba: actualBoundingBoxAscent,
        abd: actualBoundingBoxDescent,
        sp: (fontBoundingBoxAscent + fontBoundingBoxDescent) / 2,
        sbr: 0.5,
        sbo: fontSize,
        spr: 0.5,
        spo: fontSize
      };
    }
  };
  __publicField(FontCache, "_getTextHeightCache", {});
  __publicField(FontCache, "_context");
  __publicField(FontCache, "_fontDataMap", /* @__PURE__ */ new Map());
  // 文字缓存全局变量
  __publicField(FontCache, "_globalFontMeasureCache", /* @__PURE__ */ new Map());

  // ../packages/engine-render/src/basics/tools.ts
  var DEG180 = 180;
  var PI_OVER_DEG180 = Math.PI / DEG180;
  var DEG180_OVER_PI = DEG180 / Math.PI;
  var RGB_PAREN2 = "rgb(";
  var RGBA_PAREN2 = "rgba(";
  var getColor = (RgbArray, opacity) => {
    if (!RgbArray) {
      return `${RGB_PAREN2}0,0,0)`;
    }
    if (opacity != null) {
      return `${RGBA_PAREN2 + RgbArray.join(",")},${opacity})`;
    }
    return `${RGB_PAREN2 + RgbArray.join(",")})`;
  };
  var PERCENT_TO_NUMBER_DIVIDE = 100;
  var toPx = (num, ReferenceValue) => {
    if (Tools.isNumber(num)) {
      return num;
    }
    if (ReferenceValue && num && Tools.isString(num) && num.substr(num.length - 1, 1) === "%") {
      const numFloat = Number.parseFloat(num) / PERCENT_TO_NUMBER_DIVIDE;
      return ReferenceValue * numFloat;
    }
    return 0;
  };
  var ONE_FRAME_NUMBER = 16;
  var requestNewFrame = (func, requester) => {
    if (!requester) {
      requester = window;
    }
    if (requester.requestPostAnimationFrame) {
      return requester.requestPostAnimationFrame(func);
    }
    if (requester.requestAnimationFrame) {
      return requester.requestAnimationFrame(func);
    }
    if (requester.msRequestAnimationFrame) {
      return requester.msRequestAnimationFrame(func);
    }
    if (requester.webkitRequestAnimationFrame) {
      return requester.webkitRequestAnimationFrame(func);
    }
    if (requester.mozRequestAnimationFrame) {
      return requester.mozRequestAnimationFrame(func);
    }
    if (requester.oRequestAnimationFrame) {
      return requester.oRequestAnimationFrame(func);
    }
    return setTimeout(func, ONE_FRAME_NUMBER);
  };
  var cancelRequestFrame = (requestID, requester) => {
    if (!requester) {
      requester = window;
    }
    if (requester.requestPostAnimationFrame) {
      return requester.cancelPostAnimationFrame(requestID);
    }
    if (requester.requestAnimationFrame) {
      return requester.cancelAnimationFrame(requestID);
    }
    if (requester.msRequestAnimationFrame) {
      return requester.msCancelAnimationFrame(requestID);
    }
    if (requester.webkitRequestAnimationFrame) {
      return requester.webkitCancelAnimationFrame(requestID);
    }
    if (requester.mozRequestAnimationFrame) {
      return requester.mozCancelAnimationFrame(requestID);
    }
    if (requester.oRequestAnimationFrame) {
      return requester.oCancelAnimationFrame(requestID);
    }
    return clearTimeout(requestID);
  };
  var createCanvasElement = () => {
    const canvas = document.createElement("canvas");
    try {
      canvas.style = canvas.style || {};
    } catch (e) {
      console.error(e);
    }
    return canvas;
  };
  var radToDeg = (rad) => rad * DEG180_OVER_PI;
  var degToRad = (deg) => deg * PI_OVER_DEG180;
  var getPointerPrefix = () => {
    let eventPrefix = "pointer";
    if (typeof window !== "undefined" && !window.PointerEvent && typeof navigator !== "undefined") {
      eventPrefix = "mouse";
    }
    if (Tools.isTablet() && !Tools.isIPhone() && // And not ipad pros who claim to be macs...
    !(document && "ontouchend" in document)) {
      eventPrefix = "mouse";
    }
    return eventPrefix;
  };
  var IsSafari = () => {
    if (Tools.getBrowserType() === "safari") {
      return true;
    }
    return false;
  };
  var GENERATE_RANDOM_KEY_DEFAULT_LENGTH = 4;
  var generateRandomKey = (prefix = "obj", keyLength = GENERATE_RANDOM_KEY_DEFAULT_LENGTH) => {
    const userAgent = window.navigator.userAgent.replace(/[^a-zA-Z0-9]/g, "").split("");
    let mid = "";
    for (let i = 0; i < keyLength; i++) {
      mid += userAgent[Math.round(Math.random() * (userAgent.length - 1))];
    }
    const time = (/* @__PURE__ */ new Date()).getTime();
    return `${prefix}_${mid}_${time}`;
  };
  function getValueType(value) {
    return Object.prototype.toString.apply(value);
  }
  function isFunction2(value) {
    return getValueType(value) === "[object Function]";
  }
  function isString(value) {
    return getValueType(value) === "[object String]";
  }
  function precisionTo(num, accurate) {
    accurate = 10 ** accurate;
    return Math.round(num * accurate) / accurate;
  }
  function fixLineWidthByScale(num, scale) {
    return Math.round(num * scale) / scale;
  }
  var UNIVER_GLOBAL_DEFAULT_FONT_SIZE = 11;
  var UNIVER_GLOBAL_DEFAULT_FONT_FAMILY = "Arial";
  function getFontStyleString(textStyle, localeService) {
    const defaultFont = UNIVER_GLOBAL_DEFAULT_FONT_FAMILY;
    const defaultFontSize = UNIVER_GLOBAL_DEFAULT_FONT_SIZE;
    if (!textStyle) {
      const fontString2 = `${defaultFontSize}pt  ${defaultFont}`;
      return {
        fontCache: fontString2,
        fontString: fontString2,
        fontSize: defaultFontSize,
        fontFamily: defaultFont
      };
    }
    let italic = "italic" /* ITALIC */;
    if (textStyle.it === 0 || textStyle.it === void 0) {
      italic = "normal" /* NORMAL */;
    }
    let bold = "bold" /* BOLD */;
    if (textStyle.bl === 0 || textStyle.bl === void 0) {
      bold = "normal" /* NORMAL */;
    }
    let fontSize = defaultFontSize;
    if (textStyle.fs) {
      fontSize = Math.ceil(textStyle.fs);
    }
    let fontFamilyResult = defaultFont;
    if (textStyle.ff) {
      let fontFamily = textStyle.ff;
      fontFamily = fontFamily.replace(/"/g, "").replace(/'/g, "");
      if (fontFamily.indexOf(" ") > -1) {
        fontFamily = `"${fontFamily}"`;
      }
      if (fontFamily == null) {
        fontFamily = defaultFont;
      }
      fontFamilyResult = fontFamily;
    }
    const { va: baselineOffset } = textStyle;
    if (baselineOffset === 2 /* SUBSCRIPT */ || baselineOffset === 3 /* SUPERSCRIPT */) {
      const baselineOffsetInfo = FontCache.getBaselineOffsetInfo(fontFamilyResult, fontSize);
      const { sbr, spr } = baselineOffsetInfo;
      fontSize *= baselineOffset === 2 /* SUBSCRIPT */ ? sbr : spr;
    }
    const fontStringPure = `${italic} ${bold} ${fontSize}pt ${fontFamilyResult}`;
    const fontString = `${fontStringPure}, ${DEFAULT_FONTFACE_PLANE} `;
    return {
      fontCache: fontStringPure,
      fontString,
      fontSize,
      fontFamily: fontFamilyResult
    };
  }
  var CJK_LETTER_REG = letters().toRegExp();
  function hasCJKText(text) {
    return CJK_LETTER_REG.test(text);
  }
  var CJK_ALL_REG = all().toRegExp();
  function hasCJK(text) {
    return CJK_ALL_REG.test(text);
  }
  var CJK_PUNCTUATION_REG = punctuations().toRegExp();
  function hasCJKPunctuation(text) {
    return CJK_PUNCTUATION_REG.test(text);
  }
  var EMOJI_REG = /^(?:[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?))/g;
  var EMOJI_REG_LOCAL = /^(?:[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE88\uDE90-\uDEBD\uDEBF-\uDEC2\uDECE-\uDEDB\uDEE0-\uDEE8]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?))/;
  function startWithEmoji(text) {
    return EMOJI_REG_LOCAL.test(text);
  }
  function hasArabic(text) {
    const pattern = /[\u0600-\u06FF]|[\u0750-\u0750]|[\u0870-\u08FF]|[\uFB50-\uFDFF]|[\uFE70-\uFEFF]/gi;
    return pattern.test(text);
  }
  function hasTibetan(text) {
    const pattern = /[\u0180-\u024F]/gi;
    return pattern.test(text);
  }
  function hasSpace(text) {
    const pattern = /\s+/g;
    return pattern.test(text);
  }
  function isCjkLeftAlignedPunctuation(text) {
    const LEFT_ALIGNED_PUNCTUATION = ["\u201D", "\u2019", "\uFF0C", "\u3002", "\uFF0E", "\u3001", "\uFF1A", "\uFF1B", "\uFF1F", "\uFF01", "\u300B", "\uFF09", "\u300F", "\u300D", "\u3011", "\u3017", "\u3015", "\u3009", "\uFF3D", "\uFF5D"];
    return LEFT_ALIGNED_PUNCTUATION.indexOf(text) > -1;
  }
  function isCjkRightAlignedPunctuation(text) {
    const RIGHT_ALIGNED_PUNCTUATION = ["\u201C", "\u2018", "\u300A", "\uFF08", "\u300E", "\u300C", "\u3010", "\u3016", "\u3014", "\u3008", "\uFF3B", "\uFF5B"];
    return RIGHT_ALIGNED_PUNCTUATION.indexOf(text) > -1;
  }
  function isCjkCenterAlignedPunctuation(text) {
    const CENTER_ALIGNED_PUNCTUATION = ["\u30FB", "\xB7"];
    return CENTER_ALIGNED_PUNCTUATION.indexOf(text) > -1;
  }
  function getScale(parentScale) {
    const { scaleX = 1, scaleY = 1 } = parentScale;
    return Math.max(scaleX, scaleY);
  }
  function getCellPositionByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation) {
    const startRow = row - 1;
    const startColumn = column - 1;
    const startY = rowHeightAccumulation[startRow] || 0;
    let endY = rowHeightAccumulation[row];
    if (endY == null) {
      endY = rowHeightAccumulation[rowHeightAccumulation.length - 1];
    }
    const startX = columnWidthAccumulation[startColumn] || 0;
    let endX = columnWidthAccumulation[column];
    if (endX == null) {
      endX = columnWidthAccumulation[columnWidthAccumulation.length - 1];
    }
    return {
      startY,
      endY,
      startX,
      endX
    };
  }
  function getCellByIndex(row, column, rowHeightAccumulation, columnWidthAccumulation, mergeData) {
    let { startY, endY, startX, endX } = getCellPositionByIndex(
      row,
      column,
      rowHeightAccumulation,
      columnWidthAccumulation
    );
    const { isMerged, isMergedMainCell, startRow, startColumn, endRow, endColumn } = getCellInfoInMergeData(
      row,
      column,
      mergeData
    );
    let mergeInfo = {
      startRow,
      startColumn,
      endRow,
      endColumn,
      startY: 0,
      endY: 0,
      startX: 0,
      endX: 0
    };
    const rowAccumulationCount = rowHeightAccumulation.length - 1;
    const columnAccumulationCount = columnWidthAccumulation.length - 1;
    if (isMerged && startRow !== -1 && startColumn !== -1) {
      const mergeStartY = rowHeightAccumulation[startRow - 1] || 0;
      const mergeEndY = rowHeightAccumulation[endRow] || rowHeightAccumulation[rowAccumulationCount];
      const mergeStartX = columnWidthAccumulation[startColumn - 1] || 0;
      const mergeEndX = columnWidthAccumulation[endColumn] || columnWidthAccumulation[columnAccumulationCount];
      mergeInfo = {
        ...mergeInfo,
        startY: mergeStartY,
        endY: mergeEndY,
        startX: mergeStartX,
        endX: mergeEndX
      };
    } else if (!isMerged && endRow !== -1 && endColumn !== -1) {
      const mergeEndY = rowHeightAccumulation[endRow] || rowHeightAccumulation[rowAccumulationCount];
      const mergeEndX = columnWidthAccumulation[endColumn] || columnWidthAccumulation[columnAccumulationCount];
      mergeInfo = {
        ...mergeInfo,
        startY,
        endY: mergeEndY,
        startX,
        endX: mergeEndX
      };
    }
    return {
      isMerged,
      isMergedMainCell,
      actualRow: row,
      actualColumn: column,
      startY,
      endY,
      startX,
      endX,
      mergeInfo
    };
  }
  function getCellInfoInMergeData(row, column, mergeData) {
    let isMerged = false;
    let isMergedMainCell = false;
    let newEndRow = row;
    let newEndColumn = column;
    let mergeRow = row;
    let mergeColumn = column;
    if (mergeData == null) {
      return {
        actualRow: row,
        actualColumn: column,
        isMergedMainCell,
        isMerged,
        endRow: newEndRow,
        endColumn: newEndColumn,
        startRow: mergeRow,
        startColumn: mergeColumn
      };
    }
    for (let i = 0; i < mergeData.length; i++) {
      const {
        startRow: startRowMarge,
        endRow: endRowMarge,
        startColumn: startColumnMarge,
        endColumn: endColumnMarge
      } = mergeData[i];
      if (row === startRowMarge && column === startColumnMarge) {
        newEndRow = endRowMarge;
        newEndColumn = endColumnMarge;
        mergeRow = startRowMarge;
        mergeColumn = startColumnMarge;
        isMergedMainCell = true;
        break;
      }
      if (row >= startRowMarge && row <= endRowMarge && column >= startColumnMarge && column <= endColumnMarge) {
        newEndRow = endRowMarge;
        newEndColumn = endColumnMarge;
        mergeRow = startRowMarge;
        mergeColumn = startColumnMarge;
        isMerged = true;
        break;
      }
    }
    return {
      actualRow: row,
      actualColumn: column,
      isMergedMainCell,
      isMerged,
      endRow: newEndRow,
      endColumn: newEndColumn,
      startRow: mergeRow,
      startColumn: mergeColumn
    };
  }
  function hasUnMergedCellInRow(row, startColumn, endColumn, mergeData) {
    let hasUnMergedCell = false;
    for (let colIndex = startColumn; colIndex <= endColumn; colIndex++) {
      const { isMerged, isMergedMainCell } = getCellInfoInMergeData(row, colIndex, mergeData);
      if (!isMerged && !isMergedMainCell) {
        hasUnMergedCell = true;
        break;
      }
    }
    return hasUnMergedCell;
  }
  function mergeInfoOffset(mergeInfo, offsetX, offsetY) {
    const { startY, endY, startX, endX } = mergeInfo;
    mergeInfo.startY = startY + offsetY;
    mergeInfo.endY = endY + offsetY;
    mergeInfo.startX = startX + offsetX;
    mergeInfo.endX = endX + offsetX;
    return {
      ...mergeInfo
    };
  }
  function isRectIntersect(rect1, rect2) {
    return !(rect1.left > rect2.right || rect1.top > rect2.bottom || rect2.left > rect1.right || rect2.top > rect1.bottom);
  }
  function pxToNum(unit) {
    return Number(unit.replace(/px/gi, ""));
  }
  function getSizeForDom(dom) {
    const style = getComputedStyle(dom);
    const { borderTopWidth, borderLeftWidth, borderRightWidth, borderBottomWidth, width, height } = style;
    return {
      top: pxToNum(borderTopWidth),
      left: pxToNum(borderLeftWidth),
      right: pxToNum(borderRightWidth),
      bottom: pxToNum(borderBottomWidth),
      width: pxToNum(width),
      height: pxToNum(height)
    };
  }

  // ../packages/engine-render/src/basics/vector2.ts
  var Vector2 = class _Vector2 {
    /**
     * Creates a new Vector2 from the given x and y coordinates
     * @param x defines the first coordinate
     * @param y defines the second coordinate
     */
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
    }
    // Statics
    /**
     * Gets a new Vector2(0, 0)
     * @returns a new Vector2
     */
    static Zero() {
      return new _Vector2(0, 0);
    }
    /**
     * Gets a new Vector2(1, 1)
     * @returns a new Vector2
     */
    static One() {
      return new _Vector2(1, 1);
    }
    /**
     * Gets a new Vector2 set from the given index element of the given array
     * @param array defines the data source
     * @param offset defines the offset in the data source
     * @returns a new Vector2
     */
    static FromArray(array, offset = 0) {
      return new _Vector2(array[offset], array[offset + 1]);
    }
    /**
     * Sets "result" from the given index element of the given array
     * @param array defines the data source
     * @param offset defines the offset in the data source
     * @param result defines the target vector
     */
    static FromArrayToRef(array, offset, result) {
      result.x = array[offset];
      result.y = array[offset + 1];
    }
    /**
     * Gets a new Vector2 located for "amount" (float) on the CatmullRom spline defined by the given four Vector2
     * @param value1 defines 1st point of control
     * @param value2 defines 2nd point of control
     * @param value3 defines 3rd point of control
     * @param value4 defines 4th point of control
     * @param amount defines the interpolation factor
     * @returns a new Vector2
     */
    static CatmullRom(value1, value2, value3, value4, amount) {
      const squared = amount * amount;
      const cubed = amount * squared;
      const x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
      const y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
      return new _Vector2(x, y);
    }
    /**
     * Returns a new Vector2 set with same the coordinates than "value" ones if the vector "value" is in the square defined by "min" and "max".
     * If a coordinate of "value" is lower than "min" coordinates, the returned Vector2 is given this "min" coordinate.
     * If a coordinate of "value" is greater than "max" coordinates, the returned Vector2 is given this "max" coordinate
     * @param value defines the value to clamp
     * @param min defines the lower limit
     * @param max defines the upper limit
     * @returns a new Vector2
     */
    static Clamp(value, min, max) {
      let x = value.x;
      x = x > max.x ? max.x : x;
      x = x < min.x ? min.x : x;
      let y = value.y;
      y = y > max.y ? max.y : y;
      y = y < min.y ? min.y : y;
      return new _Vector2(x, y);
    }
    /**
     * Returns a new Vector2 located for "amount" (float) on the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2"
     * @param value1 defines the 1st control point
     * @param tangent1 defines the outgoing tangent
     * @param value2 defines the 2nd control point
     * @param tangent2 defines the incoming tangent
     * @param amount defines the interpolation factor
     * @returns a new Vector2
     */
    static Hermite(value1, tangent1, value2, tangent2, amount) {
      const squared = amount * amount;
      const cubed = amount * squared;
      const part1 = 2 * cubed - 3 * squared + 1;
      const part2 = -2 * cubed + 3 * squared;
      const part3 = cubed - 2 * squared + amount;
      const part4 = cubed - squared;
      const x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
      const y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
      return new _Vector2(x, y);
    }
    /**
     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
     * @param value1 defines the first control point
     * @param tangent1 defines the first tangent
     * @param value2 defines the second control point
     * @param tangent2 defines the second tangent
     * @param time define where the derivative must be done
     * @returns 1st derivative
     */
    static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
      const result = _Vector2.Zero();
      this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
      return result;
    }
    /**
     * Returns a new Vector2 which is the 1st derivative of the Hermite spline defined by the vectors "value1", "value2", "tangent1", "tangent2".
     * @param value1 defines the first control point
     * @param tangent1 defines the first tangent
     * @param value2 defines the second control point
     * @param tangent2 defines the second tangent
     * @param time define where the derivative must be done
     * @param result define where the derivative will be stored
     */
    static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
      const t2 = time * time;
      result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
      result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
    }
    /**
     * Returns a new Vector2 located for "amount" (float) on the linear interpolation between the vector "start" adn the vector "end".
     * @param start defines the start vector
     * @param end defines the end vector
     * @param amount defines the interpolation factor
     * @returns a new Vector2
     */
    static Lerp(start, end, amount) {
      const x = start.x + (end.x - start.x) * amount;
      const y = start.y + (end.y - start.y) * amount;
      return new _Vector2(x, y);
    }
    /**
     * Gets the dot product of the vector "left" and the vector "right"
     * @param left defines first vector
     * @param right defines second vector
     * @returns the dot product (float)
     */
    static Dot(left, right) {
      return left.x * right.x + left.y * right.y;
    }
    /**
     * Returns a new Vector2 equal to the normalized given vector
     * @param vector defines the vector to normalize
     * @returns a new Vector2
     */
    static Normalize(vector) {
      const newVector = _Vector2.Zero();
      this.NormalizeToRef(vector, newVector);
      return newVector;
    }
    /**
     * Normalize a given vector into a second one
     * @param vector defines the vector to normalize
     * @param result defines the vector where to store the result
     */
    static NormalizeToRef(vector, result) {
      const len = vector.length();
      if (len === 0) {
        return;
      }
      result.x = vector.x / len;
      result.y = vector.y / len;
    }
    /**
     * Gets a new Vector2 set with the minimal coordinate values from the "left" and "right" vectors
     * @param left defines 1st vector
     * @param right defines 2nd vector
     * @returns a new Vector2
     */
    static Minimize(left, right) {
      const x = left.x < right.x ? left.x : right.x;
      const y = left.y < right.y ? left.y : right.y;
      return new _Vector2(x, y);
    }
    /**
     * Gets a new Vector2 set with the maximal coordinate values from the "left" and "right" vectors
     * @param left defines 1st vector
     * @param right defines 2nd vector
     * @returns a new Vector2
     */
    static Maximize(left, right) {
      const x = left.x > right.x ? left.x : right.x;
      const y = left.y > right.y ? left.y : right.y;
      return new _Vector2(x, y);
    }
    // /**
    //  * Transforms the given vector coordinates by the given transformation Transform and stores the result in the vector "result" coordinates
    //  * @param vector defines the vector to transform
    //  * @param transformation defines the Transform to apply
    //  * @param result defines the target vector
    //  */
    // static Transform(vector: DeepImmutable<Vector2>, transformation: DeepImmutable<Transform>, ignoreOffset: boolean = false) {
    //     const t = transformation as IKeyValue;
    //     const p = vector;
    //     if (ignoreOffset) {
    //         return new Vector2(t[0] * p.x + t[2] * p.y, t[1] * p.x + t[3] * p.y);
    //     }
    //     return new Vector2(t[0] * p.x + t[2] * p.y + t[4], t[1] * p.x + t[3] * p.y + t[5]);
    // }
    /**
     * Determines if a given vector is included in a triangle
     * @param p defines the vector to test
     * @param p0 defines 1st triangle point
     * @param p1 defines 2nd triangle point
     * @param p2 defines 3rd triangle point
     * @returns true if the point "p" is in the triangle defined by the vectors "p0", "p1", "p2"
     */
    static PointInTriangle(p, p0, p1, p2) {
      const a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
      const sign = a < 0 ? -1 : 1;
      const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
      const t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
      return s > 0 && t > 0 && s + t < 2 * a * sign;
    }
    /**
     * Gets the distance between the vectors "value1" and "value2"
     * @param value1 defines first vector
     * @param value2 defines second vector
     * @returns the distance between vectors
     */
    static Distance(value1, value2) {
      return Math.sqrt(_Vector2.DistanceSquared(value1, value2));
    }
    /**
     * Returns the squared distance between the vectors "value1" and "value2"
     * @param value1 defines first vector
     * @param value2 defines second vector
     * @returns the squared distance between vectors
     */
    static DistanceSquared(value1, value2) {
      const x = value1.x - value2.x;
      const y = value1.y - value2.y;
      return x * x + y * y;
    }
    /**
     * Gets a new Vector2 located at the center of the vectors "value1" and "value2"
     * @param value1 defines first vector
     * @param value2 defines second vector
     * @returns a new Vector2
     */
    static Center(value1, value2) {
      return _Vector2.CenterToRef(value1, value2, _Vector2.Zero());
    }
    /**
     * Gets the center of the vectors "value1" and "value2" and stores the result in the vector "ref"
     * @param value1 defines first vector
     * @param value2 defines second vector
     * @param ref defines third vector
     * @returns ref
     */
    static CenterToRef(value1, value2, ref) {
      return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
    }
    /**
     * Gets the shortest distance (float) between the point "p" and the segment defined by the two points "segA" and "segB".
     * @param p defines the middle point
     * @param segA defines one point of the segment
     * @param segB defines the other point of the segment
     * @returns the shortest distance
     */
    static DistanceOfPointFromSegment(p, segA, segB) {
      const l2 = _Vector2.DistanceSquared(segA, segB);
      if (l2 === 0) {
        return _Vector2.Distance(p, segA);
      }
      const v = segB.subtract(segA);
      const t = Math.max(0, Math.min(1, _Vector2.Dot(p.subtract(segA), v) / l2));
      const proj = segA.add(v.multiplyByFloats(t, t));
      return _Vector2.Distance(p, proj);
    }
    static create(x, y) {
      return new _Vector2(x, y);
    }
    /**
     * Gets a string with the Vector2 coordinates
     * @returns a string with the Vector2 coordinates
     */
    toString() {
      return `{X: ${this.x} Y: ${this.y}}`;
    }
    /**
     * Gets class name
     * @returns the string "Vector2"
     */
    getClassName() {
      return "Vector2";
    }
    /**
     * Gets current vector hash code
     * @returns the Vector2 hash code as a number
     */
    getHashCode() {
      let hash = this.x | 0;
      hash = hash * 397 ^ (this.y | 0);
      return hash;
    }
    // Operators
    /**
     * Sets the Vector2 coordinates in the given array or Float32Array from the given index.
     * @param array defines the source array
     * @param index defines the offset in source array
     * @returns the current Vector2
     */
    toArray(array, index = 0) {
      array[index] = this.x;
      array[index + 1] = this.y;
      return this;
    }
    /**
     * Update the current vector from an array
     * @param array defines the destination array
     * @param index defines the offset in the destination array
     * @returns the current Vector3
     */
    fromArray(array, index = 0) {
      _Vector2.FromArrayToRef(array, index, this);
      return this;
    }
    /**
     * Copy the current vector to an array
     * @returns a new array with 2 elements: the Vector2 coordinates.
     */
    asArray() {
      const result = new Array();
      this.toArray(result, 0);
      return result;
    }
    /**
     * Sets the Vector2 coordinates with the given Vector2 coordinates
     * @param source defines the source Vector2
     * @returns the current updated Vector2
     */
    copyFrom(source) {
      this.x = source.x;
      this.y = source.y;
      return this;
    }
    /**
     * Sets the Vector2 coordinates with the given floats
     * @param x defines the first coordinate
     * @param y defines the second coordinate
     * @returns the current updated Vector2
     */
    copyFromFloats(x, y) {
      this.x = x;
      this.y = y;
      return this;
    }
    /**
     * Sets the Vector2 coordinates with the given floats
     * @param x defines the first coordinate
     * @param y defines the second coordinate
     * @returns the current updated Vector2
     */
    set(x, y) {
      return this.copyFromFloats(x, y);
    }
    /**
     * Add another vector with the current one
     * @param otherVector defines the other vector
     * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates
     */
    add(otherVector) {
      return new _Vector2(this.x + otherVector.x, this.y + otherVector.y);
    }
    /**
     * Sets the "result" coordinates with the addition of the current Vector2 and the given one coordinates
     * @param otherVector defines the other vector
     * @param result defines the target vector
     * @returns the unmodified current Vector2
     */
    addToRef(otherVector, result) {
      result.x = this.x + otherVector.x;
      result.y = this.y + otherVector.y;
      return this;
    }
    addByPoint(x, y) {
      return new _Vector2(this.x + x, this.y + y);
    }
    /**
     * Set the Vector2 coordinates by adding the given Vector2 coordinates
     * @param otherVector defines the other vector
     * @returns the current updated Vector2
     */
    addInPlace(otherVector) {
      this.x += otherVector.x;
      this.y += otherVector.y;
      return this;
    }
    /**
     * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2
     * @param otherVector defines the other vector
     * @returns a new Vector2
     */
    subtract(otherVector) {
      return new _Vector2(this.x - otherVector.x, this.y - otherVector.y);
    }
    subtractByPoint(x, y) {
      return new _Vector2(this.x - x, this.y - y);
    }
    /**
     * Sets the "result" coordinates with the subtraction of the given one from the current Vector2 coordinates.
     * @param otherVector defines the other vector
     * @param result defines the target vector
     * @returns the unmodified current Vector2
     */
    subtractToRef(otherVector, result) {
      result.x = this.x - otherVector.x;
      result.y = this.y - otherVector.y;
      return this;
    }
    /**
     * Sets the current Vector2 coordinates by subtracting from it the given one coordinates
     * @param otherVector defines the other vector
     * @returns the current updated Vector2
     */
    subtractInPlace(otherVector) {
      this.x -= otherVector.x;
      this.y -= otherVector.y;
      return this;
    }
    /**
     * Multiplies in place the current Vector2 coordinates by the given ones
     * @param otherVector defines the other vector
     * @returns the current updated Vector2
     */
    multiplyInPlace(otherVector) {
      this.x *= otherVector.x;
      this.y *= otherVector.y;
      return this;
    }
    /**
     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates
     * @param otherVector defines the other vector
     * @returns a new Vector2
     */
    multiply(otherVector) {
      return new _Vector2(this.x * otherVector.x, this.y * otherVector.y);
    }
    /**
     * Sets "result" coordinates with the multiplication of the current Vector2 and the given one coordinates
     * @param otherVector defines the other vector
     * @param result defines the target vector
     * @returns the unmodified current Vector2
     */
    multiplyToRef(otherVector, result) {
      result.x = this.x * otherVector.x;
      result.y = this.y * otherVector.y;
      return this;
    }
    /**
     * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats
     * @param x defines the first coordinate
     * @param y defines the second coordinate
     * @returns a new Vector2
     */
    multiplyByFloats(x, y) {
      return new _Vector2(this.x * x, this.y * y);
    }
    /**
     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates
     * @param otherVector defines the other vector
     * @returns a new Vector2
     */
    divide(otherVector) {
      return new _Vector2(this.x / otherVector.x, this.y / otherVector.y);
    }
    /**
     * Sets the "result" coordinates with the Vector2 divided by the given one coordinates
     * @param otherVector defines the other vector
     * @param result defines the target vector
     * @returns the unmodified current Vector2
     */
    divideToRef(otherVector, result) {
      result.x = this.x / otherVector.x;
      result.y = this.y / otherVector.y;
      return this;
    }
    /**
     * Divides the current Vector2 coordinates by the given ones
     * @param otherVector defines the other vector
     * @returns the current updated Vector2
     */
    divideInPlace(otherVector) {
      return this.divideToRef(otherVector, this);
    }
    /**
     * Gets a new Vector2 with current Vector2 negated coordinates
     * @returns a new Vector2
     */
    negate() {
      return new _Vector2(-this.x, -this.y);
    }
    /**
     * Negate this vector in place
     * @returns this
     */
    negateInPlace() {
      this.x *= -1;
      this.y *= -1;
      return this;
    }
    /**
     * Negate the current Vector2 and stores the result in the given vector "result" coordinates
     * @param result defines the Vector3 object where to store the result
     * @returns the current Vector2
     */
    negateToRef(result) {
      return result.copyFromFloats(this.x * -1, this.y * -1);
    }
    /**
     * Multiply the Vector2 coordinates by scale
     * @param scale defines the scaling factor
     * @returns the current updated Vector2
     */
    scaleInPlace(scale) {
      this.x *= scale;
      this.y *= scale;
      return this;
    }
    /**
     * Returns a new Vector2 scaled by "scale" from the current Vector2
     * @param scale defines the scaling factor
     * @returns a new Vector2
     */
    scale(scale) {
      const result = new _Vector2(0, 0);
      this.scaleToRef(scale, result);
      return result;
    }
    /**
     * Scale the current Vector2 values by a factor to a given Vector2
     * @param scale defines the scale factor
     * @param result defines the Vector2 object where to store the result
     * @returns the unmodified current Vector2
     */
    scaleToRef(scale, result) {
      result.x = this.x * scale;
      result.y = this.y * scale;
      return this;
    }
    /**
     * Scale the current Vector2 values by a factor and add the result to a given Vector2
     * @param scale defines the scale factor
     * @param result defines the Vector2 object where to store the result
     * @returns the unmodified current Vector2
     */
    scaleAndAddToRef(scale, result) {
      result.x += this.x * scale;
      result.y += this.y * scale;
      return this;
    }
    /**
     * Gets a boolean if two vectors are equals
     * @param otherVector defines the other vector
     * @returns true if the given vector coordinates strictly equal the current Vector2 ones
     */
    equals(otherVector) {
      return otherVector && this.x === otherVector.x && this.y === otherVector.y;
    }
    /**
     * Gets a new Vector2 from current Vector2 floored values
     * eg (1.2, 2.31) returns (1, 2)
     * @returns a new Vector2
     */
    floor() {
      return new _Vector2(Math.floor(this.x), Math.floor(this.y));
    }
    /**
     * Gets a new Vector2 from current Vector2 fractional values
     * eg (1.2, 2.31) returns (0.2, 0.31)
     * @returns a new Vector2
     */
    fract() {
      return new _Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
    }
    /**
     * Rotate the current vector into a given result vector
     * @param angle defines the rotation angle
     * @returns the current vector
     */
    rotate(angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const rx = cos * this.x - sin * this.y;
      const ry = sin * this.x + cos * this.y;
      this.x = rx;
      this.y = ry;
      return this;
    }
    /**
     * Rotate the current vector into a given result vector
     * @param angle defines the rotation angle
     * @param result defines the result vector where to store the rotated vector
     * @returns the current vector
     */
    rotateToRef(angle, result) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      result.x = cos * this.x - sin * this.y;
      result.y = sin * this.x + cos * this.y;
      return this;
    }
    rotateByPoint(angle, originPoint = _Vector2.create(0, 0)) {
      const cosA = Math.cos(angle);
      const sinA = Math.sin(angle);
      const rx = originPoint.x + (this.x - originPoint.x) * cosA - (this.y - originPoint.y) * sinA;
      const ry = originPoint.y + (this.x - originPoint.x) * sinA + (this.y - originPoint.y) * cosA;
      this.x = rx;
      this.y = ry;
      return this;
    }
    transformCoordinateOnRotate(angle) {
      const hypotenuse = Math.sqrt(this.x ** 2 + this.y ** 2);
      const beta = Math.atan2(this.y, this.x);
      const theta = -angle + beta;
      this.x = hypotenuse * Math.cos(theta);
      this.y = hypotenuse * Math.sin(theta);
      return this;
    }
    // Properties
    /**
     * Gets the length of the vector
     * @returns the vector length (float)
     */
    length() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    }
    /**
     * Gets the vector squared length
     * @returns the vector squared length (float)
     */
    lengthSquared() {
      return this.x * this.x + this.y * this.y;
    }
    // Methods
    /**
     * Normalize the vector
     * @returns the current updated Vector2
     */
    normalize() {
      _Vector2.NormalizeToRef(this, this);
      return this;
    }
    /**
     * Gets a new Vector2 copied from the Vector2
     * @returns a new Vector2
     */
    clone() {
      return new _Vector2(this.x, this.y);
    }
  };

  // ../packages/engine-render/src/basics/transform.ts
  var INITIAL_MATRIX = [1, 0, 0, 1, 0, 0];
  var Transform = class _Transform {
    constructor(m = INITIAL_MATRIX) {
      __publicField(this, "dirty", false);
      __publicField(this, "_m");
      this._m = m && m.slice() || INITIAL_MATRIX;
    }
    static create(m = INITIAL_MATRIX) {
      return new this(m);
    }
    reset() {
      this._m[0] = 1;
      this._m[1] = 0;
      this._m[2] = 0;
      this._m[3] = 1;
      this._m[4] = 0;
      this._m[5] = 0;
    }
    /**
     * Copy UniverSheet.Transform object
     * @method
     * @name UniverSheet.Transform#copy
     * @returns {UniverSheet.Transform}
     * @example
     * const tr = shape.getTransform().copy()
     */
    copy() {
      return new _Transform(this._m);
    }
    copyInto(tr) {
      tr._m[0] = this._m[0];
      tr._m[1] = this._m[1];
      tr._m[2] = this._m[2];
      tr._m[3] = this._m[3];
      tr._m[4] = this._m[4];
      tr._m[5] = this._m[5];
    }
    /**
     * Transform point
     * @method
     * @name UniverSheet.Transform#point
     * @param {object} point 2D point(x, y)
     * @returns {object} 2D point(x, y)
     */
    applyPoint(point, ignoreOffset = false) {
      const m = this._m;
      const xNew = m[0] * point.x + m[2] * point.y;
      const yNew = m[1] * point.x + m[3] * point.y;
      if (ignoreOffset) {
        return new Vector2(xNew, yNew);
      }
      return new Vector2(xNew + m[4], yNew + m[5]);
    }
    /**
     * Apply translation
     * @method
     * @name universheet.Transform#translate
     * @param {number} x
     * @param {number} y
     * @returns {UniverSheet.Transform}
     */
    translate(x, y) {
      this._m[4] += this._m[0] * x + this._m[2] * y;
      this._m[5] += this._m[1] * x + this._m[3] * y;
      return this;
    }
    /**
     * Apply scale
     * @method
     * @name UniverSheet.Transform#scale
     * @param {number} sx
     * @param {number} sy
     * @returns {UniverSheet.Transform}
     */
    scale(sx, sy) {
      this._m[0] *= sx;
      this._m[1] *= sx;
      this._m[2] *= sy;
      this._m[3] *= sy;
      return this;
    }
    /**
     * Apply rotation
     * @method
     * @name UniverSheet.Transform#rotate
     * @param {number} Degree  Angle in Degree
     * @returns {UniverSheet.Transform}
     */
    rotate(deg) {
      const rad = degToRad(deg);
      const c = Math.cos(rad);
      const s = Math.sin(rad);
      const m11 = this._m[0] * c + this._m[2] * s;
      const m12 = this._m[1] * c + this._m[3] * s;
      const m21 = this._m[0] * -s + this._m[2] * c;
      const m22 = this._m[1] * -s + this._m[3] * c;
      this._m[0] = m11;
      this._m[1] = m12;
      this._m[2] = m21;
      this._m[3] = m22;
      return this;
    }
    /**
     * Returns the translation
     * @method
     * @name UniverSheet.Transform#getTranslation
     * @returns {object} 2D point(x, y)
     */
    getTranslation() {
      return {
        x: this._m[4],
        y: this._m[5]
      };
    }
    /**
     * Apply skew
     * @method
     * @name UniverSheet.Transform#skew
     * @param {number} sx
     * @param {number} sy
     * @returns {UniverSheet.Transform}
     */
    skew(sx, sy) {
      const m11 = this._m[0] + this._m[2] * sy;
      const m12 = this._m[1] + this._m[3] * sy;
      const m21 = this._m[2] + this._m[0] * sx;
      const m22 = this._m[3] + this._m[1] * sx;
      this._m[0] = m11;
      this._m[1] = m12;
      this._m[2] = m21;
      this._m[3] = m22;
      return this;
    }
    /**
     * Transform multiplication
     * @method
     * @name UniverSheet.Transform#multiply
     * @param {UniverSheet.Transform} matrix
     * @returns {UniverSheet.Transform}
     */
    multiply(matrix) {
      const m11 = this._m[0] * matrix._m[0] + this._m[2] * matrix._m[1];
      const m12 = this._m[1] * matrix._m[0] + this._m[3] * matrix._m[1];
      const m21 = this._m[0] * matrix._m[2] + this._m[2] * matrix._m[3];
      const m22 = this._m[1] * matrix._m[2] + this._m[3] * matrix._m[3];
      const dx = this._m[0] * matrix._m[4] + this._m[2] * matrix._m[5] + this._m[4];
      const dy = this._m[1] * matrix._m[4] + this._m[3] * matrix._m[5] + this._m[5];
      this._m[0] = m11;
      this._m[1] = m12;
      this._m[2] = m21;
      this._m[3] = m22;
      this._m[4] = dx;
      this._m[5] = dy;
      return this;
    }
    /**
     * Invert the matrix
     * @method
     * @name UniverSheet.Transform#invert
     * @returns {UniverSheet.Transform}
     */
    invert() {
      const d = 1 / (this._m[0] * this._m[3] - this._m[1] * this._m[2]);
      const m0 = this._m[3] * d;
      const m1 = -this._m[1] * d;
      const m2 = -this._m[2] * d;
      const m3 = this._m[0] * d;
      const m4 = d * (this._m[2] * this._m[5] - this._m[3] * this._m[4]);
      const m5 = d * (this._m[1] * this._m[4] - this._m[0] * this._m[5]);
      this._m[0] = m0;
      this._m[1] = m1;
      this._m[2] = m2;
      this._m[3] = m3;
      this._m[4] = m4;
      this._m[5] = m5;
      return this;
    }
    /**
     * return matrix
     * @method
     * @name UniverSheet.Transform#getMatrix
     */
    getMatrix() {
      return this._m;
    }
    /**
     * return matrix
     * @method
     * @name UniverSheet.Transform#getMatrix
     */
    getMatrixByAccurate(accurate = 3) {
      return this._m.map((value) => precisionTo(value, accurate));
    }
    /**
     * set to absolute position via translation
     * @method
     * @name UniverSheet.Transform#setAbsolutePosition
     * @returns {UniverSheet.Transform}
     */
    setAbsolutePosition(coord) {
      const m0 = this._m[0];
      const m1 = this._m[1];
      const m2 = this._m[2];
      const m3 = this._m[3];
      const m4 = this._m[4];
      const m5 = this._m[5];
      const yt = (m0 * (coord.y - m5) - m1 * (coord.x - m4)) / (m0 * m3 - m1 * m2);
      const xt = (coord.x - m4 - m2 * yt) / m0;
      return this.translate(xt, yt);
    }
    /**
     * convert transformation matrix back into node's attributes
     * @method
     * @name UniverSheet.Transform#decompose
     * @returns {UniverSheet.Transform}
     */
    decompose() {
      const a = this._m[0];
      const b = this._m[1];
      const c = this._m[2];
      const d = this._m[3];
      const e = this._m[4];
      const f = this._m[5];
      const delta = a * d - b * c;
      const result = {
        x: e,
        y: f,
        angle: 0,
        scaleX: 0,
        scaleY: 0,
        skewX: 0,
        skewY: 0
      };
      if (a !== 0 || b !== 0) {
        const r = Math.sqrt(a * a + b * b);
        result.angle = b > 0 ? Math.acos(a / r) : -Math.acos(a / r);
        result.scaleX = r;
        result.scaleY = delta / r;
        result.skewX = (a * c + b * d) / delta;
        result.skewY = 0;
      } else if (c !== 0 || d !== 0) {
        const s = Math.sqrt(c * c + d * d);
        result.angle = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s));
        result.scaleX = delta / s;
        result.scaleY = s;
        result.skewX = 0;
        result.skewY = (a * c + b * d) / delta;
      } else {
      }
      result.angle = radToDeg(result.angle);
      return result;
    }
    makeBoundingBoxFromPoints(points) {
      if (this) {
        for (let i = 0; i < points.length; i++) {
          points[i] = this.applyPoint(points[i]);
        }
      }
      const xPoints = [points[0].x, points[1].x, points[2].x, points[3].x];
      const minX = Math.min(...xPoints);
      const maxX = Math.max(...xPoints);
      const width = maxX - minX;
      const yPoints = [points[0].y, points[1].y, points[2].y, points[3].y];
      const minY = Math.min(...yPoints);
      const maxY = Math.max(...yPoints);
      const height = maxY - minY;
      return {
        left: minX,
        top: minY,
        width,
        height,
        points
      };
    }
    composeMatrix(options) {
      const matrix = new _Transform([1, 0, 0, 1, options.left || 0, options.top || 0]);
      if (options.angle) {
        matrix.rotate(options.angle);
      }
      if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {
        matrix.multiply(this._calcDimensionsMatrix(options));
      }
      this._m = matrix.getMatrix();
      return this;
    }
    clone() {
      return new _Transform([...this._m]);
    }
    /**
     * Returns a transform matrix starting from an object of the same kind of
     * the one returned from qrDecompose, useful also if you want to calculate some
     * transformations from an object that is not enLived yet.
     * is called DimensionsTransformMatrix because those properties are the one that influence
     * the size of the resulting box of the object.
     * @param  {object} options
     * @param  {number} [options.scaleX]
     * @param  {number} [options.scaleY]
     * @param  {boolean} [options.flipX]
     * @param  {boolean} [options.flipY]
     * @param  {number} [options.skewX]
     * @param  {number} [options.skewX]
     * @return {number[]} transform matrix
     */
    _calcDimensionsMatrix(options) {
      var _a2, _b2;
      const scaleX = (_a2 = options.scaleX) != null ? _a2 : 1;
      const scaleY = (_b2 = options.scaleY) != null ? _b2 : 1;
      const scaleMatrix = new _Transform([
        options.flipX ? -scaleX : scaleX,
        0,
        0,
        options.flipY ? -scaleY : scaleY,
        0,
        0
      ]);
      if (options.skewX) {
        scaleMatrix.multiply(new _Transform([1, 0, Math.tan(degToRad(options.skewX)), 1, 0, 0]));
      }
      if (options.skewY) {
        scaleMatrix.multiply(new _Transform([1, Math.tan(degToRad(options.skewY)), 0, 1, 0, 0]));
      }
      return scaleMatrix;
    }
    // static createTransformByState(state: positionState) {
    //     const newTr = new this();
    //     let { x, y, angle, scaleX, scaleY, skewX, skewY, flipX, flipY } = state;
    //     x = x ?? 0;
    //     y = y ?? 0;
    //     newTr.translate(x, y);
    //     if (angle) {
    //         newTr.rotate(angle);
    //     }
    //     scaleX = scaleX ?? 1;
    //     scaleY = scaleY ?? 1;
    //     newTr.scale(scaleX, scaleY);
    //     return newTr;
    // }
  };

  // ../packages/engine-render/src/base-object.ts
  var BASE_OBJECT_ARRAY = [
    "top",
    "left",
    "width",
    "height",
    "angle",
    "scaleX",
    "scaleY",
    "skewX",
    "skewY",
    "flipX",
    "flipY",
    "strokeWidth"
  ];
  var BaseObject = class {
    // TODO: @DR-Univer. Belong to layer
    constructor(key) {
      __publicField(this, "groupKey");
      __publicField(this, "isInGroup", false);
      __publicField(this, "onTransformChangeObservable", new Observable2());
      __publicField(this, "onPointerDownObserver", new Observable2());
      __publicField(this, "onPointerMoveObserver", new Observable2());
      __publicField(this, "onPointerUpObserver", new Observable2());
      __publicField(this, "onDblclickObserver", new Observable2());
      __publicField(this, "onTripleClickObserver", new Observable2());
      __publicField(this, "onMouseWheelObserver", new Observable2());
      // onKeyDownObservable = new Observable<IKeyboardEvent>();
      // onKeyUpObservable = new Observable<IKeyboardEvent>();
      __publicField(this, "onPointerOutObserver", new Observable2());
      __publicField(this, "onPointerLeaveObserver", new Observable2());
      __publicField(this, "onPointerOverObserver", new Observable2());
      __publicField(this, "onPointerEnterObserver", new Observable2());
      __publicField(this, "onIsAddedToParentObserver", new Observable2());
      __publicField(this, "onDisposeObserver", new Observable2());
      __publicField(this, "_oKey");
      __publicField(this, "_dirty", true);
      __publicField(this, "_top", 0);
      __publicField(this, "_topOrigin", 0);
      __publicField(this, "_left", 0);
      __publicField(this, "_leftOrigin", 0);
      __publicField(this, "_width", 0);
      __publicField(this, "_widthOrigin", 0);
      __publicField(this, "_height", 0);
      __publicField(this, "_heightOrigin", 0);
      __publicField(this, "_angle", 0);
      __publicField(this, "_scaleX", 1);
      __publicField(this, "_scaleY", 1);
      __publicField(this, "_skewX", 0);
      __publicField(this, "_skewY", 0);
      __publicField(this, "_flipX", false);
      __publicField(this, "_flipY", false);
      __publicField(this, "_strokeWidth", 0);
      __publicField(this, "_parent");
      // TODO: @DR-Univer. The object must be mounted to a scene or group. 'Any' is used here to avoid circular dependencies. This will be resolved later through dependency injection.
      __publicField(this, "_zIndex", 0);
      __publicField(this, "_evented", true);
      __publicField(this, "_visible", true);
      __publicField(this, "_debounceParentDirty", true);
      __publicField(this, "_transform", new Transform());
      __publicField(this, "_cursor", "default" /* DEFAULT */);
      __publicField(this, "_isTransformer", false);
      __publicField(this, "_forceRender", false);
      __publicField(this, "_layer");
      if (key) {
        this._oKey = key;
      } else {
        this._oKey = generateRandomKey();
      }
    }
    get transform() {
      return this._transform;
    }
    get topOrigin() {
      return this._topOrigin;
    }
    get leftOrigin() {
      return this._leftOrigin;
    }
    get widthOrigin() {
      return this._widthOrigin;
    }
    get heightOrigin() {
      return this._heightOrigin;
    }
    get classType() {
      return "BaseObject" /* BASE_OBJECT */;
    }
    get top() {
      return this._top;
    }
    get left() {
      return this._left;
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get strokeWidth() {
      return this._strokeWidth;
    }
    get angle() {
      return this._angle;
    }
    get scaleX() {
      return this._scaleX;
    }
    get scaleY() {
      return this._scaleY;
    }
    get ancestorScaleX() {
      var _a2;
      const pScale = ((_a2 = this.getParent()) == null ? void 0 : _a2.ancestorScaleX) || 1;
      return this.scaleX * pScale;
    }
    get ancestorScaleY() {
      var _a2;
      const pScale = ((_a2 = this.getParent()) == null ? void 0 : _a2.ancestorScaleY) || 1;
      return this.scaleY * pScale;
    }
    get skewX() {
      return this._skewX;
    }
    get skewY() {
      return this._skewY;
    }
    get flipX() {
      return this._flipX;
    }
    get flipY() {
      return this._flipY;
    }
    get parent() {
      return this._parent;
    }
    get oKey() {
      return this._oKey;
    }
    get zIndex() {
      return this._zIndex;
    }
    get evented() {
      return this._evented;
    }
    get visible() {
      return this._visible;
    }
    get debounceParentDirty() {
      return this._debounceParentDirty;
    }
    get isTransformer() {
      return this._isTransformer;
    }
    get cursor() {
      return this._cursor;
    }
    get layer() {
      return this._layer;
    }
    set transform(trans) {
      this._transform = trans;
    }
    set zIndex(index) {
      this._zIndex = index;
    }
    set parent(o) {
      this._parent = o;
    }
    set evented(state) {
      this._evented = state;
    }
    set debounceParentDirty(state) {
      this._debounceParentDirty = state;
    }
    set isTransformer(state) {
      this._isTransformer = state;
    }
    set cursor(val) {
      this.setCursor(val);
    }
    set layer(layer) {
      this._layer = layer;
    }
    set top(num) {
      var _a2;
      this._topOrigin = num;
      this._top = toPx(num, (_a2 = this._parent) == null ? void 0 : _a2.height);
    }
    set left(num) {
      var _a2;
      this._leftOrigin = num;
      this._left = toPx(num, (_a2 = this._parent) == null ? void 0 : _a2.width);
    }
    set width(num) {
      var _a2;
      this._widthOrigin = num;
      this._width = toPx(num, (_a2 = this._parent) == null ? void 0 : _a2.width);
    }
    set height(num) {
      var _a2;
      this._heightOrigin = num;
      this._height = toPx(num, (_a2 = this._parent) == null ? void 0 : _a2.height);
    }
    set strokeWidth(width) {
      this._strokeWidth = width;
    }
    set angle(angle) {
      this._angle = angle;
    }
    set scaleX(scaleX) {
      this._scaleX = scaleX;
    }
    set scaleY(scaleY) {
      this._scaleY = scaleY;
    }
    set skewX(skewX) {
      this._skewX = skewX;
    }
    set flipY(flipY) {
      this._flipY = flipY;
    }
    set flipX(flipX) {
      this._flipX = flipX;
    }
    set skewY(skewY) {
      this._skewY = skewY;
    }
    makeDirty(state = true) {
      this._dirty = state;
      if (state) {
        if (this._layer == null) {
          this._dirty = false;
          return;
        }
        if (typeof this._layer.debounceParentTimeout === "function") {
          this._layer.debounceParentTimeout();
        }
        this._layer.debounceParentTimeout = requestImmediateMacroTask(() => {
          var _a2;
          (_a2 = this._layer) == null ? void 0 : _a2.makeDirty(state);
        });
      }
      return this;
    }
    makeDirtyNoDebounce(state = true) {
      var _a2;
      this._dirty = state;
      if (state) {
        (_a2 = this._layer) == null ? void 0 : _a2.makeDirty(state);
      }
      return this;
    }
    isDirty() {
      return this._dirty;
    }
    translate(x, y) {
      const preTop = this.top;
      if (y !== void 0) {
        this.top = y;
      }
      const preLeft = this.left;
      if (x !== void 0) {
        this.left = x;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 0 /* translate */,
        value: { top: this._top, left: this._left },
        preValue: { top: preTop, left: preLeft }
      });
      return this;
    }
    resize(width, height) {
      const preWidth = this.width;
      if (width !== void 0) {
        this.width = width;
      }
      const preHeight = this.height;
      if (height !== void 0) {
        this.height = height;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 1 /* resize */,
        value: { width: this._width, height: this._height },
        preValue: { width: preWidth, height: preHeight }
      });
      return this;
    }
    scale(scaleX, scaleY) {
      const preScaleX = this.scaleX;
      if (scaleX !== void 0) {
        this.scaleX = scaleX;
      }
      const preScaleY = this.scaleY;
      if (scaleY !== void 0) {
        this.scaleY = scaleY;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 2 /* scale */,
        value: { scaleX: this._scaleX, scaleY: this._scaleY },
        preValue: { scaleX: preScaleX, scaleY: preScaleY }
      });
      return this;
    }
    skew(skewX, skewY) {
      const preSkewX = skewX;
      if (skewX !== void 0) {
        this.skewX = skewX;
      }
      const preSkewY = skewY;
      if (skewY !== void 0) {
        this.skewY = skewY;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 3 /* skew */,
        value: { skewX: this._skewX, skewY: this._skewY },
        preValue: { skewX: preSkewX, skewY: preSkewY }
      });
      return this;
    }
    flip(flipX, flipY) {
      const preFlipX = flipX;
      if (flipX !== void 0) {
        this.flipX = flipX;
      }
      const preFlipY = flipY;
      if (flipY !== void 0) {
        this.flipY = flipY;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 4 /* flip */,
        value: { flipX: this._flipX, flipY: this._flipY },
        preValue: { flipX: preFlipX, flipY: preFlipY }
      });
      return this;
    }
    transformByState(option) {
      const optionKeys = Object.keys(option);
      const preKeys = {};
      if (optionKeys.length === 0) {
        return;
      }
      optionKeys.forEach((pKey) => {
        if (option[pKey] !== void 0) {
          preKeys[pKey] = this[pKey];
          this[pKey] = option[pKey];
        }
      });
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 5 /* all */,
        value: option,
        preValue: preKeys
      });
      return this;
    }
    isRender(bounds) {
      if (this._forceRender) {
        return false;
      }
      return bounds && !this.isInGroup;
    }
    getParent() {
      return this._parent;
    }
    getState() {
      return {
        left: this.left,
        top: this.top,
        width: this.width,
        height: this.height,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        angle: this.angle,
        skewX: this.skewX,
        skewY: this.skewY,
        flipX: this.flipX,
        flipY: this.flipY
      };
    }
    hide() {
      this._visible = false;
      this._makeDirtyMix();
    }
    show() {
      this._visible = true;
      this._makeDirtyMix();
    }
    render(ctx, bounds) {
    }
    isHit(coord) {
      const oCoord = this._getInverseCoord(coord);
      if (oCoord.x >= -this.strokeWidth / 2 && oCoord.x <= this.width + this.strokeWidth / 2 && oCoord.y >= -this.strokeWidth / 2 && oCoord.y <= this.height + this.strokeWidth / 2) {
        return true;
      }
      return false;
    }
    on(eventType, func) {
      const observable2 = this[`on${eventType}Observer`];
      const observer = observable2.add(func.bind(this));
      return observer;
    }
    off(eventType, observer) {
      const observable2 = this[`on${eventType}Observer`];
      observable2.remove(observer);
    }
    clear(eventType) {
      const observable2 = this[`on${eventType}Observer`];
      observable2.clear();
    }
    triggerPointerMove(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerMoveObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerMove(evt);
        return false;
      }
      return true;
    }
    triggerPointerDown(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerDownObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerDown(evt);
        return false;
      }
      return true;
    }
    triggerPointerUp(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerUpObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerUp(evt);
        return false;
      }
      return true;
    }
    triggerDblclick(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onDblclickObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerDblclick(evt);
        return false;
      }
      return true;
    }
    triggerTripleClick(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onTripleClickObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerTripleClick(evt);
        return false;
      }
      return true;
    }
    triggerMouseWheel(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onMouseWheelObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerMouseWheel(evt);
        return false;
      }
      return true;
    }
    // triggerKeyDown(evt: IKeyboardEvent) {
    //     // this.onKeyDownObservable.notifyObservers(evt);
    //     this._parent?.triggerKeyDown(evt);
    // }
    // triggerKeyUp(evt: IKeyboardEvent) {
    //     // this.onKeyUpObservable.notifyObservers(evt);
    //     this._parent?.triggerKeyUp(evt);
    // }
    triggerPointerOut(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerOutObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerOut(evt);
        return false;
      }
      return true;
    }
    triggerPointerLeave(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerLeaveObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerLeave(evt);
        return false;
      }
      return true;
    }
    triggerPointerOver(evt) {
      var _a2;
      if (!this.onPointerOverObserver.notifyObservers(evt)) {
        (_a2 = this._parent) == null ? void 0 : _a2.triggerPointerOver(evt);
        return false;
      }
      return true;
    }
    triggerPointerEnter(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerEnterObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation)) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerEnter(evt);
        return false;
      }
      return true;
    }
    dispose() {
      var _a2;
      this.onTransformChangeObservable.clear();
      this.onPointerDownObserver.clear();
      this.onPointerMoveObserver.clear();
      this.onPointerUpObserver.clear();
      this.onMouseWheelObserver.clear();
      this.onPointerOutObserver.clear();
      this.onPointerLeaveObserver.clear();
      this.onPointerOverObserver.clear();
      this.onPointerEnterObserver.clear();
      this.onDblclickObserver.clear();
      this.onTripleClickObserver.clear();
      this.onIsAddedToParentObserver.clear();
      (_a2 = this.parent) == null ? void 0 : _a2.removeObject(this);
      this.onDisposeObserver.notifyObservers(this);
      this._makeDirtyMix();
      this.onDisposeObserver.clear();
    }
    toJson() {
      const props = {};
      BASE_OBJECT_ARRAY.forEach((key) => {
        if (this[key]) {
          props[key] = this[key];
        }
      });
      return props;
    }
    getScene() {
      let parent = this.parent;
      if (parent == null) {
        return;
      }
      if (parent.classType === "Scene" /* SCENE */) {
        return parent;
      }
      while (parent) {
        if (parent.classType === "Scene" /* SCENE */) {
          return parent;
        }
        parent = parent.getParent();
      }
    }
    resetCursor() {
      var _a2;
      (_a2 = this.getScene()) == null ? void 0 : _a2.resetCursor();
    }
    setCursor(val) {
      var _a2;
      this._cursor = val;
      (_a2 = this.getScene()) == null ? void 0 : _a2.setCursor(val);
    }
    getEngine() {
      let parent = this.getParent();
      while (parent != null) {
        if (parent.classType === "Engine" /* ENGINE */) {
          return parent;
        }
        parent = parent.getParent();
      }
      return null;
    }
    getObjects() {
      return [];
    }
    _getInverseCoord(coord) {
      return this._transform.clone().invert().applyPoint(coord);
    }
    _setTransForm() {
      const composeResult = Transform.create().composeMatrix({
        left: this.left + this.strokeWidth / 2,
        top: this.top + this.strokeWidth / 2,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        angle: this.angle,
        skewX: this.skewX,
        skewY: this.skewY,
        flipX: this.flipX,
        flipY: this.flipY
      });
      this.transform = composeResult;
      this._makeDirtyMix();
    }
    _makeDirtyMix() {
      if (this.debounceParentDirty) {
        this.makeDirty(true);
      } else {
        this.makeDirtyNoDebounce(true);
      }
    }
  };

  // ../packages/engine-render/src/basics/draw.ts
  function getDevicePixelRatio() {
    let _pixelRatio = 1;
    const canvas = createCanvasElement();
    const context2 = canvas.getContext("2d");
    _pixelRatio = (() => {
      const devicePixelRatio = window.devicePixelRatio || 1;
      const backingStoreRatio = context2.webkitBackingStorePixelRatio || context2.mozBackingStorePixelRatio || context2.msBackingStorePixelRatio || context2.oBackingStorePixelRatio || context2.backingStorePixelRatio || 1;
      return devicePixelRatio / backingStoreRatio;
    })();
    if (_pixelRatio < 1) {
      return 1;
    }
    return _pixelRatio;
  }
  function drawLineByBorderType(ctx, type, lineWidthBuffer, position) {
    let drawStartX = 0;
    let drawStartY = 0;
    let drawEndX = 0;
    let drawEndY = 0;
    const { startX, startY, endX, endY } = position;
    if (type === "t" /* TOP */) {
      drawStartX = startX - lineWidthBuffer;
      drawStartY = startY;
      drawEndX = endX + lineWidthBuffer;
      drawEndY = startY;
    } else if (type === "b" /* BOTTOM */) {
      drawStartX = startX - lineWidthBuffer;
      drawStartY = endY;
      drawEndX = endX - lineWidthBuffer;
      drawEndY = endY;
    } else if (type === "l" /* LEFT */) {
      drawStartX = startX;
      drawStartY = startY - lineWidthBuffer;
      drawEndX = startX;
      drawEndY = endY + lineWidthBuffer;
    } else if (type === "r" /* RIGHT */) {
      drawStartX = endX;
      drawStartY = startY - lineWidthBuffer;
      drawEndX = endX;
      drawEndY = endY + lineWidthBuffer;
    }
    ctx.beginPath();
    ctx.moveToByPrecision(drawStartX, drawStartY);
    ctx.lineToByPrecision(drawEndX, drawEndY);
    ctx.closePathByEnv();
    ctx.stroke();
  }
  function drawDiagonalLineByBorderType(ctx, type, position) {
    let drawStartX = 0;
    let drawStartY = 0;
    let drawEndX = 0;
    let drawEndY = 0;
    const { startX, startY, endX, endY } = position;
    if (type === "tl_br" /* TL_BR */) {
      drawStartX = startX;
      drawStartY = startY;
      drawEndX = endX;
      drawEndY = endY;
    } else if (type === "tl_bc" /* TL_BC */) {
      drawStartX = startX;
      drawStartY = startY;
      drawEndX = (startX + endX) / 2;
      drawEndY = endY;
    } else if (type === "tl_mr" /* TL_MR */) {
      drawStartX = startX;
      drawStartY = startY;
      drawEndX = endX;
      drawEndY = (startY + endY) / 2;
    } else if (type === "bl_tr" /* BL_TR */) {
      drawStartX = startX;
      drawStartY = endY;
      drawEndX = endX;
      drawEndY = startY;
    } else if (type === "ml_tr" /* ML_TR */) {
      drawStartX = startX;
      drawStartY = (startY + endY) / 2;
      drawEndX = endX;
      drawEndY = startY;
    } else if (type === "bc_tr" /* BC_TR */) {
      drawStartX = (startX + endX) / 2;
      drawStartY = endY;
      drawEndX = endX;
      drawEndY = startY;
    }
    ctx.beginPath();
    ctx.moveToByPrecision(drawStartX, drawStartY);
    ctx.lineToByPrecision(drawEndX, drawEndY);
    ctx.closePathByEnv();
    ctx.stroke();
  }
  function setLineType(ctx, style) {
    if (style === 2 /* HAIR */) {
      ctx.setLineDash([1, 2]);
    } else if (style === 6 /* DASH_DOT_DOT */ || style === 11 /* MEDIUM_DASH_DOT_DOT */) {
      ctx.setLineDash([2, 2, 5, 2, 2]);
    } else if (style === 5 /* DASH_DOT */ || style === 10 /* MEDIUM_DASH_DOT */ || style === 12 /* SLANT_DASH_DOT */) {
      ctx.setLineDash([2, 5, 2]);
    } else if (style === 3 /* DOTTED */) {
      ctx.setLineDash([2]);
    } else if (style === 4 /* DASHED */ || style === 9 /* MEDIUM_DASHED */) {
      ctx.setLineDash([3]);
    } else {
      ctx.setLineDash([0]);
    }
  }
  function getLineWidth(style) {
    let lineWidth = 1;
    if (style === 8 /* MEDIUM */ || style === 10 /* MEDIUM_DASH_DOT */ || style === 9 /* MEDIUM_DASHED */ || style === 11 /* MEDIUM_DASH_DOT_DOT */) {
      lineWidth = 2;
    } else if (style === 13 /* THICK */) {
      lineWidth = 3;
    }
    return lineWidth;
  }
  function calculateRectRotate(startPoint, centerPoint, radiusCenter, radiusVertex, offsetPoint = Vector2.create(0, 0)) {
    const rotationVector = startPoint.add(centerPoint).rotateByPoint(radiusVertex);
    const newVector = rotationVector.subtract(centerPoint);
    const finalAngle = radiusVertex - radiusCenter;
    const finalXY = newVector.rotateByPoint(finalAngle, rotationVector);
    const newXY = finalXY.add(offsetPoint).transformCoordinateOnRotate(finalAngle);
    return newXY;
  }
  function getRotateOrientation(angle) {
    return angle > 0 ? 1 /* DOWN */ : 0 /* UP */;
  }
  function getRotateOffsetAndFarthestHypotenuse(lines, rectWidth, vertexAngle) {
    var _a2;
    const rotateTranslateXList = [];
    let rotateTranslateY = 0;
    let rotatedHeight = 0;
    let rotatedWidth = 0;
    let fixOffsetX = 0;
    let fixOffsetY = 0;
    const orientation = getRotateOrientation(vertexAngle);
    const linesCount = lines.length;
    vertexAngle = Math.abs(vertexAngle);
    const tanTheta = Math.tan(vertexAngle);
    const sinTheta = Math.sin(vertexAngle);
    const cosTheta = Math.cos(vertexAngle);
    if (orientation === 0 /* UP */) {
      let cumRectHeight = 0;
      for (let i = 0; i < linesCount; i++) {
        const line = lines[i];
        const { lineHeight: rectHeight = 0 } = line;
        cumRectHeight += i === 0 ? 0 : rectHeight;
        const currentRotateHeight = rectWidth * sinTheta + rectHeight * cosTheta;
        rotateTranslateXList.push(cumRectHeight / tanTheta);
        if (currentRotateHeight > rotatedHeight) {
          rotatedHeight = currentRotateHeight;
        }
        if (i === 0) {
          rotatedWidth += rectHeight * sinTheta;
          fixOffsetY += rectHeight * cosTheta;
        }
      }
      rotatedWidth += cumRectHeight / sinTheta + rectWidth * cosTheta;
      fixOffsetY -= rotatedHeight;
    } else {
      let maxOffsetX = 0;
      let maxOffsetLineIndex = -1;
      const rotateOffsetXList = [];
      for (let i = linesCount - 1; i >= 0; i--) {
        const line = lines[i];
        const { lineHeight: rectHeight = 0 } = line;
        const offsetX = rectHeight / tanTheta;
        const currentRotateHeight = (rectWidth + offsetX) * sinTheta;
        rotateOffsetXList.unshift(rectHeight / tanTheta);
        if (currentRotateHeight > rotatedHeight) {
          rotatedHeight = currentRotateHeight;
          maxOffsetX = offsetX;
          maxOffsetLineIndex = i;
        }
        if (i === 0) {
          rotatedWidth += rectHeight * sinTheta;
        } else if (i === linesCount - 1) {
          rotatedWidth += rectWidth * cosTheta + rectHeight / sinTheta;
        } else {
          rotatedWidth += rectHeight / sinTheta;
        }
      }
      let cumRotateHeightFix = ((_a2 = lines[maxOffsetLineIndex]) == null ? void 0 : _a2.lineHeight) || 0;
      let cumBlowValue = 0;
      for (let i = maxOffsetLineIndex + 1; i <= linesCount - 1; i++) {
        const line = lines[i];
        const { lineHeight: rectHeight = 0 } = line;
        cumRotateHeightFix += rectHeight;
        cumBlowValue += rotateOffsetXList[i] || 0;
        rotateTranslateXList[i] = -cumBlowValue;
      }
      cumBlowValue = 0;
      for (let i = maxOffsetLineIndex - 1; i >= 0; i--) {
        const line = lines[i];
        const { lineHeight: rectHeight = 0 } = line;
        cumBlowValue += rotateOffsetXList[i + 1] || 0;
        rotateTranslateXList[i] = cumBlowValue;
        rotateTranslateY += rectHeight;
      }
      rotateTranslateXList[maxOffsetLineIndex] = 0;
      if (linesCount === 1) {
        rotatedWidth += rectWidth * cosTheta;
      }
      fixOffsetX = cumRotateHeightFix / sinTheta - maxOffsetX * cosTheta;
    }
    return {
      rotateTranslateXList,
      rotatedHeight,
      rotatedWidth,
      fixOffsetX,
      fixOffsetY,
      rotateTranslateY
    };
  }

  // ../packages/engine-render/src/basics/path2.ts
  var INITIAL_Path2 = [new Vector2(0, 0), new Vector2(1, 1)];
  var Path2 = class {
    constructor(_lines = INITIAL_Path2) {
      this._lines = _lines;
    }
    intersection(lines) {
      if (this._lines.length < 1 || lines.length < 1) {
        return;
      }
      const crossPoint = [];
      for (let o = 1; o < this._lines.length; o++) {
        const from2 = this._lines[o - 1];
        const to = this._lines[o];
        for (let n = 1; n < lines.length; n++) {
          const contrastFrom = this._lines[o - 1];
          const contrastTo = this._lines[o];
          const point = this._intersection(
            {
              from: from2,
              to
            },
            {
              from: contrastFrom,
              to: contrastTo
            }
          );
          if (point) {
            crossPoint.push(point);
          }
        }
      }
      return crossPoint;
    }
    _intersection(line1, line2) {
      const a = line1.from;
      const b = line1.to;
      const c = line2.from;
      const d = line2.to;
      const area_abc = (a.x - c.x) * (b.y - c.y) - (a.y - c.y) * (b.x - c.x);
      const area_abd = (a.x - d.x) * (b.y - d.y) - (a.y - d.y) * (b.x - d.x);
      if (area_abc * area_abd >= 0) {
        return false;
      }
      const area_cda = (c.x - a.x) * (d.y - a.y) - (c.y - a.y) * (d.x - a.x);
      const area_cdb = area_cda + area_abc - area_abd;
      if (area_cda * area_cdb >= 0) {
        return false;
      }
      const t = area_cda / (area_abd - area_abc);
      const dx = t * (b.x - a.x);
      const dy = t * (b.y - a.y);
      return new Vector2(a.x + dx, a.y + dy);
    }
  };

  // ../packages/engine-render/src/basics/performance-monitor.ts
  var PerformanceMonitor = class {
    /**
     * constructor
     * @param frameSampleSize The number of samples required to saturate the sliding window
     */
    constructor(frameSampleSize = 30) {
      __publicField(this, "_enabled", true);
      __publicField(this, "_rollingFrameTime");
      __publicField(this, "_lastFrameTimeMs");
      this._rollingFrameTime = new RollingAverage(frameSampleSize);
    }
    /**
     * Returns the average frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
     */
    get averageFrameTime() {
      return this._rollingFrameTime.average;
    }
    /**
     * Returns the variance frame time in milliseconds over the sliding window (or the subset of frames sampled so far)
     */
    get averageFrameTimeVariance() {
      return this._rollingFrameTime.variance;
    }
    /**
     * Returns the frame time of the most recent frame
     */
    get instantaneousFrameTime() {
      return this._rollingFrameTime.history(0);
    }
    /**
     * Returns the average framerate in frames per second over the sliding window (or the subset of frames sampled so far)
     */
    get averageFPS() {
      return 1e3 / this._rollingFrameTime.average;
    }
    /**
     * Returns the average framerate in frames per second using the most recent frame time
     */
    get instantaneousFPS() {
      const history = this._rollingFrameTime.history(0);
      if (history === 0) {
        return 0;
      }
      return 1e3 / history;
    }
    /**
     * Returns true if enough samples have been taken to completely fill the sliding window
     */
    get isSaturated() {
      return this._rollingFrameTime.isSaturated();
    }
    /**
     * Returns true if sampling is enabled
     */
    get isEnabled() {
      return this._enabled;
    }
    /**
     * Samples current frame
     * @param timeMs A timestamp in milliseconds of the current frame to compare with other frames
     */
    sampleFrame(timeMs = this.Now()) {
      if (!this._enabled) {
        return;
      }
      if (this._lastFrameTimeMs != null) {
        const dt = timeMs - this._lastFrameTimeMs;
        this._rollingFrameTime.add(dt);
      }
      this._lastFrameTimeMs = timeMs;
    }
    Now() {
      if (performance && performance.now) {
        return performance.now();
      }
      return Date.now();
    }
    /**
     * Enables contributions to the sliding window sample set
     */
    enable() {
      this._enabled = true;
    }
    /**
     * Disables contributions to the sliding window sample set
     * Samples will not be interpolated over the disabled period
     */
    disable() {
      this._enabled = false;
      this._lastFrameTimeMs = null;
    }
    /**
     * Resets performance monitor
     */
    reset() {
      this._lastFrameTimeMs = null;
      this._rollingFrameTime.reset();
    }
  };
  var RollingAverage = class {
    // sum of squares of differences from the (current) mean
    /**
     * constructor
     * @param length The number of samples required to saturate the sliding window
     */
    constructor(length) {
      /**
       * Current average
       */
      __publicField(this, "average", 0);
      /**
       * Current variance
       */
      __publicField(this, "variance", 0);
      __publicField(this, "_samples", []);
      __publicField(this, "_sampleCount", 0);
      __publicField(this, "_pos", 0);
      __publicField(this, "_m2", 0);
      this._samples = new Array(length);
      this.reset();
    }
    /**
     * Adds a sample to the sample set
     * @param v The sample value
     */
    add(v) {
      let delta;
      if (this.isSaturated()) {
        const bottomValue = this._samples[this._pos];
        delta = bottomValue - this.average;
        this.average -= delta / (this._sampleCount - 1);
        this._m2 -= delta * (bottomValue - this.average);
      } else {
        this._sampleCount++;
      }
      delta = v - this.average;
      this.average += delta / this._sampleCount;
      this._m2 += delta * (v - this.average);
      this.variance = this._m2 / (this._sampleCount - 1);
      this._samples[this._pos] = v;
      this._pos++;
      this._pos %= this._samples.length;
    }
    /**
     * Returns previously added values or null if outside of history or outside the sliding window domain
     * @param i Index in history. For example, pass 0 for the most recent value and 1 for the value before that
     * @return Value previously recorded with add() or null if outside of range
     */
    history(i) {
      if (i >= this._sampleCount || i >= this._samples.length) {
        return 0;
      }
      const i0 = this._wrapPosition(this._pos - 1);
      return this._samples[this._wrapPosition(i0 - i)];
    }
    /**
     * Returns true if enough samples have been taken to completely fill the sliding window
     * @return true if sample-set saturated
     */
    isSaturated() {
      return this._sampleCount >= this._samples.length;
    }
    /**
     * Resets the rolling average (equivalent to 0 samples taken so far)
     */
    reset() {
      this.average = 0;
      this.variance = 0;
      this._sampleCount = 0;
      this._pos = 0;
      this._m2 = 0;
    }
    /**
     * Wraps a value around the sample range boundaries
     * @param i Position in sample range, for example if the sample length is 5, and i is -3, then 2 will be returned.
     * @return Wrapped position in sample range
     */
    _wrapPosition(i) {
      const max = this._samples.length;
      return (i % max + max) % max;
    }
  };

  // ../packages/engine-render/src/basics/range.ts
  var NORMAL_TEXT_SELECTION_PLUGIN_STYLE = {
    strokeWidth: 1,
    stroke: "rgba(0, 0, 0, 0)",
    strokeActive: "rgba(0, 0, 0, 1)",
    fill: "rgba(0, 0, 0, 0.2)"
  };

  // ../packages/engine-render/src/basics/scroll-xy.ts
  function getCurrentScrollXY(scrollTimer) {
    const scene = scrollTimer.getScene();
    const viewport = scrollTimer.getViewportByCoord(scene);
    const scrollX2 = 0;
    const scrollY2 = 0;
    if (!viewport) {
      return {
        scrollX: scrollX2,
        scrollY: scrollY2
      };
    }
    const actualScroll = viewport.getActualScroll(viewport.scrollX, viewport.scrollY);
    return {
      scrollX: actualScroll.x,
      scrollY: actualScroll.y
    };
  }

  // ../packages/engine-render/src/basics/text-rotation.ts
  var VERTICAL_ROTATE_ANGLE = 90;
  function convertTextRotation(textRotation) {
    const { a: angle = 0, v: isVertical = 0 /* FALSE */ } = textRotation || { a: 0, v: 0 /* FALSE */ };
    let centerAngle = 0;
    let vertexAngle = angle;
    if (isVertical === 1 /* TRUE */) {
      centerAngle = VERTICAL_ROTATE_ANGLE;
      vertexAngle = VERTICAL_ROTATE_ANGLE;
    }
    return { centerAngle, vertexAngle };
  }

  // ../packages/engine-render/src/context.ts
  var UniverRenderingContext2D = class {
    constructor(context2) {
      __publicField(this, "canvas");
      __publicField(this, "_context");
      this._context = context2;
      this.canvas = context2.canvas;
    }
    // globalAlpha: number;
    get globalAlpha() {
      return this._context.globalAlpha;
    }
    set globalAlpha(val) {
      this._context.globalAlpha = val;
    }
    // globalCompositeOperation: GlobalCompositeOperation;
    get globalCompositeOperation() {
      return this._context.globalCompositeOperation;
    }
    set globalCompositeOperation(val) {
      this._context.globalCompositeOperation = val;
    }
    // fillStyle: string | CanvasGradient | CanvasPattern;
    get fillStyle() {
      return this._context.fillStyle;
    }
    set fillStyle(val) {
      this._context.fillStyle = val;
    }
    // strokeStyle: string | CanvasGradient | CanvasPattern;
    get strokeStyle() {
      return this._context.strokeStyle;
    }
    set strokeStyle(val) {
      this._context.strokeStyle = val;
    }
    // filter: string;
    get filter() {
      return this._context.filter;
    }
    set filter(val) {
      this._context.filter = val;
    }
    // imageSmoothingEnabled: boolean;
    get imageSmoothingEnabled() {
      return this._context.imageSmoothingEnabled;
    }
    set imageSmoothingEnabled(val) {
      this._context.imageSmoothingEnabled = val;
    }
    // imageSmoothingQuality: ImageSmoothingQuality;
    get imageSmoothingQuality() {
      return this._context.imageSmoothingQuality;
    }
    set imageSmoothingQuality(val) {
      this._context.imageSmoothingQuality = val;
    }
    // lineCap: CanvasLineCap;
    get lineCap() {
      return this._context.lineCap;
    }
    set lineCap(val) {
      this._context.lineCap = val;
    }
    // lineDashOffset: number;
    get lineDashOffset() {
      return this._context.lineDashOffset;
    }
    set lineDashOffset(val) {
      this._context.lineDashOffset = val;
    }
    // lineJoin: CanvasLineJoin;
    get lineJoin() {
      return this._context.lineJoin;
    }
    set lineJoin(val) {
      this._context.lineJoin = val;
    }
    // lineWidth: number;
    get lineWidth() {
      return this._context.lineWidth;
    }
    set lineWidth(val) {
      this._context.lineWidth = val;
    }
    setLineWidthByPrecision(val) {
      const { scaleX, scaleY } = this._getScale();
      this._context.lineWidth = val / Math.max(scaleX, scaleY);
    }
    // miterLimit: number;
    get miterLimit() {
      return this._context.miterLimit;
    }
    set miterLimit(val) {
      this._context.miterLimit = val;
    }
    // shadowBlur: number;
    get shadowBlur() {
      return this._context.shadowBlur;
    }
    set shadowBlur(val) {
      this._context.shadowBlur = val;
    }
    // shadowColor: string;
    get shadowColor() {
      return this._context.shadowColor;
    }
    set shadowColor(val) {
      this._context.shadowColor = val;
    }
    // shadowOffsetX: number;
    get shadowOffsetX() {
      return this._context.shadowOffsetX;
    }
    set shadowOffsetX(val) {
      this._context.shadowOffsetX = val;
    }
    // shadowOffsetY: number;
    get shadowOffsetY() {
      return this._context.shadowOffsetY;
    }
    set shadowOffsetY(val) {
      this._context.shadowOffsetY = val;
    }
    // direction: CanvasDirection;
    get direction() {
      return this._context.direction;
    }
    set direction(val) {
      this._context.direction = val;
    }
    // font: string;
    get font() {
      return this._context.font;
    }
    set font(val) {
      this._context.font = val;
    }
    // fontKerning: CanvasFontKerning;
    get fontKerning() {
      return this._context.fontKerning;
    }
    set fontKerning(val) {
      this._context.fontKerning = val;
    }
    // fontStretch: CanvasFontStretch;
    get fontStretch() {
      return this._context.fontStretch;
    }
    set fontStretch(val) {
      this._context.fontStretch = val;
    }
    // fontVariantCaps: CanvasFontVariantCaps;
    get fontVariantCaps() {
      return this._context.fontVariantCaps;
    }
    set fontVariantCaps(val) {
      this._context.fontVariantCaps = val;
    }
    // letterSpacing: string;
    get letterSpacing() {
      return this._context.letterSpacing;
    }
    set letterSpacing(val) {
      this._context.letterSpacing = val;
    }
    // textRendering: CanvasTextRendering;
    get textRendering() {
      return this._context.textRendering;
    }
    set textRendering(val) {
      this._context.textRendering = val;
    }
    // wordSpacing: string;
    get wordSpacing() {
      return this._context.wordSpacing;
    }
    set wordSpacing(val) {
      this._context.wordSpacing = val;
    }
    // textAlign: CanvasTextAlign;
    get textAlign() {
      return this._context.textAlign;
    }
    set textAlign(val) {
      this._context.textAlign = val;
    }
    // textBaseline: CanvasTextBaseline;
    get textBaseline() {
      return this._context.textBaseline;
    }
    set textBaseline(val) {
      this._context.textBaseline = val;
    }
    _getScale() {
      const m = this.getTransform();
      return {
        scaleX: m.a,
        scaleY: m.d
      };
    }
    getScale() {
      return this._getScale();
    }
    getContextAttributes() {
      return this._context.getContextAttributes();
    }
    isPointInStroke(...args) {
      return this._context.isPointInStroke(...args);
    }
    createConicGradient(startAngle, x, y) {
      return this._context.createConicGradient(startAngle, x, y);
    }
    roundRect(x, y, w, h, radii) {
      this._context.roundRect(x, y, w, h, radii);
    }
    roundRectByPrecision(x, y, w, h, radii) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      w = fixLineWidthByScale(w, scaleX);
      h = fixLineWidthByScale(h, scaleY);
      this.roundRect(x, y, w, h, radii);
    }
    getTransform() {
      return this._context.getTransform();
    }
    resetTransform() {
      this._context.resetTransform();
    }
    drawFocusIfNeeded(...args) {
      return this._context.drawFocusIfNeeded(...args);
    }
    /**
     * reset canvas context transform
     * @method
     */
    reset() {
      this._context.reset();
    }
    /**
     * arc function.
     * @method
     */
    arc(x, y, radius, startAngle, endAngle, counterClockwise) {
      this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /**
     * arc function.
     * @method
     */
    arcByPrecision(x, y, radius, startAngle, endAngle, counterClockwise) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      this.arc(x, y, radius, startAngle, endAngle, counterClockwise);
    }
    /**
     * arcTo function.
     * @method
     *
     */
    arcTo(x1, y1, x2, y2, radius) {
      this._context.arcTo(x1, y1, x2, y2, radius);
    }
    /**
     * arcTo function.
     * @method
     *
     */
    arcToByPrecision(x1, y1, x2, y2, radius) {
      const { scaleX, scaleY } = this._getScale();
      x1 = fixLineWidthByScale(x1, scaleX);
      y1 = fixLineWidthByScale(y1, scaleY);
      x2 = fixLineWidthByScale(x2, scaleX);
      y2 = fixLineWidthByScale(y2, scaleY);
      this.arcTo(x1, y1, x2, y2, radius);
    }
    /**
     * beginPath function.
     * @method
     */
    beginPath() {
      this._context.beginPath();
    }
    /**
     * bezierCurveTo function.
     * @method
     */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
      this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /**
     * bezierCurveTo function precision.
     * @method
     */
    bezierCurveToByPrecision(cp1x, cp1y, cp2x, cp2y, x, y) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      cp1x = fixLineWidthByScale(cp1x, scaleX);
      cp1y = fixLineWidthByScale(cp1y, scaleY);
      cp2x = fixLineWidthByScale(cp2x, scaleX);
      cp2y = fixLineWidthByScale(cp2y, scaleY);
      this.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    }
    /**
     * clearRect function.
     * @method
     */
    clearRect(x, y, width, height) {
      this._context.clearRect(x, y, width, height);
    }
    /**
     * clearRect function.
     * @method
     */
    clearRectByPrecision(x, y, width, height) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      width = fixLineWidthByScale(width, scaleX);
      height = fixLineWidthByScale(height, scaleY);
      this.clearRect(x, y, width, height);
    }
    clip(...args) {
      this._context.clip(...args);
    }
    /**
     * closePath function.
     * @method
     */
    closePath() {
      this._context.closePath();
    }
    /**
     * Chrome hardware acceleration causes canvas stroke to fail to draw lines on Mac.
     */
    closePathByEnv() {
      const system = Tools.getSystemType();
      const isMac = system === "Mac";
      const browser = Tools.getBrowserType();
      const isChrome = browser === "Chrome";
      if (isMac && isChrome) {
        return;
      }
      this._context.closePath();
    }
    createImageData(...args) {
      if (args.length === 0) {
        throw new Error("arguments is zero");
      }
      if (args.length === 1) {
        return this._context.createImageData(args[0]);
      }
      if (args.length === 2) {
        return this._context.createImageData(args[0], args[1]);
      }
      return this._context.createImageData(args[0], args[1], args[1]);
    }
    /**
     * createLinearGradient function.
     * @method
     */
    createLinearGradient(x0, y0, x1, y1) {
      return this._context.createLinearGradient(x0, y0, x1, y1);
    }
    /**
     * createPattern function.
     * @method
     */
    createPattern(image, repetition) {
      return this._context.createPattern(image, repetition);
    }
    /**
     * createRadialGradient function.
     * @method
     */
    createRadialGradient(x0, y0, r0, x1, y1, r1) {
      return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);
    }
    drawImage(...args) {
      const a = args;
      const _context = this._context;
      if (a.length === 3) {
        _context.drawImage(args[0], args[1], args[2]);
      } else if (a.length === 5) {
        _context.drawImage(args[0], args[1], args[2], args[3], args[4]);
      } else if (a.length === 9) {
        _context.drawImage(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);
      }
    }
    /**
     * ellipse function.
     * @method
     */
    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {
      this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);
    }
    isPointInPath(...args) {
      return this._context.isPointInPath(...args);
    }
    fill(...args) {
      this._context.fill(...args);
    }
    /**
     * fillRect function.
     * @method
     */
    fillRect(x, y, width, height) {
      this._context.fillRect(x, y, width, height);
    }
    /**
     * fillRect function precision.
     * @method
     */
    fillRectByPrecision(x, y, width, height) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      width = fixLineWidthByScale(width, scaleX);
      height = fixLineWidthByScale(height, scaleY);
      this.fillRect(x, y, width, height);
    }
    /**
     * strokeRect function.
     * @method
     */
    strokeRect(x, y, width, height) {
      this._context.strokeRect(x, y, width, height);
    }
    /**
     * strokeRect function precision.
     * @method
     */
    strokeRectPrecision(x, y, width, height) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      width = fixLineWidthByScale(width, scaleX);
      height = fixLineWidthByScale(height, scaleY);
      this.strokeRect(x, y, width, height);
    }
    /**
     * fillText function.
     * @method
     */
    fillText(text, x, y, maxWidth) {
      if (maxWidth) {
        this._context.fillText(text, x, y, maxWidth);
      } else {
        this._context.fillText(text, x, y);
      }
    }
    /**
     * fillText function.
     * @method
     */
    fillTextPrecision(text, x, y, maxWidth) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      if (maxWidth) {
        maxWidth = fixLineWidthByScale(maxWidth, scaleX);
        this._context.fillText(text, x, y, maxWidth);
      } else {
        this._context.fillText(text, x, y);
      }
    }
    /**
     * measureText function.
     * @method
     */
    measureText(text) {
      return this._context.measureText(text);
    }
    /**
     * getImageData function.
     * @method
     */
    getImageData(sx, sy, sw, sh) {
      return this._context.getImageData(sx, sy, sw, sh);
    }
    /**
     * lineTo function.
     * @method
     */
    lineTo(x, y) {
      this._context.lineTo(x, y);
    }
    /**
     * lineTo function precision.
     * @method
     */
    lineToByPrecision(x, y) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      this.lineTo(x, y);
    }
    /**
     * moveTo function.
     * @method
     */
    moveTo(x, y) {
      this._context.moveTo(x, y);
    }
    /**
     * moveTo function precision.
     * @method
     */
    moveToByPrecision(x, y) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      this.moveTo(x, y);
    }
    /**
     * rect function.
     * @method
     */
    rect(x, y, width, height) {
      this._context.rect(x, y, width, height);
    }
    /**
     * rect function.
     * @method
     */
    rectByPrecision(x, y, width, height) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      width = fixLineWidthByScale(width, scaleX);
      height = fixLineWidthByScale(height, scaleY);
      this.rect(x, y, width, height);
    }
    /**
     * putImageData function.
     * @method
     */
    putImageData(imageData, dx, dy) {
      this._context.putImageData(imageData, dx, dy);
    }
    /**
     * quadraticCurveTo function.
     * @method
     */
    quadraticCurveTo(cpx, cpy, x, y) {
      this._context.quadraticCurveTo(cpx, cpy, x, y);
    }
    /**
     * restore function.
     * @method
     */
    restore() {
      this._context.restore();
    }
    /**
     * rotate function.
     * @method
     */
    rotate(angle) {
      this._context.rotate(angle);
    }
    /**
     * save function.
     * @method
     */
    save() {
      this._context.save();
    }
    /**
     * scale function.
     * @method
     */
    scale(x, y) {
      this._context.scale(x, y);
    }
    /**
     * setLineDash function.
     * @method
     */
    setLineDash(segments) {
      if (this._context.setLineDash) {
        this._context.setLineDash(segments);
      } else if ("mozDash" in this._context) {
        this._context.mozDash = segments;
      } else if ("webkitLineDash" in this._context) {
        this._context.webkitLineDash = segments;
      }
    }
    /**
     * getLineDash function.
     * @method
     */
    getLineDash() {
      return this._context.getLineDash();
    }
    setTransform(...args) {
      this._context.setTransform(...args);
    }
    /**
     * stroke function.
     * @method
     */
    stroke(path2d) {
      if (path2d) {
        this._context.stroke(path2d);
      } else {
        this._context.stroke();
      }
    }
    /**
     * strokeText function.
     * @method
     */
    strokeText(text, x, y, maxWidth) {
      this._context.strokeText(text, x, y, maxWidth);
    }
    /**
     * strokeText function precision.
     * @method
     */
    strokeTextByPrecision(text, x, y, maxWidth) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      if (maxWidth) {
        maxWidth = fixLineWidthByScale(maxWidth, scaleX);
      }
      this.strokeText(text, x, y, maxWidth);
    }
    /**
     * transform function.
     * @method
     */
    transform(a, b, c, d, e, f) {
      this._context.transform(a, b, c, d, e, f);
    }
    /**
     * translate function.
     * @method
     */
    translate(x, y) {
      this._context.translate(x, y);
    }
    translateWithPrecision(x, y) {
      const { scaleX, scaleY } = this._getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      this._context.translate(x, y);
    }
    translateWithPrecisionRatio(x, y) {
      const { scaleX, scaleY } = this._getScale();
      this._context.translate(x / scaleX, y / scaleY);
    }
    clearRectForTexture(x, y, width, height) {
      this.clearRectByPrecision(x, y, width, height);
    }
    setGlobalCompositeOperation(val) {
      this._context.globalCompositeOperation = val;
    }
  };
  var UniverRenderingContext = class extends UniverRenderingContext2D {
  };
  var UniverPrintingContext = class extends UniverRenderingContext2D {
    __getScale() {
      const m = this.getTransform();
      return {
        scaleX: m.a,
        scaleY: m.d
      };
    }
    clearRect(x, y, width, height) {
      const { scaleX, scaleY } = this.__getScale();
      x = fixLineWidthByScale(x, scaleX);
      y = fixLineWidthByScale(y, scaleY);
      width = fixLineWidthByScale(width, scaleX);
      height = fixLineWidthByScale(height, scaleY);
      this._context.save();
      this._context.fillStyle = getColor([255, 255, 255]);
      this._context.fillRect(x, y, width, height);
      this._context.restore();
    }
    clearRectForTexture(x, y, width, height) {
    }
    setGlobalCompositeOperation(val) {
    }
  };

  // ../packages/engine-render/src/canvas.ts
  var Canvas = class {
    constructor(props) {
      __publicField(this, "isCache", false);
      __publicField(this, "_pixelRatio", 1);
      __publicField(this, "_canvasEle");
      __publicField(this, "_context");
      __publicField(this, "_width", 0);
      __publicField(this, "_height", 0);
      props = props || {};
      this._canvasEle = createCanvasElement();
      this._canvasEle.style.padding = "0";
      this._canvasEle.style.margin = "0";
      this._canvasEle.style.border = "0";
      this._canvasEle.style.background = "transparent";
      this._canvasEle.style.position = "absolute";
      this._canvasEle.style.top = "0";
      this._canvasEle.style.left = "0";
      this._canvasEle.style.zIndex = "8";
      this._canvasEle.className = "univer-render-canvas";
      this._canvasEle.tabIndex = 1;
      this._canvasEle.style.touchAction = "none";
      this._canvasEle.style.outline = "0";
      const context2 = this._canvasEle.getContext("2d");
      if (context2 == null) {
        throw new Error("context is not support");
      }
      if (props.mode === 1 /* Printing */) {
        this._context = new UniverPrintingContext(context2);
      } else {
        this._context = new UniverRenderingContext(context2);
      }
      this.setSize(props.width, props.height, props.pixelRatio);
    }
    getCanvasEle() {
      return this._canvasEle;
    }
    /**
     * get canvas context
     * @method
     * @returns {CanvasContext} context
     */
    getContext() {
      return this._context;
    }
    getPixelRatio() {
      return this._pixelRatio;
    }
    getWidth() {
      return this._width;
    }
    getHeight() {
      return this._height;
    }
    setSize(width, height, pixelRatioParam) {
      this._pixelRatio = pixelRatioParam || getDevicePixelRatio();
      if (width) {
        this._canvasEle.width = width * this._pixelRatio;
        this._width = this._canvasEle.width / this._pixelRatio;
        this._canvasEle.style.width = `${this._width}px`;
      }
      if (height) {
        this._canvasEle.height = height * this._pixelRatio;
        this._height = this._canvasEle.height / this._pixelRatio;
        this._canvasEle.style.height = `${this._height}px`;
      }
      this.getContext().setTransform(this._pixelRatio, 0, 0, this._pixelRatio, 0, 0);
    }
    setPixelRatio(pixelRatio) {
      if (this._width === 0 || this._height === 0) {
        return;
      }
      if (pixelRatio < 1) {
        pixelRatio = 1;
      }
      this.setSize(this._width, this._height, pixelRatio);
    }
    dispose() {
      this.clear();
      this._canvasEle.remove();
    }
    clear() {
      const ctx = this.getContext();
      ctx.clearRect(0, 0, this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    /**
     * to data url
     * @method
     * @param {string} mimeType
     * @param {number} quality between 0 and 1 for jpg mime types
     * @returns {string} data url string
     */
    toDataURL(mimeType, quality) {
      try {
        return this._canvasEle.toDataURL(mimeType, quality);
      } catch (e) {
        try {
          return this._canvasEle.toDataURL();
        } catch (err) {
          const { message } = err;
          console.error(
            `Unable to get data URL. ${message} For more info read https://universheet.net/docs/Canvas.html.`
          );
          return "";
        }
      }
    }
  };

  // ../packages/engine-render/src/components/extension.ts
  var ComponentExtension = class {
    constructor() {
      __publicField(this, "uKey", "");
      __publicField(this, "type");
      __publicField(this, "Z_INDEX", 0);
      __publicField(this, "parent");
      __publicField(this, "translateX", 0);
      __publicField(this, "translateY", 0);
      __publicField(this, "extensionOffset", {});
    }
    get zIndex() {
      return this.Z_INDEX;
    }
    draw(ctx, parentScale, skeleton, diffBounds) {
    }
    clearCache() {
    }
    _getScale(parentScale) {
      return getScale(parentScale);
    }
  };
  var SpreadsheetExtensionRegistry = Registry.create();
  var SheetRowHeaderExtensionRegistry = Registry.create();
  var SheetColumnHeaderExtensionRegistry = Registry.create();
  var DocumentsSpanAndLineExtensionRegistry = Registry.create();

  // ../packages/engine-render/src/components/sheets/extensions/sheet-extension.ts
  var SheetExtension = class extends ComponentExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "type", 0 /* GRID */);
    }
    getCellIndex(rowIndex, columnIndex, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache) {
      return getCellByIndex(rowIndex, columnIndex, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
    }
    isRenderDiffRangesByCell(range, diffRanges) {
      if (diffRanges == null || diffRanges.length === 0) {
        return true;
      }
      for (const range2 of diffRanges) {
        const { startRow, startColumn, endRow, endColumn } = range2;
        const isIntersect = Rectangle.intersects(range2, {
          startRow,
          endRow,
          startColumn,
          endColumn
        });
        if (isIntersect) {
          return true;
        }
      }
      return false;
    }
    // isRenderDiffRangesByColumn(column: number, diffRanges?: IRange[]) {
    //     if (diffRanges == null || diffRanges.length === 0) {
    //         return true;
    //     }
    //     for (const range of diffRanges) {
    //         const { startColumn, endColumn } = range;
    //         if (column >= startColumn && column <= endColumn) {
    //             return true;
    //         }
    //     }
    //     return false;
    // }
    isRenderDiffRangesByColumn(curStartColumn, curEndColumn, diffRanges) {
      if (diffRanges == null || diffRanges.length === 0) {
        return true;
      }
      for (const range of diffRanges) {
        const { startColumn, endColumn } = range;
        const isIntersect = Rectangle.intersects(
          {
            startRow: 0,
            endRow: 0,
            startColumn: curStartColumn,
            endColumn: curEndColumn
          },
          {
            startRow: 0,
            endRow: 0,
            startColumn,
            endColumn
          }
        );
        if (isIntersect) {
          return true;
        }
      }
      return false;
    }
    isRenderDiffRangesByRow(curStartRow, curEndRow, diffRanges) {
      if (diffRanges == null || diffRanges.length === 0) {
        return true;
      }
      for (const range of diffRanges) {
        const { startRow, endRow } = range;
        const isIntersect = Rectangle.intersects(
          {
            startRow: curStartRow,
            endRow: curEndRow,
            startColumn: 0,
            endColumn: 0
          },
          {
            startRow,
            endRow,
            startColumn: 0,
            endColumn: 0
          }
        );
        if (isIntersect) {
          return true;
        }
      }
      return false;
    }
  };

  // ../packages/engine-render/src/components/sheets/extensions/background.ts
  var UNIQUE_KEY = "DefaultBackgroundExtension";
  var DOC_EXTENSION_Z_INDEX = 40;
  var PRINTING_Z_INDEX = 20;
  var Background = class extends SheetExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY);
      __publicField(this, "Z_INDEX", DOC_EXTENSION_Z_INDEX);
      __publicField(this, "PRINTING_Z_INDEX", PRINTING_Z_INDEX);
    }
    get zIndex() {
      var _a2;
      return ((_a2 = this.parent) == null ? void 0 : _a2.isPrinting) ? this.PRINTING_Z_INDEX : this.Z_INDEX;
    }
    draw(ctx, parentScale, spreadsheetSkeleton, diffRanges) {
      const { stylesCache } = spreadsheetSkeleton;
      const { background, backgroundPositions } = stylesCache;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      ctx.save();
      ctx.setGlobalCompositeOperation("destination-over");
      background && Object.keys(background).forEach((rgb) => {
        const backgroundCache = background[rgb];
        ctx.fillStyle = rgb || getColor([255, 255, 255]);
        ctx.beginPath();
        backgroundCache.forValue((rowIndex, columnIndex) => {
          const cellInfo = backgroundPositions == null ? void 0 : backgroundPositions.getValue(rowIndex, columnIndex);
          if (cellInfo == null) {
            return true;
          }
          let { startY, endY, startX, endX } = cellInfo;
          const { isMerged, isMergedMainCell, mergeInfo } = cellInfo;
          if (isMerged) {
            return true;
          }
          if (!this.isRenderDiffRangesByCell(
            {
              startRow: mergeInfo.startRow,
              endRow: mergeInfo.endRow,
              startColumn: mergeInfo.startColumn,
              endColumn: mergeInfo.endColumn
            },
            diffRanges
          )) {
            return true;
          }
          if (isMergedMainCell) {
            startY = mergeInfo.startY;
            endY = mergeInfo.endY;
            startX = mergeInfo.startX;
            endX = mergeInfo.endX;
          }
          ctx.moveToByPrecision(startX, startY);
          ctx.lineToByPrecision(startX, endY);
          ctx.lineToByPrecision(endX, endY);
          ctx.lineToByPrecision(endX, startY);
        });
        ctx.closePath();
        ctx.fill();
      });
      ctx.restore();
    }
  };
  SpreadsheetExtensionRegistry.add(Background);

  // ../packages/engine-render/src/components/sheets/extensions/border.ts
  var UNIQUE_KEY2 = "DefaultBorderExtension";
  var BORDER_Z_INDEX = 50;
  var Border = class extends SheetExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY2);
      __publicField(this, "Z_INDEX", BORDER_Z_INDEX);
    }
    draw(ctx, parentScale, spreadsheetSkeleton, diffRanges) {
      const { dataMergeCache, stylesCache, overflowCache } = spreadsheetSkeleton;
      const { border } = stylesCache;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      ctx.save();
      let preStyle;
      let preColor;
      ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
      const precisionScale = this._getScale(ctx.getScale());
      border == null ? void 0 : border.forValue((rowIndex, columnIndex, borderCaches) => {
        if (!borderCaches) {
          return true;
        }
        const cellInfo = this.getCellIndex(
          rowIndex,
          columnIndex,
          rowHeightAccumulation,
          columnWidthAccumulation,
          dataMergeCache
        );
        const { startY: cellStartY, endY: cellEndY, startX: cellStartX, endX: cellEndX } = cellInfo;
        const { isMerged, isMergedMainCell, mergeInfo } = cellInfo;
        if (!this.isRenderDiffRangesByRow(mergeInfo.startRow, mergeInfo.endRow, diffRanges)) {
          return true;
        }
        for (const key in borderCaches) {
          const { type, style, color } = borderCaches[key];
          let startY = cellStartY;
          let endY = cellEndY;
          let startX = cellStartX;
          let endX = cellEndX;
          if (type !== "t" /* TOP */ && type !== "b" /* BOTTOM */ && type !== "l" /* LEFT */ && type !== "r" /* RIGHT */) {
            if (isMerged) {
              return true;
            }
            if (isMergedMainCell) {
              startY = mergeInfo.startY;
              endY = mergeInfo.endY;
              startX = mergeInfo.startX;
              endX = mergeInfo.endX;
            }
          }
          const lineWidth = getLineWidth(style);
          if (style !== preStyle) {
            setLineType(ctx, style);
            ctx.setLineWidthByPrecision(lineWidth);
            preStyle = style;
          }
          if (color !== preColor) {
            ctx.strokeStyle = color || COLOR_BLACK_RGB;
            preColor = color;
          }
          drawDiagonalLineByBorderType(ctx, type, {
            startX,
            startY,
            endX,
            endY
          });
          if (this._getOverflowExclusion(overflowCache, type, rowIndex, columnIndex)) {
            continue;
          }
          drawLineByBorderType(ctx, type, (lineWidth - 1) / 2 / precisionScale, {
            startX,
            startY,
            endX,
            endY
          });
        }
      });
      ctx.closePath();
      ctx.restore();
    }
    _getOverflowExclusion(overflowCache, type, borderRow, borderColumn) {
      let isDraw = false;
      if (type === "t" /* TOP */ || type === "b" /* BOTTOM */) {
        return isDraw;
      }
      overflowCache == null ? void 0 : overflowCache.forRow((row, rowArray) => {
        if (row !== borderRow) {
          return true;
        }
        rowArray.forEach((column) => {
          const rectangle = overflowCache.getValue(row, column);
          const { startColumn, endColumn } = rectangle;
          if (type === "l" /* LEFT */ && borderColumn > startColumn && borderColumn <= endColumn) {
            isDraw = true;
            return false;
          }
          if (type === "r" /* RIGHT */ && borderColumn >= startColumn && borderColumn < endColumn) {
            isDraw = true;
            return false;
          }
        });
      });
      return isDraw;
    }
  };
  SpreadsheetExtensionRegistry.add(Border);

  // ../packages/engine-render/src/components/sheets/extensions/column-header-layout.ts
  var UNIQUE_KEY3 = "DefaultColumnHeaderLayoutExtension";
  var ColumnHeaderLayout = class extends SheetExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY3);
      __publicField(this, "Z_INDEX", 10);
    }
    draw(ctx, parentScale, spreadsheetSkeleton) {
      const { rowColumnSegment, columnHeaderHeight = 0 } = spreadsheetSkeleton;
      const { startColumn, endColumn } = rowColumnSegment;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      const scale = this._getScale(parentScale);
      ctx.fillStyle = getColor([248, 249, 250]);
      ctx.fillRectByPrecision(0, 0, columnTotalWidth, columnHeaderHeight);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = getColor([0, 0, 0]);
      ctx.beginPath();
      ctx.setLineWidthByPrecision(1);
      ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
      ctx.strokeStyle = getColor([217, 217, 217]);
      ctx.font = `13px ${DEFAULT_FONTFACE_PLANE}`;
      let preColumnPosition = 0;
      const columnWidthAccumulationLength = columnWidthAccumulation.length;
      for (let c = startColumn - 1; c <= endColumn; c++) {
        if (c < 0 || c > columnWidthAccumulationLength - 1) {
          continue;
        }
        const columnEndPosition = columnWidthAccumulation[c];
        if (preColumnPosition === columnEndPosition) {
          continue;
        }
        ctx.moveToByPrecision(columnEndPosition, 0);
        ctx.lineToByPrecision(columnEndPosition, columnHeaderHeight);
        const middleCellPos = preColumnPosition + (columnEndPosition - preColumnPosition) / 2;
        ctx.fillText(numberToABC(c), middleCellPos, columnHeaderHeight / 2 + MIDDLE_CELL_POS_MAGIC_NUMBER);
        preColumnPosition = columnEndPosition;
      }
      const columnHeaderHeightFix = columnHeaderHeight - 0.5 / scale;
      ctx.moveToByPrecision(0, columnHeaderHeightFix);
      ctx.lineToByPrecision(columnTotalWidth, columnHeaderHeightFix);
      ctx.stroke();
    }
  };
  SheetColumnHeaderExtensionRegistry.add(new ColumnHeaderLayout());

  // ../packages/engine-render/src/components/docs/layout/tools.ts
  function getLastPage(pages) {
    return pages[pages.length - 1];
  }
  function getLastSection(page) {
    var _a2;
    return (_a2 = page.sections) == null ? void 0 : _a2[page.sections.length - 1];
  }
  function getLastLine(page) {
    var _a2;
    const lines = (_a2 = getLastNotFullColumnInfo(page)) == null ? void 0 : _a2.column.lines;
    return lines == null ? void 0 : lines[lines.length - 1];
  }
  function getLastLineByColumn(column) {
    return column.lines[column.lines.length - 1];
  }
  function getLastNotFullColumnInfo(page) {
    const section = getLastSection(page);
    for (let i = 0; i < section.columns.length; i++) {
      const column = section.columns[i];
      if (!column.isFull) {
        return {
          column,
          isLast: i === section.columns.length - 1,
          index: i
        };
      }
    }
  }
  function getLastNotFullDivideInfo(page) {
    const line = getLastLine(page);
    if (!line) {
      return;
    }
    for (let i = 0; i < line.divides.length; i++) {
      const divide = line.divides[i];
      if (!divide.isFull) {
        return {
          divide,
          isLast: i === line.divides.length - 1,
          index: i
        };
      }
    }
  }
  function isColumnFull(page) {
    const section = getLastSection(page);
    const columnsLen = section.columns.length;
    for (let i = 0; i < columnsLen; i++) {
      const column = section.columns[i];
      if (!column.isFull) {
        return false;
      }
    }
    return true;
  }
  function getNumberUnitValue(unitValue, benchMark) {
    if (unitValue instanceof Object) {
      const { v: value, u: unit } = unitValue;
      if (unit === 0 /* POINT */) {
        return value;
      }
      return value * benchMark;
    }
    return unitValue;
  }
  function getCharSpaceApply(charSpace = 0, defaultTabStop, gridType = 1 /* LINES */, snapToGrid = 1 /* TRUE */) {
    let charSpaceApply = 1;
    if (validationGrid(gridType, snapToGrid)) {
      charSpaceApply = charSpace;
    }
    charSpaceApply *= defaultTabStop;
    return charSpaceApply;
  }
  function validationGrid(gridType = 1 /* LINES */, snapToGrid = 0 /* FALSE */) {
    return snapToGrid === 1 /* TRUE */ && (gridType === 2 /* LINES_AND_CHARS */ || gridType === 3 /* SNAP_TO_CHARS */);
  }
  function getLineHeightConfig(sectionBreakConfig, paragraphConfig) {
    const { paragraphStyle = {} } = paragraphConfig;
    const { linePitch = 15.6, gridType = 1 /* LINES */, paragraphLineGapDefault = 0 } = sectionBreakConfig;
    const { lineSpacing = 1, spacingRule = 0 /* AUTO */, snapToGrid = 1 /* TRUE */ } = paragraphStyle;
    return { paragraphLineGapDefault, linePitch, gridType, lineSpacing, spacingRule, snapToGrid };
  }
  function getCharSpaceConfig(sectionBreakConfig, paragraphConfig) {
    const { paragraphStyle = {} } = paragraphConfig;
    const {
      charSpace = 0,
      gridType = 1 /* LINES */,
      defaultTabStop = 36,
      documentTextStyle = {}
    } = sectionBreakConfig;
    const { fs: documentFontSize = DEFAULT_DOCUMENT_FONTSIZE } = documentTextStyle;
    const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
    return {
      charSpace,
      documentFontSize,
      defaultTabStop,
      gridType,
      snapToGrid
    };
  }
  function updateBlockIndex(pages, start = -1) {
    let prePageStartIndex = start;
    for (const page of pages) {
      const { sections } = page;
      const pageStartIndex = prePageStartIndex;
      const pageEndIndex = pageStartIndex;
      let preSectionStartIndex = pageStartIndex;
      let maxContentWidth = Number.NEGATIVE_INFINITY;
      let contentHeight = 0;
      for (const section of sections) {
        const { columns } = section;
        const sectionStartIndex = preSectionStartIndex;
        const sectionEndIndex = pageStartIndex;
        let preColumnStartIndex = sectionStartIndex;
        let maxSectionHeight = Number.NEGATIVE_INFINITY;
        let sectionWidth = 0;
        for (const column of columns) {
          const { lines } = column;
          const columStartIndex = preColumnStartIndex;
          const columnEndIndex = columStartIndex;
          let preLineStartIndex = columStartIndex;
          let columnHeight = 0;
          let maxColumnWidth = Number.NEGATIVE_INFINITY;
          let preLine = null;
          for (const line of lines) {
            const { divides, lineHeight } = line;
            const lineStartIndex = preLineStartIndex;
            const lineEndIndex = lineStartIndex;
            let preDivideStartIndex = lineStartIndex;
            let actualWidth = 0;
            let maxLineAsc = 0;
            columnHeight += lineHeight;
            const divideLength = divides.length;
            for (let i = 0; i < divideLength; i++) {
              const divide = divides[i];
              const { glyphGroup } = divide;
              const divStartIndex = preDivideStartIndex;
              let divEndIndex = divStartIndex;
              for (const glyph of glyphGroup) {
                const increaseValue = glyph.glyphType === 2 /* LIST */ ? 0 : glyph.count;
                divEndIndex += increaseValue;
                const bBox = glyph.bBox;
                const { ba } = bBox;
                maxLineAsc = Math.max(maxLineAsc, ba);
                if (i === divideLength - 1) {
                  actualWidth += glyph.width;
                }
              }
              if (i === divideLength - 1) {
                actualWidth += divide.left;
              }
              if (glyphGroup.length === 0) {
                continue;
              }
              divide.st = divStartIndex + 1;
              divide.ed = divEndIndex >= divide.st ? divEndIndex : divide.st;
              preDivideStartIndex = divide.ed;
            }
            line.st = lineStartIndex + 1;
            line.ed = preDivideStartIndex >= line.st ? preDivideStartIndex : line.st;
            line.width = actualWidth;
            line.asc = maxLineAsc;
            maxColumnWidth = Math.max(maxColumnWidth, actualWidth);
            line.top = ((preLine == null ? void 0 : preLine.top) || 0) + ((preLine == null ? void 0 : preLine.lineHeight) || 0);
            preLine = line;
            preLineStartIndex = line.ed;
          }
          column.st = columStartIndex + 1;
          column.ed = preLineStartIndex >= column.st ? preLineStartIndex : column.st;
          column.height = columnHeight;
          column.width = maxColumnWidth;
          sectionWidth += maxColumnWidth;
          maxSectionHeight = Math.max(maxSectionHeight, column.height);
          preColumnStartIndex = column.ed;
        }
        section.st = sectionStartIndex + 1;
        section.ed = preColumnStartIndex >= section.st ? preColumnStartIndex : section.st;
        section.height = maxSectionHeight;
        contentHeight += maxSectionHeight;
        maxContentWidth = Math.max(maxContentWidth, sectionWidth);
        preSectionStartIndex = section.ed;
      }
      page.st = pageStartIndex + 1;
      page.ed = preSectionStartIndex >= page.st ? preSectionStartIndex : page.st;
      page.height = contentHeight;
      page.width = maxContentWidth;
      prePageStartIndex = page.ed;
    }
  }
  function lineIterator(pages, iteratorFunction) {
    for (const page of pages) {
      const { sections } = page;
      for (const section of sections) {
        const { columns } = section;
        for (const column of columns) {
          const { lines } = column;
          for (const line of lines) {
            if (iteratorFunction && isFunction2(iteratorFunction)) {
              iteratorFunction(line);
            }
          }
        }
      }
    }
  }
  function columnIterator(pages, iteratorFunction) {
    for (const page of pages) {
      const { sections } = page;
      for (const section of sections) {
        const { columns } = section;
        for (const column of columns) {
          if (iteratorFunction && isFunction2(iteratorFunction)) {
            iteratorFunction(column);
          }
        }
      }
    }
  }
  function getPositionHorizon(positionH, column, page, objectWidth, isPageBreak = false) {
    const { relativeFrom, align, posOffset, percent } = positionH;
    if (align != null) {
      if (align === 1 /* INSIDE */ || align === 3 /* OUTSIDE */) {
        if (relativeFrom === 4 /* MARGIN */) {
        } else if (relativeFrom === 6 /* PAGE */) {
        }
      } else {
        if (relativeFrom === 1 /* COLUMN */) {
          const { width, left } = column;
          let absoluteLeft = 0;
          if (align === 2 /* LEFT */) {
            absoluteLeft = left;
          } else if (align === 4 /* RIGHT */) {
            absoluteLeft = left + width - objectWidth;
          } else if (align === 0 /* CENTER */) {
            absoluteLeft = left + width / 2 - objectWidth / 2;
          }
          return absoluteLeft;
        }
        if (relativeFrom === 3 /* LEFT_MARGIN */) {
        } else if (relativeFrom === 4 /* MARGIN */) {
        } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
        } else if (relativeFrom === 2 /* INSIDE_MARGIN */) {
        } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
        } else if (relativeFrom === 6 /* PAGE */) {
          const { pageWidth } = page;
          let absoluteLeft = 0;
          if (align === 4 /* RIGHT */) {
            absoluteLeft = pageWidth - objectWidth;
          } else if (align === 0 /* CENTER */) {
            absoluteLeft = pageWidth / 2 - objectWidth / 2;
          }
          return absoluteLeft;
        }
      }
    } else if (posOffset) {
      const { pageWidth, marginLeft, marginRight } = page;
      const boundaryLeft = marginLeft;
      const boundaryRight = pageWidth - marginRight;
      let absoluteLeft = 0;
      if (relativeFrom === 1 /* COLUMN */) {
        absoluteLeft = (isPageBreak ? 0 : (column == null ? void 0 : column.left) || 0) + posOffset;
      } else if (relativeFrom === 3 /* LEFT_MARGIN */) {
      } else if (relativeFrom === 4 /* MARGIN */) {
        absoluteLeft = posOffset + marginLeft;
      } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
      } else if (relativeFrom === 2 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 6 /* PAGE */) {
        absoluteLeft = posOffset;
      }
      if (absoluteLeft + objectWidth > boundaryRight) {
        absoluteLeft = boundaryRight - objectWidth;
      }
      return absoluteLeft;
    } else if (percent) {
      const { pageWidth, marginLeft, marginRight } = page;
      if (relativeFrom === 3 /* LEFT_MARGIN */) {
      } else if (relativeFrom === 4 /* MARGIN */) {
      } else if (relativeFrom === 7 /* RIGHT_MARGIN */) {
      } else if (relativeFrom === 2 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 6 /* PAGE */) {
        return percent * pageWidth;
      }
    }
  }
  function getPositionVertical(positionV, page, lineTop, lineHeight, objectHeight, blockAnchorTop, isPageBreak = false) {
    const { relativeFrom, align, posOffset, percent } = positionV;
    if (align != null) {
      if (relativeFrom === 2 /* LINE */) {
        let absoluteTop = 0;
        if (align === 0 /* BOTTOM */) {
          absoluteTop = lineTop + lineHeight - objectHeight;
        } else if (align === 4 /* TOP */) {
          absoluteTop = lineTop;
        } else if (align === 1 /* CENTER */) {
          absoluteTop = lineTop + lineHeight / 2 - objectHeight / 2;
        }
        return absoluteTop;
      }
      if (relativeFrom === 7 /* TOP_MARGIN */) {
      } else if (relativeFrom === 3 /* MARGIN */) {
      } else if (relativeFrom === 0 /* BOTTOM_MARGIN */) {
      } else if (relativeFrom === 1 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 4 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* PAGE */) {
        const { pageHeight } = page;
        let absoluteTop = 0;
        if (align === 0 /* BOTTOM */) {
          absoluteTop = pageHeight - objectHeight;
        } else if (align === 1 /* CENTER */) {
          absoluteTop = pageHeight / 2 - objectHeight / 2;
        }
        return absoluteTop;
      }
    } else if (posOffset) {
      let absoluteTop = 0;
      if (relativeFrom === 2 /* LINE */) {
        absoluteTop = lineTop || 0 + posOffset;
      } else if (relativeFrom === 7 /* TOP_MARGIN */) {
      } else if (relativeFrom === 3 /* MARGIN */) {
      } else if (relativeFrom === 0 /* BOTTOM_MARGIN */) {
      } else if (relativeFrom === 1 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 4 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* PAGE */) {
        absoluteTop = posOffset;
      } else if (relativeFrom === 6 /* PARAGRAPH */) {
        absoluteTop = (isPageBreak ? 0 : blockAnchorTop == null ? lineTop : blockAnchorTop) + posOffset;
      }
      return absoluteTop;
    } else if (percent) {
      const { pageHeight, marginBottom, marginTop } = page;
      if (relativeFrom === 7 /* TOP_MARGIN */) {
      } else if (relativeFrom === 3 /* MARGIN */) {
      } else if (relativeFrom === 0 /* BOTTOM_MARGIN */) {
      } else if (relativeFrom === 1 /* INSIDE_MARGIN */) {
      } else if (relativeFrom === 4 /* OUTSIDE_MARGIN */) {
      } else if (relativeFrom === 5 /* PAGE */) {
        return percent * pageHeight;
      }
    }
  }
  function getGlyphGroupWidth(divide) {
    let width = 0;
    for (const glyph of divide.glyphGroup) {
      width += glyph.width;
    }
    return width;
  }
  var fontCreateConfigCache = new ObjectMatrix();
  function clearFontCreateConfigCache() {
    fontCreateConfigCache.reset();
  }
  function getFontCreateConfig(index, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle) {
    const { startIndex } = paragraphNode;
    const textRun = bodyModel.getTextRun(index + startIndex) || { ts: {}, st: 0, ed: 0 };
    const { st, ed } = textRun;
    let { ts: textStyle = {} } = textRun;
    const cache = fontCreateConfigCache.getValue(st, ed);
    if (cache) {
      return cache;
    }
    const {
      gridType = 1 /* LINES */,
      charSpace = 0,
      documentTextStyle = {},
      pageSize = {
        width: Number.POSITIVE_INFINITY,
        height: Number.POSITIVE_INFINITY
      },
      marginRight = 0,
      marginLeft = 0,
      localeService
    } = sectionBreakConfig;
    const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
    textStyle = { ...documentTextStyle, ...textStyle };
    const fontStyle = getFontStyleString(textStyle, localeService);
    const mixTextStyle = {
      ...documentTextStyle,
      ...textStyle
    };
    const pageWidth = pageSize.width || Number.POSITIVE_INFINITY - marginLeft - marginRight;
    const result = {
      fontStyle,
      textStyle: mixTextStyle,
      charSpace,
      gridType,
      snapToGrid,
      pageWidth
    };
    fontCreateConfigCache.setValue(st, ed, result);
    return result;
  }

  // ../packages/engine-render/src/components/skeleton.ts
  var Skeleton = class extends Disposable {
    constructor(_localService) {
      super();
      this._localService = _localService;
      __publicField(this, "_fontLocale");
      __publicField(this, "_dirty", true);
      this._localeInitial();
    }
    get dirty() {
      return this._dirty;
    }
    getFontLocale() {
      return this._fontLocale;
    }
    makeDirty(state) {
      this._dirty = state;
    }
    _localeInitial() {
    }
  };
  Skeleton = __decorateClass([
    __decorateParam(0, Inject(LocaleService))
  ], Skeleton);

  // ../packages/engine-render/src/components/docs/liquid.ts
  var Liquid = class {
    constructor() {
      __publicField(this, "_translateX", 0);
      __publicField(this, "_translateY", 0);
      __publicField(this, "_translateSaveList", []);
    }
    get x() {
      return this._translateX;
    }
    get y() {
      return this._translateY;
    }
    reset() {
      this.translateBy(0, 0);
      this._translateSaveList = [];
    }
    translateBy(x = 0, y = 0) {
      this._translateX = x;
      this._translateY = y;
    }
    translate(x = 0, y = 0) {
      this._translateX += x;
      this._translateY += y;
    }
    translateSave() {
      this._translateSaveList.push({
        x: this._translateX,
        y: this._translateY
      });
    }
    translateRestore() {
      const save = this._translateSaveList.pop();
      if (save) {
        this._translateX = save.x;
        this._translateY = save.y;
      }
    }
    // const {
    //     verticalAlign = VerticalAlign.TOP,
    //     horizontalAlign = HorizontalAlign.LEFT,
    //     centerAngle: centerAngleDeg = 0,
    //     vertexAngle: vertexAngleDeg = 0,
    //     wrapStrategy = WrapStrategy.UNSPECIFIED,
    //     isRotateNonEastAsian = BooleanNumber.FALSE,
    // } = renderConfig;
    // let paddingTop = 0;
    // if (verticalAlign === VerticalAlign.MIDDLE && pageHeight !== Infinity) {
    //     paddingTop = (pageHeight - height) / 2;
    // } else if (verticalAlign === VerticalAlign.BOTTOM && pageHeight !== Infinity) {
    //     paddingTop = pageHeight - height - pagePaddingBottom;
    // } else {
    //     paddingTop = pagePaddingTop;
    // }
    // let paddingLeft = 0;
    // if (horizontalAlign === HorizontalAlign.CENTER && pageWidth !== Infinity) {
    //     paddingLeft = (pageWidth - width) / 2;
    // } else if (horizontalAlign === HorizontalAlign.RIGHT && pageWidth !== Infinity) {
    //     paddingLeft = pageWidth - width - pagePaddingRight;
    // } else {
    //     paddingLeft = pagePaddingLeft;
    // }
    translatePagePadding(page) {
      const {
        marginTop: pagePaddingTop = 0,
        marginBottom: _pagePaddingBottom = 0,
        marginLeft: pagePaddingLeft = 0,
        marginRight: _pagePaddingRight = 0
      } = page;
      this.translate(pagePaddingLeft, pagePaddingTop);
    }
    restorePagePadding(page) {
      const {
        marginTop: pagePaddingTop = 0,
        marginBottom: _pagePaddingBottom = 0,
        marginLeft: pagePaddingLeft = 0,
        marginRight: _pagePaddingRight = 0
      } = page;
      this.translate(-pagePaddingLeft, -pagePaddingTop);
    }
    translatePage(page, type = 0 /* VERTICAL */, left = 0, top = 0, _right = 0, _bottom = 0) {
      const {
        // sections,
        // marginTop: pagePaddingTop = 0,
        // marginBottom: pagePaddingBottom = 0,
        // marginLeft: pagePaddingLeft = 0,
        // marginRight: pagePaddingRight = 0,
        pageWidth,
        pageHeight
        // width,
        // height,
        // pageNumber = 1,
        // renderConfig = {},
      } = page;
      let pageTop = 0;
      let pageLeft = 0;
      if (type === 0 /* VERTICAL */) {
        pageTop += pageHeight + top;
      } else if (type === 1 /* HORIZONTAL */) {
        pageLeft += pageWidth + left;
      }
      this.translate(pageLeft, pageTop);
      return {
        x: pageLeft,
        y: pageTop
      };
    }
    translateSection(section) {
      const { top: sectionTop = 0 } = section;
      this.translate(0, sectionTop);
      return {
        x: 0,
        y: sectionTop
      };
    }
    translateColumn(column) {
      const { left: columnLeft } = column;
      this.translate(columnLeft, 0);
      return {
        x: columnLeft,
        y: 0
      };
    }
    translateLine(line, isDraw = false) {
      const {
        top: lineTop,
        marginBottom: _lineMarginBottom = 0,
        marginTop: lineMarginTop = 0,
        paddingTop: linePaddingTop = 0,
        paddingBottom: _linePaddingBottom = 0
      } = line;
      const lineOffset = lineTop + (isDraw === true ? lineMarginTop : 0) + linePaddingTop;
      this.translate(0, lineOffset);
      return {
        x: 0,
        y: lineOffset
      };
    }
    translateDivide(divide) {
      const { left: divideLeft, paddingLeft: dividePaddingLeft } = divide;
      const left = divideLeft + dividePaddingLeft;
      this.translate(left, 0);
      return {
        x: left,
        y: 0
      };
    }
    translateSpan(glyph) {
      const { left: spanLeft } = glyph;
      this.translate(spanLeft, 0);
      return {
        x: spanLeft,
        y: 0
      };
    }
  };

  // ../packages/engine-render/src/components/docs/layout/model/section.ts
  function createSkeletonSection(columnProperties = [], columnSeparatorType = 1 /* NONE */, top = 0, left = 0, sectionWidth = Number.POSITIVE_INFINITY, sectionHeight = Number.POSITIVE_INFINITY) {
    const columns = [];
    let colWidth = 0;
    let spaceWidth = 0;
    if (columnProperties.length === 0) {
      columns.push(_getSkeletonColumn(left, sectionWidth, 0, 1 /* NONE */));
    } else {
      for (let i = 0; i < columnProperties.length; i++) {
        const { width, paddingEnd } = columnProperties[i];
        spaceWidth = paddingEnd;
        colWidth = width;
        columns.push(_getSkeletonColumn(left, colWidth, spaceWidth, columnSeparatorType));
        left += colWidth + spaceWidth;
        if (i === columnProperties.length - 1) {
          colWidth = sectionWidth !== Number.POSITIVE_INFINITY ? sectionWidth - colWidth : width;
          spaceWidth = 0;
          columns.push(_getSkeletonColumn(left, colWidth, spaceWidth, columnSeparatorType));
        }
      }
    }
    const newSection = {
      columns,
      colCount: (columnProperties == null ? void 0 : columnProperties.length) || 1,
      height: sectionHeight,
      top,
      st: 0,
      ed: 0
    };
    columns.forEach((column) => {
      column.parent = newSection;
    });
    return newSection;
  }
  function setColumnFullState(column, state) {
    column.isFull = state;
  }
  function _getSkeletonColumn(left, width, spaceWidth, columnSeparatorType) {
    return {
      lines: [],
      // column坐标系相对于section
      left,
      width,
      height: 0,
      spaceWidth,
      separator: columnSeparatorType,
      st: 0,
      ed: 0,
      drawingLRIds: [],
      isFull: false
    };
  }

  // ../packages/engine-render/src/components/docs/layout/block/block-error.ts
  function dealWithBlockError() {
    return [];
  }

  // ../packages/engine-render/src/components/docs/layout/linebreak/break.ts
  var Break = class {
    constructor(position, required = false) {
      this.position = position;
      this.required = required;
    }
  };

  // ../packages/engine-render/src/components/docs/layout/linebreak/classes.ts
  var NS = 5;
  var AL = 12;
  var HL = 13;
  var HY = 16;
  var BA = 17;
  var WJ = 22;
  var RI = 28;
  var ZWJ = 31;
  var AI = 33;
  var BK = 34;
  var CJ = 35;
  var CR = 36;
  var LF = 37;
  var NL = 38;
  var SA = 39;
  var SG = 40;
  var SP = 41;
  var XX = 42;

  // ../packages/engine-render/src/components/docs/layout/linebreak/pairs.ts
  var DI_BRK = 0;
  var IN_BRK = 1;
  var CI_BRK = 2;
  var CP_BRK = 3;
  var PR_BRK = 4;
  var pairTable = [
    //OP   , CL    , CP    , QU    , GL    , NS    , EX    , SY    , IS    , PR    , PO    , NU    , AL    , HL    , ID    , IN    , HY    , BA    , BB    , B2    , ZW    , CM    , WJ    , H2    , H3    , JL    , JV    , JT    , RI    , EB    , EM    , ZWJ   , CB
    [
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      CP_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK
    ],
    // OP
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // CL
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // CP
    [
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK
    ],
    // QU
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK
    ],
    // GL
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // NS
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // EX
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // SY
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // IS
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK
    ],
    // PR
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // PO
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // NU
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // AL
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // HL
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // ID
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // IN
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // HY
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // BA
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK
    ],
    // BB
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      PR_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // B2
    [
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK
    ],
    // ZW
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // CM
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK
    ],
    // WJ
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // H2
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // H3
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // JL
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // JV
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // JT
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // RI
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK
    ],
    // EB
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // EM
    [
      IN_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      IN_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ],
    // ZWJ
    [
      DI_BRK,
      PR_BRK,
      PR_BRK,
      IN_BRK,
      IN_BRK,
      DI_BRK,
      PR_BRK,
      PR_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      PR_BRK,
      CI_BRK,
      PR_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      DI_BRK,
      IN_BRK,
      DI_BRK
    ]
    // CB
  ];

  // ../packages/engine-render/src/components/docs/layout/linebreak/rule.ts
  var Rule = class {
    constructor() {
      __publicField(this, "_rules", /* @__PURE__ */ new Map());
    }
    add(key, rule) {
      this._rules.set(key, rule);
    }
    shouldBreak(codePoint, className) {
      for (const rule of this._rules.values()) {
        if (rule(codePoint, className)) {
          return true;
        }
      }
      return false;
    }
  };

  // ../packages/engine-render/src/components/docs/layout/linebreak/trie-data.ts
  var trie_data_default = new Uint8Array([
    0,
    8,
    14,
    0,
    0,
    0,
    0,
    0,
    176,
    232,
    0,
    0,
    1,
    181,
    15,
    74,
    240,
    237,
    157,
    11,
    140,
    93,
    69,
    25,
    199,
    231,
    178,
    187,
    183,
    123,
    31,
    187,
    237,
    46,
    108,
    193,
    194,
    22,
    104,
    41,
    200,
    242,
    48,
    128,
    104,
    16,
    129,
    152,
    162,
    64,
    42,
    10,
    193,
    42,
    24,
    121,
    104,
    2,
    65,
    177,
    4,
    9,
    69,
    41,
    193,
    104,
    73,
    35,
    193,
    84,
    20,
    104,
    144,
    152,
    74,
    140,
    109,
    80,
    1,
    149,
    87,
    12,
    175,
    68,
    64,
    162,
    60,
    42,
    9,
    136,
    196,
    70,
    194,
    35,
    40,
    132,
    84,
    222,
    34,
    40,
    18,
    255,
    195,
    153,
    113,
    103,
    103,
    231,
    253,
    58,
    183,
    244,
    158,
    228,
    151,
    57,
    103,
    158,
    223,
    124,
    243,
    205,
    227,
    204,
    57,
    231,
    222,
    141,
    3,
    132,
    220,
    0,
    110,
    5,
    119,
    129,
    191,
    129,
    127,
    128,
    127,
    130,
    255,
    130,
    129,
    65,
    66,
    58,
    131,
    254,
    238,
    56,
    88,
    0,
    22,
    129,
    41,
    240,
    1,
    240,
    97,
    135,
    116,
    71,
    128,
    163,
    12,
    225,
    199,
    130,
    229,
    224,
    100,
    112,
    58,
    88,
    1,
    86,
    130,
    11,
    193,
    197,
    66,
    188,
    75,
    192,
    247,
    193,
    85,
    224,
    26,
    176,
    17,
    220,
    0,
    174,
    7,
    183,
    128,
    59,
    193,
    239,
    192,
    67,
    224,
    81,
    240,
    56,
    75,
    251,
    36,
    115,
    159,
    3,
    47,
    129,
    55,
    192,
    155,
    128,
    12,
    17,
    50,
    12,
    230,
    129,
    113,
    176,
    0,
    44,
    2,
    83,
    96,
    95,
    112,
    16,
    56,
    20,
    44,
    101,
    225,
    203,
    192,
    9,
    44,
    156,
    94,
    127,
    30,
    124,
    9,
    124,
    5,
    124,
    21,
    156,
    7,
    46,
    4,
    23,
    179,
    240,
    239,
    130,
    43,
    192,
    143,
    216,
    245,
    79,
    193,
    117,
    67,
    85,
    249,
    55,
    195,
    189,
    3,
    220,
    203,
    242,
    167,
    242,
    61,
    0,
    247,
    17,
    176,
    25,
    252,
    21,
    60,
    11,
    30,
    27,
    168,
    174,
    183,
    128,
    87,
    216,
    245,
    91,
    112,
    27,
    205,
    42,
    77,
    11,
    238,
    24,
    152,
    0,
    147,
    205,
    42,
    124,
    11,
    139,
    191,
    164,
    89,
    185,
    123,
    179,
    184,
    156,
    3,
    154,
    211,
    28,
    194,
    56,
    2,
    124,
    140,
    33,
    198,
    53,
    113,
    12,
    226,
    30,
    47,
    197,
    63,
    11,
    229,
    157,
    228,
    145,
    135,
    11,
    95,
    20,
    242,
    251,
    50,
    206,
    87,
    128,
    149,
    224,
    34,
    176,
    166,
    57,
    93,
    223,
    181,
    56,
    95,
    7,
    214,
    75,
    229,
    111,
    196,
    245,
    213,
    194,
    245,
    181,
    184,
    254,
    21,
    248,
    141,
    144,
    150,
    114,
    23,
    75,
    119,
    159,
    224,
    191,
    137,
    234,
    20,
    60,
    209,
    172,
    236,
    158,
    242,
    44,
    206,
    159,
    3,
    47,
    130,
    55,
    192,
    59,
    160,
    57,
    7,
    233,
    160,
    251,
    209,
    57,
    85,
    30,
    19,
    112,
    39,
    193,
    30,
    115,
    166,
    203,
    221,
    23,
    231,
    7,
    206,
    209,
    215,
    243,
    35,
    8,
    59,
    220,
    16,
    238,
    194,
    39,
    144,
    254,
    83,
    224,
    179,
    224,
    20,
    112,
    6,
    56,
    27,
    156,
    15,
    190,
    9,
    86,
    131,
    75,
    193,
    229,
    96,
    29,
    88,
    15,
    54,
    176,
    50,
    175,
    99,
    238,
    205,
    112,
    239,
    0,
    247,
    130,
    7,
    193,
    163,
    96,
    51,
    11,
    123,
    6,
    238,
    243,
    224,
    37,
    141,
    156,
    175,
    9,
    254,
    111,
    225,
    188,
    49,
    60,
    147,
    237,
    132,
    243,
    54,
    24,
    5,
    243,
    193,
    66,
    176,
    4,
    236,
    7,
    14,
    6,
    135,
    129,
    143,
    131,
    99,
    193,
    114,
    112,
    50,
    56,
    29,
    172,
    0,
    43,
    135,
    171,
    252,
    47,
    128,
    251,
    109,
    240,
    29,
    118,
    253,
    61,
    184,
    235,
    134,
    253,
    117,
    182,
    158,
    165,
    217,
    0,
    247,
    58,
    143,
    244,
    55,
    7,
    148,
    117,
    187,
    148,
    230,
    30,
    225,
    250,
    90,
    102,
    99,
    15,
    192,
    239,
    17,
    176,
    121,
    184,
    234,
    207,
    207,
    12,
    251,
    241,
    2,
    120,
    21,
    252,
    155,
    234,
    187,
    5,
    61,
    131,
    241,
    86,
    117,
    190,
    160,
    101,
    78,
    187,
    72,
    8,
    159,
    178,
    196,
    237,
    211,
    167,
    79,
    58,
    248,
    56,
    80,
    183,
    28,
    125,
    250,
    244,
    233,
    211,
    167,
    79,
    159,
    62,
    125,
    182,
    46,
    246,
    239,
    209,
    251,
    182,
    131,
    91,
    51,
    247,
    67,
    180,
    251,
    32,
    173,
    106,
    47,
    143,
    158,
    31,
    129,
    243,
    95,
    10,
    97,
    71,
    181,
    236,
    233,
    63,
    141,
    56,
    159,
    99,
    241,
    78,
    129,
    251,
    49,
    184,
    147,
    224,
    12,
    156,
    159,
    205,
    242,
    62,
    31,
    238,
    69,
    96,
    13,
    88,
    11,
    126,
    0,
    174,
    6,
    63,
    105,
    85,
    251,
    56,
    63,
    135,
    123,
    99,
    107,
    230,
    254,
    16,
    229,
    54,
    248,
    253,
    204,
    80,
    246,
    221,
    8,
    191,
    31,
    60,
    0,
    30,
    4,
    15,
    129,
    77,
    224,
    143,
    224,
    225,
    126,
    88,
    63,
    172,
    31,
    214,
    15,
    235,
    135,
    37,
    15,
    251,
    51,
    120,
    2,
    60,
    213,
    170,
    246,
    76,
    235,
    228,
    249,
    86,
    189,
    212,
    93,
    255,
    62,
    125,
    122,
    153,
    216,
    117,
    236,
    203,
    232,
    99,
    111,
    130,
    183,
    91,
    225,
    207,
    233,
    72,
    91,
    237,
    63,
    12,
    255,
    121,
    96,
    39,
    176,
    43,
    216,
    75,
    138,
    183,
    15,
    174,
    15,
    2,
    135,
    130,
    165,
    96,
    25,
    56,
    174,
    93,
    201,
    117,
    34,
    220,
    211,
    218,
    245,
    143,
    63,
    59,
    204,
    173,
    184,
    18,
    252,
    9,
    116,
    231,
    233,
    57,
    26,
    92,
    2,
    238,
    84,
    132,
    189,
    45,
    93,
    127,
    112,
    140,
    144,
    243,
    192,
    45,
    96,
    203,
    88,
    229,
    183,
    219,
    56,
    33,
    95,
    0,
    87,
    130,
    95,
    131,
    151,
    193,
    211,
    173,
    74,
    119,
    167,
    130,
    107,
    192,
    147,
    84,
    135,
    29,
    66,
    14,
    0,
    4,
    247,
    31,
    159,
    233,
    84,
    215,
    34,
    23,
    131,
    43,
    26,
    211,
    220,
    203,
    226,
    114,
    182,
    224,
    122,
    223,
    46,
    33,
    159,
    4,
    95,
    3,
    95,
    7,
    55,
    129,
    87,
    193,
    129,
    35,
    240,
    3,
    55,
    130,
    87,
    70,
    102,
    230,
    179,
    173,
    49,
    54,
    58,
    83,
    111,
    125,
    250,
    244,
    233,
    179,
    45,
    113,
    252,
    168,
    121,
    238,
    63,
    19,
    243,
    209,
    57,
    154,
    249,
    159,
    114,
    110,
    123,
    246,
    154,
    133,
    135,
    173,
    66,
    216,
    106,
    41,
    237,
    26,
    92,
    175,
    101,
    126,
    203,
    53,
    239,
    94,
    209,
    247,
    178,
    214,
    37,
    126,
    47,
    203,
    196,
    101,
    154,
    250,
    173,
    51,
    212,
    155,
    178,
    30,
    225,
    251,
    209,
    119,
    229,
    20,
    241,
    126,
    193,
    252,
    110,
    178,
    228,
    97,
    227,
    118,
    133,
    126,
    85,
    240,
    248,
    247,
    176,
    248,
    191,
    23,
    202,
    125,
    152,
    157,
    63,
    46,
    248,
    109,
    166,
    235,
    48,
    240,
    119,
    232,
    249,
    5,
    184,
    175,
    180,
    171,
    119,
    195,
    222,
    130,
    219,
    192,
    250,
    97,
    78,
    167,
    186,
    158,
    11,
    119,
    71,
    176,
    51,
    187,
    190,
    0,
    105,
    23,
    119,
    166,
    247,
    21,
    247,
    193,
    249,
    65,
    157,
    105,
    25,
    14,
    197,
    249,
    249,
    112,
    151,
    194,
    93,
    6,
    142,
    5,
    203,
    193,
    201,
    29,
    181,
    204,
    13,
    216,
    224,
    233,
    157,
    105,
    185,
    22,
    130,
    21,
    138,
    184,
    60,
    254,
    42,
    176,
    82,
    40,
    143,
    198,
    191,
    8,
    215,
    107,
    88,
    30,
    107,
    225,
    174,
    99,
    225,
    116,
    15,
    116,
    61,
    206,
    55,
    26,
    242,
    187,
    161,
    163,
    214,
    59,
    221,
    119,
    165,
    123,
    171,
    183,
    34,
    252,
    174,
    206,
    204,
    52,
    247,
    225,
    122,
    19,
    245,
    3,
    127,
    1,
    79,
    179,
    60,
    158,
    135,
    251,
    50,
    59,
    127,
    29,
    238,
    219,
    154,
    114,
    229,
    250,
    12,
    98,
    93,
    214,
    1,
    243,
    192,
    68,
    119,
    118,
    89,
    147,
    221,
    234,
    124,
    73,
    119,
    186,
    110,
    54,
    246,
    67,
    220,
    131,
    187,
    213,
    187,
    127,
    135,
    9,
    121,
    30,
    137,
    243,
    163,
    193,
    113,
    221,
    114,
    253,
    203,
    133,
    19,
    123,
    76,
    158,
    58,
    56,
    141,
    233,
    224,
    76,
    131,
    46,
    206,
    210,
    132,
    157,
    11,
    255,
    85,
    93,
    55,
    219,
    200,
    73,
    104,
    221,
    87,
    39,
    108,
    127,
    250,
    110,
    226,
    165,
    221,
    233,
    115,
    58,
    151,
    92,
    198,
    174,
    175,
    130,
    251,
    227,
    66,
    182,
    182,
    81,
    83,
    206,
    245,
    221,
    234,
    221,
    201,
    27,
    133,
    246,
    186,
    173,
    155,
    255,
    153,
    86,
    104,
    61,
    238,
    102,
    114,
    222,
    223,
    3,
    246,
    85,
    39,
    155,
    28,
    219,
    232,
    49,
    196,
    219,
    12,
    158,
    242,
    108,
    211,
    103,
    183,
    2,
    253,
    202,
    182,
    177,
    165,
    59,
    253,
    174,
    249,
    182,
    202,
    235,
    158,
    227,
    201,
    127,
    104,
    252,
    17,
    232,
    83,
    177,
    54,
    236,
    140,
    148,
    25,
    155,
    82,
    49,
    15,
    242,
    238,
    144,
    64,
    102,
    170,
    199,
    93,
    70,
    42,
    119,
    49,
    220,
    41,
    112,
    192,
    72,
    253,
    246,
    46,
    218,
    61,
    253,
    70,
    64,
    23,
    78,
    229,
    62,
    132,
    233,
    225,
    112,
    184,
    75,
    71,
    102,
    167,
    95,
    6,
    191,
    19,
    60,
    116,
    117,
    34,
    139,
    123,
    90,
    132,
    30,
    232,
    122,
    239,
    204,
    204,
    122,
    212,
    201,
    127,
    206,
    200,
    204,
    240,
    111,
    20,
    104,
    207,
    111,
    49,
    157,
    173,
    73,
    212,
    143,
    14,
    115,
    144,
    217,
    54,
    174,
    175,
    69,
    30,
    151,
    143,
    84,
    223,
    145,
    252,
    144,
    185,
    235,
    71,
    170,
    176,
    13,
    35,
    254,
    243,
    248,
    245,
    72,
    115,
    11,
    184,
    19,
    252,
    86,
    72,
    255,
    7,
    156,
    63,
    12,
    30,
    7,
    79,
    10,
    254,
    207,
    225,
    252,
    69,
    240,
    58,
    248,
    23,
    120,
    135,
    133,
    13,
    226,
    222,
    191,
    51,
    58,
    29,
    111,
    28,
    231,
    243,
    217,
    245,
    66,
    184,
    123,
    142,
    206,
    94,
    55,
    236,
    47,
    236,
    23,
    156,
    202,
    210,
    125,
    136,
    249,
    125,
    148,
    185,
    71,
    194,
    125,
    77,
    40,
    255,
    152,
    209,
    106,
    159,
    129,
    158,
    159,
    196,
    220,
    83,
    225,
    158,
    33,
    229,
    191,
    255,
    232,
    204,
    122,
    158,
    141,
    235,
    115,
    13,
    251,
    19,
    180,
    63,
    174,
    26,
    245,
    215,
    223,
    123,
    137,
    213,
    84,
    183,
    131,
    225,
    115,
    87,
    47,
    141,
    177,
    161,
    108,
    24,
    104,
    252,
    159,
    9,
    66,
    172,
    140,
    129,
    37,
    96,
    17,
    99,
    15,
    135,
    52,
    174,
    236,
    13,
    112,
    187,
    65,
    32,
    22,
    193,
    208,
    75,
    90,
    228,
    221,
    199,
    103,
    239,
    158,
    83,
    63,
    122,
    108,
    39,
    132,
    161,
    9,
    201,
    60,
    230,
    210,
    45,
    185,
    142,
    35,
    195,
    140,
    174,
    64,
    83,
    186,
    206,
    13,
    97,
    117,
    216,
    174,
    96,
    153,
    114,
    249,
    180,
    45,
    27,
    236,
    122,
    130,
    244,
    143,
    169,
    109,
    28,
    85,
    159,
    220,
    83,
    227,
    159,
    131,
    65,
    214,
    14,
    180,
    207,
    183,
    4,
    168,
    125,
    238,
    206,
    224,
    231,
    124,
    140,
    24,
    35,
    211,
    54,
    205,
    211,
    241,
    184,
    227,
    82,
    90,
    145,
    1,
    233,
    154,
    144,
    188,
    253,
    109,
    247,
    204,
    249,
    247,
    122,
    249,
    189,
    6,
    183,
    15,
    209,
    6,
    248,
    181,
    171,
    206,
    100,
    155,
    18,
    211,
    140,
    91,
    210,
    150,
    160,
    84,
    191,
    221,
    26,
    24,
    12,
    76,
    163,
    35,
    68,
    134,
    208,
    118,
    148,
    215,
    42,
    182,
    182,
    173,
    219,
    238,
    114,
    66,
    117,
    65,
    199,
    124,
    62,
    103,
    113,
    255,
    22,
    209,
    207,
    97,
    189,
    206,
    152,
    208,
    110,
    19,
    138,
    243,
    38,
    115,
    109,
    243,
    247,
    72,
    15,
    193,
    219,
    197,
    103,
    253,
    161,
    91,
    175,
    139,
    237,
    223,
    22,
    144,
    215,
    241,
    62,
    58,
    111,
    10,
    46,
    167,
    110,
    219,
    206,
    61,
    118,
    187,
    222,
    31,
    181,
    53,
    186,
    207,
    61,
    182,
    52,
    137,
    189,
    238,
    29,
    75,
    28,
    89,
    127,
    170,
    184,
    60,
    142,
    171,
    62,
    82,
    183,
    235,
    123,
    193,
    166,
    228,
    241,
    247,
    189,
    132,
    143,
    30,
    186,
    196,
    111,
    140,
    115,
    25,
    239,
    114,
    218,
    95,
    78,
    157,
    200,
    105,
    232,
    216,
    204,
    251,
    180,
    120,
    143,
    41,
    222,
    215,
    149,
    144,
    85,
    39,
    191,
    236,
    175,
    139,
    87,
    210,
    214,
    115,
    149,
    43,
    218,
    155,
    207,
    253,
    191,
    169,
    125,
    83,
    244,
    159,
    208,
    121,
    44,
    119,
    25,
    49,
    245,
    207,
    105,
    19,
    41,
    245,
    107,
    203,
    203,
    87,
    190,
    49,
    70,
    201,
    113,
    77,
    238,
    47,
    117,
    180,
    143,
    216,
    127,
    82,
    180,
    143,
    152,
    167,
    169,
    175,
    202,
    126,
    54,
    29,
    133,
    206,
    59,
    124,
    189,
    173,
    202,
    155,
    251,
    183,
    20,
    229,
    169,
    198,
    209,
    186,
    219,
    39,
    5,
    166,
    118,
    177,
    201,
    16,
    179,
    14,
    80,
    245,
    75,
    87,
    123,
    81,
    233,
    160,
    116,
    123,
    196,
    234,
    59,
    181,
    28,
    33,
    253,
    161,
    69,
    236,
    237,
    95,
    106,
    62,
    42,
    213,
    255,
    67,
    108,
    90,
    182,
    185,
    58,
    250,
    189,
    78,
    206,
    84,
    122,
    55,
    233,
    192,
    54,
    78,
    228,
    186,
    15,
    224,
    227,
    176,
    235,
    250,
    110,
    107,
    232,
    255,
    174,
    109,
    146,
    187,
    255,
    155,
    218,
    208,
    117,
    191,
    95,
    148,
    185,
    244,
    51,
    130,
    146,
    99,
    145,
    105,
    76,
    138,
    209,
    127,
    76,
    93,
    234,
    208,
    117,
    10,
    189,
    187,
    150,
    151,
    219,
    254,
    93,
    242,
    214,
    173,
    19,
    101,
    82,
    142,
    199,
    190,
    54,
    233,
    219,
    223,
    197,
    118,
    112,
    29,
    211,
    57,
    123,
    245,
    8,
    178,
    92,
    173,
    200,
    252,
    186,
    30,
    122,
    228,
    247,
    133,
    189,
    170,
    27,
    174,
    31,
    95,
    187,
    80,
    233,
    100,
    92,
    66,
    244,
    27,
    20,
    206,
    199,
    216,
    117,
    83,
    193,
    32,
    75,
    39,
    63,
    147,
    176,
    141,
    7,
    169,
    239,
    187,
    229,
    231,
    82,
    220,
    165,
    71,
    67,
    112,
    99,
    198,
    215,
    84,
    107,
    179,
    49,
    7,
    255,
    210,
    115,
    162,
    235,
    24,
    197,
    251,
    71,
    236,
    216,
    46,
    218,
    150,
    110,
    109,
    193,
    159,
    95,
    199,
    140,
    139,
    58,
    121,
    99,
    251,
    160,
    107,
    249,
    186,
    244,
    239,
    171,
    153,
    5,
    53,
    179,
    115,
    205,
    228,
    90,
    75,
    153,
    198,
    13,
    121,
    157,
    100,
    234,
    71,
    185,
    169,
    179,
    236,
    210,
    229,
    211,
    163,
    65,
    102,
    142,
    31,
    190,
    178,
    218,
    198,
    189,
    80,
    92,
    215,
    129,
    161,
    178,
    251,
    148,
    175,
    91,
    251,
    228,
    148,
    193,
    167,
    222,
    169,
    203,
    159,
    138,
    40,
    63,
    245,
    154,
    142,
    235,
    126,
    72,
    184,
    230,
    182,
    39,
    174,
    127,
    83,
    237,
    3,
    164,
    106,
    63,
    190,
    14,
    228,
    242,
    143,
    75,
    254,
    178,
    141,
    241,
    247,
    209,
    114,
    200,
    95,
    199,
    189,
    179,
    205,
    174,
    74,
    174,
    205,
    100,
    253,
    136,
    215,
    188,
    61,
    98,
    215,
    45,
    177,
    247,
    114,
    190,
    246,
    107,
    186,
    167,
    203,
    133,
    73,
    191,
    60,
    78,
    93,
    247,
    125,
    220,
    182,
    92,
    245,
    23,
    75,
    234,
    241,
    47,
    246,
    222,
    73,
    164,
    228,
    145,
    67,
    54,
    81,
    159,
    163,
    142,
    240,
    113,
    86,
    60,
    23,
    253,
    92,
    112,
    145,
    223,
    71,
    22,
    213,
    218,
    182,
    14,
    66,
    108,
    136,
    167,
    141,
    221,
    143,
    208,
    29,
    161,
    118,
    227,
    187,
    254,
    201,
    57,
    159,
    200,
    118,
    230,
    243,
    222,
    132,
    78,
    230,
    212,
    251,
    63,
    185,
    112,
    93,
    247,
    219,
    218,
    75,
    182,
    185,
    24,
    91,
    21,
    219,
    220,
    212,
    23,
    84,
    182,
    145,
    178,
    239,
    132,
    126,
    91,
    144,
    2,
    185,
    236,
    58,
    108,
    131,
    175,
    117,
    117,
    125,
    132,
    51,
    40,
    93,
    239,
    192,
    100,
    222,
    85,
    144,
    95,
    142,
    183,
    61,
    153,
    249,
    173,
    206,
    0,
    153,
    254,
    174,
    116,
    64,
    113,
    45,
    198,
    165,
    204,
    21,
    160,
    249,
    241,
    111,
    96,
    117,
    186,
    108,
    91,
    16,
    101,
    160,
    229,
    12,
    49,
    116,
    186,
    25,
    102,
    178,
    53,
    132,
    184,
    166,
    248,
    166,
    254,
    215,
    86,
    232,
    180,
    43,
    93,
    207,
    87,
    164,
    245,
    89,
    103,
    200,
    253,
    216,
    229,
    27,
    52,
    94,
    63,
    241,
    123,
    42,
    249,
    27,
    43,
    151,
    244,
    161,
    247,
    99,
    226,
    248,
    210,
    50,
    208,
    182,
    132,
    251,
    166,
    109,
    43,
    206,
    99,
    202,
    104,
    121,
    180,
    147,
    235,
    156,
    21,
    179,
    159,
    192,
    237,
    93,
    110,
    195,
    54,
    113,
    107,
    23,
    49,
    157,
    207,
    187,
    195,
    174,
    118,
    147,
    227,
    251,
    72,
    83,
    217,
    170,
    239,
    12,
    85,
    223,
    169,
    154,
    208,
    149,
    231,
    155,
    206,
    85,
    47,
    114,
    251,
    230,
    40,
    207,
    71,
    166,
    208,
    186,
    168,
    228,
    146,
    253,
    84,
    225,
    220,
    149,
    191,
    75,
    182,
    181,
    173,
    74,
    23,
    114,
    29,
    76,
    186,
    51,
    217,
    144,
    139,
    61,
    132,
    180,
    181,
    173,
    220,
    20,
    253,
    193,
    164,
    27,
    211,
    117,
    10,
    251,
    73,
    149,
    191,
    171,
    206,
    98,
    117,
    23,
    43,
    151,
    47,
    115,
    19,
    200,
    64,
    15,
    241,
    57,
    113,
    168,
    172,
    252,
    222,
    216,
    167,
    204,
    28,
    58,
    149,
    239,
    213,
    99,
    242,
    138,
    153,
    87,
    117,
    248,
    206,
    31,
    57,
    233,
    6,
    166,
    145,
    237,
    34,
    135,
    92,
    62,
    125,
    40,
    69,
    89,
    161,
    50,
    184,
    234,
    210,
    39,
    31,
    213,
    181,
    171,
    191,
    156,
    71,
    108,
    253,
    92,
    245,
    238,
    154,
    38,
    71,
    255,
    54,
    213,
    219,
    166,
    55,
    158,
    15,
    15,
    31,
    85,
    148,
    51,
    73,
    210,
    140,
    39,
    33,
    117,
    212,
    233,
    48,
    133,
    46,
    99,
    218,
    93,
    101,
    115,
    92,
    127,
    170,
    56,
    41,
    100,
    46,
    165,
    127,
    91,
    189,
    75,
    227,
    186,
    191,
    45,
    219,
    178,
    201,
    166,
    119,
    215,
    196,
    87,
    245,
    7,
    57,
    76,
    236,
    119,
    58,
    61,
    169,
    228,
    80,
    229,
    163,
    146,
    103,
    210,
    80,
    174,
    10,
    149,
    174,
    38,
    37,
    74,
    217,
    136,
    120,
    61,
    160,
    129,
    134,
    241,
    231,
    146,
    178,
    252,
    244,
    104,
    4,
    184,
    57,
    230,
    225,
    80,
    123,
    231,
    50,
    149,
    236,
    35,
    174,
    122,
    170,
    163,
    76,
    95,
    183,
    78,
    189,
    149,
    44,
    187,
    148,
    173,
    164,
    178,
    107,
    25,
    211,
    62,
    170,
    252,
    14,
    130,
    188,
    135,
    219,
    36,
    110,
    207,
    87,
    108,
    184,
    190,
    183,
    164,
    123,
    54,
    163,
    27,
    163,
    108,
    152,
    246,
    253,
    197,
    125,
    106,
    34,
    213,
    83,
    28,
    3,
    197,
    107,
    122,
    152,
    250,
    132,
    156,
    63,
    127,
    199,
    70,
    181,
    47,
    174,
    210,
    211,
    246,
    12,
    221,
    94,
    58,
    81,
    148,
    161,
    171,
    147,
    174,
    44,
    62,
    166,
    187,
    212,
    197,
    247,
    249,
    119,
    46,
    248,
    239,
    75,
    54,
    4,
    191,
    33,
    225,
    220,
    86,
    23,
    34,
    165,
    181,
    197,
    27,
    18,
    206,
    197,
    116,
    161,
    207,
    238,
    117,
    113,
    85,
    254,
    252,
    89,
    140,
    232,
    71,
    219,
    96,
    49,
    59,
    183,
    185,
    185,
    41,
    85,
    142,
    173,
    124,
    151,
    122,
    219,
    194,
    22,
    147,
    217,
    207,
    128,
    135,
    36,
    120,
    155,
    244,
    154,
    254,
    83,
    213,
    95,
    101,
    127,
    139,
    137,
    218,
    14,
    99,
    100,
    142,
    193,
    150,
    191,
    109,
    125,
    152,
    163,
    29,
    66,
    117,
    227,
    251,
    188,
    43,
    102,
    206,
    77,
    53,
    127,
    235,
    214,
    19,
    190,
    239,
    75,
    164,
    150,
    65,
    156,
    227,
    68,
    92,
    245,
    43,
    203,
    228,
    251,
    30,
    71,
    14,
    125,
    234,
    100,
    240,
    177,
    15,
    215,
    103,
    161,
    161,
    240,
    239,
    131,
    248,
    90,
    194,
    231,
    253,
    26,
    159,
    103,
    194,
    49,
    239,
    51,
    185,
    148,
    239,
    139,
    143,
    126,
    92,
    236,
    199,
    86,
    94,
    142,
    239,
    26,
    114,
    63,
    187,
    167,
    101,
    212,
    241,
    205,
    148,
    169,
    189,
    235,
    60,
    66,
    244,
    77,
    15,
    221,
    252,
    97,
    122,
    167,
    116,
    74,
    227,
    239,
    75,
    157,
    223,
    223,
    77,
    101,
    212,
    171,
    171,
    45,
    139,
    58,
    158,
    32,
    246,
    123,
    46,
    57,
    239,
    16,
    157,
    135,
    126,
    199,
    228,
    58,
    110,
    248,
    212,
    223,
    119,
    140,
    146,
    243,
    142,
    29,
    175,
    119,
    4,
    59,
    21,
    164,
    116,
    121,
    190,
    123,
    32,
    41,
    191,
    237,
    148,
    243,
    174,
    227,
    251,
    78,
    89,
    134,
    247,
    215,
    76,
    206,
    181,
    82,
    87,
    211,
    166,
    244,
    183,
    141,
    39,
    136,
    223,
    239,
    32,
    231,
    254,
    141,
    229,
    210,
    240,
    61,
    151,
    210,
    229,
    202,
    235,
    227,
    216,
    117,
    225,
    48,
    153,
    222,
    43,
    226,
    191,
    37,
    45,
    239,
    179,
    209,
    247,
    96,
    114,
    173,
    79,
    85,
    243,
    9,
    47,
    215,
    213,
    149,
    211,
    153,
    230,
    170,
    134,
    224,
    82,
    249,
    249,
    94,
    129,
    248,
    188,
    200,
    86,
    142,
    13,
    254,
    222,
    170,
    234,
    158,
    185,
    14,
    91,
    229,
    101,
    207,
    103,
    46,
    175,
    167,
    44,
    171,
    74,
    135,
    13,
    201,
    245,
    217,
    99,
    144,
    247,
    25,
    154,
    158,
    121,
    196,
    66,
    2,
    101,
    207,
    85,
    62,
    215,
    109,
    67,
    58,
    231,
    122,
    74,
    181,
    167,
    84,
    130,
    148,
    123,
    108,
    190,
    136,
    253,
    137,
    218,
    110,
    75,
    10,
    231,
    239,
    166,
    218,
    250,
    155,
    235,
    26,
    70,
    28,
    175,
    118,
    35,
    213,
    190,
    92,
    29,
    253,
    217,
    182,
    222,
    239,
    133,
    177,
    134,
    207,
    73,
    41,
    101,
    240,
    93,
    115,
    202,
    109,
    87,
    151,
    30,
    100,
    157,
    184,
    220,
    207,
    213,
    37,
    31,
    183,
    165,
    58,
    202,
    157,
    146,
    202,
    143,
    89,
    79,
    228,
    182,
    55,
    151,
    103,
    152,
    174,
    182,
    224,
    210,
    246,
    186,
    114,
    76,
    107,
    178,
    18,
    246,
    228,
    170,
    19,
    91,
    63,
    176,
    201,
    95,
    234,
    247,
    40,
    196,
    113,
    126,
    76,
    145,
    62,
    102,
    12,
    138,
    197,
    197,
    190,
    75,
    247,
    145,
    28,
    121,
    166,
    236,
    167,
    42,
    221,
    213,
    113,
    152,
    246,
    73,
    117,
    123,
    161,
    185,
    214,
    162,
    174,
    242,
    202,
    178,
    211,
    195,
    69,
    215,
    252,
    55,
    251,
    82,
    218,
    149,
    139,
    29,
    119,
    200,
    236,
    113,
    199,
    117,
    191,
    144,
    143,
    49,
    165,
    214,
    43,
    57,
    199,
    179,
    208,
    57,
    211,
    71,
    46,
    213,
    248,
    94,
    215,
    24,
    192,
    203,
    20,
    191,
    151,
    118,
    25,
    15,
    228,
    124,
    228,
    247,
    143,
    84,
    118,
    198,
    207,
    125,
    126,
    95,
    96,
    92,
    202,
    63,
    100,
    125,
    229,
    219,
    150,
    186,
    247,
    181,
    38,
    164,
    60,
    235,
    154,
    203,
    92,
    234,
    108,
    122,
    14,
    94,
    114,
    124,
    201,
    209,
    127,
    85,
    101,
    212,
    113,
    136,
    178,
    168,
    108,
    222,
    7,
    158,
    223,
    148,
    116,
    174,
    170,
    187,
    202,
    159,
    191,
    31,
    40,
    30,
    49,
    242,
    184,
    180,
    163,
    107,
    251,
    152,
    214,
    56,
    170,
    177,
    208,
    119,
    28,
    229,
    54,
    45,
    143,
    51,
    186,
    50,
    93,
    230,
    178,
    88,
    251,
    228,
    191,
    159,
    202,
    223,
    195,
    145,
    127,
    131,
    215,
    118,
    15,
    20,
    114,
    63,
    32,
    150,
    47,
    199,
    245,
    105,
    191,
    216,
    250,
    203,
    191,
    93,
    236,
    66,
    233,
    241,
    49,
    102,
    190,
    183,
    233,
    52,
    86,
    127,
    177,
    196,
    254,
    14,
    156,
    239,
    243,
    123,
    209,
    54,
    67,
    127,
    115,
    174,
    174,
    246,
    143,
    89,
    243,
    233,
    214,
    107,
    177,
    71,
    204,
    28,
    66,
    132,
    115,
    121,
    61,
    227,
    242,
    110,
    28,
    37,
    100,
    15,
    57,
    70,
    255,
    169,
    219,
    132,
    183,
    203,
    184,
    144,
    87,
    9,
    187,
    19,
    235,
    31,
    99,
    63,
    41,
    177,
    149,
    45,
    251,
    169,
    214,
    219,
    99,
    158,
    186,
    244,
    109,
    191,
    82,
    54,
    33,
    207,
    161,
    226,
    252,
    227,
    211,
    63,
    114,
    216,
    187,
    13,
    83,
    249,
    117,
    204,
    177,
    114,
    253,
    67,
    222,
    195,
    245,
    157,
    111,
    82,
    233,
    143,
    191,
    187,
    154,
    186,
    109,
    98,
    237,
    211,
    5,
    23,
    125,
    218,
    250,
    123,
    170,
    246,
    136,
    237,
    15,
    49,
    99,
    187,
    73,
    254,
    84,
    135,
    234,
    158,
    206,
    197,
    182,
    197,
    249,
    120,
    130,
    148,
    63,
    196,
    242,
    67,
    246,
    71,
    93,
    143,
    148,
    227,
    71,
    105,
    218,
    100,
    246,
    111,
    232,
    229,
    28,
    163,
    117,
    196,
    62,
    47,
    228,
    121,
    132,
    142,
    189,
    37,
    244,
    47,
    30,
    13,
    1,
    57,
    158,
    236,
    199,
    227,
    19,
    77,
    252,
    220,
    50,
    235,
    228,
    244,
    205,
    103,
    208,
    0,
    47,
    71,
    229,
    199,
    93,
    211,
    26,
    41,
    247,
    92,
    18,
    99,
    31,
    169,
    218,
    45,
    116,
    62,
    10,
    221,
    47,
    54,
    245,
    53,
    221,
    252,
    234,
    211,
    231,
    98,
    229,
    240,
    89,
    227,
    170,
    224,
    97,
    169,
    215,
    103,
    37,
    198,
    146,
    216,
    54,
    85,
    205,
    213,
    177,
    253,
    40,
    197,
    189,
    141,
    136,
    252,
    13,
    170,
    238,
    127,
    150,
    108,
    235,
    143,
    94,
    155,
    143,
    93,
    203,
    143,
    217,
    123,
    168,
    123,
    61,
    34,
    203,
    31,
    35,
    71,
    236,
    119,
    179,
    169,
    72,
    209,
    94,
    185,
    222,
    93,
    44,
    49,
    230,
    152,
    198,
    96,
    219,
    115,
    159,
    82,
    253,
    205,
    54,
    246,
    228,
    30,
    223,
    82,
    143,
    129,
    190,
    117,
    46,
    217,
    246,
    190,
    243,
    98,
    110,
    114,
    181,
    173,
    74,
    175,
    185,
    230,
    65,
    159,
    54,
    20,
    227,
    170,
    158,
    141,
    197,
    140,
    185,
    41,
    116,
    22,
    59,
    255,
    196,
    150,
    149,
    218,
    206,
    83,
    146,
    66,
    63,
    177,
    117,
    9,
    181,
    83,
    223,
    126,
    159,
    123,
    158,
    74,
    161,
    203,
    16,
    185,
    100,
    157,
    197,
    236,
    23,
    250,
    252,
    6,
    123,
    142,
    242,
    83,
    180,
    75,
    234,
    249,
    223,
    102,
    159,
    114,
    250,
    208,
    250,
    243,
    163,
    14,
    27,
    18,
    105,
    91,
    174,
    125,
    9,
    249,
    13,
    65,
    113,
    125,
    153,
    250,
    119,
    9,
    83,
    231,
    215,
    205,
    32,
    111,
    142,
    117,
    250,
    46,
    133,
    80,
    149,
    61,
    169,
    241,
    79,
    129,
    170,
    13,
    74,
    150,
    161,
    243,
    23,
    127,
    75,
    84,
    165,
    7,
    85,
    120,
    105,
    22,
    42,
    144,
    229,
    83,
    201,
    107,
    35,
    133,
    108,
    62,
    229,
    249,
    200,
    163,
    146,
    79,
    142,
    235,
    90,
    151,
    73,
    67,
    158,
    62,
    182,
    165,
    114,
    117,
    101,
    233,
    210,
    134,
    246,
    1,
    211,
    216,
    29,
    219,
    134,
    174,
    115,
    68,
    206,
    188,
    115,
    213,
    205,
    102,
    183,
    46,
    237,
    23,
    154,
    191,
    107,
    153,
    41,
    40,
    173,
    199,
    144,
    114,
    76,
    125,
    189,
    212,
    239,
    58,
    139,
    191,
    117,
    106,
    250,
    31,
    175,
    212,
    54,
    225,
    59,
    238,
    250,
    150,
    153,
    218,
    174,
    82,
    235,
    61,
    119,
    249,
    169,
    229,
    79,
    37,
    95,
    174,
    254,
    26,
    91,
    63,
    221,
    122,
    199,
    197,
    126,
    125,
    214,
    18,
    62,
    246,
    238,
    179,
    70,
    40,
    185,
    46,
    203,
    85,
    134,
    106,
    45,
    19,
    83,
    158,
    105,
    125,
    20,
    179,
    38,
    172,
    99,
    13,
    28,
    187,
    126,
    141,
    189,
    55,
    143,
    221,
    31,
    41,
    165,
    39,
    215,
    122,
    255,
    15
  ]);

  // ../packages/engine-render/src/components/docs/layout/linebreak/swap.ts
  var isBigEndian = new Uint8Array(new Uint32Array([305419896]).buffer)[0] === 18;
  var swap = (b, n, m) => {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
  };
  var swap32 = (array) => {
    const len = array.length;
    for (let i = 0; i < len; i += 4) {
      swap(array, i, i + 3);
      swap(array, i + 1, i + 2);
    }
  };
  var swap32LE = (array) => {
    if (isBigEndian) {
      swap32(array);
    }
  };

  // ../packages/engine-render/src/components/docs/layout/linebreak/tiny-inflate.ts
  var TINF_OK = 0;
  var TINF_DATA_ERROR = -3;
  var Tree = class {
    constructor() {
      __publicField(this, "table", new Uint16Array(16));
      /* table of code length counts */
      __publicField(this, "trans", new Uint16Array(288));
    }
    /* code -> symbol translation table */
  };
  var Data = class {
    constructor(source, dest) {
      __publicField(this, "source");
      __publicField(this, "dest");
      __publicField(this, "sourceIndex");
      __publicField(this, "tag");
      __publicField(this, "bitcount");
      __publicField(this, "destLen");
      __publicField(this, "ltree");
      __publicField(this, "dtree");
      this.source = source;
      this.sourceIndex = 0;
      this.tag = 0;
      this.bitcount = 0;
      this.dest = dest;
      this.destLen = 0;
      this.ltree = new Tree();
      this.dtree = new Tree();
    }
  };
  var sltree = new Tree();
  var sdtree = new Tree();
  var length_bits = new Uint8Array(30);
  var length_base = new Uint16Array(30);
  var dist_bits = new Uint8Array(30);
  var dist_base = new Uint16Array(30);
  var clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var code_tree = new Tree();
  var lengths = new Uint8Array(288 + 32);
  function tinf_build_bits_base(bits, base, delta, first) {
    let i;
    let sum;
    for (i = 0; i < delta; ++i)
      bits[i] = 0;
    for (i = 0; i < 30 - delta; ++i)
      bits[i + delta] = i / delta | 0;
    for (sum = first, i = 0; i < 30; ++i) {
      base[i] = sum;
      sum += 1 << bits[i];
    }
  }
  function tinf_build_fixed_trees(lt, dt) {
    let i;
    for (i = 0; i < 7; ++i)
      lt.table[i] = 0;
    lt.table[7] = 24;
    lt.table[8] = 152;
    lt.table[9] = 112;
    for (i = 0; i < 24; ++i)
      lt.trans[i] = 256 + i;
    for (i = 0; i < 144; ++i)
      lt.trans[24 + i] = i;
    for (i = 0; i < 8; ++i)
      lt.trans[24 + 144 + i] = 280 + i;
    for (i = 0; i < 112; ++i)
      lt.trans[24 + 144 + 8 + i] = 144 + i;
    for (i = 0; i < 5; ++i)
      dt.table[i] = 0;
    dt.table[5] = 32;
    for (i = 0; i < 32; ++i)
      dt.trans[i] = i;
  }
  var offs = new Uint16Array(16);
  function tinf_build_tree(t, lengths2, off, num) {
    let i;
    let sum;
    for (i = 0; i < 16; ++i)
      t.table[i] = 0;
    for (i = 0; i < num; ++i)
      t.table[lengths2[off + i]]++;
    t.table[0] = 0;
    for (sum = 0, i = 0; i < 16; ++i) {
      offs[i] = sum;
      sum += t.table[i];
    }
    for (i = 0; i < num; ++i) {
      if (lengths2[off + i])
        t.trans[offs[lengths2[off + i]]++] = i;
    }
  }
  function tinf_getbit(d) {
    if (!d.bitcount--) {
      d.tag = d.source[d.sourceIndex++];
      d.bitcount = 7;
    }
    const bit = d.tag & 1;
    d.tag >>>= 1;
    return bit;
  }
  function tinf_read_bits(d, num, base) {
    if (!num)
      return base;
    while (d.bitcount < 24) {
      d.tag |= d.source[d.sourceIndex++] << d.bitcount;
      d.bitcount += 8;
    }
    const val = d.tag & 65535 >>> 16 - num;
    d.tag >>>= num;
    d.bitcount -= num;
    return val + base;
  }
  function tinf_decode_symbol(d, t) {
    while (d.bitcount < 24) {
      d.tag |= d.source[d.sourceIndex++] << d.bitcount;
      d.bitcount += 8;
    }
    let sum = 0;
    let cur = 0;
    let len = 0;
    let tag = d.tag;
    do {
      cur = 2 * cur + (tag & 1);
      tag >>>= 1;
      ++len;
      sum += t.table[len];
      cur -= t.table[len];
    } while (cur >= 0);
    d.tag = tag;
    d.bitcount -= len;
    return t.trans[sum + cur];
  }
  function tinf_decode_trees(d, lt, dt) {
    let i;
    let num;
    let length;
    const hlit = tinf_read_bits(d, 5, 257);
    const hdist = tinf_read_bits(d, 5, 1);
    const hclen = tinf_read_bits(d, 4, 4);
    for (i = 0; i < 19; ++i)
      lengths[i] = 0;
    for (i = 0; i < hclen; ++i) {
      const clen = tinf_read_bits(d, 3, 0);
      lengths[clcidx[i]] = clen;
    }
    tinf_build_tree(code_tree, lengths, 0, 19);
    for (num = 0; num < hlit + hdist; ) {
      const sym = tinf_decode_symbol(d, code_tree);
      switch (sym) {
        case 16: {
          const prev = lengths[num - 1];
          for (length = tinf_read_bits(d, 2, 3); length; --length) {
            lengths[num++] = prev;
          }
          break;
        }
        case 17:
          for (length = tinf_read_bits(d, 3, 3); length; --length) {
            lengths[num++] = 0;
          }
          break;
        case 18:
          for (length = tinf_read_bits(d, 7, 11); length; --length) {
            lengths[num++] = 0;
          }
          break;
        default:
          lengths[num++] = sym;
          break;
      }
    }
    tinf_build_tree(lt, lengths, 0, hlit);
    tinf_build_tree(dt, lengths, hlit, hdist);
  }
  function tinf_inflate_block_data(d, lt, dt) {
    while (true) {
      let sym = tinf_decode_symbol(d, lt);
      if (sym === 256) {
        return TINF_OK;
      }
      if (sym < 256) {
        d.dest[d.destLen++] = sym;
      } else {
        let i;
        sym -= 257;
        const length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
        const dist = tinf_decode_symbol(d, dt);
        const offs2 = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);
        for (i = offs2; i < offs2 + length; ++i) {
          d.dest[d.destLen++] = d.dest[i];
        }
      }
    }
  }
  function tinf_inflate_uncompressed_block(d) {
    let length;
    let invlength;
    let i;
    while (d.bitcount > 8) {
      d.sourceIndex--;
      d.bitcount -= 8;
    }
    length = d.source[d.sourceIndex + 1];
    length = 256 * length + d.source[d.sourceIndex];
    invlength = d.source[d.sourceIndex + 3];
    invlength = 256 * invlength + d.source[d.sourceIndex + 2];
    if (length !== (~invlength & 65535))
      return TINF_DATA_ERROR;
    d.sourceIndex += 4;
    for (i = length; i; --i)
      d.dest[d.destLen++] = d.source[d.sourceIndex++];
    d.bitcount = 0;
    return TINF_OK;
  }
  function tinf_uncompress(source, dest) {
    const d = new Data(source, dest);
    let bfinal;
    let btype;
    let res;
    do {
      bfinal = tinf_getbit(d);
      btype = tinf_read_bits(d, 2, 0);
      switch (btype) {
        case 0:
          res = tinf_inflate_uncompressed_block(d);
          break;
        case 1:
          res = tinf_inflate_block_data(d, sltree, sdtree);
          break;
        case 2:
          tinf_decode_trees(d, d.ltree, d.dtree);
          res = tinf_inflate_block_data(d, d.ltree, d.dtree);
          break;
        default:
          res = TINF_DATA_ERROR;
      }
      if (res !== TINF_OK)
        throw new Error("Data error");
    } while (!bfinal);
    if (d.destLen < d.dest.length) {
      if (typeof d.dest.slice === "function")
        return d.dest.slice(0, d.destLen);
      return d.dest.subarray(0, d.destLen);
    }
    return d.dest;
  }
  tinf_build_fixed_trees(sltree, sdtree);
  tinf_build_bits_base(length_bits, length_base, 4, 3);
  tinf_build_bits_base(dist_bits, dist_base, 2, 1);
  length_bits[28] = 0;
  length_base[28] = 258;

  // ../packages/engine-render/src/components/docs/layout/linebreak/unicode-trie.ts
  var SHIFT_1 = 6 + 5;
  var SHIFT_2 = 5;
  var SHIFT_1_2 = SHIFT_1 - SHIFT_2;
  var OMITTED_BMP_INDEX_1_LENGTH = 65536 >> SHIFT_1;
  var INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
  var INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
  var INDEX_SHIFT = 2;
  var DATA_BLOCK_LENGTH = 1 << SHIFT_2;
  var DATA_MASK = DATA_BLOCK_LENGTH - 1;
  var LSCP_INDEX_2_OFFSET = 65536 >> SHIFT_2;
  var LSCP_INDEX_2_LENGTH = 1024 >> SHIFT_2;
  var INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
  var UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
  var UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
  var INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
  var DATA_GRANULARITY = 1 << INDEX_SHIFT;
  var UnicodeTrie = class {
    constructor(data) {
      __publicField(this, "highStart");
      __publicField(this, "errorValue");
      __publicField(this, "data");
      const isBuffer = typeof data.readUInt32BE === "function" && typeof data.slice === "function";
      if (isBuffer || data instanceof Uint8Array) {
        let uncompressedLength;
        if (isBuffer) {
          this.highStart = data.readUInt32LE(0);
          this.errorValue = data.readUInt32LE(4);
          uncompressedLength = data.readUInt32LE(8);
          data = data.slice(12);
        } else {
          const view = new DataView(data.buffer);
          this.highStart = view.getUint32(0, true);
          this.errorValue = view.getUint32(4, true);
          uncompressedLength = view.getUint32(8, true);
          data = data.subarray(12);
        }
        data = tinf_uncompress(data, new Uint8Array(uncompressedLength));
        data = tinf_uncompress(data, new Uint8Array(uncompressedLength));
        swap32LE(data);
        this.data = new Uint32Array(data.buffer);
      } else {
        ({ data: this.data, highStart: this.highStart, errorValue: this.errorValue } = data);
      }
    }
    get(codePoint) {
      let index;
      if (codePoint < 0 || codePoint > 1114111) {
        return this.errorValue;
      }
      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
        index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
        return this.data[index];
      }
      if (codePoint <= 65535) {
        index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
        return this.data[index];
      }
      if (codePoint < this.highStart) {
        index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
        index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
        index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
        return this.data[index];
      }
      return this.data[this.data.length - DATA_GRANULARITY];
    }
  };

  // ../packages/engine-render/src/components/docs/layout/linebreak/linebreaker.ts
  var classTrie = new UnicodeTrie(trie_data_default);
  function mapClass(c) {
    switch (c) {
      case AI:
        return AL;
      case SA:
      case SG:
      case XX:
        return AL;
      case CJ:
        return NS;
      default:
        return c;
    }
  }
  function mapFirst(c) {
    switch (c) {
      case LF:
      case NL:
        return BK;
      case SP:
        return WJ;
      default:
        return c;
    }
  }
  var LineBreaker = class {
    constructor(string) {
      this.string = string;
      __publicField(this, "_pos", 0);
      __publicField(this, "_lastPos", 0);
      __publicField(this, "_curClass", null);
      __publicField(this, "_codePoint", null);
      __publicField(this, "_nextClass", null);
      __publicField(this, "_LB8a", false);
      __publicField(this, "_LB21a", false);
      __publicField(this, "_LB30a", 0);
      __publicField(this, "_rule", new Rule());
    }
    use(extension) {
      extension(this);
      return this;
    }
    addRule(key, rule) {
      this._rule.add(key, rule);
      return this;
    }
    nextBreak() {
      if (this._curClass == null) {
        const firstClass = this._nextCharClass();
        this._curClass = mapFirst(firstClass);
        this._nextClass = firstClass;
        this._LB8a = firstClass === ZWJ;
        this._LB30a = 0;
      }
      while (this._pos < this.string.length) {
        this._lastPos = this._pos;
        const lastClass = this._nextClass;
        this._nextClass = this._nextCharClass();
        if (this._curClass === BK || this._curClass === CR && this._nextClass !== LF) {
          this._curClass = mapFirst(mapClass(this._nextClass));
          return new Break(this._lastPos, true);
        }
        if (this._rule.shouldBreak(this._codePoint, this._nextClass)) {
          this._curClass = mapFirst(mapClass(this._nextClass));
          return new Break(this._lastPos);
        }
        let shouldBreak = this._getSimpleBreak();
        if (shouldBreak === null) {
          shouldBreak = this._getPairTableBreak(lastClass);
        }
        this._LB8a = this._nextClass === ZWJ;
        if (shouldBreak) {
          return new Break(this._lastPos);
        }
      }
      if (this._lastPos < this.string.length) {
        this._lastPos = this.string.length;
        return new Break(this.string.length);
      }
      return null;
    }
    _getNextCodePoint() {
      const code = this.string.charCodeAt(this._pos++);
      const next = this.string.charCodeAt(this._pos);
      if (code >= 55296 && code <= 56319 && next >= 56320 && next <= 57343) {
        this._pos++;
        return (code - 55296) * 1024 + (next - 56320) + 65536;
      }
      return code;
    }
    _nextCharClass() {
      const nextCodePoint = this._getNextCodePoint();
      const rawClass = classTrie.get(nextCodePoint);
      this._codePoint = nextCodePoint;
      return mapClass(rawClass);
    }
    _getSimpleBreak() {
      switch (this._nextClass) {
        case SP:
          return false;
        case BK:
        case LF:
        case NL:
          this._curClass = BK;
          return false;
        case CR:
          this._curClass = CR;
          return false;
      }
      return null;
    }
    _getPairTableBreak(lastClass) {
      let shouldBreak = false;
      switch (pairTable[this._curClass][this._nextClass]) {
        case DI_BRK:
          shouldBreak = true;
          break;
        case IN_BRK:
          shouldBreak = lastClass === SP;
          break;
        case CI_BRK:
          shouldBreak = lastClass === SP;
          if (!shouldBreak) {
            shouldBreak = false;
            return shouldBreak;
          }
          break;
        case CP_BRK:
          if (lastClass !== SP) {
            return shouldBreak;
          }
          break;
        case PR_BRK:
          break;
      }
      if (this._LB8a) {
        shouldBreak = false;
      }
      if (this._LB21a && (this._curClass === HY || this._curClass === BA)) {
        shouldBreak = false;
        this._LB21a = false;
      } else {
        this._LB21a = this._curClass === HL;
      }
      if (this._curClass === RI) {
        this._LB30a++;
        if (this._LB30a === 2 && this._nextClass === RI) {
          shouldBreak = true;
          this._LB30a = 0;
        }
      } else {
        this._LB30a = 0;
      }
      this._curClass = this._nextClass;
      return shouldBreak;
    }
  };

  // ../packages/engine-render/src/components/docs/layout/linebreak/extensions/tab-linebreak-extension.ts
  var TAB_CODE_POINT = 9;
  function tabLineBreakExtension(breaker) {
    breaker.addRule("break_before_tab", (codePoint) => {
      return codePoint === TAB_CODE_POINT;
    });
  }

  // ../packages/engine-render/src/components/docs/layout/model/glyph.ts
  function isSpace(char) {
    const SPACE_CHARS = [" ", "\xA0", "\u3000"];
    return SPACE_CHARS.includes(char);
  }
  function isJustifiable(content) {
    return isSpace(content) || hasCJKText(content) || isCjkLeftAlignedPunctuation(content) || isCjkRightAlignedPunctuation(content) || isCjkCenterAlignedPunctuation(content);
  }
  function baseAdjustability(content, width) {
    if (isSpace(content)) {
      return {
        // The number for spaces is from Knuth-Plass' paper
        stretchability: [0, width / 2],
        shrinkability: [0, width / 3]
      };
    } else if (isCjkLeftAlignedPunctuation(content)) {
      return {
        stretchability: [0, 0],
        shrinkability: [0, width / 2]
      };
    } else if (isCjkRightAlignedPunctuation(content)) {
      return {
        stretchability: [0, 0],
        shrinkability: [width / 2, 0]
      };
    } else if (isCjkCenterAlignedPunctuation(content)) {
      return {
        stretchability: [0, 0],
        shrinkability: [width / 4, width / 4]
      };
    } else {
      return {
        stretchability: [0, 0],
        shrinkability: [0, 0]
      };
    }
  }
  function createSkeletonWordGlyph(content, config2, glyphWidth) {
    return _createSkeletonWordOrLetter(1 /* WORD */, content, config2, glyphWidth);
  }
  function createSkeletonLetterGlyph(content, config2, glyphWidth) {
    return _createSkeletonWordOrLetter(0 /* LETTER */, content, config2, glyphWidth);
  }
  function createSkeletonTabGlyph(config2, glyphWidth) {
    return _createSkeletonWordOrLetter(4 /* TAB */, "	" /* TAB */, config2, glyphWidth);
  }
  function _createSkeletonWordOrLetter(glyphType, content, config2, glyphWidth) {
    const { fontStyle, textStyle, charSpace = 1, gridType = 1 /* LINES */, snapToGrid = 0 /* FALSE */ } = config2;
    const skipWidthList = [
      "\n" /* SECTION_BREAK */,
      "" /* TABLE_START */,
      "" /* TABLE_END */,
      "\x1B" /* TABLE_ROW_START */,
      "" /* TABLE_ROW_END */,
      "" /* TABLE_CELL_START */,
      "" /* TABLE_CELL_END */,
      "" /* CUSTOM_RANGE_START */,
      "" /* CUSTOM_RANGE_END */,
      "\v" /* COLUMN_BREAK */,
      "\f" /* PAGE_BREAK */,
      "\0" /* DOCS_END */,
      "\b" /* CUSTOM_BLOCK */
    ];
    let streamType = "" /* LETTER */;
    if (skipWidthList.indexOf(content) > -1) {
      return {
        content: "",
        ts: textStyle,
        fontStyle,
        width: 0,
        bBox: {
          width: 0,
          ba: 0,
          bd: 0,
          aba: 0,
          abd: 0,
          sp: 0,
          sbr: 0,
          sbo: 0,
          spr: 0,
          spo: 0
        },
        xOffset: 0,
        left: 0,
        isJustifiable: false,
        adjustability: baseAdjustability(content, 0),
        glyphType: 3 /* PLACEHOLDER */,
        streamType: content,
        count: 1
      };
    }
    if (content === "\r" /* PARAGRAPH */) {
      streamType = "\r" /* PARAGRAPH */;
    }
    const bBox = FontCache.getTextSize(content, fontStyle);
    const { width: contentWidth = 0 } = bBox;
    let width = glyphWidth != null ? glyphWidth : contentWidth;
    let xOffset = 0;
    if (validationGrid(gridType, snapToGrid)) {
      width = contentWidth + (hasCJK(content) ? charSpace : charSpace / 2);
      if (gridType === 3 /* SNAP_TO_CHARS */) {
        xOffset = (width - contentWidth) / 2;
      }
    }
    return {
      content,
      ts: textStyle,
      fontStyle,
      width,
      bBox,
      xOffset,
      left: 0,
      glyphType,
      streamType,
      isJustifiable: isJustifiable(content),
      adjustability: baseAdjustability(content, width),
      count: content.length
    };
  }
  function createSkeletonBulletGlyph(glyph, bulletSkeleton, charSpaceApply) {
    const {
      bBox: boundingBox,
      symbol: content,
      ts: textStyle,
      fontStyle,
      bulletAlign = 1 /* START */,
      bulletType = false
    } = bulletSkeleton;
    const contentWidth = boundingBox.width;
    const multiple = Math.ceil(contentWidth / charSpaceApply);
    let width = (multiple < 2 ? 2 : multiple) * charSpaceApply;
    let left = 0;
    if (bulletType) {
      if (bulletAlign === 2 /* CENTER */) {
        left = -contentWidth / 2;
        width -= left;
      } else if (bulletAlign === 3 /* END */) {
        left = -contentWidth;
        width -= left;
      }
    }
    const bBox = _getMaxBoundingBox(glyph, bulletSkeleton);
    return {
      content,
      ts: textStyle,
      fontStyle,
      width,
      xOffset: 0,
      bBox,
      left,
      isJustifiable: isJustifiable(content),
      adjustability: baseAdjustability(content, width),
      glyphType: 2 /* LIST */,
      streamType: "" /* LETTER */,
      // Deliberately set to 0 so that there is no need to count when calculating the cursor.
      count: 0
    };
  }
  function setGlyphGroupLeft(glyphGroup, left = 0) {
    const spanGroupLen = glyphGroup.length;
    let preGlyph;
    for (let i = 0; i < spanGroupLen; i++) {
      const glyph = glyphGroup[i];
      glyph.left = preGlyph ? preGlyph.left + preGlyph.width : left;
      preGlyph = glyph;
    }
  }
  function addGlyphToDivide(divide, glyphGroup, offsetLeft = 0) {
    setGlyphGroupLeft(glyphGroup, offsetLeft);
    for (const glyph of glyphGroup) {
      glyph.parent = divide;
    }
    divide.glyphGroup.push(...glyphGroup);
  }
  function _getMaxBoundingBox(glyph, bulletSkeleton) {
    const { ba: spanAscent, bd: spanDescent } = glyph.bBox;
    const { ba: bulletAscent, bd: bulletDescent } = bulletSkeleton.bBox;
    if (spanAscent + spanDescent > bulletAscent + bulletDescent) {
      return glyph.bBox;
    }
    return bulletSkeleton.bBox;
  }
  function glyphShrinkRight(glyph, amount) {
    glyph.width -= amount;
    glyph.adjustability.shrinkability[1] -= amount;
  }
  function glyphShrinkLeft(glyph, amount) {
    glyph.width -= amount;
    glyph.xOffset -= amount;
    glyph.adjustability.shrinkability[0] -= amount;
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/language-ruler.ts
  function otherHandler(index, charArray, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle) {
    const glyphGroup = [];
    let step = 0;
    for (let i = 0; i < charArray.length; i++) {
      const newChar = charArray[i];
      if (hasSpace(newChar) || startWithEmoji(charArray.substring(i))) {
        break;
      }
      const config2 = getFontCreateConfig(index + i, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle);
      const glyph = createSkeletonLetterGlyph(newChar, config2);
      glyphGroup.push(glyph);
      step++;
    }
    return {
      step,
      glyphGroup
    };
  }
  function ArabicHandler(index, charArray, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle) {
    const config2 = getFontCreateConfig(index, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle);
    const glyph = [];
    let step = 0;
    for (let i = 0; i < charArray.length; i++) {
      const newChar = charArray[i];
      if (hasArabic(newChar)) {
        glyph.unshift(newChar);
        step++;
      } else {
        break;
      }
    }
    return {
      step,
      glyphGroup: [createSkeletonLetterGlyph(glyph.join(""), config2)]
    };
  }
  function emojiHandler(index, charArray, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle) {
    const config2 = getFontCreateConfig(index, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle);
    const match = charArray.match(EMOJI_REG);
    return {
      step: match[0].length,
      glyphGroup: [createSkeletonLetterGlyph(match[0], config2)]
    };
  }
  function TibetanHandler(index, charArray, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle) {
    const config2 = getFontCreateConfig(index, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle);
    const glyph = [];
    let step = 0;
    for (let i = 0; i < charArray.length; i++) {
      const newChar = charArray[i];
      if (hasTibetan(newChar)) {
        glyph.push(newChar);
        step++;
      } else {
        break;
      }
    }
    return {
      step,
      glyphGroup: [createSkeletonWordGlyph(glyph.join(""), config2)]
    };
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/shaping.ts
  function punctuationSpaceAdjustment(shapedGlyphs) {
    const len = shapedGlyphs.length;
    for (let i = 0; i < len - 1; i++) {
      const curGlyph = shapedGlyphs[i];
      const nextGlyph = shapedGlyphs[i + 1];
      const { width, content } = curGlyph;
      const delta = width / 2;
      if (hasCJKPunctuation(content) && hasCJKPunctuation(nextGlyph.content) && curGlyph.adjustability.shrinkability[1] + nextGlyph.adjustability.shrinkability[0] >= delta) {
        const leftDelta = Math.min(curGlyph.adjustability.shrinkability[1], delta);
        glyphShrinkRight(curGlyph, leftDelta);
        glyphShrinkLeft(nextGlyph, delta - leftDelta);
      }
    }
  }
  function addCJKLatinSpacing(shapedTextList) {
    const shapedGlyphs = shapedTextList.flatMap((shapedText) => shapedText.glyphs);
    let prevGlyph = null;
    const len = shapedGlyphs.length;
    const LATIN_REG = /[a-z\d]/i;
    for (let i = 0; i < len; i++) {
      const curGlyph = shapedGlyphs[i];
      const nextGlyph = i < len - 1 ? shapedGlyphs[i + 1] : null;
      const { width } = curGlyph;
      if (hasCJKText(curGlyph.content) && nextGlyph && LATIN_REG.test(nextGlyph.content)) {
        curGlyph.width += width / 4;
        curGlyph.adjustability.shrinkability[1] += width / 8;
      }
      if (hasCJKText(curGlyph.content) && prevGlyph && LATIN_REG.test(prevGlyph.content)) {
        curGlyph.width += width / 4;
        curGlyph.xOffset += width / 4;
        curGlyph.adjustability.shrinkability[0] += width / 8;
      }
      prevGlyph = curGlyph;
    }
  }
  function shaping(content, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle) {
    var _a2;
    const {
      gridType = 1 /* LINES */,
      charSpace = 0,
      defaultTabStop = 10.5
    } = sectionBreakConfig;
    const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
    const shapedTextList = [];
    const breaker = new LineBreaker(content);
    let last2 = 0;
    let bk;
    tabLineBreakExtension(breaker);
    while (bk = breaker.nextBreak()) {
      const word = content.slice(last2, bk.position);
      let src = word;
      let i = last2;
      const shapedGlyphs = [];
      while (src.length > 0) {
        const char = (_a2 = src.match(/^[\s\S]/gu)) == null ? void 0 : _a2[0];
        if (char == null) {
          break;
        }
        if (/\s/.test(char) || hasCJK(char)) {
          const config2 = getFontCreateConfig(i, bodyModel, paragraphNode, sectionBreakConfig, paragraphStyle);
          let newSpan;
          if (char === "	" /* TAB */) {
            const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
            newSpan = createSkeletonTabGlyph(config2, charSpaceApply);
          } else {
            newSpan = createSkeletonLetterGlyph(char, config2);
          }
          shapedGlyphs.push(newSpan);
          i += char.length;
          src = src.substring(char.length);
        } else if (startWithEmoji(src)) {
          const { step, glyphGroup } = emojiHandler(
            i,
            src,
            bodyModel,
            paragraphNode,
            sectionBreakConfig,
            paragraphStyle
          );
          shapedGlyphs.push(...glyphGroup);
          i += step;
          src = src.substring(step);
        } else if (hasArabic(char)) {
          const { step, glyphGroup } = ArabicHandler(
            i,
            src,
            bodyModel,
            paragraphNode,
            sectionBreakConfig,
            paragraphStyle
          );
          shapedGlyphs.push(...glyphGroup);
          i += step;
          src = src.substring(step);
        } else if (hasTibetan(char)) {
          const { step, glyphGroup } = TibetanHandler(
            i,
            src,
            bodyModel,
            paragraphNode,
            sectionBreakConfig,
            paragraphStyle
          );
          shapedGlyphs.push(...glyphGroup);
          i += step;
          src = src.substring(step);
        } else {
          const { step, glyphGroup } = otherHandler(
            i,
            src,
            bodyModel,
            paragraphNode,
            sectionBreakConfig,
            paragraphStyle
          );
          shapedGlyphs.push(...glyphGroup);
          i += step;
          src = src.substring(step);
        }
      }
      punctuationSpaceAdjustment(shapedGlyphs);
      shapedTextList.push({
        text: word,
        glyphs: shapedGlyphs
      });
      last2 = bk.position;
    }
    addCJKLatinSpacing(shapedTextList);
    return shapedTextList;
  }

  // ../packages/engine-render/src/components/docs/layout/model/page.ts
  function createSkeletonPage(sectionBreakConfig, skeletonResourceReference, pageNumber = 1, breakType = 0 /* SECTION */) {
    var _a2, _b2, _c, _d;
    const page = _getNullPage();
    const {
      pageNumberStart = 1,
      pageSize = { width: Number.POSITIVE_INFINITY, height: Number.POSITIVE_INFINITY },
      pageOrient = 0 /* PORTRAIT */,
      headerIds = {},
      footerIds = {},
      useFirstPageHeaderFooter,
      useEvenPageHeaderFooter,
      footerTreeMap,
      headerTreeMap,
      columnProperties = [],
      columnSeparatorType,
      marginTop = 0,
      marginBottom = 0,
      marginHeader = 0,
      marginFooter = 0,
      marginLeft = 0,
      marginRight = 0,
      renderConfig = {}
    } = sectionBreakConfig;
    const { skeHeaders, skeFooters } = skeletonResourceReference;
    const { width: pageWidth = Number.POSITIVE_INFINITY, height: pageHeight = Number.POSITIVE_INFINITY } = pageSize;
    page.pageNumber = pageNumber;
    page.pageNumberStart = pageNumberStart;
    page.renderConfig = renderConfig;
    page.marginLeft = marginLeft;
    page.marginRight = marginRight;
    page.breakType = breakType;
    page.pageWidth = pageWidth;
    page.width = 0;
    page.pageHeight = pageHeight;
    page.height = 0;
    page.pageOrient = pageOrient;
    const { defaultHeaderId, evenPageHeaderId, firstPageHeaderId } = headerIds;
    const { defaultFooterId, evenPageFooterId, firstPageFooterId } = footerIds;
    let headerId = defaultHeaderId != null ? defaultHeaderId : "";
    let footerId = defaultFooterId != null ? defaultFooterId : "";
    if (pageNumber === pageNumberStart && useFirstPageHeaderFooter) {
      headerId = firstPageHeaderId != null ? firstPageHeaderId : "";
      footerId = firstPageFooterId != null ? firstPageFooterId : "";
    } else if (pageNumber % 2 === 0 && useEvenPageHeaderFooter) {
      headerId = evenPageHeaderId != null ? evenPageHeaderId : "";
      footerId = evenPageFooterId != null ? evenPageFooterId : "";
    }
    let header;
    let footer;
    if (headerId) {
      if ((_a2 = skeHeaders.get(headerId)) == null ? void 0 : _a2.has(pageWidth)) {
        header = (_b2 = skeHeaders.get(headerId)) == null ? void 0 : _b2.get(pageWidth);
      } else if (headerTreeMap && headerTreeMap.has(headerId)) {
        header = _createSkeletonHeader(
          headerTreeMap.get(headerId),
          sectionBreakConfig,
          skeletonResourceReference
        );
        skeHeaders.set(headerId, /* @__PURE__ */ new Map([[pageWidth, header]]));
      }
      page.headerId = headerId;
    }
    if (footerId) {
      if ((_c = skeFooters.get(footerId)) == null ? void 0 : _c.has(pageWidth)) {
        footer = (_d = skeFooters.get(footerId)) == null ? void 0 : _d.get(pageWidth);
      } else if (footerTreeMap && footerTreeMap.has(footerId)) {
        footer = _createSkeletonHeader(
          footerTreeMap.get(footerId),
          sectionBreakConfig,
          skeletonResourceReference
        );
        skeFooters.set(headerId, /* @__PURE__ */ new Map([[pageWidth, footer]]));
      }
      page.footerId = footerId;
    }
    page.marginTop = _getVerticalMargin(marginTop, marginHeader, header);
    page.marginBottom = _getVerticalMargin(marginBottom, marginFooter, footer);
    const sections = page.sections;
    const lastSection = sections[sections.length - 1];
    const { marginTop: curPageMT, marginBottom: curPageMB, marginLeft: curPageML, marginRight: curPageMR } = page;
    const pageContentWidth = pageWidth - curPageML - curPageMR;
    const pageContentHeight = pageHeight - curPageMT - curPageMB;
    let lastSectionBottom = 0;
    if (lastSection) {
      lastSectionBottom = lastSection.top + lastSection.height;
    }
    const newSection = createSkeletonSection(
      columnProperties,
      columnSeparatorType,
      lastSectionBottom,
      0,
      pageContentWidth,
      pageContentHeight - lastSectionBottom
    );
    newSection.parent = page;
    sections.push(newSection);
    return page;
  }
  function _getNullPage() {
    return {
      sections: [],
      headerId: "",
      footerId: "",
      // page
      pageWidth: 0,
      pageHeight: 0,
      pageOrient: 0 /* PORTRAIT */,
      pageNumber: 1,
      pageNumberStart: 1,
      verticalAlign: false,
      angle: 0,
      width: 0,
      height: 0,
      marginLeft: 0,
      marginRight: 0,
      marginTop: 0,
      marginBottom: 0,
      breakType: 0 /* SECTION */,
      st: 0,
      ed: 0,
      skeDrawings: /* @__PURE__ */ new Map()
    };
  }
  function _createSkeletonHeader(headerOrFooter, sectionBreakConfig, skeletonResourceReference, isHeader = true) {
    const {
      lists,
      footerTreeMap,
      headerTreeMap,
      localeService,
      pageSize,
      marginLeft = 0,
      marginRight = 0,
      drawings,
      marginTop = 0,
      marginBottom = 0,
      marginHeader = 0,
      marginFooter = 0
    } = sectionBreakConfig;
    const pageWidth = (pageSize == null ? void 0 : pageSize.width) || Number.POSITIVE_INFINITY;
    const headerConfig = {
      lists,
      footerTreeMap,
      headerTreeMap,
      pageSize: {
        width: pageWidth - marginLeft - marginRight,
        height: Number.POSITIVE_INFINITY
      },
      localeService,
      drawings
    };
    const areaPage = createSkeletonPage(headerConfig, skeletonResourceReference);
    const page = dealWithSections(
      headerOrFooter,
      headerOrFooter.children[0],
      areaPage,
      headerConfig,
      skeletonResourceReference
    ).pages[0];
    updateBlockIndex([page]);
    const column = page.sections[0].columns[0];
    const height = column.height || 0;
    const { skeDrawings, st, ed } = page;
    const headerOrFooterSke = {
      lines: column.lines,
      skeDrawings,
      height,
      st,
      ed,
      marginLeft,
      marginRight
    };
    if (isHeader) {
      return {
        ...headerOrFooterSke,
        marginTop: __getHeaderMarginTop(marginTop, marginHeader, height)
      };
    }
    return {
      ...headerOrFooterSke,
      marginBottom: __getHeaderMarginBottom(marginBottom, marginFooter, height)
    };
  }
  function _getVerticalMargin(marginTB, marginHF, headerOrFooter) {
    if (!headerOrFooter || headerOrFooter.lines.length === 0) {
      return marginTB;
    }
    return Math.max(marginTB, marginHF, (headerOrFooter == null ? void 0 : headerOrFooter.height) || 0);
  }
  function __getHeaderMarginTop(marginTop, marginHeader, height) {
    const maxMargin = Math.max(marginTop, marginHeader);
    if (height > maxMargin) {
      return 0;
    }
    return maxMargin - height;
  }
  function __getHeaderMarginBottom(marginBottom, marginFooter, height) {
    const maxMargin = Math.max(marginBottom, marginFooter);
    if (height > maxMargin) {
      return 0;
    }
    return maxMargin - height;
  }

  // ../packages/engine-render/src/components/docs/layout/model/line.ts
  function createSkeletonLine(paragraphIndex, lineType, lineBoundingBox, columnWidth, lineIndex = 0, isParagraphStart = false, affectSkeDrawings, headersDrawings, footersDrawings) {
    const {
      lineHeight = 15.6,
      lineTop = 0,
      contentHeight = 0,
      paddingLeft = 0,
      paddingRight = 0,
      paddingTop = 0,
      paddingBottom = 0,
      marginTop = 0,
      spaceBelowApply = 0
    } = lineBoundingBox;
    const lineSke = _getLineSke(lineType, paragraphIndex);
    lineSke.lineIndex = lineIndex;
    lineSke.paragraphStart = isParagraphStart;
    lineSke.contentHeight = contentHeight;
    lineSke.top = lineTop;
    lineSke.lineHeight = lineHeight;
    lineSke.paddingTop = paddingTop;
    lineSke.paddingBottom = paddingBottom;
    lineSke.marginTop = marginTop;
    lineSke.spaceBelowApply = spaceBelowApply;
    lineSke.divides = _calculateDividesByDrawings(
      lineHeight,
      lineTop,
      columnWidth,
      paddingLeft,
      paddingRight,
      affectSkeDrawings,
      headersDrawings,
      footersDrawings
    );
    for (const divide of lineSke.divides) {
      divide.parent = lineSke;
    }
    return lineSke;
  }
  function calculateLineTopByDrawings(lineHeight = 15.6, lineTop = 0, pageSkeDrawings, headersDrawings, footersDrawings) {
    let maxTop = lineTop;
    headersDrawings == null ? void 0 : headersDrawings.forEach((drawing) => {
      const top = _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop);
      if (top) {
        maxTop = Math.max(maxTop, top);
      }
    });
    footersDrawings == null ? void 0 : footersDrawings.forEach((drawing) => {
      const top = _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop);
      if (top) {
        maxTop = Math.max(maxTop, top);
      }
    });
    pageSkeDrawings == null ? void 0 : pageSkeDrawings.forEach((drawing) => {
      const top = _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop);
      if (top) {
        maxTop = Math.max(maxTop, top);
      }
    });
    return maxTop;
  }
  function _getLineTopWidthWrapTopBottom(drawing, lineHeight, lineTop) {
    const { aTop, height, aLeft, width, angle = 0, drawingOrigin } = drawing;
    const { layoutType, distT = 0, distB = 0 } = drawingOrigin;
    if (layoutType !== 6 /* WRAP_TOP_AND_BOTTOM */) {
      return;
    }
    if (angle === 0) {
      const newAtop = aTop - distT;
      const newHeight = height + distB;
      if (newAtop + newHeight < lineTop || newAtop > lineHeight + lineTop) {
        return;
      }
      return newAtop + height;
    }
    let { top: sTop = 0, height: sHeight = 0 } = __getBoundingBox(angle, aLeft, width, aTop, height);
    sTop -= distT;
    sHeight += distB;
    if (sTop + sHeight < lineTop || sTop > lineHeight + lineTop) {
      return;
    }
    return sTop + sHeight;
  }
  function _calculateDividesByDrawings(lineHeight, lineTop, columnWidth, paddingLeft, paddingRight, paragraphAffectSkeDrawings, headersDrawings, footersDrawings) {
    const drawingsMix = [];
    drawingsMix.push(
      {
        left: 0,
        width: paddingLeft
      },
      {
        left: columnWidth - paddingRight,
        width: paddingRight
      }
    );
    headersDrawings == null ? void 0 : headersDrawings.forEach((drawing, drawingId) => {
      const split = _calculateSplit(drawing, lineHeight, lineTop, columnWidth);
      if (split) {
        drawingsMix.push(split);
      }
    });
    footersDrawings == null ? void 0 : footersDrawings.forEach((drawing, drawingId) => {
      const split = _calculateSplit(drawing, lineHeight, lineTop, columnWidth);
      if (split) {
        drawingsMix.push(split);
      }
    });
    paragraphAffectSkeDrawings == null ? void 0 : paragraphAffectSkeDrawings.forEach((drawing, drawingId) => {
      const split = _calculateSplit(drawing, lineHeight, lineTop, columnWidth);
      if (split) {
        drawingsMix.push(split);
      }
    });
    return _calculateDivideByDrawings(columnWidth, drawingsMix);
  }
  function setDivideFullState(divide, state) {
    divide.isFull = state;
  }
  function _calculateSplit(drawing, lineHeight, lineTop, columnWidth) {
    const { aTop, height, aLeft, width, angle = 0, drawingOrigin } = drawing;
    const { layoutType } = drawingOrigin;
    if (layoutType === 1 /* WRAP_NONE */ || layoutType === 6 /* WRAP_TOP_AND_BOTTOM */) {
      return;
    }
    if (layoutType === 2 /* WRAP_POLYGON */) {
      const { start = [0, 0], lineTo } = drawingOrigin;
      if (!lineTo) {
        return;
      }
      const points = [];
      points.push(new Vector2(start[0], start[1]));
      for (let i = 0; i < lineTo.length; i++) {
        const point = lineTo[i];
        points.push(new Vector2(point[0], point[1]));
      }
      if (angle !== 0) {
        const transform = new Transform().rotate(angle);
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          points[i] = transform.applyPoint(point);
        }
      }
      return __getCrossPoint(points, lineTop, lineHeight, columnWidth);
    }
    if (angle === 0) {
      return __getSplitWidthNoAngle(aTop, height, aLeft, width, lineTop, lineHeight, columnWidth, drawingOrigin);
    }
    const boundingBox = __getBoundingBox(angle, aLeft, width, aTop, height);
    if (layoutType === 3 /* WRAP_SQUARE */) {
      const { left: sLeft, width: sWidth, top: sTop, height: sHeight } = boundingBox;
      return __getSplitWidthNoAngle(
        sTop,
        sHeight,
        sLeft,
        sWidth,
        lineTop,
        lineHeight,
        columnWidth,
        drawingOrigin
      );
    }
    return __getCrossPoint(boundingBox.points, lineTop, lineHeight, columnWidth);
  }
  function __getBoundingBox(angle, left, width, top, height) {
    const transform = new Transform().rotate(angle);
    const lt = new Vector2(left, top);
    const lb = new Vector2(left, top + height);
    const rt = new Vector2(left + width, top);
    const rb = new Vector2(left + width, top + height);
    const boundingBox = transform.makeBoundingBoxFromPoints([lt, lb, rt, rb]);
    return boundingBox;
  }
  function __getCrossPoint(points, lineTop, lineHeight, columnWidth) {
    const path = new Path2(points);
    const crossPointTop = path.intersection([new Vector2(0, lineTop), new Vector2(columnWidth, lineTop)]);
    const crossPointBottom = path.intersection([
      new Vector2(0, lineTop + lineHeight),
      new Vector2(columnWidth, lineTop + lineHeight)
    ]);
    if (!crossPointTop && !crossPointBottom) {
      return;
    }
    const range = ___getMaxAndMinAxis([...points, ...crossPointTop || [], ...crossPointBottom || []]);
    return {
      left: range.min,
      width: range.max
    };
  }
  function ___getMaxAndMinAxis(points, axis = 0 /* X */) {
    const result = [];
    for (let i = 0; i < points.length; i++) {
      const point = points[i];
      if (axis === 0 /* X */) {
        result.push(point.x);
      } else {
        result.push(point.y);
      }
    }
    return {
      max: Math.max(...result),
      min: Math.min(...result)
    };
  }
  function __getSplitWidthNoAngle(top, height, left, width, lineTop, lineHeight, columnWidth, drawingOrigin) {
    const {
      layoutType,
      wrapText = 0 /* BOTH_SIDES */,
      distL = 0,
      distR = 0,
      distT = 0,
      distB = 0
    } = drawingOrigin;
    const newAtop = top - (layoutType === 3 /* WRAP_SQUARE */ ? distT : 0);
    const newHeight = height + (layoutType === 3 /* WRAP_SQUARE */ ? distB : 0);
    if (newAtop + newHeight < lineTop || newAtop > lineHeight + lineTop) {
      return;
    }
    let resultLeft = left - distL;
    let resultWidth = width + distR;
    const ruler = ___getWrapTextRuler(wrapText, resultLeft, resultWidth, columnWidth);
    if (ruler === 1 /* LEFT */) {
      resultWidth = columnWidth - resultLeft;
    } else if (ruler === 2 /* RIGHT */) {
      resultLeft = 0;
      resultWidth = left + width + distR;
    }
    return {
      left: resultLeft,
      width: resultWidth
    };
  }
  function ___getWrapTextRuler(wrapText, resultLeft, resultWidth, columnWidth) {
    let ruler = 0 /* BOTH */;
    if (wrapText === 1 /* LEFT */) {
      ruler = 1 /* LEFT */;
    } else if (wrapText === 2 /* RIGHT */) {
      ruler = 2 /* RIGHT */;
    } else if (wrapText === 3 /* LARGEST */) {
      if (resultLeft > columnWidth - resultLeft - resultWidth) {
        ruler = 1 /* LEFT */;
      } else {
        ruler = 2 /* RIGHT */;
      }
    }
    return ruler;
  }
  function _calculateDivideByDrawings(columnWidth, drawingSplit) {
    drawingSplit.sort((pre, next) => {
      if (pre.left > next.left) {
        return 1;
      }
      return -1;
    });
    const divideSkeleton = [];
    let start = 0;
    const splitLength = drawingSplit.length;
    for (let i = 0; i < splitLength; i++) {
      const split = drawingSplit[i];
      const { left, width } = split;
      if (left > start) {
        let width2 = left - start;
        width2 = width2 < columnWidth ? width2 : columnWidth - start;
        const divide = __getDivideSKe(start, width2);
        divideSkeleton.push(divide);
      }
      start = Math.max(left + width, start);
      if (i === splitLength - 1 && left + width < columnWidth) {
        const divide = __getDivideSKe(left + width, columnWidth - left - width);
        divideSkeleton.push(divide);
      }
    }
    return divideSkeleton;
  }
  function __getDivideSKe(left, width) {
    return {
      // divide 分割，为了适配插入对象、图片、表格等，图文混排
      glyphGroup: [],
      // glyphGroup
      width,
      // width 被分割后的总宽度
      left,
      // left 被对象分割后的偏移位置 | d1 | | d2 |
      paddingLeft: 0,
      // paddingLeft 根据horizonAlign和width计算对齐偏移
      isFull: false,
      // isFull， // 内容是否装满
      st: 0,
      // startIndex
      ed: 0
      // endIndex
    };
  }
  function _getLineSke(lineType, paragraphIndex) {
    return {
      paragraphIndex,
      type: lineType,
      divides: [],
      // /divides 受到对象影响，把行切分为 N 部分
      lineHeight: 0,
      // lineHeight =max(glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent, span2.....) + space
      contentHeight: 0,
      // contentHeight =max(glyph.fontBoundingBoxAscent + glyph.fontBoundingBoxDescent, span2.....)
      top: 0,
      // top paragraph(spaceAbove, spaceBelow, lineSpacing*PreLineHeight)
      asc: 0,
      // =max(glyph.textMetrics.asc) alphaBeta对齐，需要校准
      paddingTop: 0,
      // paddingTop 内容到顶部的距离
      paddingBottom: 0,
      // paddingBottom 内容到底部的距离
      marginTop: 0,
      // marginTop 针对段落的spaceAbove
      marginBottom: 0,
      // marginBottom 针对段落的spaceBelow
      spaceBelowApply: 0,
      // lineSpacingApply
      divideLen: 0,
      // divideLen 被对象分割为多少块
      st: -1,
      // startIndex 文本开始索引
      ed: -1,
      // endIndex 文本结束索引
      lineIndex: 0,
      // lineIndex 行号
      paragraphStart: false
    };
  }
  function createAndUpdateBlockAnchor(paragraphIndex, line, top, drawingAnchor) {
    if (!drawingAnchor) {
      return;
    }
    if (drawingAnchor.has(paragraphIndex)) {
      const anchor = drawingAnchor.get(paragraphIndex);
      anchor == null ? void 0 : anchor.elements.push(line);
    } else {
      drawingAnchor.set(paragraphIndex, {
        elements: [line],
        paragraphIndex,
        top
      });
    }
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/layout-ruler.ts
  function layoutParagraph(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart = false) {
    if (paragraphStart) {
      if (paragraphConfig.bulletSkeleton) {
        const { bulletSkeleton, paragraphStyle = {} } = paragraphConfig;
        const { gridType = 1 /* LINES */, charSpace = 0, defaultTabStop = 1 } = sectionBreakConfig;
        const { snapToGrid = 1 /* TRUE */ } = paragraphStyle;
        const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
        __bulletIndentHandler(paragraphStyle, bulletSkeleton, charSpaceApply);
        const bulletGlyph = createSkeletonBulletGlyph(glyphGroup[0], bulletSkeleton, charSpaceApply);
        _lineOperator([bulletGlyph, ...glyphGroup], pages, sectionBreakConfig, paragraphConfig, paragraphStart);
      } else {
        _lineOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart);
      }
    } else {
      _divideOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart);
    }
    return [...pages];
  }
  function _divideOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart = false, defaultSpanLineHeight) {
    var _a2;
    const lastPage = getLastPage(pages);
    const divideInfo = getLastNotFullDivideInfo(lastPage);
    if (divideInfo) {
      const width = __getGlyphGroupWidth(glyphGroup);
      const { divide } = divideInfo;
      const lastGlyph = (_a2 = divide == null ? void 0 : divide.glyphGroup) == null ? void 0 : _a2[divide.glyphGroup.length - 1];
      const lastWidth = (lastGlyph == null ? void 0 : lastGlyph.width) || 0;
      const lastLeft = (lastGlyph == null ? void 0 : lastGlyph.left) || 0;
      const preOffsetLeft = lastWidth + lastLeft;
      if (preOffsetLeft + width > divide.width) {
        setDivideFullState(divide, true);
        if (divideInfo.isLast && glyphGroup.length === 1 && (glyphGroup[0].content === " " /* SPACE */ || glyphGroup[0].content === "\r" /* PARAGRAPH */)) {
          addGlyphToDivide(divide, glyphGroup, preOffsetLeft);
        } else if ((divide == null ? void 0 : divide.glyphGroup.length) === 0) {
          const sliceGlyphGroup = [];
          while (glyphGroup.length) {
            sliceGlyphGroup.push(glyphGroup.shift());
            const sliceGlyphGroupWidth = __getGlyphGroupWidth(sliceGlyphGroup);
            if (sliceGlyphGroupWidth > divide.width) {
              if (sliceGlyphGroup.length > 1) {
                glyphGroup.unshift(sliceGlyphGroup.pop());
              }
              break;
            }
          }
          addGlyphToDivide(divide, sliceGlyphGroup, preOffsetLeft);
          if (glyphGroup.length) {
            _lineOperator(
              glyphGroup,
              pages,
              sectionBreakConfig,
              paragraphConfig,
              paragraphStart,
              defaultSpanLineHeight
            );
          }
        } else {
          _lineOperator(
            glyphGroup,
            pages,
            sectionBreakConfig,
            paragraphConfig,
            paragraphStart,
            defaultSpanLineHeight
          );
        }
      } else {
        const currentLine = divide.parent;
        const maxBox = __maxFontBoundingBoxByGlyphGroup(glyphGroup);
        if (currentLine && maxBox && !__isNullLine(currentLine)) {
          const { paragraphLineGapDefault, linePitch, lineSpacing, spacingRule, snapToGrid, gridType } = getLineHeightConfig(sectionBreakConfig, paragraphConfig);
          const { boundingBoxAscent, boundingBoxDescent } = maxBox;
          const spanLineHeight = boundingBoxAscent + boundingBoxDescent;
          const { contentHeight } = __getLineHeight(
            spanLineHeight,
            paragraphLineGapDefault,
            linePitch,
            gridType,
            lineSpacing,
            spacingRule,
            snapToGrid
          );
          if (currentLine.contentHeight < contentHeight) {
            const spanGroupCached = __getSpanGroupByLine(currentLine);
            const spanGroupCachedLen = spanGroupCached.length;
            let newSpanGroup = [];
            let startIndex = 1;
            if (spanGroupCachedLen > 2 && spanGroupCached[0].glyphType === 2 /* LIST */) {
              newSpanGroup = [spanGroupCached[0], spanGroupCached[1]];
              startIndex = 2;
            } else {
              newSpanGroup = [spanGroupCached[0]];
            }
            const column = currentLine.parent;
            const { paragraphStart: lineIsStart } = column == null ? void 0 : column.lines.pop();
            _lineOperator(
              newSpanGroup,
              pages,
              sectionBreakConfig,
              paragraphConfig,
              lineIsStart,
              boundingBoxAscent + boundingBoxDescent
            );
            for (let i = startIndex; i < spanGroupCached.length; i++) {
              _divideOperator(
                [spanGroupCached[i]],
                pages,
                sectionBreakConfig,
                paragraphConfig,
                paragraphStart
              );
            }
            _divideOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart);
            return;
          }
        }
        addGlyphToDivide(divide, glyphGroup, preOffsetLeft);
      }
    } else {
      _lineOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart, defaultSpanLineHeight);
    }
  }
  function _lineOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart = false, defaultSpanLineHeight) {
    var _a2, _b2, _c, _d, _e;
    let lastPage = getLastPage(pages);
    let columnInfo = getLastNotFullColumnInfo(lastPage);
    if (!columnInfo || !columnInfo.column) {
      _pageOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig);
      lastPage = getLastPage(pages);
      columnInfo = getLastNotFullColumnInfo(lastPage);
    }
    if (!columnInfo)
      return;
    const column = columnInfo.column;
    if (column.width <= 0) {
      console.error("The column width is less than 0, need to adjust page width to make it great than 0");
      return;
    }
    const line = getLastLineByColumn(column);
    const ascent = Math.max(...glyphGroup.map((glyph) => glyph.bBox.ba));
    const descent = Math.max(...glyphGroup.map((glyph) => glyph.bBox.bd));
    const spanLineHeight = defaultSpanLineHeight || ascent + descent;
    const {
      paragraphStyle = {},
      paragraphAffectSkeDrawings,
      skeHeaders,
      skeFooters,
      drawingAnchor,
      paragraphIndex
    } = paragraphConfig;
    const {
      // namedStyleType = NamedStyleType.NAMED_STYLE_TYPE_UNSPECIFIED,
      // horizontalAlign = HorizontalAlign.UNSPECIFIED,
      // direction,
      spaceAbove = 0,
      spaceBelow = 0,
      // borderBetween,
      // borderTop,
      // borderBottom,
      // borderLeft,
      // borderRight,
      indentFirstLine = 0,
      hanging = 0,
      indentStart = 0,
      indentEnd = 0
      // tabStops = [],
      // keepLines = BooleanNumber.FALSE,
      // keepNext = BooleanNumber.FALSE,
      // wordWrap = BooleanNumber.FALSE,
      // widowControl = BooleanNumber.FALSE,
      // shading,
    } = paragraphStyle;
    const { paragraphLineGapDefault, linePitch, lineSpacing, spacingRule, snapToGrid, gridType } = getLineHeightConfig(
      sectionBreakConfig,
      paragraphConfig
    );
    const { paddingTop, paddingBottom, contentHeight, lineSpacingApply } = __getLineHeight(
      spanLineHeight,
      paragraphLineGapDefault,
      linePitch,
      gridType,
      lineSpacing,
      spacingRule,
      snapToGrid
    );
    const { marginTop, spaceBelowApply } = __getParagraphSpace(
      lineSpacingApply,
      spaceAbove,
      spaceBelow,
      paragraphStart,
      line
    );
    const lineHeight = marginTop + paddingTop + contentHeight + paddingBottom;
    let section = column.parent;
    if (!section) {
      section = getLastSection(lastPage);
    }
    const preLineHeight = (line == null ? void 0 : line.lineHeight) || 0;
    const preTop = (line == null ? void 0 : line.top) || 0;
    const lineTop = preLineHeight + preTop;
    const { pageWidth, headerId, footerId } = lastPage;
    const headersDrawings = (_b2 = (_a2 = skeHeaders == null ? void 0 : skeHeaders.get(headerId)) == null ? void 0 : _a2.get(pageWidth)) == null ? void 0 : _b2.skeDrawings;
    const footersDrawings = (_d = (_c = skeFooters == null ? void 0 : skeFooters.get(footerId)) == null ? void 0 : _c.get(pageWidth)) == null ? void 0 : _d.skeDrawings;
    __updateDrawingPosition(
      lineTop,
      lineHeight,
      column,
      (_e = drawingAnchor == null ? void 0 : drawingAnchor.get(paragraphIndex)) == null ? void 0 : _e.top,
      paragraphAffectSkeDrawings
    );
    const newLineTop = calculateLineTopByDrawings(
      lineHeight,
      lineTop,
      lastPage.skeDrawings,
      headersDrawings,
      footersDrawings
    );
    if (lineHeight + newLineTop > section.height && column.lines.length > 0 && lastPage.sections.length > 0) {
      setColumnFullState(column, true);
      _columnOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart, defaultSpanLineHeight);
      return;
    }
    const lineIndex = line ? line.lineIndex + 1 : 0;
    const { charSpace, defaultTabStop } = getCharSpaceConfig(sectionBreakConfig, paragraphConfig);
    const charSpaceApply = getCharSpaceApply(charSpace, defaultTabStop, gridType, snapToGrid);
    const { paddingLeft, paddingRight, changeBulletWidth } = __getIndentPadding(
      glyphGroup[0],
      indentFirstLine,
      hanging,
      indentStart,
      indentEnd,
      charSpaceApply
    );
    if (changeBulletWidth.state) {
      glyphGroup[0].width = changeBulletWidth.hangingNumber;
    }
    const newLine = createSkeletonLine(
      paragraphIndex,
      0 /* PARAGRAPH */,
      {
        lineHeight,
        contentHeight,
        lineTop: newLineTop,
        paddingLeft,
        paddingRight,
        paddingTop,
        paddingBottom,
        marginTop,
        spaceBelowApply
      },
      column.width,
      lineIndex,
      paragraphStart,
      lastPage.skeDrawings,
      headersDrawings,
      footersDrawings
    );
    column.lines.push(newLine);
    newLine.parent = column;
    createAndUpdateBlockAnchor(paragraphIndex, newLine, lineTop, drawingAnchor);
    _divideOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart, defaultSpanLineHeight);
  }
  function _columnOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart = false, defaultSpanLineHeight) {
    const lastPage = getLastPage(pages);
    const columnIsFull = isColumnFull(lastPage);
    if (columnIsFull === true) {
      _pageOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart, defaultSpanLineHeight);
    } else {
      _lineOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart, defaultSpanLineHeight);
    }
  }
  function _pageOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart = false, defaultSpanLineHeight) {
    const curSkeletonPage = getLastPage(pages);
    const { skeHeaders, skeFooters } = paragraphConfig;
    pages.push(createSkeletonPage(sectionBreakConfig, { skeHeaders, skeFooters }, curSkeletonPage == null ? void 0 : curSkeletonPage.pageNumber));
    _columnOperator(glyphGroup, pages, sectionBreakConfig, paragraphConfig, paragraphStart, defaultSpanLineHeight);
  }
  function __getIndentPadding(glyph, indentFirstLine = 0, hanging = 0, indentStart = 0, indentEnd = 0, charSpaceApply) {
    const { glyphType = 0 /* LETTER */, bBox } = glyph;
    const indentFirstLineNumber = getNumberUnitValue(indentFirstLine, charSpaceApply);
    const hangingNumber = getNumberUnitValue(hanging, charSpaceApply);
    const indentStartNumber = getNumberUnitValue(indentStart, charSpaceApply);
    const indentEndNumber = getNumberUnitValue(indentEnd, charSpaceApply);
    let paddingLeft = indentStartNumber;
    const paddingRight = indentEndNumber;
    const changeBulletWidth = {
      state: false,
      hangingNumber: 0
    };
    if (glyphType === 2 /* LIST */) {
      const { width: fontWidth } = bBox;
      if (indentFirstLineNumber > 0) {
        paddingLeft += indentFirstLineNumber;
      } else if (hangingNumber > 0 && hangingNumber > fontWidth) {
        changeBulletWidth.state = true;
        changeBulletWidth.hangingNumber = hangingNumber;
      }
    } else {
      paddingLeft += hangingNumber;
    }
    return {
      paddingLeft,
      paddingRight,
      changeBulletWidth
    };
  }
  function __getParagraphSpace(lineSpacing = 0, spaceAbove = 0, spaceBelow = 0, paragraphStart, preLine) {
    let marginTop = 0;
    let spaceBelowApply = 0;
    if (!paragraphStart) {
      return {
        marginTop,
        spaceBelowApply
      };
    }
    marginTop = getNumberUnitValue(spaceAbove, lineSpacing);
    spaceBelowApply = getNumberUnitValue(spaceBelow, lineSpacing);
    if (preLine) {
      const { spaceBelowApply: PreSpaceBelowApply } = preLine;
      if (PreSpaceBelowApply > marginTop) {
        marginTop = 0;
        preLine.lineHeight += PreSpaceBelowApply;
        preLine.marginBottom = PreSpaceBelowApply;
      }
    }
    return {
      marginTop,
      spaceBelowApply
    };
  }
  function __getLineHeight(spanLineHeight, paragraphLineGapDefault, linePitch, gridType, lineSpacing, spacingRule, snapToGrid) {
    let paddingTop = paragraphLineGapDefault;
    let paddingBottom = paragraphLineGapDefault;
    if (gridType === 0 /* DEFAULT */ || snapToGrid === 0 /* FALSE */) {
      if (spacingRule === 0 /* AUTO */) {
        return {
          paddingTop,
          paddingBottom,
          contentHeight: lineSpacing * spanLineHeight,
          lineSpacingApply: spanLineHeight
        };
      }
      return {
        paddingTop,
        paddingBottom,
        contentHeight: Math.max(lineSpacing, spanLineHeight),
        lineSpacingApply: lineSpacing
      };
    }
    let lineSpacingApply = 0;
    if (spacingRule === 0 /* AUTO */) {
      lineSpacingApply = lineSpacing * linePitch;
    } else {
      lineSpacingApply = lineSpacing;
    }
    if (spanLineHeight + paragraphLineGapDefault * 2 < lineSpacingApply) {
      paddingTop = paddingBottom = (lineSpacingApply - spanLineHeight) / 2;
    }
    return {
      paddingTop,
      paddingBottom,
      contentHeight: spanLineHeight,
      lineSpacingApply
    };
  }
  function __updateDrawingPosition(lineTop, lineHeight, column, blockAnchorTop, paragraphAffectSkeDrawings) {
    var _a2;
    if (!paragraphAffectSkeDrawings) {
      return;
    }
    const page = (_a2 = column.parent) == null ? void 0 : _a2.parent;
    if (!page) {
      return;
    }
    const drawings = /* @__PURE__ */ new Map();
    const isPageBreak = __checkPageBreak(column);
    paragraphAffectSkeDrawings.forEach((drawing) => {
      if (!drawing) {
        return;
      }
      const { initialState, drawingOrigin } = drawing;
      if (initialState || !drawingOrigin) {
        return;
      }
      const { objectTransform } = drawingOrigin;
      const { positionH, positionV, size, angle } = objectTransform;
      const { width = 0, height = 0 } = size;
      drawing.aLeft = getPositionHorizon(positionH, column, page, width, isPageBreak) || 0;
      drawing.aTop = getPositionVertical(positionV, page, lineTop, lineHeight, height, blockAnchorTop, isPageBreak) || 0;
      drawing.width = width;
      drawing.height = height;
      drawing.angle = angle;
      drawing.initialState = true;
      drawings.set(drawing.objectId, drawing);
    });
    page.skeDrawings = new Map([...page.skeDrawings, ...drawings]);
  }
  function __checkPageBreak(column) {
    const section = column.parent;
    if (!section) {
      return false;
    }
    const columns = section == null ? void 0 : section.columns;
    if (!columns) {
      return false;
    }
    const columnLength = columns.length;
    for (let c = columnLength - 1; c >= 0; c--) {
      const curColumn = columns[c];
      const lines = curColumn.lines;
      const lineLength = lines.length;
      if (lineLength <= 0) {
        continue;
      }
      for (let i = lineLength - 1; i >= 0; i--) {
        const line = lines[i];
        if (line.paragraphStart) {
          return false;
        }
      }
    }
    return true;
  }
  function __getGlyphGroupWidth(glyphGroup) {
    const glyphGroupLen = glyphGroup.length;
    let width = 0;
    for (let i = 0; i < glyphGroupLen; i++) {
      const glyph = glyphGroup[i];
      width += glyph.width;
    }
    return width;
  }
  function __maxFontBoundingBoxByGlyphGroup(glyphGroup) {
    const glyphGroupLen = glyphGroup.length;
    let height = Number.NEGATIVE_INFINITY;
    let maxBox;
    for (let i = 0; i < glyphGroupLen; i++) {
      const glyph = glyphGroup[i];
      const { ba: boundingBoxAscent, bd: boundingBoxDescent } = glyph.bBox;
      if (height < boundingBoxAscent + boundingBoxDescent) {
        maxBox = { boundingBoxAscent, boundingBoxDescent };
      }
      height = boundingBoxAscent + boundingBoxDescent;
    }
    return maxBox;
  }
  function __getSpanGroupByLine(line) {
    const divides = line.divides;
    const dividesLen = divides.length;
    const glyphGroup = [];
    for (let i = 0; i < dividesLen; i++) {
      const divide = divides[i];
      glyphGroup.push(...divide.glyphGroup);
    }
    return glyphGroup;
  }
  function __bulletIndentHandler(paragraphStyle, bulletSkeleton, charSpaceApply) {
    const { hanging, indentStart } = paragraphStyle;
    const { hanging: hangingBullet, indentStart: indentStartBullet } = bulletSkeleton;
    if (hanging === void 0) {
      paragraphStyle.hanging = hangingBullet;
    }
    if (indentStart === void 0) {
      paragraphStyle.indentStart = getNumberUnitValue(indentStartBullet || 0, charSpaceApply) - getNumberUnitValue(hangingBullet || 0, charSpaceApply);
    }
  }
  function __isNullLine(line) {
    return !line.divides[0].glyphGroup[0];
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/inline-drawing.ts
  function dealWidthInlineDrawing(drawing, sectionBreakConfig, allPages, paragraphConfig, localeService) {
    return [];
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/bullet-ruler.ts
  function getBulletOrderedSymbol(startIndex, startNumber, glyphType) {
    return generateOrderedSymbol(startIndex, startNumber, glyphType);
  }
  function generateOrderedSymbol(startIndex, startNumber, glyphType) {
    if (glyphType === 2 /* DECIMAL */) {
      return decimal(startIndex, startNumber);
    }
    if (glyphType === 3 /* ZERO_DECIMAL */) {
      return zeroDecimal(startIndex, startNumber);
    }
    if (glyphType === 4 /* UPPER_ALPHA */) {
      return upperAlpha(startIndex, startNumber);
    }
    if (glyphType === 5 /* ALPHA */) {
      return alpha(startIndex, startNumber);
    }
    if (glyphType === 6 /* UPPER_ROMAN */) {
      return upperRoman(startIndex, startNumber);
    }
    if (glyphType === 7 /* ROMAN */) {
      return roman(startIndex, startNumber);
    }
    return decimal(startIndex, startNumber);
  }
  function decimal(startIndex, startNumber) {
    const currentIndex = startIndex + startNumber;
    return currentIndex.toString();
  }
  function zeroDecimal(startIndex, startNumber) {
    const currentIndex = startIndex + startNumber;
    if (currentIndex < 10) {
      return `0${currentIndex}`;
    }
    return currentIndex.toString();
  }
  function upperAlpha(startIndex, startNumber) {
    return numberToListABC(startIndex + startNumber - 1, true);
  }
  function alpha(startIndex, startNumber) {
    return numberToListABC(startIndex + startNumber - 1, false);
  }
  function upperRoman(startIndex, startNumber) {
    return _convertRoman(startIndex + startNumber, true);
  }
  function roman(startIndex, startNumber) {
    return _convertRoman(startIndex + startNumber, false);
  }
  function _convertRoman(num, uppercase = false) {
    const upperLookup = {
      M: 1e3,
      CM: 900,
      D: 500,
      CD: 400,
      C: 100,
      XC: 90,
      L: 50,
      XL: 40,
      X: 10,
      IX: 9,
      V: 5,
      IV: 4,
      I: 1
    };
    const lowerLookup = {
      m: 1e3,
      cm: 900,
      d: 500,
      cd: 400,
      c: 100,
      xc: 90,
      l: 50,
      xl: 40,
      x: 10,
      ix: 9,
      v: 5,
      iv: 4,
      i: 1
    };
    let lookup = lowerLookup;
    if (uppercase) {
      lookup = upperLookup;
    }
    let romanStr = "";
    for (const i in lookup) {
      while (num >= lookup[i]) {
        romanStr += i;
        num -= lookup[i];
      }
    }
    return romanStr;
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/bullet.ts
  function dealWithBullet(bullet, lists, listLevelAncestors, localeService) {
    var _a2, _b2;
    if (!bullet || !lists) {
      return;
    }
    const { listId, listType, nestingLevel = 0, textStyle } = bullet;
    const list = lists[listType];
    if (!list || !list.nestingLevel) {
      return getDefaultBulletSke(listId, (_a2 = listLevelAncestors == null ? void 0 : listLevelAncestors[nestingLevel]) == null ? void 0 : _a2.startIndexItem);
    }
    const nesting = list.nestingLevel[nestingLevel];
    if (!nesting) {
      return getDefaultBulletSke(listId, (_b2 = listLevelAncestors == null ? void 0 : listLevelAncestors[nestingLevel]) == null ? void 0 : _b2.startIndexItem);
    }
    const bulletSke = _getBulletSke(
      listId,
      nestingLevel,
      list.nestingLevel,
      listLevelAncestors,
      textStyle,
      localeService
    );
    return bulletSke;
  }
  function getDefaultBulletSke(listId, startIndex = 1) {
    return {
      listId,
      symbol: "\u25CF",
      // symbol 列表的内容
      ts: {
        // TODO: @jikkai @DR-Univer should read default font from configuration, not from locale service
        ff: "Arial",
        fs: 9
      },
      // 文字样式
      startIndexItem: startIndex,
      bBox: {
        width: 8.4560546875,
        ba: 7,
        bd: -1,
        aba: 7,
        abd: -1,
        sp: -2,
        sbr: 0.5,
        sbo: 0,
        spr: 0.5,
        spo: 0
      },
      indentFirstLine: 0,
      hanging: 21,
      indentStart: 0
    };
  }
  function _getBulletSke(listId, nestingLevel, nestings, listLevelAncestors, textStyleConfig, localeService) {
    var _a2, _b2;
    const nesting = nestings[nestingLevel];
    const {
      bulletAlignment,
      glyphFormat,
      textStyle: textStyleFirst,
      startNumber,
      glyphType,
      glyphSymbol,
      indentFirstLine,
      hanging,
      indentStart
    } = nesting;
    const textStyle = { ...textStyleConfig, ...textStyleFirst };
    const fontStyle = getFontStyleString(textStyle, localeService);
    let symbolContent;
    if (glyphSymbol) {
      symbolContent = glyphSymbol;
    } else {
      symbolContent = __generateOrderedListSymbol(glyphFormat, nestingLevel, nestings, listLevelAncestors);
    }
    const bBox = FontCache.getTextSize(symbolContent, fontStyle);
    const startIndex = (_b2 = (_a2 = listLevelAncestors == null ? void 0 : listLevelAncestors[nestingLevel]) == null ? void 0 : _a2.startIndexItem) != null ? _b2 : 1;
    return {
      listId,
      symbol: symbolContent,
      // symbol 列表的内容
      ts: textStyle,
      // 文字样式
      fontStyle,
      //
      startIndexItem: startIndex + 1,
      bBox,
      nestingLevel: nesting,
      bulletAlign: bulletAlignment,
      bulletType: glyphSymbol ? false : !!glyphType,
      // 默认是无序列表，假如glyphSymbol为空且glyphType不为空才是有序列表
      indentFirstLine,
      hanging,
      indentStart
    };
  }
  function __generateOrderedListSymbol(glyphFormat, nestingLevel, nestings, listLevelAncestors) {
    var _a2;
    const glyphFormatSplit = glyphFormat.split("%");
    const prefix = glyphFormatSplit[0];
    const resultSymbol = [prefix];
    for (let i = 1; i < glyphFormatSplit.length; i++) {
      const levelAndSuffixPre = glyphFormatSplit[i];
      const { level, suffix } = ___getLevelAndSuffix(levelAndSuffixPre);
      let startIndexItem = ((_a2 = listLevelAncestors == null ? void 0 : listLevelAncestors[level]) == null ? void 0 : _a2.startIndexItem) || 1;
      if (level !== nestingLevel && (listLevelAncestors == null ? void 0 : listLevelAncestors[level]) !== null) {
        startIndexItem -= 1;
      }
      const singleSymbol = ___getSymbolByBesting(startIndexItem, nestings[level]);
      resultSymbol.push(singleSymbol, suffix);
    }
    return resultSymbol.join("");
  }
  function ___getSymbolByBesting(startIndex = 1, nesting) {
    const { startNumber, glyphType, glyphSymbol } = nesting;
    if (glyphSymbol) {
      return glyphSymbol;
    }
    if (!glyphType) {
      return "\u25CF";
    }
    return getBulletOrderedSymbol(startIndex, startNumber, glyphType);
  }
  function ___getLevelAndSuffix(levelAndSuffixPre) {
    if (levelAndSuffixPre === "") {
      return {
        level: 0,
        suffix: ""
      };
    }
    const levelAndSuffixPreSpit = levelAndSuffixPre.split("");
    let level = "";
    let suffix = "";
    let isSuffixState = false;
    const digitReg = /[0-9]/g;
    levelAndSuffixPreSpit.forEach((w) => {
      if (!isSuffixState && digitReg.test(`${level}${w}`)) {
        level += w;
      } else {
        isSuffixState = true;
        suffix += w;
      }
    });
    return {
      level: Number.parseInt(level) - 1,
      suffix
    };
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/linebreaking.ts
  function _getListLevelAncestors(bullet, listLevel) {
    if (!bullet || !listLevel) {
      return;
    }
    const { listId, nestingLevel } = bullet;
    const sameList = listLevel == null ? void 0 : listLevel.get(listId);
    let level = nestingLevel;
    if (level < 0) {
      level = 0;
    }
    const listLevelAncestors = [];
    for (let i = level; i >= 0; i--) {
      const bs = sameList == null ? void 0 : sameList[i];
      listLevelAncestors[i] = bs || null;
    }
    return listLevelAncestors;
  }
  function _updateListLevelAncestors(bullet, bulletSkeleton, listLevel) {
    if (!bullet || !bulletSkeleton) {
      return;
    }
    const { listId, nestingLevel } = bullet;
    const cacheItem = [...(listLevel == null ? void 0 : listLevel.get(listId)) || []];
    cacheItem[nestingLevel] = bulletSkeleton;
    cacheItem.splice(nestingLevel + 1);
    listLevel == null ? void 0 : listLevel.set(listId, cacheItem);
  }
  function _getDrawingSkeletonFormat(drawingOrigin) {
    const objectId = drawingOrigin.objectId;
    return {
      objectId,
      aLeft: 0,
      aTop: 0,
      width: 0,
      height: 0,
      angle: 0,
      initialState: false,
      drawingOrigin
    };
  }
  function _getNextPageNumber(lastPage) {
    return lastPage.pageNumber + 1;
  }
  function lineBreaking(shapedTextList, curPage, bodyModel, paragraphNode, sectionBreakConfig, skeletonResourceReference) {
    const {
      lists,
      drawings = {},
      localeService
    } = sectionBreakConfig;
    const { endIndex, startIndex, blocks = [] } = paragraphNode;
    const paragraph = bodyModel.getParagraph(endIndex) || { startIndex: 0 };
    const { paragraphStyle = {}, bullet } = paragraph;
    const { skeHeaders, skeFooters, skeListLevel, drawingAnchor } = skeletonResourceReference;
    const paragraphAffectSkeDrawings = /* @__PURE__ */ new Map();
    const paragraphConfig = {
      paragraphIndex: endIndex,
      paragraphStyle,
      paragraphAffectSkeDrawings,
      skeHeaders,
      skeFooters,
      drawingAnchor
    };
    const listLevelAncestors = _getListLevelAncestors(bullet, skeListLevel);
    const bulletSkeleton = dealWithBullet(bullet, lists, listLevelAncestors, localeService);
    _updateListLevelAncestors(bullet, bulletSkeleton, skeListLevel);
    paragraphConfig.bulletSkeleton = bulletSkeleton;
    const customBlockCache = /* @__PURE__ */ new Map();
    for (let i = 0, len = blocks.length; i < len; i++) {
      const charIndex2 = blocks[i];
      const customBlock = bodyModel.getCustomBlock(charIndex2);
      if (customBlock == null) {
        continue;
      }
      customBlockCache.set(charIndex2, customBlock);
      const blockId = customBlock.blockId;
      const drawingOrigin = drawings[blockId];
      if (drawingOrigin.layoutType !== 0 /* INLINE */) {
        paragraphAffectSkeDrawings.set(blockId, _getDrawingSkeletonFormat(drawingOrigin));
      }
    }
    let allPages = [curPage];
    let paragraphStart = true;
    let charIndex = startIndex;
    for (const { text, glyphs } of shapedTextList) {
      charIndex += text.length;
      const pushPending = () => {
        if (glyphs.length === 0) {
          return;
        }
        allPages = layoutParagraph(
          glyphs,
          allPages,
          sectionBreakConfig,
          paragraphConfig,
          paragraphStart
        );
        paragraphStart = false;
      };
      if (text.endsWith("\b" /* CUSTOM_BLOCK */)) {
        let customBlock = customBlockCache.get(charIndex);
        if (customBlock == null) {
          customBlock = bodyModel.getCustomBlock(charIndex);
        }
        if (customBlock != null) {
          const blockId = customBlock.blockId;
          const drawingOrigin = drawings[blockId];
          if (drawingOrigin.layoutType === 0 /* INLINE */) {
            allPages = dealWidthInlineDrawing(
              drawingOrigin,
              sectionBreakConfig,
              allPages,
              paragraphConfig,
              localeService
            );
          }
        }
        pushPending();
        continue;
      } else if (text.endsWith("\f" /* PAGE_BREAK */)) {
        pushPending();
        allPages.push(
          createSkeletonPage(
            sectionBreakConfig,
            skeletonResourceReference,
            _getNextPageNumber(allPages[allPages.length - 1]),
            1 /* PAGE */
          )
        );
        paragraphAffectSkeDrawings.clear();
        continue;
      } else if (text.endsWith("\v" /* COLUMN_BREAK */)) {
        pushPending();
        const lastPage = allPages[allPages.length - 1];
        const columnInfo = getLastNotFullColumnInfo(lastPage);
        if (columnInfo && !columnInfo.isLast) {
          setColumnFullState(columnInfo.column, true);
        } else {
          allPages.push(
            createSkeletonPage(
              sectionBreakConfig,
              skeletonResourceReference,
              _getNextPageNumber(lastPage),
              2 /* COLUMN */
            )
          );
        }
        continue;
      }
      pushPending();
    }
    return allPages;
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/line-adjustment.ts
  function overhang(c) {
    switch (c) {
      case "\u2013":
      case "\u2014": {
        return 0.2;
      }
      case ".":
      case ",": {
        return 0.8;
      }
      case ":":
      case ";": {
        return 0.3;
      }
      case "\u060C":
      case "\u06D4": {
        return 0.4;
      }
      default: {
        return 0;
      }
    }
  }
  function getDivideShrinkability(divide) {
    const { glyphGroup } = divide;
    let shrinkability = 0;
    for (const glyph of glyphGroup) {
      const [left, right] = glyph.adjustability.shrinkability;
      shrinkability += left + right;
    }
    return shrinkability;
  }
  function getDivideStretchability(divide) {
    const { glyphGroup } = divide;
    let stretchability = 0;
    for (const glyph of glyphGroup) {
      const [left, right] = glyph.adjustability.stretchability;
      stretchability += left + right;
    }
    return stretchability;
  }
  function getJustifiables(divide) {
    const justifiables = divide.glyphGroup.filter((glyph) => glyph.isJustifiable).length;
    const lastGlyph = divide.glyphGroup[divide.glyphGroup.length - 1];
    if (hasCJK(lastGlyph.content)) {
      return justifiables - 1;
    }
    return justifiables;
  }
  function adjustGlyphsInDivide(divide, justificationRatio, extraJustification) {
    for (const glyph of divide.glyphGroup) {
      const adjustabilityLeft = justificationRatio < 0 ? glyph.adjustability.shrinkability[0] : glyph.adjustability.stretchability[0];
      const adjustabilityRight = justificationRatio < 0 ? glyph.adjustability.shrinkability[1] : glyph.adjustability.stretchability[1];
      const justificationLeft = adjustabilityLeft * justificationRatio;
      let justificationRight = adjustabilityRight * justificationRatio;
      if (glyph.isJustifiable) {
        justificationRight += extraJustification;
      }
      glyph.width += justificationLeft + justificationRight;
      glyph.xOffset += justificationLeft;
    }
    setGlyphGroupLeft(divide.glyphGroup);
  }
  function horizontalAlignHandler(line, horizontalAlign) {
    const { divides } = line;
    for (let i = 0; i < divides.length; i++) {
      const divide = divides[i];
      const { width } = divide;
      let glyphGroupWidth = getGlyphGroupWidth(divide);
      if (width === Number.POSITIVE_INFINITY) {
        continue;
      }
      if (divide.isFull) {
        let remaining = width - glyphGroupWidth;
        if (divide.glyphGroup.length > 1) {
          const lastGlyph = divide.glyphGroup[divide.glyphGroup.length - 1];
          const amount = overhang(lastGlyph.content) * lastGlyph.width;
          remaining += amount;
        }
        let justificationRatio = 0;
        let extraJustification = 0;
        const shrink = getDivideShrinkability(divide);
        const stretch = getDivideStretchability(divide);
        if (remaining < 0 && shrink > 0) {
          justificationRatio = Math.max(remaining / shrink, -1);
          remaining = Math.min(remaining + shrink, 0);
        } else if (horizontalAlign === 4 /* JUSTIFIED */) {
          if (stretch > 0) {
            justificationRatio = Math.min(remaining / stretch, 1);
            remaining = Math.max(remaining - stretch, 0);
          }
          const justifiables = getJustifiables(divide);
          if (justifiables > 0 && remaining > 0) {
            extraJustification = remaining / justifiables;
            remaining = 0;
          }
        }
        if (justificationRatio !== 0 || extraJustification !== 0) {
          adjustGlyphsInDivide(divide, justificationRatio, extraJustification);
          glyphGroupWidth = getGlyphGroupWidth(divide);
        }
      }
      if (horizontalAlign === 2 /* CENTER */) {
        divide.paddingLeft = (width - glyphGroupWidth) / 2;
      } else if (horizontalAlign === 3 /* RIGHT */) {
        divide.paddingLeft = width - glyphGroupWidth;
      }
    }
  }
  function restoreLastCJKGlyphWidth(line) {
    for (const divide of line.divides) {
      const lastGlyph = divide.glyphGroup[divide.glyphGroup.length - 1];
      if (divide.isFull && hasCJKText(lastGlyph.content) && lastGlyph.width - lastGlyph.xOffset > lastGlyph.bBox.width) {
        const shrinkAmount = lastGlyph.width - lastGlyph.xOffset - lastGlyph.bBox.width;
        lastGlyph.width -= shrinkAmount;
        lastGlyph.adjustability.shrinkability[1] = 0;
      }
    }
  }
  function shrinkStartAndEndCJKPunctuation(line) {
    for (const divide of line.divides) {
      const glyphGroupLength = divide.glyphGroup.length;
      if (glyphGroupLength < 2) {
        continue;
      }
      const firstGlyph = divide.glyphGroup[0];
      const lastGlyph = divide.glyphGroup[glyphGroupLength - 1];
      if (isCjkRightAlignedPunctuation(firstGlyph.content)) {
        const shrinkAmount = firstGlyph.adjustability.shrinkability[0];
        glyphShrinkLeft(firstGlyph, shrinkAmount);
      }
      if (isCjkLeftAlignedPunctuation(lastGlyph.content)) {
        const shrinkAmount = lastGlyph.adjustability.shrinkability[1];
        glyphShrinkRight(lastGlyph, shrinkAmount);
      }
    }
  }
  function lineAdjustment(pages, paragraph) {
    lineIterator(pages, (line) => {
      if (line.paragraphIndex !== paragraph.startIndex) {
        return;
      }
      const { paragraphStyle = {} } = paragraph;
      const { horizontalAlign = 0 /* UNSPECIFIED */ } = paragraphStyle;
      shrinkStartAndEndCJKPunctuation(line);
      restoreLastCJKGlyphWidth(line);
      horizontalAlignHandler(line, horizontalAlign);
    });
  }

  // ../packages/engine-render/src/components/docs/layout/block/paragraph/layout.ts
  function dealWidthParagraph(bodyModel, paragraphNode, curPage, sectionBreakConfig, skeletonResourceReference) {
    clearFontCreateConfigCache();
    const { endIndex, content = "" } = paragraphNode;
    const paragraph = bodyModel.getParagraph(endIndex) || { startIndex: 0 };
    const { paragraphStyle = {} } = paragraph;
    const shapedTextList = shaping(
      content,
      bodyModel,
      paragraphNode,
      sectionBreakConfig,
      paragraphStyle
    );
    const allPages = lineBreaking(
      shapedTextList,
      curPage,
      bodyModel,
      paragraphNode,
      sectionBreakConfig,
      skeletonResourceReference
    );
    lineAdjustment(allPages, paragraph);
    return allPages;
  }

  // ../packages/engine-render/src/components/docs/layout/block/section.ts
  function dealWithSections(bodyModel, sectionNode, curPage, sectionBreakConfig, skeletonResourceReference, _preRenderedBlockIdMap) {
    const allCurrentSkeletonPages = [];
    const renderedBlockIdMap = /* @__PURE__ */ new Map();
    for (const node of sectionNode.children) {
      let skeletonPages = [];
      let currentPageCache = curPage;
      if (allCurrentSkeletonPages.length > 0) {
        currentPageCache = allCurrentSkeletonPages[allCurrentSkeletonPages.length - 1];
      }
      if (node.nodeType === 0 /* PARAGRAPH */) {
        skeletonPages = dealWidthParagraph(
          bodyModel,
          node,
          currentPageCache,
          sectionBreakConfig,
          skeletonResourceReference
        );
      } else if (node.nodeType === 2 /* TABLE */) {
      }
      if (skeletonPages.length === 0) {
        skeletonPages = dealWithBlockError();
      }
      _pushPage(allCurrentSkeletonPages, skeletonPages);
    }
    return {
      pages: allCurrentSkeletonPages,
      renderedBlockIdMap
    };
  }
  function _pushPage(allCurrentSkeletonPages, blockSkeletonPages) {
    const lastIndex = allCurrentSkeletonPages.length - 1;
    const lastOldPage = allCurrentSkeletonPages[lastIndex];
    const firstNewPage = blockSkeletonPages[0];
    if (lastOldPage === firstNewPage) {
      blockSkeletonPages.splice(0, 1);
    }
    allCurrentSkeletonPages.push(...blockSkeletonPages);
  }

  // ../packages/engine-render/src/components/docs/layout/doc-skeleton.ts
  var DEFAULT_SECTION_BREAK = {
    columnProperties: [],
    columnSeparatorType: 1 /* NONE */,
    sectionType: 0 /* SECTION_TYPE_UNSPECIFIED */,
    startIndex: 0
  };
  var DocumentSkeleton = class _DocumentSkeleton extends Skeleton {
    constructor(_docViewModel, localeService) {
      super(localeService);
      this._docViewModel = _docViewModel;
      __publicField(this, "_skeletonData");
      __publicField(this, "_renderedBlockIdMap", /* @__PURE__ */ new Map());
      __publicField(this, "_findLiquid", new Liquid());
    }
    static create(docViewModel, localeService) {
      return new _DocumentSkeleton(docViewModel, localeService);
    }
    getViewModel() {
      return this._docViewModel;
    }
    // Layout the document.
    calculate(bounds) {
      if (!this.dirty) {
        return;
      }
      this._skeletonData = this._createSkeleton(bounds);
    }
    getSkeletonData() {
      return this._skeletonData;
    }
    getActualSize() {
      const skeletonData = this.getSkeletonData();
      let actualWidth = Number.NEGATIVE_INFINITY;
      let actualHeight = 0;
      skeletonData == null ? void 0 : skeletonData.pages.forEach((page) => {
        const { width, height } = page;
        actualWidth = Math.max(actualWidth, width);
        actualHeight += height;
      });
      return {
        actualWidth,
        actualHeight
      };
    }
    _getPageActualWidth(page) {
      let maxWidth = Number.NEGATIVE_INFINITY;
      for (const section of page.sections) {
        for (const column of section.columns) {
          for (const line of column.lines) {
            let lineWidth = 0;
            for (const divide of line.divides) {
              for (const glyph of divide.glyphGroup) {
                lineWidth += glyph.width;
              }
            }
            maxWidth = Math.max(maxWidth, lineWidth);
          }
        }
      }
      return maxWidth;
    }
    getPageSize() {
      return this.getViewModel().getDataModel().documentStyle.pageSize;
    }
    findPositionByGlyph(glyph) {
      const divide = glyph.parent;
      const line = divide == null ? void 0 : divide.parent;
      const column = line == null ? void 0 : line.parent;
      const section = column == null ? void 0 : column.parent;
      const page = section == null ? void 0 : section.parent;
      const skeletonData = this.getSkeletonData();
      if (!divide || !column || !section || !page || !skeletonData) {
        return;
      }
      const glyphIndex = divide.glyphGroup.indexOf(glyph);
      const divideIndex = line.divides.indexOf(divide);
      const lineIndex = column.lines.indexOf(line);
      const columnIndex = section.columns.indexOf(column);
      const sectionIndex = page.sections.indexOf(section);
      const pageIndex = skeletonData.pages.indexOf(page);
      return {
        glyph: glyphIndex,
        divide: divideIndex,
        line: lineIndex,
        column: columnIndex,
        section: sectionIndex,
        page: pageIndex
      };
    }
    findNodePositionByCharIndex(charIndex, isBack = true) {
      const nodes = this._findNodeIterator(charIndex);
      if (nodes == null) {
        return;
      }
      const skeletonData = this.getSkeletonData();
      if (!skeletonData) {
        return;
      }
      const pages = skeletonData.pages;
      const { glyph, divide, line, column, section, page } = nodes;
      return {
        glyph: divide.glyphGroup.indexOf(glyph),
        divide: line.divides.indexOf(divide),
        line: column.lines.indexOf(line),
        column: section.columns.indexOf(column),
        section: page.sections.indexOf(section),
        page: pages.indexOf(page),
        isBack
      };
    }
    findNodeByCharIndex(charIndex) {
      const nodes = this._findNodeIterator(charIndex);
      return nodes == null ? void 0 : nodes.glyph;
    }
    findGlyphByPosition(position) {
      if (position == null) {
        return;
      }
      const skeletonData = this.getSkeletonData();
      if (skeletonData == null) {
        return;
      }
      const { divide, line, column, section, page, isBack } = position;
      let { glyph } = position;
      if (isBack === true) {
        glyph -= 1;
      }
      glyph = glyph < 0 ? 0 : glyph;
      const glyphGroup = skeletonData.pages[page].sections[section].columns[column].lines[line].divides[divide].glyphGroup;
      if (glyphGroup[glyph].glyphType === 2 /* LIST */) {
        return glyphGroup[glyph + 1];
      }
      return glyphGroup[glyph];
    }
    findNodeByCoord(coord, pageLayoutType, pageMarginLeft, pageMarginTop) {
      const { x, y } = coord;
      this._findLiquid.reset();
      const skeletonData = this.getSkeletonData();
      if (skeletonData == null) {
        return;
      }
      const pages = skeletonData.pages;
      let nearestNodeList = [];
      let nearestNodeDistanceList = [];
      let nearestNodeDistanceY = Number.POSITIVE_INFINITY;
      for (let i = 0, len = pages.length; i < len; i++) {
        const page = pages[i];
        this._findLiquid.translatePagePadding(page);
        const sections = page.sections;
        for (const section of sections) {
          const { columns, height } = section;
          this._findLiquid.translateSection(section);
          for (const column of columns) {
            const { lines, width: columnWidth } = column;
            this._findLiquid.translateColumn(column);
            const linesCount = lines.length;
            for (let i2 = 0; i2 < linesCount; i2++) {
              const line = lines[i2];
              const { divides, type, lineHeight = 0 } = line;
              if (type === 1 /* BLOCK */) {
                continue;
              } else {
                this._findLiquid.translateSave();
                this._findLiquid.translateLine(line);
                const { y: startY } = this._findLiquid;
                const startY_fin = startY;
                const endY_fin = startY + lineHeight;
                const distanceY = Math.abs(y - endY_fin);
                const divideLength = divides.length;
                for (let i3 = 0; i3 < divideLength; i3++) {
                  const divide = divides[i3];
                  const { glyphGroup, width: divideWidth } = divide;
                  this._findLiquid.translateSave();
                  this._findLiquid.translateDivide(divide);
                  const { x: startX } = this._findLiquid;
                  for (const glyph of glyphGroup) {
                    if (!glyph.content || glyph.content.length === 0) {
                      continue;
                    }
                    const { width: glyphWidth, left: glyphLeft } = glyph;
                    const startX_fin = startX + glyphLeft;
                    const endX_fin = startX + glyphLeft + glyphWidth;
                    const distanceX = Math.abs(x - endX_fin);
                    if (y >= startY_fin && y <= endY_fin) {
                      if (x >= startX_fin && x <= endX_fin) {
                        return {
                          node: glyph,
                          ratioX: x / (startX_fin + endX_fin),
                          ratioY: y / (startY_fin + endY_fin)
                        };
                      }
                      if (nearestNodeDistanceY !== Number.NEGATIVE_INFINITY) {
                        nearestNodeList = [];
                        nearestNodeDistanceList = [];
                      }
                      nearestNodeList.push({
                        node: glyph,
                        ratioX: x / (startX_fin + endX_fin),
                        ratioY: y / (startY_fin + endY_fin)
                      });
                      nearestNodeDistanceList.push(distanceX);
                      nearestNodeDistanceY = Number.NEGATIVE_INFINITY;
                      continue;
                    }
                    if (distanceY < nearestNodeDistanceY) {
                      nearestNodeDistanceY = distanceY;
                      nearestNodeList = [];
                      nearestNodeDistanceList = [];
                    }
                    if (distanceY === nearestNodeDistanceY) {
                      nearestNodeList.push({
                        node: glyph,
                        ratioX: x / (startX_fin + endX_fin),
                        ratioY: y / (startY_fin + endY_fin)
                      });
                      nearestNodeDistanceList.push(distanceX);
                    }
                  }
                  this._findLiquid.translateRestore();
                }
                this._findLiquid.translateRestore();
              }
            }
          }
        }
        this._findLiquid.restorePagePadding(page);
        this._translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
      }
      return this._getNearestNode(nearestNodeList, nearestNodeDistanceList);
    }
    _getNearestNode(nearestNodeList, nearestNodeDistanceList) {
      const miniValue = Math.min(...nearestNodeDistanceList);
      const miniValueIndex = nearestNodeDistanceList.indexOf(miniValue);
      return nearestNodeList[miniValueIndex];
    }
    _getPageBoundingBox(page, pageLayoutType) {
      const { pageWidth, pageHeight } = page;
      const { x: startX, y: startY } = this._findLiquid;
      let endX = -1;
      let endY = -1;
      if (pageLayoutType === 0 /* VERTICAL */) {
        endX = pageWidth;
        endY = startY + pageHeight;
      } else if (pageLayoutType === 1 /* HORIZONTAL */) {
        endX = startX + pageWidth;
        endY = pageHeight;
      }
      return {
        startX,
        startY,
        endX,
        endY
      };
    }
    _translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop) {
      this._findLiquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
    }
    /**
     * \v COLUMN_BREAK
     * \f PAGE_BREAK
     * \0 DOCS_END
     * \t TAB
     *
     * Needs to be changed：
     * \r PARAGRAPH
     * \n SECTION_BREAK
     *
     * \b customBlock: Scenarios where customBlock, images, mentions, etc. do not participate in the document flow.
     *
     * Table
     * \x1A table start
     * \x1B table row start
     * \x1C table cell start
     * \x1D table cell end
     * \x1E table row end
     * \x1F table end
     *
     * Special ranges within the document flow:：hyperlinks，field，structured document tags， bookmark，comment
     * \x1F customRange start
     * \x1E customRange end
     *
     * Split the document according to SectionBreak and perform layout calculations.
     * @returns view model: skeleton
     */
    _createSkeleton(_bounds) {
      var _a2;
      const DEFAULT_PAGE_SIZE = { width: Number.POSITIVE_INFINITY, height: Number.POSITIVE_INFINITY };
      const viewModel = this.getViewModel();
      const { headerTreeMap, footerTreeMap } = viewModel;
      const { documentStyle, drawings, lists: customLists = {} } = viewModel.getDataModel();
      const lists = {
        ...PRESET_LIST_TYPE,
        ...customLists
      };
      const {
        pageNumberStart: global_pageNumberStart = 1,
        // pageNumberStart
        pageSize: global_pageSize = DEFAULT_PAGE_SIZE,
        pageOrient: global_pageOrient = 0 /* PORTRAIT */,
        defaultHeaderId: global_defaultHeaderId,
        defaultFooterId: global_defaultFooterId,
        evenPageHeaderId: global_evenPageHeaderId,
        evenPageFooterId: global_evenPageFooterId,
        firstPageHeaderId: global_firstPageHeaderId,
        firstPageFooterId: global_firstPageFooterId,
        useFirstPageHeaderFooter: global_useFirstPageHeaderFooter,
        useEvenPageHeaderFooter: global_useEvenPageHeaderFooter,
        marginTop: global_marginTop = 0,
        marginBottom: global_marginBottom = 0,
        marginRight: global_marginRight = 0,
        marginLeft: global_marginLeft = 0,
        marginHeader: global_marginHeader = 0,
        marginFooter: global_marginFooter = 0,
        charSpace = 0,
        // charSpace
        linePitch = 15.6,
        // linePitch pt
        gridType = 1 /* LINES */,
        // gridType
        paragraphLineGapDefault = 0,
        defaultTabStop = 10.5,
        textStyle = {},
        renderConfig: global_renderConfig = {
          horizontalAlign: 1 /* LEFT */,
          verticalAlign: 1 /* TOP */,
          centerAngle: 0,
          vertexAngle: 0,
          wrapStrategy: 0 /* UNSPECIFIED */
        }
      } = documentStyle;
      const docsConfig = {
        headerTreeMap,
        footerTreeMap,
        lists,
        drawings,
        charSpace,
        linePitch,
        gridType,
        localeService: this._localService,
        paragraphLineGapDefault,
        defaultTabStop,
        documentTextStyle: textStyle
      };
      const skeleton = this._getNullSke();
      const { skeHeaders, skeFooters, skeListLevel, drawingAnchor } = skeleton;
      const skeletonResourceReference = {
        skeHeaders,
        skeFooters,
        skeListLevel,
        drawingAnchor
      };
      const allSkeletonPages = [];
      skeleton.pages = allSkeletonPages;
      const bodyModel = this.getViewModel();
      bodyModel.resetCache();
      for (let i = 0, len = bodyModel.children.length; i < len; i++) {
        const sectionNode = bodyModel.children[i];
        const sectionBreak = bodyModel.getSectionBreak(sectionNode.endIndex) || DEFAULT_SECTION_BREAK;
        const {
          pageNumberStart = global_pageNumberStart,
          pageSize = global_pageSize,
          pageOrient = global_pageOrient,
          marginTop = global_marginTop,
          marginBottom = global_marginBottom,
          marginRight = global_marginRight,
          marginLeft = global_marginLeft,
          marginHeader = global_marginHeader,
          marginFooter = global_marginFooter,
          defaultHeaderId = global_defaultHeaderId,
          defaultFooterId = global_defaultFooterId,
          evenPageHeaderId = global_evenPageHeaderId,
          evenPageFooterId = global_evenPageFooterId,
          firstPageHeaderId = global_firstPageHeaderId,
          firstPageFooterId = global_firstPageFooterId,
          useFirstPageHeaderFooter = global_useFirstPageHeaderFooter,
          useEvenPageHeaderFooter = global_useEvenPageHeaderFooter,
          columnProperties = [],
          columnSeparatorType = 1 /* NONE */,
          contentDirection,
          sectionType,
          textDirection,
          renderConfig = global_renderConfig
        } = sectionBreak;
        const sectionNodeNext = bodyModel.children[i + 1];
        const sectionTypeNext = (_a2 = bodyModel.getSectionBreak(sectionNodeNext == null ? void 0 : sectionNodeNext.endIndex)) == null ? void 0 : _a2.sectionType;
        const headerIds = { defaultHeaderId, evenPageHeaderId, firstPageHeaderId };
        const footerIds = { defaultFooterId, evenPageFooterId, firstPageFooterId };
        if (pageSize.width === null) {
          pageSize.width = Number.POSITIVE_INFINITY;
        }
        if (pageSize.height === null) {
          pageSize.height = Number.POSITIVE_INFINITY;
        }
        const sectionBreakConfig = {
          pageNumberStart,
          pageSize,
          pageOrient,
          marginTop,
          marginBottom,
          marginRight,
          marginLeft,
          marginHeader,
          marginFooter,
          headerIds,
          footerIds,
          useFirstPageHeaderFooter,
          useEvenPageHeaderFooter,
          columnProperties,
          columnSeparatorType,
          contentDirection,
          sectionType,
          sectionTypeNext,
          textDirection,
          renderConfig,
          ...docsConfig
        };
        let curSkeletonPage = getLastPage(allSkeletonPages);
        let isContinuous = false;
        if (sectionType === 1 /* CONTINUOUS */) {
          updateBlockIndex(allSkeletonPages);
          this._addNewSectionByContinuous(curSkeletonPage, columnProperties, columnSeparatorType);
          isContinuous = true;
        } else {
          curSkeletonPage = createSkeletonPage(
            sectionBreakConfig,
            skeletonResourceReference,
            curSkeletonPage == null ? void 0 : curSkeletonPage.pageNumber
          );
        }
        const blockInfo = dealWithSections(
          bodyModel,
          sectionNode,
          curSkeletonPage,
          sectionBreakConfig,
          skeletonResourceReference,
          this._renderedBlockIdMap
        );
        if (sectionTypeNext === 1 /* CONTINUOUS */ && columnProperties.length > 0) {
        }
        const { pages } = blockInfo;
        if (isContinuous) {
          pages.splice(0, 1);
        }
        allSkeletonPages.push(...pages);
      }
      updateBlockIndex(allSkeletonPages);
      this._setPageParent(allSkeletonPages, skeleton);
      return skeleton;
    }
    _setPageParent(pages, parent) {
      for (const page of pages) {
        page.parent = parent;
      }
    }
    // 一页存在多个 section 的情况，仅在 SectionType.CONTINUOUS 的情况下出现
    _addNewSectionByContinuous(curSkeletonPage, columnProperties, columnSeparatorType) {
      const sections = curSkeletonPage.sections;
      const lastSection = sections[sections.length - 1];
      const {
        pageWidth,
        pageHeight,
        marginTop: curPageMT,
        marginBottom: curPageMB,
        marginLeft: curPageML,
        marginRight: curPageMR
      } = curSkeletonPage;
      const pageContentWidth = pageWidth - curPageML - curPageMR;
      const pageContentHeight = pageHeight - curPageMT - curPageMB;
      const lastSectionBottom = ((lastSection == null ? void 0 : lastSection.top) || 0) + ((lastSection == null ? void 0 : lastSection.height) || 0);
      const newSection = createSkeletonSection(
        columnProperties,
        columnSeparatorType,
        lastSectionBottom,
        0,
        pageContentWidth,
        pageContentHeight - lastSectionBottom
      );
      newSection.parent = curSkeletonPage;
      sections.push(newSection);
    }
    _getNullSke() {
      return {
        pages: [],
        left: 0,
        top: 0,
        st: 0,
        skeHeaders: /* @__PURE__ */ new Map(),
        skeFooters: /* @__PURE__ */ new Map(),
        skeListLevel: /* @__PURE__ */ new Map(),
        drawingAnchor: /* @__PURE__ */ new Map()
      };
    }
    _findNodeIterator(charIndex) {
      const skeletonData = this.getSkeletonData();
      if (!skeletonData) {
        return;
      }
      const pages = skeletonData.pages;
      for (const page of pages) {
        const { sections, st, ed } = page;
        if (charIndex < st || charIndex > ed) {
          continue;
        }
        for (const section of sections) {
          const { columns, st: st2, ed: ed2 } = section;
          if (charIndex < st2 || charIndex > ed2) {
            continue;
          }
          for (const column of columns) {
            const { lines, st: st3, ed: ed3 } = column;
            if (charIndex < st3 || charIndex > ed3) {
              continue;
            }
            for (const line of lines) {
              const { divides, st: st4, ed: ed4 } = line;
              const divideLength = divides.length;
              if (charIndex < st4 || charIndex > ed4) {
                continue;
              }
              for (let i = 0; i < divideLength; i++) {
                const divide = divides[i];
                const { glyphGroup, st: st5, ed: ed5 } = divide;
                if (charIndex < st5 || charIndex > ed5) {
                  continue;
                }
                let delta = charIndex - st5;
                for (const glyph of glyphGroup) {
                  delta -= glyph.count;
                  if (delta < 0) {
                    return {
                      page,
                      section,
                      column,
                      line,
                      divide,
                      glyph
                    };
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  // ../packages/engine-render/src/components/docs/view-model/data-stream-tree-node.ts
  var DataStreamTreeNode = class _DataStreamTreeNode {
    constructor(nodeType, content) {
      this.nodeType = nodeType;
      this.content = content;
      __publicField(this, "children", []);
      __publicField(this, "parent");
      __publicField(this, "startIndex", -1);
      __publicField(this, "endIndex", -1);
      // isBullet: boolean = false;
      // isIndent: boolean = false;
      __publicField(this, "blocks", []);
    }
    static create(nodeType, content) {
      return new _DataStreamTreeNode(nodeType, content);
    }
    dispose() {
      this.children.forEach((child) => {
        child.dispose();
      });
      this.parent = null;
      this.blocks = [];
    }
    getProps() {
      const { children, parent, startIndex, endIndex, nodeType, content } = this;
      return {
        children,
        parent,
        startIndex,
        endIndex,
        nodeType,
        content
      };
    }
    addBlocks(blocks) {
      this.blocks = this.blocks.concat(blocks);
    }
    setIndexRange(startIndex, endIndex) {
      this.startIndex = startIndex;
      this.endIndex = endIndex;
    }
    insertText(text, insertIndex) {
      this.content = insertTextToContent(this.content || "", insertIndex - this.startIndex, text);
    }
    exclude(index) {
      const { startIndex, endIndex } = this;
      return index < startIndex || index > endIndex;
    }
    plus(len) {
      this.startIndex += len;
      this.endIndex += len;
      this._addIndexForBlock(len);
    }
    selfPlus(len, index) {
      this.endIndex += len;
      if (index == null) {
        index = this.startIndex;
      }
      this._addIndexForBlock(len, index);
    }
    split(index) {
      const { children, parent, startIndex, nodeType, content = "" } = this.getProps();
      if (this.exclude(index)) {
        return;
      }
      const firstStartIndex = 0;
      const firstEndIndex = index - startIndex;
      const lastStartIndex = firstEndIndex;
      const firstNodeContent = content.slice(firstStartIndex, firstEndIndex);
      const firstNode = _DataStreamTreeNode.create(nodeType, firstNodeContent);
      firstNode.parent = parent;
      firstNode.setIndexRange(firstStartIndex, firstEndIndex - 1);
      const lastNodeContent = content.slice(lastStartIndex);
      const lastNode = _DataStreamTreeNode.create(nodeType, lastNodeContent);
      lastNode.parent = parent;
      lastNode.setIndexRange(lastStartIndex, lastStartIndex + lastNodeContent.length - 1);
      const firstChildNodes = [];
      const lastChildNodes = [];
      for (const node of children) {
        const { startIndex: childStartIndex } = node;
        if (node.exclude(index)) {
          if (index < childStartIndex) {
            firstChildNodes.push(node);
          } else {
            lastChildNodes.push(node);
          }
        } else {
          const splitData = node.split(index);
          if (splitData == null) {
            firstChildNodes.push(node);
            continue;
          }
          const { firstNode: firstNode2, lastNode: lastNode2 } = splitData;
          firstChildNodes.push(firstNode2);
          firstChildNodes.push(lastNode2);
        }
      }
      firstNode.children = firstChildNodes;
      lastNode.children = lastChildNodes;
      firstNode._resetBlocks();
      lastNode._resetBlocks();
      return {
        firstNode,
        lastNode
      };
    }
    getPositionInParent() {
      var _a2;
      const index = (_a2 = this.parent) == null ? void 0 : _a2.children.indexOf(this);
      if (index == null) {
        return -1;
      }
      return index;
    }
    remove() {
      this.children = [];
      if (this.parent == null) {
        return;
      }
      this.parent.children.splice(this.getPositionInParent(), 1);
      this.parent = null;
    }
    minus(startIndex, endIndex) {
      const segments = horizontalLineSegmentsSubtraction(this.startIndex, this.endIndex, startIndex, endIndex);
      if (segments.length === 0) {
        return;
      }
      const originStartIndex = this.startIndex;
      this.startIndex = segments[0];
      this.endIndex = segments[1];
      if (this.content != null) {
        this.content = deleteContent(
          this.content || "",
          startIndex - originStartIndex,
          endIndex - originStartIndex + 1
        );
      }
    }
    merge(node) {
      const { startIndex, endIndex, children } = node;
      this.endIndex += endIndex - startIndex + 1;
      this.children.push(...children);
      this.content += node.content || "";
      node.remove();
    }
    _addIndexForBlock(addLen, index = Number.NEGATIVE_INFINITY) {
      for (let i = 0, len = this.blocks.length; i < len; i++) {
        const block = this.blocks[i];
        if (block >= index) {
          this.blocks[i] = block + addLen;
        }
      }
    }
    _resetBlocks() {
      if (this.nodeType !== 0 /* PARAGRAPH */) {
        return;
      }
      if (this.content == null) {
        return;
      }
      if (this.content.length === 0) {
        return;
      }
      this.blocks = [];
      for (let i = 0, len = this.content.length; i < len; i++) {
        const char = this.content[i];
        if (char === "\b" /* CUSTOM_BLOCK */) {
          this.blocks.push(this.startIndex + i);
        }
      }
    }
  };

  // ../packages/engine-render/src/components/docs/view-model/document-view-model.ts
  var DocumentViewModel = class _DocumentViewModel {
    constructor(_documentDataModel) {
      this._documentDataModel = _documentDataModel;
      __publicField(this, "children", []);
      __publicField(this, "_sectionBreakCurrentIndex", 0);
      __publicField(this, "_paragraphCurrentIndex", 0);
      __publicField(this, "_textRunCurrentIndex", 0);
      __publicField(this, "_customBlockCurrentIndex", 0);
      __publicField(this, "_tableBlockCurrentIndex", 0);
      __publicField(this, "_customRangeCurrentIndex", 0);
      __publicField(this, "headerTreeMap", /* @__PURE__ */ new Map());
      __publicField(this, "footerTreeMap", /* @__PURE__ */ new Map());
      if (_documentDataModel.getBody() == null) {
        return;
      }
      this.children = this._transformToTree(_documentDataModel.getBody().dataStream);
      this._buildHeaderFooterViewModel();
    }
    dispose() {
      this.children.forEach((child) => {
        child.dispose();
      });
    }
    selfPlus(len, index) {
    }
    getPositionInParent() {
      return 0;
    }
    getLastIndex() {
      return this.children[this.children.length - 1].endIndex;
    }
    getBody() {
      return this._documentDataModel.getBody();
    }
    getDataModel() {
      return this._documentDataModel;
    }
    getSelfOrHeaderFooterViewModel(segmentId) {
      if (segmentId == null) {
        return this;
      }
      if (this.headerTreeMap.has(segmentId)) {
        return this.headerTreeMap.get(segmentId);
      }
      if (this.footerTreeMap.has(segmentId)) {
        return this.footerTreeMap.get(segmentId);
      }
      return this;
    }
    reset(documentDataModel) {
      this._documentDataModel = documentDataModel;
      this.children = this._transformToTree(documentDataModel.getBody().dataStream);
      this._buildHeaderFooterViewModel();
    }
    insert(insertBody, insertIndex = 0) {
      var _a2;
      const dataStream = insertBody.dataStream;
      let dataStreamLen = dataStream.length;
      const insertedNode = this._getParagraphByIndex(this.children, insertIndex);
      if (insertedNode == null) {
        return;
      }
      if (dataStream[dataStreamLen - 1] === "\n" /* SECTION_BREAK */) {
        const docDataModel = new DocumentDataModel({ body: insertBody });
        const insertBodyModel = new _DocumentViewModel(docDataModel);
        dataStreamLen -= 1;
        const insertNodes = insertBodyModel.children;
        for (const node of insertNodes) {
          this._forEachDown(node, (newNode) => {
            newNode.plus(insertIndex);
          });
        }
        const insertedNodeSplit = insertedNode.split(insertIndex);
        if (insertedNodeSplit == null) {
          return;
        }
        const { firstNode: insertedFirstNode, lastNode: insertedLastNode } = insertedNodeSplit;
        (_a2 = insertedNode.parent) == null ? void 0 : _a2.children.splice(
          insertedNode.getPositionInParent(),
          1,
          insertedFirstNode,
          ...insertNodes,
          insertedLastNode
        );
        this._forEachTop(insertedNode.parent, (currentNode) => {
          currentNode.selfPlus(dataStreamLen, currentNode.getPositionInParent());
          const children = currentNode.children;
          let isStartFix = false;
          for (const node of children) {
            if (node === insertedLastNode) {
              isStartFix = true;
            }
            if (!isStartFix) {
              continue;
            }
            this._forEachDown(node, (newNode) => {
              newNode.plus(dataStreamLen);
            });
          }
        });
      } else if (dataStreamLen === 1 && dataStream[dataStreamLen - 1] === "\r" /* PARAGRAPH */) {
        this._insertParagraph(insertedNode, insertIndex);
      } else {
        insertedNode.insertText(dataStream, insertIndex);
        insertedNode.selfPlus(dataStreamLen, insertIndex);
        this._forEachTop(insertedNode.parent, (currentNode) => {
          currentNode.selfPlus(dataStreamLen, currentNode.getPositionInParent());
          const children = currentNode.children;
          let isStartFix = false;
          for (const node of children) {
            if (node.startIndex > insertIndex) {
              isStartFix = true;
            }
            if (!isStartFix) {
              continue;
            }
            this._forEachDown(node, (newNode) => {
              newNode.plus(dataStreamLen);
            });
          }
        });
      }
    }
    delete(currentIndex, textLength) {
      const nodes = this.children;
      this._deleteTree(nodes, currentIndex, textLength);
    }
    /** Get pure text content in the given range. */
    getText() {
      const pieces = [];
      function traverseTreeNode(node) {
        if (node.content) {
          pieces.push(node.content);
        }
        node.children.forEach(traverseTreeNode);
      }
      this.children.forEach((n) => traverseTreeNode(n));
      return pieces.join("");
    }
    resetCache() {
      this._sectionBreakCurrentIndex = 0;
      this._paragraphCurrentIndex = 0;
      this._textRunCurrentIndex = 0;
      this._customBlockCurrentIndex = 0;
      this._tableBlockCurrentIndex = 0;
      this._customRangeCurrentIndex = 0;
    }
    getSectionBreak(index) {
      if (index == null) {
        return;
      }
      const sectionBreaks = this.getBody().sectionBreaks;
      if (sectionBreaks == null) {
        return;
      }
      for (let i = this._sectionBreakCurrentIndex; i < sectionBreaks.length; i++) {
        const sectionBreak = sectionBreaks[i];
        if (sectionBreak.startIndex === index) {
          this._sectionBreakCurrentIndex = i;
          return sectionBreak;
        }
      }
    }
    getParagraph(index) {
      const paragraphs = this.getBody().paragraphs;
      if (paragraphs == null) {
        return;
      }
      for (let i = this._paragraphCurrentIndex; i < paragraphs.length; i++) {
        const paragraph = paragraphs[i];
        if (paragraph.startIndex === index) {
          this._paragraphCurrentIndex = i;
          return paragraph;
        }
      }
    }
    getTextRunRange(startIndex = 0, endIndex) {
      const textRuns = this.getBody().textRuns;
      if (textRuns == null) {
        return [
          {
            st: startIndex,
            ed: endIndex
          }
        ];
      }
      const trRange = [];
      for (let i = this._textRunCurrentIndex, textRunsLen = textRuns.length; i < textRunsLen; i++) {
        const textRun = textRuns[i];
        if (textRun.st > endIndex) {
          this._textRunCurrentIndex = i;
          break;
        } else if (textRun.ed < startIndex) {
          this._textRunCurrentIndex = i;
          continue;
        } else {
          trRange.push({
            st: textRun.st < startIndex ? startIndex : textRun.st,
            ed: textRun.ed > endIndex ? endIndex : textRun.ed,
            sId: textRun.sId,
            ts: textRun.ts
          });
          this._textRunCurrentIndex = i;
        }
      }
      const firstTr = trRange[0] || { st: endIndex + 1 };
      if (firstTr.st > startIndex) {
        trRange.push({
          st: startIndex,
          ed: firstTr.st - 1
        });
      }
      const lastTr = trRange[trRange.length - 1] || { ed: startIndex - 1 };
      if (lastTr.ed < endIndex) {
        trRange.push({
          st: lastTr.ed + 1,
          ed: endIndex
        });
      }
      return trRange;
    }
    /**
     * textRun matches according to the selection. If the text length is 10, then the range of textRun is from 0 to 11.
     */
    getTextRun(index) {
      const textRuns = this.getBody().textRuns;
      if (textRuns == null) {
        return;
      }
      const curTextRun = textRuns[this._textRunCurrentIndex];
      if (curTextRun != null) {
        if (index >= curTextRun.st && index < curTextRun.ed) {
          return curTextRun;
        }
        if (index < curTextRun.st) {
          return;
        }
      }
      for (let i = this._textRunCurrentIndex, textRunsLen = textRuns.length; i < textRunsLen; i++) {
        const textRun = textRuns[i];
        if (index >= textRun.st && index < textRun.ed) {
          this._textRunCurrentIndex = i;
          return textRun;
        }
      }
    }
    getCustomBlock(index) {
      const customBlocks = this.getBody().customBlocks;
      if (customBlocks == null) {
        return;
      }
      for (let i = this._customBlockCurrentIndex; i < customBlocks.length; i++) {
        const customBlock = customBlocks[i];
        if (customBlock.startIndex === index) {
          this._customBlockCurrentIndex = i;
          return customBlock;
        }
      }
    }
    getTable(index) {
      const tables = this.getBody().tables;
      if (tables == null) {
        return;
      }
      for (let i = this._tableBlockCurrentIndex; i < tables.length; i++) {
        const table = tables[i];
        if (table.startIndex === index) {
          this._tableBlockCurrentIndex = i;
          return table;
        }
      }
    }
    getCustomRange(index) {
      const customRanges = this.getBody().customRanges;
      if (customRanges == null) {
        return;
      }
      for (let i = 0, customRangesLen = customRanges.length; i < customRangesLen; i++) {
        const customRange = customRanges[i];
        if (index >= customRange.startIndex && index <= customRange.endIndex) {
          return customRange;
        }
      }
    }
    _transformToTree(dataStream) {
      const dataStreamLen = dataStream.length;
      let content = "";
      const sectionList = [];
      let nodeList = [];
      let currentBlocks = [];
      for (let i = 0; i < dataStreamLen; i++) {
        const char = dataStream[i];
        if (char === "\r" /* PARAGRAPH */) {
          content += "\r" /* PARAGRAPH */;
          const node = DataStreamTreeNode.create(0 /* PARAGRAPH */, content);
          node.setIndexRange(i - content.length + 1, i);
          node.addBlocks(currentBlocks);
          nodeList.push(node);
          content = "";
          currentBlocks = [];
        } else if (char === "\n" /* SECTION_BREAK */) {
          const sectionTree = DataStreamTreeNode.create(1 /* SECTION_BREAK */);
          this._batchParent(sectionTree, nodeList);
          const lastNode = nodeList[nodeList.length - 1];
          if (lastNode && lastNode.content) {
            lastNode.content += "\n" /* SECTION_BREAK */;
          }
          sectionList.push(sectionTree);
          nodeList = [];
        } else if (char === "" /* TABLE_START */) {
          nodeList.push(DataStreamTreeNode.create(2 /* TABLE */));
        } else if (char === "\x1B" /* TABLE_ROW_START */) {
          nodeList.push(DataStreamTreeNode.create(3 /* TABLE_ROW */));
        } else if (char === "" /* TABLE_CELL_START */) {
          nodeList.push(DataStreamTreeNode.create(4 /* TABLE_CELL */));
        } else if (char === "" /* TABLE_END */) {
          this._processPreviousNodesUntil(nodeList, 2 /* TABLE */);
        } else if (char === "" /* TABLE_ROW_END */) {
          this._processPreviousNodesUntil(nodeList, 3 /* TABLE_ROW */);
        } else if (char === "" /* TABLE_CELL_END */) {
          this._processPreviousNodesUntil(nodeList, 4 /* TABLE_CELL */);
        } else if (char === "\b" /* CUSTOM_BLOCK */) {
          currentBlocks.push(i);
          content += char;
        } else {
          content += char;
        }
      }
      return sectionList;
    }
    _processPreviousNodesUntil(nodeList, untilNodeType) {
      const nodeCollection = [];
      let node = nodeList.pop();
      while (node) {
        if (node.nodeType === untilNodeType) {
          break;
        }
        nodeCollection.push(node);
        node = nodeList.pop();
      }
      const recentTree = nodeList[nodeList.length - 1];
      this._batchParent(recentTree, nodeCollection, 2 /* TABLE */);
      if (untilNodeType === 4 /* TABLE_CELL */) {
        const firstNode = nodeCollection[0];
        const lastNode = nodeCollection[nodeCollection.length];
        firstNode.content = "" /* TABLE_CELL_START */ + firstNode.content || "";
        firstNode.startIndex -= 1;
        lastNode.content += "" /* TABLE_CELL_END */;
        lastNode.endIndex += 1;
      } else if (untilNodeType === 3 /* TABLE_ROW */) {
        const firstNode = nodeCollection[0].children[0];
        let lastNode = nodeCollection[nodeCollection.length];
        lastNode = lastNode.children[lastNode.children.length - 1];
        firstNode.content = "\x1B" /* TABLE_ROW_START */ + firstNode.content || "";
        firstNode.startIndex -= 1;
        lastNode.content += "" /* TABLE_ROW_END */;
        lastNode.endIndex += 1;
      } else if (untilNodeType === 2 /* TABLE */) {
        const firstNode = nodeCollection[0].children[0].children[0];
        let lastNode = nodeCollection[nodeCollection.length];
        lastNode = lastNode.children[lastNode.children.length - 1];
        lastNode = lastNode.children[lastNode.children.length - 1];
        firstNode.content = "" /* TABLE_START */ + firstNode.content || "";
        firstNode.startIndex -= 1;
        lastNode.content += "" /* TABLE_END */;
        lastNode.endIndex += 1;
      }
    }
    _batchParent(parent, children, nodeType = 1 /* SECTION_BREAK */) {
      for (const child of children) {
        child.parent = parent;
        parent.children.push(child);
      }
      const startOffset = nodeType === 1 /* SECTION_BREAK */ ? 0 : 1;
      parent.setIndexRange(children[0].startIndex - startOffset, children[children.length - 1].endIndex + 1);
    }
    _buildHeaderFooterViewModel() {
      const { headerModelMap, footerModelMap } = this._documentDataModel;
      for (const [headerId, headerModel] of headerModelMap) {
        this.headerTreeMap.set(headerId, new _DocumentViewModel(headerModel));
      }
      for (const [footerId, footerModel] of footerModelMap) {
        this.footerTreeMap.set(footerId, new _DocumentViewModel(footerModel));
      }
    }
    _getParagraphByIndex(nodes, insertIndex) {
      for (const node of nodes) {
        const { children } = node;
        if (node.exclude(insertIndex)) {
          continue;
        }
        if (node.nodeType === 0 /* PARAGRAPH */) {
          return node;
        }
        return this._getParagraphByIndex(children, insertIndex);
      }
      return null;
    }
    _forEachTop(node, func) {
      let parent = node;
      while (parent) {
        func(parent);
        parent = parent.parent;
      }
      func(this);
    }
    _forEachDown(node, func) {
      func(node);
      const children = node.children;
      for (node of children) {
        this._forEachDown(node, func);
      }
    }
    _deleteTree(nodes, currentIndex, textLength) {
      const startIndex = currentIndex;
      const endIndex = currentIndex + textLength - 1;
      let mergeNode = null;
      let nodeCount = nodes.length;
      let i = 0;
      while (i < nodeCount) {
        const node = nodes[i];
        const { startIndex: st, endIndex: ed, children } = node;
        this._deleteTree(children, currentIndex, textLength);
        if (startIndex === endIndex && endIndex === ed) {
          if (node.nodeType === 0 /* PARAGRAPH */) {
            const nextNode = this._getNextNode(node);
            if (nextNode == null) {
              i++;
              continue;
            }
            node.minus(startIndex, endIndex);
            node.merge(nextNode);
            nodeCount--;
          }
        } else if (startIndex <= st && endIndex >= ed) {
          node.remove();
          nodeCount--;
          continue;
        } else if (st <= startIndex && ed >= endIndex) {
          node.minus(startIndex, endIndex);
        } else if (endIndex > st && endIndex < ed) {
          node.minus(st, endIndex);
          if (mergeNode != null) {
            mergeNode.merge(node);
            mergeNode = null;
            nodeCount--;
            continue;
          }
        } else if (startIndex > st && startIndex < ed) {
          node.minus(startIndex, ed);
          mergeNode = node;
        } else if (st > endIndex) {
          node.plus(-textLength);
        }
        i++;
      }
    }
    _getNextNode(node) {
      var _a2;
      const currentIndex = node.getPositionInParent();
      const children = (_a2 = node.parent) == null ? void 0 : _a2.children;
      return children == null ? void 0 : children[currentIndex + 1];
    }
    _insertParagraph(insertedNode, insertIndex = 0) {
      var _a2;
      const insertStartIndex = insertedNode.startIndex;
      const insertEndIndex = insertedNode.endIndex;
      const insertedNodeSplit = insertedNode.split(insertIndex);
      if (insertedNodeSplit == null) {
        return;
      }
      const { firstNode: insertedFirstNode, lastNode: insertedLastNode } = insertedNodeSplit;
      insertedFirstNode.content += "\r" /* PARAGRAPH */;
      insertedFirstNode.selfPlus(1);
      insertedFirstNode.plus(insertStartIndex);
      this._forEachDown(insertedLastNode, (newNode) => {
        newNode.plus(insertStartIndex + 1);
      });
      (_a2 = insertedNode.parent) == null ? void 0 : _a2.children.splice(
        insertedNode.getPositionInParent(),
        1,
        insertedFirstNode,
        insertedLastNode
      );
      this._forEachTop(insertedNode.parent, (currentNode) => {
        currentNode.selfPlus(1, currentNode.getPositionInParent());
        const children = currentNode.children;
        let isStartFix = false;
        for (const node of children) {
          if (node === insertedLastNode) {
            continue;
          }
          if (node.startIndex >= insertEndIndex + 1) {
            isStartFix = true;
          }
          if (!isStartFix) {
            continue;
          }
          this._forEachDown(node, (newNode) => {
            newNode.plus(1);
          });
        }
      });
    }
    // private move() {}
    // private split() {}
    // private merge() {}
  };

  // ../packages/engine-render/src/components/sheets/sheet-skeleton.ts
  function getDocsSkeletonPageSize(documentSkeleton, angleInDegree = 0) {
    const skeletonData = documentSkeleton == null ? void 0 : documentSkeleton.getSkeletonData();
    const angle = degToRad(angleInDegree);
    if (!skeletonData) {
      return;
    }
    const { pages } = skeletonData;
    const lastPage = pages[pages.length - 1];
    const { width, height } = lastPage;
    if (angle === 0) {
      return { width, height };
    }
    if (Math.abs(angle) === Math.PI / 2) {
      return { width: height, height: width };
    }
    let allRotatedWidth = 0;
    let allRotatedHeight = 0;
    const widthArray = [];
    columnIterator([lastPage], (column) => {
      const { lines, width: columnWidth, spaceWidth } = column;
      const { rotatedHeight, rotatedWidth } = getRotateOffsetAndFarthestHypotenuse(lines, columnWidth, angle);
      allRotatedHeight += rotatedHeight;
      widthArray.push({ rotatedWidth, spaceWidth });
    });
    const widthCount = widthArray.length;
    for (let i = 0; i < widthCount; i++) {
      const { rotatedWidth } = widthArray[i];
      if (i === 0) {
        allRotatedWidth += rotatedWidth;
      }
    }
    return {
      width: allRotatedWidth,
      height: allRotatedHeight
    };
  }
  var DEFAULT_PADDING_DATA = {
    t: 0,
    b: 0,
    l: 2,
    r: 2
  };
  var RENDER_RAW_FORMULA_KEY = "RENDER_RAW_FORMULA";
  var SpreadsheetSkeleton = class extends Skeleton {
    constructor(_worksheet, _config, _cellData, _styles, _localeService, _contextService) {
      super(_localeService);
      this._worksheet = _worksheet;
      this._config = _config;
      this._cellData = _cellData;
      this._styles = _styles;
      this._contextService = _contextService;
      __publicField(this, "_rowHeightAccumulation", []);
      __publicField(this, "_columnWidthAccumulation", []);
      __publicField(this, "_rowTotalHeight", 0);
      __publicField(this, "_columnTotalWidth", 0);
      __publicField(this, "_rowHeaderWidth", 0);
      __publicField(this, "_columnHeaderHeight", 0);
      __publicField(this, "_rowColumnSegment", {
        startRow: -1,
        endRow: -1,
        startColumn: -1,
        endColumn: -1
      });
      __publicField(this, "_dataMergeCache", []);
      __publicField(this, "_overflowCache", new ObjectMatrix());
      __publicField(this, "_stylesCache", {
        background: {},
        backgroundPositions: new ObjectMatrix(),
        font: {},
        border: new ObjectMatrix()
      });
      /** A matrix to store if a (row, column) position has render cache. */
      __publicField(this, "_renderedCellCache", new ObjectMatrix());
      __publicField(this, "_showGridlines", 1 /* TRUE */);
      __publicField(this, "_marginTop", 0);
      __publicField(this, "_marginLeft", 0);
      __publicField(this, "_renderRawFormula", false);
      this._updateLayout();
      this._initContextListener();
    }
    get rowHeightAccumulation() {
      return this._rowHeightAccumulation;
    }
    get rowTotalHeight() {
      return this._rowTotalHeight;
    }
    get columnWidthAccumulation() {
      return this._columnWidthAccumulation;
    }
    get columnTotalWidth() {
      return this._columnTotalWidth;
    }
    get rowHeaderWidth() {
      return this._rowHeaderWidth;
    }
    get columnHeaderHeight() {
      return this._columnHeaderHeight;
    }
    get rowColumnSegment() {
      return this._rowColumnSegment;
    }
    get dataMergeCache() {
      return this._dataMergeCache;
    }
    get stylesCache() {
      return this._stylesCache;
    }
    get overflowCache() {
      return this._overflowCache;
    }
    get showGridlines() {
      return this._showGridlines;
    }
    get mergeData() {
      return this._config.mergeData;
    }
    get rowHeaderWidthAndMarginLeft() {
      return this.rowHeaderWidth + this._marginLeft;
    }
    get columnHeaderHeightAndMarginTop() {
      return this.columnHeaderHeight + this._marginTop;
    }
    get worksheet() {
      return this._worksheet;
    }
    // get dataMergeCacheAll() {
    //     return this._dataMergeCacheAll;
    // }
    /**
     * @deprecated
     */
    static create(worksheet, config2, cellData, styles, localeService, contextService) {
      return new SpreadsheetSkeleton(worksheet, config2, cellData, styles, localeService, contextService);
    }
    /**
     * @deprecated should never expose a property that is provided by another module!
     */
    getCellData() {
      return this._cellData;
    }
    /**
     * @deprecated should never expose a property that is provided by another module!
     */
    getsStyles() {
      return this._styles;
    }
    _initContextListener() {
      this.disposeWithMe(
        this._contextService.subscribeContextValue$(RENDER_RAW_FORMULA_KEY).pipe(
          startWith(false),
          distinctUntilChanged()
        ).subscribe((renderRaw) => {
          this._renderRawFormula = renderRaw;
          this._resetCache();
          this.makeDirty(true);
        })
      );
    }
    setOverflowCache(value) {
      this._overflowCache = value;
    }
    setMarginLeft(left) {
      this._marginLeft = left;
    }
    setMarginTop(top) {
      this._marginTop = top;
    }
    calculateSegment(bounds) {
      if (!this._config) {
        return;
      }
      this._updateLayout();
      if (!this._rowHeightAccumulation || !this._columnWidthAccumulation) {
        return;
      }
      if (bounds != null) {
        this._rowColumnSegment = this.getRowColumnSegment(bounds);
      }
      return true;
    }
    calculateWithoutClearingCache(bounds) {
      if (!this.calculateSegment(bounds)) {
        return;
      }
      const { mergeData } = this._config;
      this._dataMergeCache = mergeData && this._getMergeCells(mergeData, this._rowColumnSegment);
      this._calculateStylesCache();
      return this;
    }
    calculate(bounds) {
      this._resetCache();
      this.calculateWithoutClearingCache(bounds);
      return this;
    }
    calculateAutoHeightInRange(ranges) {
      var _a2;
      if (!Tools.isArray(ranges)) {
        return [];
      }
      const results = [];
      const { mergeData, rowData } = this._config;
      const rowObjectArray = rowData;
      for (const range of ranges) {
        const { startRow, endRow, startColumn, endColumn } = range;
        for (let rowIndex = startRow; rowIndex <= endRow; rowIndex++) {
          if (results.some(({ row }) => row === rowIndex)) {
            continue;
          }
          if (((_a2 = rowObjectArray[rowIndex]) == null ? void 0 : _a2.ia) === 0 /* FALSE */) {
            continue;
          }
          const hasUnMergedCell = hasUnMergedCellInRow(rowIndex, startColumn, endColumn, mergeData);
          if (hasUnMergedCell) {
            const autoHeight = this._calculateRowAutoHeight(rowIndex);
            results.push({
              row: rowIndex,
              autoHeight
            });
          }
        }
      }
      return results;
    }
    // TODO: auto height
    _calculateRowAutoHeight(rowNum) {
      var _a2, _b2;
      const { columnCount, columnData, mergeData, defaultRowHeight } = this._config;
      const data = columnData;
      let height = defaultRowHeight;
      const worksheet = this._worksheet;
      if (!worksheet) {
        return height;
      }
      for (let i = 0; i < columnCount; i++) {
        const { isMerged, isMergedMainCell } = getCellInfoInMergeData(rowNum, i, mergeData);
        if (isMerged || isMergedMainCell) {
          continue;
        }
        const cell = worksheet.getCell(rowNum, i);
        if (cell == null ? void 0 : cell.interceptorAutoHeight) {
          height = Math.max(height, cell.interceptorAutoHeight);
          continue;
        }
        const modelObject = cell && this._getCellDocumentModel(cell);
        if (modelObject == null) {
          continue;
        }
        const { documentModel, textRotation, wrapStrategy, paddingData } = modelObject;
        if (documentModel == null) {
          continue;
        }
        const documentViewModel = new DocumentViewModel(documentModel);
        const { vertexAngle: angle } = convertTextRotation(textRotation);
        const colWidth = (_a2 = data[i]) == null ? void 0 : _a2.w;
        if (typeof colWidth === "number" && wrapStrategy === 3 /* WRAP */) {
          documentModel.updateDocumentDataPageSize(colWidth);
        }
        const documentSkeleton = DocumentSkeleton.create(documentViewModel, this._localService);
        documentSkeleton.calculate();
        let { height: h = 0 } = (_b2 = getDocsSkeletonPageSize(documentSkeleton, angle)) != null ? _b2 : {};
        if (documentSkeleton) {
          const skeletonData = documentSkeleton.getSkeletonData();
          const {
            marginTop: t,
            marginBottom: b,
            marginLeft: l,
            marginRight: r
          } = skeletonData.pages[skeletonData.pages.length - 1];
          const absAngleInRad = Math.abs(degToRad(angle));
          h += t * Math.cos(absAngleInRad) + r * Math.sin(absAngleInRad) + b * Math.cos(absAngleInRad) + l * Math.sin(absAngleInRad);
        }
        height = Math.max(height, h);
      }
      return Math.min(height, MAXIMUM_ROW_HEIGHT2);
    }
    _updateLayout() {
      if (!this.dirty) {
        return;
      }
      const {
        rowData,
        columnData,
        defaultRowHeight,
        defaultColumnWidth,
        rowCount,
        columnCount,
        rowHeader,
        columnHeader,
        showGridlines
      } = this._config;
      const { rowTotalHeight, rowHeightAccumulation } = this._generateRowMatrixCache(
        rowCount,
        rowData,
        defaultRowHeight
      );
      const { columnTotalWidth, columnWidthAccumulation } = this._generateColumnMatrixCache(
        columnCount,
        columnData,
        defaultColumnWidth
      );
      this._rowHeaderWidth = rowHeader.hidden !== 1 /* TRUE */ ? this._dynamicallyUpdateRowHeaderWidth(rowHeader) : 0;
      this._columnHeaderHeight = columnHeader.hidden !== 1 /* TRUE */ ? columnHeader.height : 0;
      this._rowTotalHeight = rowTotalHeight;
      this._rowHeightAccumulation = rowHeightAccumulation;
      this._columnTotalWidth = columnTotalWidth;
      this._columnWidthAccumulation = columnWidthAccumulation;
      this._showGridlines = showGridlines;
      this.makeDirty(false);
      return this;
    }
    _dynamicallyUpdateRowHeaderWidth(rowHeader) {
      var _a2;
      const SIZE_BY_EACH_CHARACTER = 8;
      const widthByComputation = `${(_a2 = this._worksheet) == null ? void 0 : _a2.getRowCount()}`.length * SIZE_BY_EACH_CHARACTER;
      return Math.max(rowHeader.width, widthByComputation);
    }
    getRowColumnSegment(bounds) {
      return this._getBounding(this._rowHeightAccumulation, this._columnWidthAccumulation, bounds == null ? void 0 : bounds.viewBound);
    }
    /**
     * @deprecated should never expose a property that is provided by another module!
     * @returns
     */
    getWorksheetConfig() {
      return this._config;
    }
    getRowColumnSegmentByViewBound(bound) {
      return this._getBounding(this._rowHeightAccumulation, this._columnWidthAccumulation, bound);
    }
    getMergeBounding(startRow, startColumn, endRow, endColumn) {
      const mergeData = this._config.mergeData;
      if (!mergeData) {
        return {
          startRow,
          startColumn,
          endRow,
          endColumn
        };
      }
      let isSearching = true;
      const searchedMarge = new ObjectMatrix();
      while (isSearching) {
        isSearching = false;
        for (let i = 0; i < mergeData.length; i++) {
          const {
            startRow: mainStartRow,
            startColumn: mainStartColumn,
            endRow: mainEndRow,
            endColumn: mainEndColumn
          } = mergeData[i];
          if (searchedMarge.getValue(mainStartRow, mainStartColumn)) {
            continue;
          }
          const rect1 = {
            left: startColumn,
            top: startRow,
            right: endColumn,
            bottom: endRow
          };
          const rect2 = {
            left: mainStartColumn,
            top: mainStartRow,
            right: mainEndColumn,
            bottom: mainEndRow
          };
          if (isRectIntersect(rect1, rect2)) {
            startRow = Math.min(startRow, mainStartRow);
            startColumn = Math.min(startColumn, mainStartColumn);
            endRow = Math.max(endRow, mainEndRow);
            endColumn = Math.max(endColumn, mainEndColumn);
            searchedMarge.setValue(mainStartRow, mainStartColumn, true);
            isSearching = true;
          }
        }
      }
      return {
        startRow,
        startColumn,
        endRow,
        endColumn
      };
    }
    appendToOverflowCache(row, column, startColumn, endColumn) {
      this._overflowCache.setValue(row, column, {
        startRow: row,
        endRow: row,
        startColumn,
        endColumn
      });
    }
    getColumnCount() {
      return this._columnWidthAccumulation.length;
    }
    getRowCount() {
      return this._rowHeightAccumulation.length;
    }
    getOverflowPosition(contentSize, horizontalAlign, row, column, columnCount) {
      const { width: contentWidth } = contentSize;
      let startColumn = column;
      let endColumn = column;
      if (horizontalAlign === 2 /* CENTER */) {
        startColumn = this._getOverflowBound(row, column, 0, contentWidth / 2, horizontalAlign);
        endColumn = this._getOverflowBound(row, column, columnCount - 1, contentWidth / 2, horizontalAlign);
      } else if (horizontalAlign === 3 /* RIGHT */) {
        startColumn = this._getOverflowBound(row, column, 0, contentWidth);
      } else {
        endColumn = this._getOverflowBound(row, column, columnCount - 1, contentWidth);
      }
      return {
        startColumn,
        endColumn
      };
    }
    getNoMergeCellPositionByIndex(rowIndex, columnIndex) {
      const {
        rowHeightAccumulation,
        columnWidthAccumulation,
        rowHeaderWidthAndMarginLeft,
        columnHeaderHeightAndMarginTop
      } = this;
      let { startY, endY, startX, endX } = getCellPositionByIndex(
        rowIndex,
        columnIndex,
        rowHeightAccumulation,
        columnWidthAccumulation
      );
      startY += columnHeaderHeightAndMarginTop;
      endY += columnHeaderHeightAndMarginTop;
      startX += rowHeaderWidthAndMarginLeft;
      endX += rowHeaderWidthAndMarginLeft;
      return {
        startY,
        endY,
        startX,
        endX
      };
    }
    getNoMergeCellPositionByIndexWithNoHeader(rowIndex, columnIndex) {
      const { rowHeightAccumulation, columnWidthAccumulation } = this;
      const { startY, endY, startX, endX } = getCellPositionByIndex(
        rowIndex,
        columnIndex,
        rowHeightAccumulation,
        columnWidthAccumulation
      );
      return {
        startY,
        endY,
        startX,
        endX
      };
    }
    /**
     *
     * @param offsetX HTML coordinate system, mouse position x.
     * @param offsetY HTML coordinate system, mouse position y.
     * @param scaleX render scene scale x-axis, scene.getAncestorScale
     * @param scaleY render scene scale y-axis, scene.getAncestorScale
     * @param scrollXY render viewport scroll {x, y}, scene.getScrollXYByRelativeCoords, scene.getScrollXY
     * @param scrollXY.x
     * @param scrollXY.y
     * @returns Selection data with coordinates
     */
    calculateCellIndexByPosition(offsetX, offsetY, scaleX, scaleY, scrollXY) {
      const { row, column } = this.getCellPositionByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY);
      return this.getCellByIndex(row, column);
    }
    /**
     *
     * @param offsetX HTML coordinate system, mouse position x.
     * @param offsetY HTML coordinate system, mouse position y.
     * @param scaleX render scene scale x-axis, scene.getAncestorScale
     * @param scaleY render scene scale y-axis, scene.getAncestorScale
     * @param scrollXY  render viewport scroll {x, y}, scene.getScrollXYByRelativeCoords, scene.getScrollXY
     * @param scrollXY.x
     * @param scrollXY.y
     * @returns Hit cell coordinates
     */
    getCellPositionByOffset(offsetX, offsetY, scaleX, scaleY, scrollXY) {
      const row = this.getRowPositionByOffsetY(offsetY, scaleY, scrollXY);
      const column = this.getColumnPositionByOffsetX(offsetX, scaleX, scrollXY);
      return {
        row,
        column
      };
    }
    /**
     *
     * @param offsetX scaled offset x
     * @param scaleX scale x
     * @param scrollXY
     * @returns
     */
    getColumnPositionByOffsetX(offsetX, scaleX, scrollXY) {
      offsetX = this.getTransformOffsetX(offsetX, scaleX, scrollXY);
      const { columnWidthAccumulation } = this;
      let column = searchArray(columnWidthAccumulation, offsetX);
      if (column === Number.POSITIVE_INFINITY) {
        column = columnWidthAccumulation.length - 1;
      } else if (column === -1) {
        column = 0;
      }
      return column;
    }
    /**
     *
     * @param offsetY scaled offset y
     * @param scaleY scale y
     * @param scrollXY
     * @param scrollXY.x
     * @param scrollXY.y
     */
    getRowPositionByOffsetY(offsetY, scaleY, scrollXY) {
      const { rowHeightAccumulation } = this;
      offsetY = this.getTransformOffsetY(offsetY, scaleY, scrollXY);
      let row = searchArray(rowHeightAccumulation, offsetY);
      if (row === Number.POSITIVE_INFINITY) {
        row = rowHeightAccumulation.length - 1;
      } else if (row === -1) {
        row = 0;
      }
      return row;
    }
    getTransformOffsetX(offsetX, scaleX, scrollXY) {
      const { x: scrollX2 } = scrollXY;
      offsetX = offsetX / scaleX + scrollX2 - this.rowHeaderWidthAndMarginLeft;
      return offsetX;
    }
    getTransformOffsetY(offsetY, scaleY, scrollXY) {
      const { y: scrollY2 } = scrollXY;
      offsetY = offsetY / scaleY + scrollY2 - this.columnHeaderHeightAndMarginTop;
      return offsetY;
    }
    getOffsetByPositionX(column) {
      const { columnWidthAccumulation, rowHeaderWidthAndMarginLeft } = this;
      const lastColumnIndex = columnWidthAccumulation.length - 1;
      const columnValue = columnWidthAccumulation[column];
      if (columnValue != null) {
        return columnValue + rowHeaderWidthAndMarginLeft;
      }
      if (column < 0) {
        return rowHeaderWidthAndMarginLeft;
      }
      return columnWidthAccumulation[lastColumnIndex] + rowHeaderWidthAndMarginLeft;
    }
    getOffsetByPositionY(row) {
      const { rowHeightAccumulation, columnHeaderHeightAndMarginTop } = this;
      const lastRowIndex = rowHeightAccumulation.length - 1;
      const rowValue = rowHeightAccumulation[row];
      if (rowValue != null) {
        return rowValue + columnHeaderHeightAndMarginTop;
      }
      if (row < 0) {
        return columnHeaderHeightAndMarginTop;
      }
      return rowHeightAccumulation[lastRowIndex] + columnHeaderHeightAndMarginTop;
    }
    /**
     * Return cell information corresponding to the current coordinates, including the merged cell object.
     * @param row Specified Row Coordinate
     * @param column Specified Column Coordinate
     */
    getCellByIndex(row, column) {
      const {
        rowHeightAccumulation,
        columnWidthAccumulation,
        rowHeaderWidthAndMarginLeft,
        columnHeaderHeightAndMarginTop
      } = this;
      const primary = getCellByIndex(
        row,
        column,
        rowHeightAccumulation,
        columnWidthAccumulation,
        this._config.mergeData
      );
      const { isMerged, isMergedMainCell } = primary;
      let { startY, endY, startX, endX, mergeInfo } = primary;
      startY += columnHeaderHeightAndMarginTop;
      endY += columnHeaderHeightAndMarginTop;
      startX += rowHeaderWidthAndMarginLeft;
      endX += rowHeaderWidthAndMarginLeft;
      mergeInfo = mergeInfoOffset(mergeInfo, rowHeaderWidthAndMarginLeft, columnHeaderHeightAndMarginTop);
      return {
        actualRow: row,
        actualColumn: column,
        startY,
        endY,
        startX,
        endX,
        isMerged,
        isMergedMainCell,
        mergeInfo
      };
    }
    getCellByIndexWithNoHeader(row, column) {
      const { rowHeightAccumulation, columnWidthAccumulation } = this;
      const primary = getCellByIndex(
        row,
        column,
        rowHeightAccumulation,
        columnWidthAccumulation,
        this._config.mergeData
      );
      const { isMerged, isMergedMainCell } = primary;
      const { startY, endY, startX, endX, mergeInfo } = primary;
      const newMergeInfo = mergeInfoOffset(mergeInfo, 0, 0);
      return {
        actualRow: row,
        actualColumn: column,
        startY,
        endY,
        startX,
        endX,
        isMerged,
        isMergedMainCell,
        mergeInfo: newMergeInfo
      };
    }
    // convert canvas content position to physical position in screen
    convertTransformToOffsetX(offsetX, scaleX, scrollXY) {
      const { x: scrollX2 } = scrollXY;
      offsetX = (offsetX - scrollX2) * scaleX;
      return offsetX;
    }
    // convert canvas content position to physical position in screen
    convertTransformToOffsetY(offsetY, scaleY, scrollXY) {
      const { y: scrollY2 } = scrollXY;
      offsetY = (offsetY - scrollY2) * scaleY;
      return offsetY;
    }
    getSelectionBounding(startRow, startColumn, endRow, endColumn) {
      return this.getMergeBounding(startRow, startColumn, endRow, endColumn);
    }
    // Only used for cell edit, and no need to rotate text when edit cell content!
    getBlankCellDocumentModel(cell) {
      const documentModelObject = this._getCellDocumentModel(cell, void 0, void 0, true);
      if (documentModelObject != null) {
        if (documentModelObject.documentModel == null) {
          documentModelObject.documentModel = this._getDocumentDataByStyle("", {}, {});
        }
        return documentModelObject;
      }
      const content = "";
      let fontString = "document";
      const textRotation = { a: 0, v: 0 /* FALSE */ };
      const horizontalAlign = 0 /* UNSPECIFIED */;
      const verticalAlign = 0 /* UNSPECIFIED */;
      const wrapStrategy = 0 /* UNSPECIFIED */;
      const paddingData = DEFAULT_PADDING_DATA;
      fontString = getFontStyleString({}, this._localService).fontCache;
      const documentModel = this._getDocumentDataByStyle(content, {}, {});
      return {
        documentModel,
        fontString,
        textRotation,
        wrapStrategy,
        verticalAlign,
        horizontalAlign,
        paddingData
      };
    }
    // Only used for cell edit, and no need to rotate text when edit cell content!
    getCellDocumentModelWithFormula(cell) {
      return this._getCellDocumentModel(cell, true, true, true);
    }
    _getCellDocumentModel(cell, isDeepClone = false, displayRawFormula = false, ignoreTextRotation = false) {
      var _a2;
      const style = this._styles.getStyleByCell(cell);
      if (!cell) {
        return;
      }
      let documentModel;
      let fontString = "document";
      const cellOtherConfig = this._getOtherStyle(style);
      const textRotation = ignoreTextRotation ? { a: 0, v: 0 /* FALSE */ } : cellOtherConfig.textRotation || { a: 0, v: 0 /* FALSE */ };
      let horizontalAlign = cellOtherConfig.horizontalAlign || 0 /* UNSPECIFIED */;
      const verticalAlign = cellOtherConfig.verticalAlign || 0 /* UNSPECIFIED */;
      const wrapStrategy = cellOtherConfig.wrapStrategy || 0 /* UNSPECIFIED */;
      const paddingData = cellOtherConfig.paddingData || DEFAULT_PADDING_DATA;
      if (cell.f && displayRawFormula) {
        documentModel = this._getDocumentDataByStyle(cell.f.toString(), {}, { verticalAlign });
        horizontalAlign = 0 /* UNSPECIFIED */;
      } else if (cell.p) {
        const { centerAngle, vertexAngle } = convertTextRotation(textRotation);
        documentModel = this._updateConfigAndGetDocumentModel(
          isDeepClone ? Tools.deepClone(cell.p) : cell.p,
          horizontalAlign,
          {
            horizontalAlign,
            verticalAlign,
            centerAngle,
            vertexAngle,
            wrapStrategy
          }
        );
      } else if (cell.v != null) {
        const textStyle = this._getFontFormat(style);
        fontString = getFontStyleString(textStyle, this._localService).fontCache;
        documentModel = this._getDocumentDataByStyle(extractPureTextFromCell(cell), textStyle, {
          ...cellOtherConfig,
          textRotation,
          cellValueType: cell.t
        });
      }
      return {
        documentModel,
        fontString,
        textRotation,
        wrapStrategy,
        verticalAlign,
        horizontalAlign,
        paddingData,
        fill: (_a2 = style == null ? void 0 : style.bg) == null ? void 0 : _a2.rgb
      };
    }
    getDecomposedOffset(offsetX, offsetY) {
      let column = searchArray(this._columnWidthAccumulation, offsetX);
      let columnOffset = 0;
      if (column === -1 || column === 0) {
        column = 0;
        columnOffset = offsetX;
      } else {
        columnOffset = offsetX - this._columnWidthAccumulation[column - 1];
      }
      let row = searchArray(this._rowHeightAccumulation, offsetY);
      let rowOffset = 0;
      if (row === -1 || row === 0) {
        row = 0;
        rowOffset = offsetY;
      } else {
        rowOffset = offsetY - this._rowHeightAccumulation[row - 1];
      }
      return {
        row,
        column,
        columnOffset,
        rowOffset
      };
    }
    /**
     * Calculate the overflow of cell text. If there is no value on either side of the cell,
     * the text content of this cell can be drawn to both sides, not limited by the cell's width.
     * Overflow on the left or right is aligned according to the text's horizontal alignment.
     */
    _calculateOverflowCell(row, column, docsConfig) {
      const { documentSkeleton, vertexAngle = 0, centerAngle = 0, horizontalAlign, wrapStrategy } = docsConfig;
      const cell = this._cellData.getValue(row, column);
      const { t: cellValueType = 1 /* STRING */ } = cell || {};
      let horizontalAlignPos = horizontalAlign;
      if (horizontalAlign === 0 /* UNSPECIFIED */) {
        if (centerAngle === VERTICAL_ROTATE_ANGLE && vertexAngle === VERTICAL_ROTATE_ANGLE) {
          horizontalAlignPos = 2 /* CENTER */;
        } else if (vertexAngle > 0 && vertexAngle !== VERTICAL_ROTATE_ANGLE || vertexAngle === -VERTICAL_ROTATE_ANGLE) {
          horizontalAlignPos = 3 /* RIGHT */;
        }
      }
      if ((wrapStrategy === 1 /* OVERFLOW */ || wrapStrategy === 0 /* UNSPECIFIED */) && cellValueType !== 2 /* NUMBER */ && cellValueType !== 3 /* BOOLEAN */ && horizontalAlign !== 4 /* JUSTIFIED */) {
        if (this.intersectMergeRange(row, column)) {
          return true;
        }
        let contentSize = getDocsSkeletonPageSize(documentSkeleton, vertexAngle);
        if (!contentSize) {
          return true;
        }
        if (vertexAngle !== 0) {
          const { startY, endY, startX, endX } = getCellByIndex(
            row,
            column,
            this.rowHeightAccumulation,
            this.columnWidthAccumulation,
            this.mergeData
          );
          const cellWidth = endX - startX;
          const cellHeight = endY - startY;
          if (contentSize.height > cellHeight) {
            contentSize = {
              width: cellHeight / Math.tan(Math.abs(vertexAngle)) + cellWidth,
              height: cellHeight
            };
          }
        }
        const position = this.getOverflowPosition(contentSize, horizontalAlignPos, row, column, this.getColumnCount());
        const { startColumn, endColumn } = position;
        if (startColumn === endColumn) {
          return true;
        }
        this.appendToOverflowCache(row, column, startColumn, endColumn);
      } else if (wrapStrategy === 3 /* WRAP */ && vertexAngle !== 0) {
        if (this.intersectMergeRange(row, column)) {
          return true;
        }
        const { startY, endY } = getCellByIndex(
          row,
          column,
          this.rowHeightAccumulation,
          this.columnWidthAccumulation,
          this.mergeData
        );
        const cellHeight = endY - startY;
        documentSkeleton.getViewModel().getDataModel().updateDocumentDataPageSize(cellHeight);
        documentSkeleton.calculate();
        const contentSize = getDocsSkeletonPageSize(documentSkeleton, vertexAngle);
        if (!contentSize) {
          return true;
        }
        const { startColumn, endColumn } = this.getOverflowPosition(
          contentSize,
          horizontalAlignPos,
          row,
          column,
          this.getColumnCount()
        );
        if (startColumn === endColumn) {
          return true;
        }
        this.appendToOverflowCache(row, column, startColumn, endColumn);
      }
    }
    /**
     *
     * @param rowHeightAccumulation Row layout information
     * @param columnWidthAccumulation Column layout information
     * @param viewBound The range of the visible area of the canvas
     * @returns The range cell index of the canvas visible area
     */
    _getBounding(rowHeightAccumulation, columnWidthAccumulation, viewBound) {
      const rhaLength = rowHeightAccumulation.length;
      const cwaLength = columnWidthAccumulation.length;
      if (!viewBound) {
        return {
          startRow: 0,
          endRow: rhaLength - 1,
          startColumn: 0,
          endColumn: cwaLength - 1
        };
      }
      let dataset_row_st = -1;
      let dataset_row_ed = -1;
      let dataset_col_st = -1;
      let dataset_col_ed = -1;
      const row_st = searchArray(rowHeightAccumulation, Math.round(viewBound.top) - this.columnHeaderHeightAndMarginTop);
      const row_ed = searchArray(rowHeightAccumulation, Math.round(viewBound.bottom) - this.columnHeaderHeightAndMarginTop);
      if (row_st === -1 && row_ed === 0) {
        dataset_row_st = -1;
        dataset_row_ed = -1;
      } else {
        if (row_st === -1) {
          dataset_row_st = 0;
        } else {
          dataset_row_st = row_st;
        }
        if (row_ed === Number.POSITIVE_INFINITY) {
          dataset_row_ed = rhaLength - 1;
        } else if (row_ed >= rhaLength) {
          dataset_row_ed = rhaLength - 1;
        } else {
          dataset_row_ed = row_ed;
        }
      }
      const col_st = searchArray(columnWidthAccumulation, Math.round(viewBound.left) - this.rowHeaderWidthAndMarginLeft);
      const col_ed = searchArray(columnWidthAccumulation, Math.round(viewBound.right) - this.rowHeaderWidthAndMarginLeft);
      if (col_st === -1 && col_ed === 0) {
        dataset_col_st = -1;
        dataset_col_ed = -1;
      } else {
        if (col_st === -1) {
          dataset_col_st = 0;
        } else {
          dataset_col_st = col_st;
        }
        if (col_ed === Number.POSITIVE_INFINITY) {
          dataset_col_ed = cwaLength - 1;
        } else if (col_ed >= cwaLength) {
          dataset_col_ed = cwaLength - 1;
        } else {
          dataset_col_ed = col_ed;
        }
      }
      return {
        startRow: dataset_row_st,
        endRow: dataset_row_ed,
        startColumn: dataset_col_st,
        endColumn: dataset_col_ed
      };
    }
    _generateRowMatrixCache(rowCount, rowData, defaultRowHeight) {
      let rowTotalHeight = 0;
      const rowHeightAccumulation = [];
      const data = rowData;
      for (let r = 0; r < rowCount; r++) {
        let rowHeight = defaultRowHeight;
        if (data[r] != null) {
          const rowDataItem = data[r];
          if (!rowDataItem) {
            continue;
          }
          const { h = defaultRowHeight, ah, ia } = rowDataItem;
          if ((ia == null || ia === 1 /* TRUE */) && typeof ah === "number") {
            rowHeight = ah;
          } else {
            rowHeight = h;
          }
          if (rowDataItem.hd === 1 /* TRUE */) {
            rowHeight = 0;
          }
        }
        rowTotalHeight += rowHeight;
        rowHeightAccumulation.push(rowTotalHeight);
      }
      return {
        rowTotalHeight,
        rowHeightAccumulation
      };
    }
    _generateColumnMatrixCache(colCount, columnData, defaultColumnWidth) {
      let columnTotalWidth = 0;
      const columnWidthAccumulation = [];
      const data = columnData;
      for (let c = 0; c < colCount; c++) {
        let columnWidth = defaultColumnWidth;
        if (data[c] != null) {
          const columnDataItem = data[c];
          if (!columnDataItem) {
            continue;
          }
          if (columnDataItem.w != null) {
            columnWidth = columnDataItem.w;
          }
          if (columnDataItem.hd === 1 /* TRUE */) {
            columnWidth = 0;
          }
        }
        columnTotalWidth += columnWidth;
        columnWidthAccumulation.push(columnTotalWidth);
      }
      return {
        columnTotalWidth,
        columnWidthAccumulation
      };
    }
    _getOverflowBound(row, startColumn, endColumn, contentWidth, horizontalAlign = 1 /* LEFT */) {
      var _a2, _b2;
      let cumWidth = 0;
      if (startColumn > endColumn) {
        const columnCount = this._columnWidthAccumulation.length - 1;
        for (let i = startColumn; i >= endColumn; i--) {
          const column = i;
          const cell = (_a2 = this._worksheet) == null ? void 0 : _a2.getCell(row, column);
          if (!isEmptyCell(cell) && column !== startColumn || this.intersectMergeRange(row, column)) {
            if (column === startColumn) {
              return column;
            }
            return column + 1 > columnCount ? columnCount : column + 1;
          }
          const { startX, endX } = getCellPositionByIndex(
            row,
            column,
            this.rowHeightAccumulation,
            this.columnWidthAccumulation
          );
          if (horizontalAlign === 2 /* CENTER */ && column === startColumn) {
            cumWidth += (endX - startX) / 2;
          } else {
            cumWidth += endX - startX;
          }
          if (contentWidth < cumWidth) {
            return column;
          }
        }
        return startColumn;
      }
      for (let i = startColumn; i <= endColumn; i++) {
        const column = i;
        const cell = (_b2 = this._worksheet) == null ? void 0 : _b2.getCell(row, column);
        if (!isEmptyCell(cell) && column !== startColumn || this.intersectMergeRange(row, column)) {
          if (column === startColumn) {
            return column;
          }
          return column - 1 < 0 ? 0 : column - 1;
        }
        const { startX, endX } = getCellPositionByIndex(
          row,
          column,
          this.rowHeightAccumulation,
          this.columnWidthAccumulation
        );
        if (horizontalAlign === 2 /* CENTER */ && column === startColumn) {
          cumWidth += (endX - startX) / 2;
        } else {
          cumWidth += endX - startX;
        }
        if (contentWidth < cumWidth) {
          return column;
        }
      }
      return endColumn;
    }
    intersectMergeRange(row, column) {
      const dataMergeCache = this.dataMergeCache;
      for (const dataCache of dataMergeCache) {
        const {
          startRow: startRowMargeIndex,
          endRow: endRowMargeIndex,
          startColumn: startColumnMargeIndex,
          endColumn: endColumnMargeIndex
        } = dataCache;
        if (row >= startRowMargeIndex && row <= endRowMargeIndex && column >= startColumnMargeIndex && column <= endColumnMargeIndex) {
          return true;
        }
      }
      return false;
    }
    // private _getMergeRangeCache() {
    //     const dataMergeCache = this.dataMergeCache;
    //     const mergeRangeCache = new ObjectMatrix<ObjectMatrix<boolean>>();
    //     dataMergeCache?.forEach((r, dataMergeRow) => {
    //         dataMergeRow?.forEach((c, dataCache) => {
    //             const { startRow: startRowMargeIndex, endRow: endRowMargeIndex, startColumn: startColumnMargeIndex, endColumn: endColumnMargeIndex } = dataCache;
    //             const endObject = new ObjectMatrix<boolean>();
    //             endObject.setValue(endRowMargeIndex, endColumnMargeIndex, true);
    //             mergeRangeCache.setValue(startRowMargeIndex, startColumnMargeIndex, endObject);
    //         });
    //     });
    //     return mergeRangeCache;
    // }
    _calculateStylesCache() {
      const dataMergeCache = this._dataMergeCache;
      const rowColumnSegment = this._rowColumnSegment;
      const columnWidthAccumulation = this.columnWidthAccumulation;
      const { startRow, endRow, startColumn, endColumn } = rowColumnSegment;
      if (endColumn === -1 || endRow === -1) {
        return;
      }
      for (const data of dataMergeCache) {
        this._setCellCache(data.startRow, data.startColumn, false, data);
      }
      for (let r = startRow; r <= endRow; r++) {
        for (let c = startColumn; c <= endColumn; c++) {
          this._setCellCache(r, c, false);
        }
        for (let c = 0; c < startColumn; c++) {
          this._setCellCache(r, c, true);
        }
        if (endColumn === 0) {
          continue;
        }
        for (let c = endColumn + 1; c < columnWidthAccumulation.length; c++) {
          this._setCellCache(r, c, true);
        }
      }
    }
    _resetCache() {
      this._stylesCache = {
        background: {},
        backgroundPositions: new ObjectMatrix(),
        font: {},
        border: new ObjectMatrix()
      };
      this._renderedCellCache = new ObjectMatrix();
      this._overflowCache.reset();
    }
    _makeDocumentSkeletonDirty(r, c) {
      if (this._stylesCache.font == null) {
        return;
      }
      const keys = Object.keys(this._stylesCache.font);
      for (const fontString of keys) {
        const fontCache = this._stylesCache.font[fontString];
        if (fontCache != null && fontCache.getValue(r, c)) {
          fontCache.getValue(r, c).documentSkeleton.makeDirty(true);
          return;
        }
      }
    }
    _setCellCache(r, c, skipBackgroundAndBorder, mergeRange) {
      var _a2;
      const needsRendering = this._renderedCellCache.getValue(r, c);
      if (r === -1 || c === -1) {
        return true;
      }
      if (needsRendering === false) {
        this._makeDocumentSkeletonDirty(r, c);
        return true;
      }
      if (!this._worksheet) {
        return true;
      }
      const cell = this._worksheet.getCell(r, c) || this._worksheet.getCellRaw(r, c);
      if (!cell) {
        return true;
      }
      const hidden = this._worksheet.getColVisible(c) === false || this._worksheet.getRowVisible(r) === false;
      if (hidden) {
        const { isMerged, isMergedMainCell } = getCellInfoInMergeData(
          r,
          c,
          this._dataMergeCache
        );
        if (isMerged && !isMergedMainCell) {
          return true;
        } else if (!isMergedMainCell) {
          return true;
        }
      }
      const cache = this._stylesCache;
      const style = this._styles.getStyleByCell(cell);
      if (!skipBackgroundAndBorder && style && style.bg && style.bg.rgb) {
        const rgb = style.bg.rgb;
        if (!cache.background[rgb]) {
          cache.background[rgb] = new ObjectMatrix();
        }
        const bgCache = cache.background[rgb];
        bgCache.setValue(r, c, rgb);
        const cellInfo = this.getCellByIndexWithNoHeader(r, c);
        (_a2 = cache.backgroundPositions) == null ? void 0 : _a2.setValue(r, c, cellInfo);
      }
      if (!skipBackgroundAndBorder && style && style.bd) {
        if (mergeRange) {
          this._setMergeBorderProps("t" /* TOP */, cache, mergeRange);
          this._setMergeBorderProps("b" /* BOTTOM */, cache, mergeRange);
          this._setMergeBorderProps("l" /* LEFT */, cache, mergeRange);
          this._setMergeBorderProps("r" /* RIGHT */, cache, mergeRange);
        } else if (!this.intersectMergeRange(r, c)) {
          this._setBorderProps(r, c, "t" /* TOP */, style, cache);
          this._setBorderProps(r, c, "b" /* BOTTOM */, style, cache);
          this._setBorderProps(r, c, "l" /* LEFT */, style, cache);
          this._setBorderProps(r, c, "r" /* RIGHT */, style, cache);
        }
        this._setBorderProps(r, c, "tl_br" /* TL_BR */, style, cache);
        this._setBorderProps(r, c, "tl_bc" /* TL_BC */, style, cache);
        this._setBorderProps(r, c, "tl_mr" /* TL_MR */, style, cache);
        this._setBorderProps(r, c, "bl_tr" /* BL_TR */, style, cache);
        this._setBorderProps(r, c, "ml_tr" /* ML_TR */, style, cache);
        this._setBorderProps(r, c, "bc_tr" /* BC_TR */, style, cache);
      }
      if (needsRendering === true) {
        this._makeDocumentSkeletonDirty(r, c);
        return true;
      }
      if (isNullCell(cell)) {
        return;
      }
      const modelObject = cell && this._getCellDocumentModel(cell, void 0, this._renderRawFormula);
      if (modelObject == null) {
        return;
      }
      const { documentModel } = modelObject;
      if (documentModel == null) {
        return;
      }
      const { fontString, textRotation, wrapStrategy, verticalAlign, horizontalAlign } = modelObject;
      const documentViewModel = new DocumentViewModel(documentModel);
      if (!cache.font[fontString]) {
        cache.font[fontString] = new ObjectMatrix();
      }
      const fontCache = cache.font[fontString];
      const { vertexAngle, centerAngle } = convertTextRotation(textRotation);
      if (documentViewModel) {
        const documentSkeleton = DocumentSkeleton.create(documentViewModel, this._localService);
        documentSkeleton.calculate();
        const config2 = {
          documentSkeleton,
          vertexAngle,
          centerAngle,
          verticalAlign,
          horizontalAlign,
          wrapStrategy
        };
        fontCache.setValue(r, c, config2);
        this._calculateOverflowCell(r, c, config2);
      }
      if (!skipBackgroundAndBorder) {
        this._renderedCellCache.setValue(r, c, false);
      } else {
        this._renderedCellCache.setValue(r, c, true);
      }
    }
    _updateConfigAndGetDocumentModel(documentData, horizontalAlign, renderConfig) {
      var _a2;
      if (!renderConfig) {
        return;
      }
      if (!((_a2 = documentData.body) == null ? void 0 : _a2.dataStream)) {
        return;
      }
      if (!documentData.documentStyle) {
        documentData.documentStyle = {};
      }
      documentData.documentStyle.renderConfig = renderConfig;
      const paragraphs = documentData.body.paragraphs || [];
      for (const paragraph of paragraphs) {
        if (!paragraph.paragraphStyle) {
          paragraph.paragraphStyle = {};
        }
        paragraph.paragraphStyle.horizontalAlign = horizontalAlign;
      }
      return new DocumentDataModel(documentData);
    }
    _getDocumentDataByStyle(content, textStyle, config2) {
      const contentLength = content.length;
      const {
        textRotation,
        paddingData = {
          t: 2,
          r: 2,
          b: 0,
          l: 2
        },
        horizontalAlign = 0 /* UNSPECIFIED */,
        verticalAlign = 0 /* UNSPECIFIED */,
        wrapStrategy = 0 /* UNSPECIFIED */,
        cellValueType
      } = config2;
      const { t: marginTop, r: marginRight, b: marginBottom, l: marginLeft } = paddingData || {};
      const { vertexAngle, centerAngle } = convertTextRotation(textRotation);
      const documentData = {
        id: "d",
        body: {
          dataStream: `${content}${DEFAULT_EMPTY_DOCUMENT_VALUE}`,
          textRuns: [
            {
              ts: textStyle,
              st: 0,
              ed: contentLength
            }
          ],
          paragraphs: [
            {
              startIndex: contentLength,
              paragraphStyle: {
                horizontalAlign
              }
            }
          ]
        },
        documentStyle: {
          pageSize: {
            width: Number.POSITIVE_INFINITY,
            height: Number.POSITIVE_INFINITY
          },
          marginTop,
          marginBottom,
          marginRight,
          marginLeft,
          renderConfig: {
            horizontalAlign,
            verticalAlign,
            centerAngle,
            vertexAngle,
            wrapStrategy,
            cellValueType
          }
        }
      };
      return new DocumentDataModel(documentData);
    }
    /**
     * pro/issues/344
     * In Excel, for the border rendering of merged cells to take effect, the outermost cells need to have the same border style.
     */
    _setMergeBorderProps(type, cache, mergeRange) {
      var _a2;
      if (!this._worksheet || !cache.border) {
        return;
      }
      const borders = [];
      let isAddBorders = true;
      let forStart = mergeRange.startRow;
      let forEnd = mergeRange.endRow;
      let row = mergeRange.startRow;
      let column = mergeRange.startColumn;
      if (type === "t" /* TOP */) {
        row = mergeRange.startRow;
        forStart = mergeRange.startColumn;
        forEnd = mergeRange.endColumn;
      } else if (type === "b" /* BOTTOM */) {
        row = mergeRange.endRow;
        forStart = mergeRange.startColumn;
        forEnd = mergeRange.endColumn;
      } else if (type === "l" /* LEFT */) {
        column = mergeRange.startColumn;
        forStart = mergeRange.startRow;
        forEnd = mergeRange.endRow;
      } else if (type === "r" /* RIGHT */) {
        column = mergeRange.endColumn;
        forStart = mergeRange.startRow;
        forEnd = mergeRange.endRow;
      }
      for (let i = forStart; i <= forEnd; i++) {
        if (type === "t" /* TOP */) {
          column = i;
        } else if (type === "b" /* BOTTOM */) {
          column = i;
        } else if (type === "l" /* LEFT */) {
          row = i;
        } else if (type === "r" /* RIGHT */) {
          row = i;
        }
        const cell = this._worksheet.getCell(row, column);
        if (!cell) {
          isAddBorders = false;
          break;
        }
        const style = this._styles.getStyleByCell(cell);
        if (!style) {
          isAddBorders = false;
          break;
        }
        const props = (_a2 = style.bd) == null ? void 0 : _a2[type];
        if (props) {
          const rgb = getColorStyle(props.cl) || COLOR_BLACK_RGB;
          borders.push({
            r: row,
            c: column,
            style: props.s,
            color: rgb
          });
        } else {
          isAddBorders = false;
        }
      }
      if (isAddBorders) {
        borders.forEach((border) => {
          const { r, c, style, color } = border;
          if (!cache.border.getValue(r, c)) {
            cache.border.setValue(r, c, {});
          }
          cache.border.getValue(r, c)[type] = {
            type,
            style,
            color
          };
        });
      }
    }
    _setBorderProps(r, c, type, style, cache) {
      var _a2, _b2, _c;
      const props = (_a2 = style.bd) == null ? void 0 : _a2[type];
      if (!props || !cache.border) {
        return true;
      }
      const rgb = getColorStyle(props.cl) || COLOR_BLACK_RGB;
      const borderCache = cache.border;
      if (!borderCache.getValue(r, c)) {
        borderCache.setValue(r, c, { [type]: {} });
      }
      if (type === "t" /* TOP */) {
        const borderBottom = (_b2 = borderCache.getValue(r - 1, c)) == null ? void 0 : _b2["b" /* BOTTOM */];
        if (borderBottom && isWhiteColor(rgb)) {
          return true;
        }
      } else if (type === "l" /* LEFT */) {
        const borderRight = (_c = borderCache.getValue(r, c - 1)) == null ? void 0 : _c["r" /* RIGHT */];
        if (borderRight && isWhiteColor(rgb)) {
          return true;
        }
      }
      borderCache.getValue(r, c)[type] = {
        type,
        style: props.s,
        color: rgb
      };
    }
    _getFontFormat(format) {
      if (!format) {
        return {};
      }
      const { ff, fs, it, bl, ul, st, ol, cl } = format;
      const style = {};
      ff && (style.ff = ff);
      fs && (style.fs = fs);
      it && (style.it = it);
      bl && (style.bl = bl);
      ul && (style.ul = ul);
      st && (style.st = st);
      ol && (style.ol = ol);
      cl && (style.cl = cl);
      return style;
    }
    _getOtherStyle(format) {
      if (!format) {
        return {};
      }
      const {
        tr: textRotation,
        td: textDirection,
        ht: horizontalAlign,
        vt: verticalAlign,
        tb: wrapStrategy,
        pd: paddingData
      } = format;
      return {
        textRotation,
        textDirection,
        horizontalAlign,
        verticalAlign,
        wrapStrategy,
        paddingData
      };
    }
    /**
     * Cache the merged cells on the current screen to improve computational performance.
     * @param mergeData all marge data
     * @param rowColumnSegment current screen range, include row and column
     */
    _getMergeCells(mergeData, rowColumnSegment) {
      const endColumnLast = this.columnWidthAccumulation.length - 1;
      if (!rowColumnSegment) {
        const endRow2 = this.rowHeightAccumulation.length - 1;
        rowColumnSegment = { startRow: 0, startColumn: 0, endRow: endRow2, endColumn: endColumnLast };
      } else {
        rowColumnSegment = {
          startRow: rowColumnSegment.startRow,
          endRow: rowColumnSegment.endRow,
          endColumn: endColumnLast,
          startColumn: 0
        };
      }
      const { startRow, startColumn, endRow, endColumn } = rowColumnSegment;
      const cacheDataMerge = [];
      for (let i = 0; i < mergeData.length; i++) {
        const {
          startRow: mergeStartRow,
          endRow: mergeEndRow,
          startColumn: mergeStartColumn,
          endColumn: mergeEndColumn
        } = mergeData[i];
        for (let r = startRow; r <= endRow; r++) {
          let isBreak = false;
          for (let c = startColumn; c <= endColumn; c++) {
            if (r >= mergeStartRow && r <= mergeEndRow && c >= mergeStartColumn && c <= mergeEndColumn) {
              cacheDataMerge.push({
                startRow: mergeStartRow,
                endRow: mergeEndRow,
                startColumn: mergeStartColumn,
                endColumn: mergeEndColumn
              });
              isBreak = true;
              break;
            }
          }
          if (isBreak) {
            break;
          }
        }
      }
      return cacheDataMerge;
    }
  };
  SpreadsheetSkeleton = __decorateClass([
    __decorateParam(4, Inject(LocaleService)),
    __decorateParam(5, IContextService)
  ], SpreadsheetSkeleton);

  // ../packages/engine-render/src/components/sheets/extensions/font.ts
  var UNIQUE_KEY4 = "DefaultFontExtension";
  var EXTENSION_Z_INDEX = 30;
  var Font = class extends SheetExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY4);
      __publicField(this, "Z_INDEX", EXTENSION_Z_INDEX);
    }
    getDocuments() {
      const parent = this.parent;
      return parent == null ? void 0 : parent.getDocuments();
    }
    draw(ctx, parentScale, spreadsheetSkeleton, diffRanges) {
      const { stylesCache, dataMergeCache, overflowCache, worksheet } = spreadsheetSkeleton;
      const { font: fontList } = stylesCache;
      if (!spreadsheetSkeleton || !worksheet) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0 || !worksheet) {
        return;
      }
      ctx.save();
      const scale = this._getScale(parentScale);
      fontList && Object.keys(fontList).forEach((fontFormat) => {
        const fontObjectArray = fontList[fontFormat];
        fontObjectArray.forValue((rowIndex, columnIndex, docsConfig) => {
          var _a2, _b2, _c, _d, _e;
          const cellInfo = this.getCellIndex(
            rowIndex,
            columnIndex,
            rowHeightAccumulation,
            columnWidthAccumulation,
            dataMergeCache
          );
          let { startY, endY, startX, endX } = cellInfo;
          const { isMerged, isMergedMainCell, mergeInfo } = cellInfo;
          if (isMerged) {
            return true;
          }
          if (isMergedMainCell) {
            startY = mergeInfo.startY;
            endY = mergeInfo.endY;
            startX = mergeInfo.startX;
            endX = mergeInfo.endX;
          }
          if (!this.isRenderDiffRangesByRow(mergeInfo.startRow, mergeInfo.endRow, diffRanges)) {
            return true;
          }
          const cellData = worksheet.getCell(rowIndex, columnIndex) || {};
          if ((_a2 = cellData.fontRenderExtension) == null ? void 0 : _a2.isSkip) {
            return true;
          }
          const overflowRectangle = overflowCache.getValue(rowIndex, columnIndex);
          const { horizontalAlign, vertexAngle = 0, centerAngle = 0 } = docsConfig;
          let horizontalAlignOverFlow = horizontalAlign;
          if (horizontalAlign === 0 /* UNSPECIFIED */) {
            if (centerAngle === VERTICAL_ROTATE_ANGLE && vertexAngle === VERTICAL_ROTATE_ANGLE) {
              horizontalAlignOverFlow = 2 /* CENTER */;
            } else if (vertexAngle > 0 && vertexAngle !== VERTICAL_ROTATE_ANGLE || vertexAngle === -VERTICAL_ROTATE_ANGLE) {
              horizontalAlignOverFlow = 3 /* RIGHT */;
            }
          }
          ctx.save();
          ctx.beginPath();
          const rightOffset = (_c = (_b2 = cellData.fontRenderExtension) == null ? void 0 : _b2.rightOffset) != null ? _c : 0;
          const leftOffset = (_e = (_d = cellData.fontRenderExtension) == null ? void 0 : _d.leftOffset) != null ? _e : 0;
          let isOverflow = true;
          if (vertexAngle === 0) {
            startX = startX + leftOffset;
            endX = endX - rightOffset;
            if (rightOffset !== 0 || leftOffset !== 0) {
              isOverflow = false;
            }
          }
          const cellWidth = endX - startX;
          const cellHeight = endY - startY;
          if (overflowRectangle && isOverflow) {
            const { startColumn, startRow, endColumn, endRow } = overflowRectangle;
            if (startColumn === endColumn && startColumn === columnIndex) {
              ctx.rectByPrecision(
                startX + 1 / scale,
                startY + 1 / scale,
                cellWidth - 2 / scale,
                cellHeight - 2 / scale
              );
              ctx.clip();
              ctx.clearRectForTexture(
                startX + 1 / scale,
                startY + 1 / scale,
                cellWidth - 2 / scale,
                cellHeight - 2 / scale
              );
            } else {
              if (horizontalAlignOverFlow === 2 /* CENTER */) {
                this._clipRectangle(
                  ctx,
                  startRow,
                  endRow,
                  startColumn,
                  endColumn,
                  scale,
                  rowHeightAccumulation,
                  columnWidthAccumulation
                );
              } else if (horizontalAlignOverFlow === 3 /* RIGHT */) {
                this._clipRectangle(
                  ctx,
                  startRow,
                  rowIndex,
                  startColumn,
                  columnIndex,
                  scale,
                  rowHeightAccumulation,
                  columnWidthAccumulation
                );
              } else {
                this._clipRectangle(
                  ctx,
                  rowIndex,
                  endRow,
                  columnIndex,
                  endColumn,
                  scale,
                  rowHeightAccumulation,
                  columnWidthAccumulation
                );
              }
            }
          } else {
            ctx.rectByPrecision(startX + 1 / scale, startY + 1 / scale, cellWidth - 2 / scale, cellHeight - 2 / scale);
            ctx.clip();
            ctx.clearRectForTexture(
              startX + 1 / scale,
              startY + 1 / scale,
              cellWidth - 2 / scale,
              cellHeight - 2 / scale
            );
          }
          ctx.translate(startX, startY);
          this._renderDocuments(ctx, docsConfig, startX, startY, endX, endY, rowIndex, columnIndex, overflowCache);
          ctx.restore();
        });
      });
      ctx.restore();
    }
    _renderDocuments(ctx, docsConfig, startX, startY, endX, endY, row, column, overflowCache) {
      const documents = this.getDocuments();
      if (documents == null) {
        throw new Error("documents is null");
      }
      const { documentSkeleton, vertexAngle = 0, wrapStrategy } = docsConfig;
      const cellWidth = endX - startX;
      const cellHeight = endY - startY;
      if (wrapStrategy === 3 /* WRAP */ && vertexAngle === 0) {
        documentSkeleton.getViewModel().getDataModel().updateDocumentDataPageSize(cellWidth);
        documentSkeleton.calculate();
      } else {
        documentSkeleton.getViewModel().getDataModel().updateDocumentDataPageSize(Number.POSITIVE_INFINITY);
      }
      const overflowRectangle = overflowCache.getValue(row, column);
      if (!(wrapStrategy === 3 /* WRAP */ && !overflowRectangle && vertexAngle === 0)) {
        const contentSize = getDocsSkeletonPageSize(documentSkeleton);
        const documentStyle = documentSkeleton.getViewModel().getDataModel().getSnapshot().documentStyle;
        if (contentSize && documentStyle) {
          const { width } = contentSize;
          const { marginRight = 0, marginLeft = 0 } = documentStyle;
          documentSkeleton.getViewModel().getDataModel().updateDocumentDataPageSize(width + marginLeft + marginRight);
          documentSkeleton.calculate();
        }
      }
      documentSkeleton.makeDirty(false);
      documents.resize(cellWidth, cellHeight);
      documents.changeSkeleton(documentSkeleton).render(ctx);
    }
    _clipRectangle(ctx, startRow, endRow, startColumn, endColumn, scale, rowHeightAccumulation, columnWidthAccumulation) {
      const startY = rowHeightAccumulation[startRow - 1] || 0;
      const endY = rowHeightAccumulation[endRow] || rowHeightAccumulation[rowHeightAccumulation.length - 1];
      const startX = columnWidthAccumulation[startColumn - 1] || 0;
      const endX = columnWidthAccumulation[endColumn] || columnWidthAccumulation[columnWidthAccumulation.length - 1];
      ctx.rectByPrecision(startX, startY, endX - startX, endY - startY);
      ctx.clip();
      ctx.clearRectForTexture(startX, startY, endX - startX, endY - startY);
    }
  };
  SpreadsheetExtensionRegistry.add(Font);

  // ../packages/engine-render/src/components/sheets/extensions/row-header-layout.ts
  var UNIQUE_KEY5 = "DefaultRowHeaderLayoutExtension";
  var RowHeaderLayout = class extends SheetExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY5);
      __publicField(this, "Z_INDEX", 10);
    }
    draw(ctx, parentScale, spreadsheetSkeleton) {
      const { rowColumnSegment, rowHeaderWidth = 0, columnHeaderHeight = 0 } = spreadsheetSkeleton;
      const { startRow, endRow, startColumn, endColumn } = rowColumnSegment;
      if (!spreadsheetSkeleton) {
        return;
      }
      const { rowHeightAccumulation, columnTotalWidth, columnWidthAccumulation, rowTotalHeight } = spreadsheetSkeleton;
      if (!rowHeightAccumulation || !columnWidthAccumulation || columnTotalWidth === void 0 || rowTotalHeight === void 0) {
        return;
      }
      const scale = this._getScale(parentScale);
      ctx.fillStyle = getColor([248, 249, 250]);
      ctx.fillRectByPrecision(0, 0, rowHeaderWidth, rowTotalHeight);
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillStyle = getColor([0, 0, 0]);
      ctx.beginPath();
      ctx.setLineWidthByPrecision(1);
      ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
      ctx.strokeStyle = getColor([217, 217, 217]);
      ctx.font = `13px ${DEFAULT_FONTFACE_PLANE}`;
      let preRowPosition = 0;
      const rowHeightAccumulationLength = rowHeightAccumulation.length;
      for (let r = startRow - 1; r <= endRow; r++) {
        if (r < 0 || r > rowHeightAccumulationLength - 1) {
          continue;
        }
        const rowEndPosition = rowHeightAccumulation[r];
        if (preRowPosition === rowEndPosition) {
          continue;
        }
        ctx.moveToByPrecision(0, rowEndPosition);
        ctx.lineToByPrecision(rowHeaderWidth, rowEndPosition);
        const middleCellPos = preRowPosition + (rowEndPosition - preRowPosition) / 2;
        ctx.fillText(`${r + 1}`, rowHeaderWidth / 2, middleCellPos + MIDDLE_CELL_POS_MAGIC_NUMBER);
        preRowPosition = rowEndPosition;
      }
      const rowHeaderWidthFix = rowHeaderWidth - 0.5 / scale;
      ctx.moveToByPrecision(rowHeaderWidthFix, 0);
      ctx.lineToByPrecision(rowHeaderWidthFix, rowTotalHeight);
      ctx.stroke();
    }
  };
  SheetRowHeaderExtensionRegistry.add(new RowHeaderLayout());

  // ../packages/engine-render/src/components/sheets/extensions/marker.ts
  var UNIQUE_KEY6 = "DefaultMarkerExtension";
  var Z_INDEX = 60;
  var stringifyRange = (range) => {
    const { startRow, endRow, startColumn, endColumn } = range;
    return `${startRow}-${endRow}-${startColumn}-${endColumn}`;
  };
  var Marker = class extends SheetExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "Z_INDEX", Z_INDEX);
      __publicField(this, "uKey", UNIQUE_KEY6);
    }
    draw(ctx, parentScale, skeleton, diffRanges) {
      const { worksheet, rowColumnSegment } = skeleton;
      if (!worksheet) {
        return;
      }
      const mergeCellRendered = /* @__PURE__ */ new Set();
      Range.foreach(rowColumnSegment, (row, col) => {
        var _a2, _b2, _c, _d;
        let cellData = worksheet.getCell(row, col);
        const cellInfo = this.getCellIndex(
          row,
          col,
          skeleton.rowHeightAccumulation,
          skeleton.columnWidthAccumulation,
          skeleton.dataMergeCache
        );
        const { isMerged, isMergedMainCell, mergeInfo } = cellInfo;
        let { startY, endY, startX, endX } = cellInfo;
        if (isMergedMainCell || isMerged) {
          startY = mergeInfo.startY;
          endY = mergeInfo.endY;
          startX = mergeInfo.startX;
          endX = mergeInfo.endX;
        }
        if (isMerged) {
          const mainCell = {
            row: mergeInfo.startRow,
            col: mergeInfo.startColumn
          };
          cellData = worksheet.getCell(mainCell.row, mainCell.col);
        }
        if (!this.isRenderDiffRangesByRow(mergeInfo.startRow, mergeInfo.endRow, diffRanges)) {
          return true;
        }
        if (cellInfo.isMerged || cellInfo.isMergedMainCell) {
          const rangeStr = stringifyRange(mergeInfo);
          if (mergeCellRendered.has(rangeStr)) {
            return;
          }
          mergeCellRendered.add(rangeStr);
        }
        if (!worksheet.getColVisible(col) || !worksheet.getRowVisible(row)) {
          return;
        }
        if (!cellData) {
          return;
        }
        if ((_a2 = cellData.markers) == null ? void 0 : _a2.tr) {
          ctx.save();
          const marker = cellData.markers.tr;
          const x = endX;
          const y = startY;
          ctx.fillStyle = marker.color;
          ctx.moveTo(x, y);
          ctx.beginPath();
          ctx.lineTo(x - marker.size, y);
          ctx.lineTo(x, y + marker.size);
          ctx.lineTo(x, y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        if ((_b2 = cellData.markers) == null ? void 0 : _b2.tl) {
          ctx.save();
          const marker = cellData.markers.tl;
          const x = startX;
          const y = startY;
          ctx.fillStyle = marker.color;
          ctx.moveTo(x, y);
          ctx.beginPath();
          ctx.lineTo(x + marker.size, y);
          ctx.lineTo(x, y + marker.size);
          ctx.lineTo(x, y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        if ((_c = cellData.markers) == null ? void 0 : _c.br) {
          ctx.save();
          const marker = cellData.markers.br;
          const x = endX;
          const y = endY;
          ctx.fillStyle = marker.color;
          ctx.moveTo(x, y);
          ctx.beginPath();
          ctx.lineTo(x - marker.size, y);
          ctx.lineTo(x, y - marker.size);
          ctx.lineTo(x, y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
        if ((_d = cellData.markers) == null ? void 0 : _d.bl) {
          ctx.save();
          const marker = cellData.markers.bl;
          const x = startX;
          const y = endY;
          ctx.fillStyle = marker.color;
          ctx.moveTo(x, y);
          ctx.beginPath();
          ctx.lineTo(x + marker.size, y);
          ctx.lineTo(x, y - marker.size);
          ctx.lineTo(x, y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        }
      });
    }
  };
  SpreadsheetExtensionRegistry.add(Marker);

  // ../packages/engine-render/src/components/sheets/extensions/custom.ts
  var UNIQUE_KEY7 = "DefaultCustomExtension";
  var Z_INDEX2 = 55;
  var stringifyRange2 = (range) => {
    const { startRow, endRow, startColumn, endColumn } = range;
    return `${startRow}-${endRow}-${startColumn}-${endColumn}`;
  };
  var Custom = class extends SheetExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "Z_INDEX", Z_INDEX2);
      __publicField(this, "uKey", UNIQUE_KEY7);
    }
    draw(ctx, parentScale, skeleton, diffRanges) {
      const { rowHeightAccumulation, columnWidthAccumulation, worksheet, dataMergeCache, rowColumnSegment } = skeleton;
      if (!worksheet) {
        return;
      }
      const mergeCellRendered = /* @__PURE__ */ new Set();
      const subUnitId = worksheet.getSheetId();
      Range.foreach(rowColumnSegment, (row, col) => {
        let cellData = worksheet.getCell(row, col);
        if (!(cellData == null ? void 0 : cellData.customRender)) {
          return;
        }
        let primaryWithCoord = this.getCellIndex(row, col, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
        const { mergeInfo } = primaryWithCoord;
        if (!this.isRenderDiffRangesByRow(mergeInfo.startRow, mergeInfo.endRow, diffRanges)) {
          return true;
        }
        if (primaryWithCoord.isMerged || primaryWithCoord.isMergedMainCell) {
          const rangeStr = stringifyRange2(mergeInfo);
          if (mergeCellRendered.has(rangeStr)) {
            return;
          }
          mergeCellRendered.add(rangeStr);
        }
        if (primaryWithCoord.isMerged) {
          const mainCell = {
            row: mergeInfo.startRow,
            col: mergeInfo.startColumn
          };
          cellData = worksheet.getCell(mainCell.row, mainCell.col);
          if (!(cellData == null ? void 0 : cellData.customRender)) {
            return;
          }
          primaryWithCoord = this.getCellIndex(mainCell.row, mainCell.col, rowHeightAccumulation, columnWidthAccumulation, dataMergeCache);
        }
        const renderInfo = {
          data: cellData,
          style: skeleton.getsStyles().getStyleByCell(cellData),
          primaryWithCoord,
          subUnitId,
          row,
          col
        };
        if (!worksheet.getColVisible(col) || !worksheet.getRowVisible(row)) {
          return;
        }
        const customRender = cellData.customRender.sort(sortRules);
        ctx.save();
        customRender.forEach((item) => {
          item.drawWith(ctx, renderInfo, skeleton, this.parent);
        });
        ctx.restore();
      });
    }
  };
  SpreadsheetExtensionRegistry.add(Custom);

  // ../packages/engine-render/src/components/docs/doc-extension.ts
  var docExtension = class extends ComponentExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "type", 0 /* SPAN */);
      __publicField(this, "translateX", 0);
      __publicField(this, "translateY", 0);
    }
  };

  // ../packages/engine-render/src/components/docs/extensions/background.ts
  var UNIQUE_KEY8 = "DefaultDocsBackgroundExtension";
  var DOC_EXTENSION_Z_INDEX2 = 10;
  var Background2 = class extends docExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY8);
      __publicField(this, "Z_INDEX", DOC_EXTENSION_Z_INDEX2);
      __publicField(this, "_preBackgroundColor", "");
    }
    draw(ctx, parentScale, span) {
      var _a2;
      const line = (_a2 = span.parent) == null ? void 0 : _a2.parent;
      if (!line) {
        return;
      }
      const { contentHeight = 0 } = line;
      const { ts: textStyle, width } = span;
      if (!textStyle) {
        return;
      }
      const { bg } = textStyle;
      if (!bg) {
        return;
      }
      const background = getColorStyle(bg);
      const { spanStartPoint = Vector2.create(0, 0) } = this.extensionOffset;
      if (background) {
        ctx.fillStyle = background;
        ctx.fillRectByPrecision(spanStartPoint.x - 0.5, spanStartPoint.y, width + 1, contentHeight + 1);
      }
    }
    clearCache() {
      this._preBackgroundColor = "";
    }
  };
  DocumentsSpanAndLineExtensionRegistry.add(new Background2());

  // ../packages/engine-render/src/components/docs/extensions/border.ts
  var UNIQUE_KEY9 = "DefaultDocsBorderExtension";
  var Border2 = class extends docExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY9);
      __publicField(this, "Z_INDEX", 50);
      __publicField(this, "_preBorderStyle");
      __publicField(this, "_preBorderColor", "");
    }
    draw(ctx, parentScale, glyph) {
      var _a2;
      const line = (_a2 = glyph.parent) == null ? void 0 : _a2.parent;
      if (!line) {
        return;
      }
      const { asc: maxLineAsc = 0, lineHeight = 0 } = line;
      const { ts: textStyle, left, width: spanWidth } = glyph;
      if (!textStyle) {
        return;
      }
      const { bd: borderData } = textStyle;
      if (!borderData) {
        return;
      }
      const precisionScale = this._getScale(ctx.getScale());
      const borderCache = this._createBorderCache(borderData);
      ctx.save();
      ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
      const { spanStartPoint = Vector2.create(0, 0) } = this.extensionOffset;
      for (const type of borderCache.keys()) {
        const borderCacheValue = borderCache.get(type);
        if (!borderCacheValue) {
          continue;
        }
        const { s: style, cl: colorStyle } = borderCacheValue;
        const color = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
        const lineWidth = getLineWidth(style);
        if (style !== this._preBorderStyle) {
          setLineType(ctx, style);
          ctx.setLineWidthByPrecision(lineWidth);
          this._preBorderStyle = style;
        }
        if (color !== this._preBorderColor) {
          ctx.strokeStyle = color || COLOR_BLACK_RGB;
          this._preBorderColor = color;
        }
        drawLineByBorderType(ctx, type, (lineWidth - 1) / 2 / precisionScale, {
          startX: spanStartPoint.x,
          startY: spanStartPoint.y,
          endX: spanStartPoint.x + spanWidth,
          endY: spanStartPoint.y + lineHeight
        });
      }
      ctx.restore();
    }
    clearCache() {
      this._preBorderStyle = null;
      this._preBorderColor = "";
    }
    _createBorderCache(borderData) {
      const { t, b, l, r } = borderData;
      const borderCache = /* @__PURE__ */ new Map();
      t && borderCache.set("t" /* TOP */, t);
      b && borderCache.set("b" /* BOTTOM */, b);
      l && borderCache.set("l" /* LEFT */, l);
      r && borderCache.set("r" /* RIGHT */, r);
      return borderCache;
    }
  };
  DocumentsSpanAndLineExtensionRegistry.add(new Border2());

  // ../packages/engine-render/src/components/docs/extensions/font-and-base-line.ts
  var UNIQUE_KEY10 = "DefaultDocsFontAndBaseLineExtension";
  var DOC_EXTENSION_Z_INDEX3 = 20;
  var FontAndBaseLine = class extends docExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY10);
      __publicField(this, "Z_INDEX", DOC_EXTENSION_Z_INDEX3);
      __publicField(this, "_preFontString", "");
      __publicField(this, "_preFontColor", "");
    }
    draw(ctx, parentScale, glyph) {
      var _a2;
      const line = (_a2 = glyph.parent) == null ? void 0 : _a2.parent;
      if (!line) {
        return;
      }
      const { ts: textStyle, content, fontStyle, bBox } = glyph;
      const { spanPointWithFont = Vector2.create(0, 0) } = this.extensionOffset;
      if (content == null) {
        return;
      }
      if (!textStyle) {
        this._fillText(ctx, glyph, spanPointWithFont);
        return;
      }
      if (this._preFontString !== (fontStyle == null ? void 0 : fontStyle.fontString)) {
        ctx.font = this._preFontString = (fontStyle == null ? void 0 : fontStyle.fontString) || "";
      }
      const { cl: colorStyle, va: baselineOffset } = textStyle;
      const fontColor = getColorStyle(colorStyle) || COLOR_BLACK_RGB;
      if (fontColor && this._preFontColor !== fontColor) {
        ctx.fillStyle = fontColor;
      }
      if (baselineOffset === 2 /* SUBSCRIPT */ || baselineOffset === 3 /* SUPERSCRIPT */) {
        let offset = 0;
        if (baselineOffset === 3 /* SUPERSCRIPT */) {
          offset = -bBox.sbo;
        }
        spanPointWithFont.y += offset;
      }
      this._fillText(ctx, glyph, spanPointWithFont);
    }
    _fillText(ctx, glyph, spanPointWithFont) {
      const { renderConfig, spanStartPoint, centerPoint } = this.extensionOffset;
      const { content, width, bBox } = glyph;
      const { aba, abd } = bBox;
      if (content == null || spanStartPoint == null || centerPoint == null) {
        return;
      }
      const { vertexAngle, centerAngle } = renderConfig != null ? renderConfig : {};
      const VERTICAL_DEG = 90;
      const isVertical = vertexAngle === VERTICAL_DEG && centerAngle === VERTICAL_DEG;
      if (isVertical && !hasCJK(content)) {
        ctx.save();
        ctx.translate(spanStartPoint.x + centerPoint.x, spanStartPoint.y + centerPoint.y);
        ctx.rotate(Math.PI / 2);
        ctx.translate(-width / 2, (aba + abd) / 2 - abd);
        ctx.fillText(content, 0, 0);
        ctx.restore();
      } else {
        ctx.fillText(content, spanPointWithFont.x, spanPointWithFont.y);
      }
    }
    clearCache() {
      this._preFontString = "";
      this._preFontColor = "";
    }
  };
  DocumentsSpanAndLineExtensionRegistry.add(new FontAndBaseLine());

  // ../packages/engine-render/src/components/docs/extensions/line.ts
  var UNIQUE_KEY11 = "DefaultDocsLineExtension";
  var DOC_EXTENSION_Z_INDEX4 = 40;
  var Line = class extends docExtension {
    constructor() {
      super(...arguments);
      __publicField(this, "uKey", UNIQUE_KEY11);
      __publicField(this, "Z_INDEX", DOC_EXTENSION_Z_INDEX4);
      __publicField(this, "_preBackgroundColor", "");
    }
    draw(ctx, parentScale, span) {
      var _a2;
      const line = (_a2 = span.parent) == null ? void 0 : _a2.parent;
      if (!line) {
        return;
      }
      const { contentHeight = 0, asc } = line;
      const { ts: textStyle, bBox } = span;
      if (!textStyle) {
        return;
      }
      const { sp: strikeoutPosition, ba } = bBox;
      const scale = getScale(parentScale);
      const DELTA = 0.5;
      const { ul: underline, st: strikethrough, ol: overline } = textStyle;
      if (underline) {
        const startY = contentHeight + DEFAULT_OFFSET_SPACING - 3;
        this._drawLine(ctx, span, underline, startY, scale);
      }
      if (strikethrough) {
        const startY = asc - (ba - strikeoutPosition) - DELTA;
        this._drawLine(ctx, span, strikethrough, startY, scale);
      }
      if (overline) {
        const startY = -DEFAULT_OFFSET_SPACING - DELTA;
        this._drawLine(ctx, span, overline, startY, scale);
      }
    }
    clearCache() {
      this._preBackgroundColor = "";
    }
    _drawLine(ctx, span, line, startY, scale) {
      var _a2;
      const { s: show, cl: colorStyle, t: lineType, c = 1 /* TRUE */ } = line;
      if (show === 1 /* TRUE */) {
        const {
          originTranslate = Vector2.create(0, 0),
          alignOffset = Vector2.create(0, 0),
          renderConfig = {}
        } = this.extensionOffset;
        const { left, width } = span;
        const { centerAngle: centerAngleDeg = 0, vertexAngle: vertexAngleDeg = 0 } = renderConfig;
        const centerAngle = degToRad(centerAngleDeg);
        const vertexAngle = degToRad(vertexAngleDeg);
        ctx.save();
        ctx.translateWithPrecisionRatio(FIX_ONE_PIXEL_BLUR_OFFSET, FIX_ONE_PIXEL_BLUR_OFFSET);
        ctx.beginPath();
        const color = (c === 1 /* TRUE */ ? getColorStyle((_a2 = span.ts) == null ? void 0 : _a2.cl) : getColorStyle(colorStyle)) || COLOR_BLACK_RGB;
        ctx.strokeStyle = color;
        this._setLineType(ctx, lineType || 12 /* SINGLE */);
        const start = calculateRectRotate(
          originTranslate.addByPoint(left, startY),
          Vector2.create(0, 0),
          centerAngle,
          vertexAngle,
          alignOffset
        );
        const end = calculateRectRotate(
          originTranslate.addByPoint(left + width, startY),
          Vector2.create(0, 0),
          centerAngle,
          vertexAngle,
          alignOffset
        );
        ctx.moveToByPrecision(start.x, start.y);
        ctx.lineToByPrecision(end.x, end.y);
        ctx.stroke();
        ctx.restore();
      }
    }
    _setLineType(ctx, style) {
      if (style === 1 /* DASH_DOT_DOT_HEAVY */ || style === 7 /* DOT_DOT_DASH */) {
        ctx.setLineDash([2, 2, 5, 2, 2]);
      } else if (style === 2 /* DASH_DOT_HEAVY */ || style === 6 /* DOT_DASH */) {
        ctx.setLineDash([2, 5, 2]);
      } else if (style === 8 /* DOTTED */ || style === 9 /* DOTTED_HEAVY */) {
        ctx.setLineDash([2]);
      } else if (style === 0 /* DASH */ || style === 3 /* DASHED_HEAVY */) {
        ctx.setLineDash([3]);
      } else if (style === 4 /* DASH_LONG */ || style === 5 /* DASH_LONG_HEAVY */) {
        ctx.setLineDash([6]);
      } else {
        ctx.setLineDash([0]);
      }
    }
  };
  DocumentsSpanAndLineExtensionRegistry.add(new Line());

  // ../packages/engine-render/src/scene-viewer.ts
  var SceneViewer = class extends BaseObject {
    constructor(key, props) {
      super(key);
      __publicField(this, "_subScenes", /* @__PURE__ */ new Map());
      __publicField(this, "_activeSubScene");
      __publicField(this, "_allowSelectedClipElement", false);
      this._initialProps(props);
    }
    get classType() {
      return "SceneViewer" /* SCENE_VIEWER */;
    }
    render(mainCtx, bounds) {
      var _a2;
      if (!this.visible) {
        this.makeDirty(false);
        return this;
      }
      if (bounds) {
        const { left, top, right, bottom } = bounds.viewBound;
        if (this.width + this.strokeWidth + this.left < left || right < this.left || this.height + this.strokeWidth + this.top < top || bottom < this.top) {
          return this;
        }
      }
      const m = this.transform.getMatrix();
      mainCtx.save();
      mainCtx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      (_a2 = this._activeSubScene) == null ? void 0 : _a2.makeDirtyNoParent(true).render(mainCtx);
      mainCtx.restore();
      this.makeDirty(false);
      return this;
    }
    getSubScenes() {
      return this._subScenes;
    }
    getActiveSubScene() {
      return this._activeSubScene;
    }
    getSubScene(sceneKey) {
      for (const [key, scene] of this._subScenes) {
        if (key === sceneKey) {
          return scene;
        }
      }
    }
    addSubScene(scene) {
      this._activeSubScene = scene;
      this._subScenes.set(scene.sceneKey, scene);
      this.makeDirty();
    }
    removeSubScene(key) {
      const subScene = this._subScenes.get(key);
      this._subScenes.delete(key);
      if (this._activeSubScene === subScene) {
        this._activeSubScene = this._subScenes.values().next().value;
      }
      this.makeDirty();
    }
    activeSubScene(key) {
      if (key == null) {
        return;
      }
      const subScene = this._subScenes.get(key);
      if (this._activeSubScene !== subScene) {
        this._activeSubScene = subScene;
        this.makeDirty();
      }
    }
    enableSelectedClipElement() {
      this._allowSelectedClipElement = true;
    }
    disableSelectedClipElement() {
      this._allowSelectedClipElement = false;
    }
    allowSelectedClipElement() {
      return this._allowSelectedClipElement;
    }
    // 判断被选中的唯一对象
    pick(coord) {
      var _a2;
      if (this._activeSubScene === void 0) {
        return;
      }
      const trans = this.transform.clone().invert();
      const tCoord = trans.applyPoint(coord);
      return (_a2 = this._activeSubScene) == null ? void 0 : _a2.pick(tCoord);
    }
    dispose() {
      super.dispose();
      this._subScenes.forEach((scene) => {
        scene.dispose();
      });
    }
    _initialProps(props) {
      if (!props) {
        return;
      }
      const themeKeys = Object.keys(props);
      if (themeKeys.length === 0) {
        return;
      }
      const transformState = {};
      let hasTransformState = false;
      themeKeys.forEach((key) => {
        if (props[key] === void 0) {
          return true;
        }
        transformState[key] = props[key];
        hasTransformState = true;
      });
      if (hasTransformState) {
        this.transformByState(transformState);
      }
      this.makeDirty(true);
    }
  };

  // ../packages/engine-render/src/shape/shape.ts
  var SHAPE_OBJECT_ARRAY = [
    "hoverCursor",
    "moveCursor",
    "fillRule",
    "globalCompositeOperation",
    "paintFirst",
    "stroke",
    "strokeScaleEnabled",
    "fill",
    "fillAfterStrokeEnabled",
    "hitStrokeWidth",
    "strokeLineJoin",
    "strokeLineCap",
    "shadowColor",
    "shadowBlur",
    "shadowOffset",
    "shadowOffsetX",
    "shadowOffsetY",
    "shadowOpacity",
    "shadowEnabled",
    "shadowForStrokeEnabled",
    "strokeDashArray",
    "strokeDashOffset",
    "strokeMiterLimit"
  ];
  var Shape = class extends BaseObject {
    constructor(key, props) {
      super(key);
      __publicField(this, "_hoverCursor");
      __publicField(this, "_moveCursor", null);
      __publicField(this, "_fillRule", "nonzero");
      __publicField(this, "_globalCompositeOperation", "source-over");
      __publicField(this, "_paintFirst", "fill");
      __publicField(this, "_stroke");
      __publicField(this, "_strokeScaleEnabled", false);
      // strokeUniform: boolean;
      __publicField(this, "_fill");
      __publicField(this, "_fillAfterStrokeEnabled", false);
      __publicField(this, "_hitStrokeWidth", 0);
      __publicField(this, "_strokeLineJoin", "round");
      __publicField(this, "_strokeLineCap", "round");
      __publicField(this, "_shadowColor");
      __publicField(this, "_shadowBlur", 0);
      __publicField(this, "_shadowOffset");
      __publicField(this, "_shadowOffsetX", 0);
      __publicField(this, "_shadowOffsetY", 0);
      __publicField(this, "_shadowOpacity", 0);
      __publicField(this, "_shadowEnabled", false);
      __publicField(this, "_shadowForStrokeEnabled", false);
      __publicField(this, "_strokeDashArray");
      __publicField(this, "_strokeDashOffset", 0);
      __publicField(this, "_strokeMiterLimit", 0);
      __publicField(this, "_type", "rect" /* RECT */);
      this._initialProps(props);
    }
    get hoverCursor() {
      return this._hoverCursor;
    }
    get moveCursor() {
      return this._moveCursor;
    }
    get fillRule() {
      return this._fillRule;
    }
    get globalCompositeOperation() {
      return this._globalCompositeOperation;
    }
    get paintFirst() {
      return this._paintFirst;
    }
    get stroke() {
      return this._stroke;
    }
    get strokeScaleEnabled() {
      return this._strokeScaleEnabled;
    }
    get fill() {
      return this._fill;
    }
    get fillAfterStrokeEnabled() {
      return this._fillAfterStrokeEnabled;
    }
    get hitStrokeWidth() {
      return this._hitStrokeWidth;
    }
    get strokeLineJoin() {
      return this._strokeLineJoin;
    }
    get strokeLineCap() {
      return this._strokeLineCap;
    }
    get shadowColor() {
      return this._shadowColor;
    }
    get shadowBlur() {
      return this._shadowBlur;
    }
    get shadowOffset() {
      return this._shadowOffset;
    }
    get shadowOffsetX() {
      return this._shadowOffsetX;
    }
    get shadowOffsetY() {
      return this._shadowOffsetY;
    }
    get shadowOpacity() {
      return this._shadowOpacity;
    }
    get shadowEnabled() {
      return this._shadowEnabled;
    }
    get shadowForStrokeEnabled() {
      return this._shadowForStrokeEnabled;
    }
    get strokeDashArray() {
      return this._strokeDashArray;
    }
    get strokeDashOffset() {
      return this._strokeDashOffset;
    }
    get strokeMiterLimit() {
      return this._strokeMiterLimit;
    }
    static drawWith(ctx, props) {
    }
    static _renderPaintInOrder(ctx, props) {
      if (props.paintFirst === "stroke") {
        this._renderStroke(ctx, props);
        this._renderFill(ctx, props);
      } else {
        this._renderFill(ctx, props);
        this._renderStroke(ctx, props);
      }
    }
    /**
     * @private
     * @param {UniverRenderingContext} ctx SheetContext to render on
     */
    static _renderFill(ctx, props) {
      if (!props.fill) {
        return;
      }
      ctx.save();
      this._setFillStyles(ctx, props);
      if (props.fillRule === "evenodd") {
        ctx.fill("evenodd");
      } else {
        ctx.fill();
      }
      ctx.restore();
    }
    /**
     * @private
     * @param {UniverRenderingContext} ctx SheetContext to render on
     */
    static _renderStroke(ctx, props) {
      const { stroke, strokeWidth, shadowEnabled, shadowForStrokeEnabled, strokeScaleEnabled, parent } = props;
      let { scaleX, scaleY } = props;
      if (!stroke || strokeWidth === 0) {
        return;
      }
      if (shadowEnabled && !shadowForStrokeEnabled) {
        this._removeShadow(ctx);
      }
      ctx.save();
      if (strokeScaleEnabled && parent) {
        const scaling = this._getObjectScaling();
        ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
      } else if (strokeScaleEnabled) {
        scaleX = scaleX != null ? scaleX : 1;
        scaleY = scaleY != null ? scaleY : 1;
        ctx.scale(1 / scaleX, 1 / scaleY);
      }
      this._setLineDash(ctx);
      this._setStrokeStyles(ctx, props);
      ctx.stroke();
      ctx.restore();
    }
    static _getObjectScaling() {
      return { scaleX: 1, scaleY: 1 };
    }
    static _removeShadow(ctx) {
    }
    static _setFillStyles(ctx, props) {
      ctx.fillStyle = props.fill;
    }
    static _setStrokeStyles(ctx, props) {
      const { strokeWidth, strokeLineCap, strokeDashOffset, strokeLineJoin, strokeMiterLimit, stroke } = props;
      ctx.lineWidth = strokeWidth;
      ctx.lineCap = strokeLineCap;
      ctx.lineDashOffset = strokeDashOffset;
      ctx.lineJoin = strokeLineJoin;
      ctx.miterLimit = strokeMiterLimit;
      ctx.strokeStyle = stroke;
    }
    static _setLineDash(ctx) {
    }
    render(mainCtx, bounds) {
      if (!this.visible) {
        this.makeDirty(false);
        return this;
      }
      if (this.isRender(bounds)) {
        const { top, left, bottom, right } = bounds.viewBound;
        if (this.width + this.strokeWidth + this.left < left || right < this.left || this.height + this.strokeWidth + this.top < top || bottom < this.top) {
          return this;
        }
      }
      const m = this.transform.getMatrix();
      mainCtx.save();
      mainCtx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._draw(mainCtx);
      mainCtx.restore();
      this.makeDirty(false);
      return this;
    }
    setProps(props) {
      if (!props) {
        return;
      }
      const themeKeys = Object.keys(props);
      if (themeKeys.length === 0) {
        return;
      }
      themeKeys.forEach((key) => {
        if (props[key] === void 0) {
          return true;
        }
        if (BASE_OBJECT_ARRAY.indexOf(key) === -1) {
          this[`_${key}`] = props[key];
        }
      });
      this.makeDirty(true);
      return this;
    }
    toJson() {
      const props = {};
      SHAPE_OBJECT_ARRAY.forEach((key) => {
        if (this[key]) {
          props[key] = this[key];
        }
      });
      return {
        ...super.toJson(),
        ...props
      };
    }
    _draw(ctx) {
    }
    _initialProps(props) {
      if (!props) {
        return;
      }
      const themeKeys = Object.keys(props);
      if (themeKeys.length === 0) {
        return;
      }
      const transformState = {};
      let hasTransformState = false;
      themeKeys.forEach((key) => {
        if (props[key] === void 0) {
          return true;
        }
        if (BASE_OBJECT_ARRAY.indexOf(key) > -1) {
          transformState[key] = props[key];
          hasTransformState = true;
        } else {
          this[`_${key}`] = props[key];
        }
      });
      if (hasTransformState) {
        this.transformByState(transformState);
      }
      this.makeDirty(true);
    }
  };

  // ../packages/engine-render/src/thin-engine.ts
  var ThinEngine = class extends Disposable {
    constructor() {
      super(...arguments);
      __publicField(this, "onInputChangedObservable", new Observable2());
      __publicField(this, "onTransformChangeObservable", new Observable2());
      __publicField(this, "_scenes", {});
      __publicField(this, "_activeScene", null);
    }
    get classType() {
      return "Engine" /* ENGINE */;
    }
    get activeScene() {
      return this._activeScene;
    }
    get width() {
      return 0;
    }
    get height() {
      return 0;
    }
    getScenes() {
      return this._scenes;
    }
    getScene(sceneKey) {
      return this._scenes[sceneKey];
    }
    hasScene(sceneKey) {
      return sceneKey in this._scenes;
    }
    addScene(sceneInstance) {
      const sceneKey = sceneInstance.sceneKey;
      if (this.hasScene(sceneKey)) {
        console.warn("Scenes has similar key, it will be covered");
      }
      this._scenes[sceneKey] = sceneInstance;
      return sceneInstance;
    }
    setActiveScene(sceneKey) {
      const scene = this.getScene(sceneKey);
      if (scene) {
        this._activeScene = scene;
      }
      return scene;
    }
    setRemainCapture() {
    }
    hasActiveScene() {
      return this._activeScene != null;
    }
    dispose() {
      super.dispose();
      const scenes = this.getScenes();
      const sceneKeys = Object.keys(scenes);
      sceneKeys.forEach((key) => {
        scenes[key].dispose();
      });
    }
    remainScene(key) {
      const scenes = this.getScenes();
      if (scenes[key]) {
        const scene = scenes[key];
        delete scenes[key];
        return scene;
      }
    }
  };

  // ../packages/engine-render/src/engine.ts
  var Engine = class extends ThinEngine {
    constructor(elemWidth = 1, elemHeight = 1, pixelRatio, mode) {
      super();
      __publicField(this, "renderEvenInBackground", true);
      /**
       * Observable raised when the engine begins a new frame
       */
      __publicField(this, "onBeginFrameObservable", new Observable2());
      /**
       * Observable raised when the engine ends the current frame
       */
      __publicField(this, "onEndFrameObservable", new Observable2());
      __publicField(this, "_container");
      __publicField(this, "_canvas");
      __publicField(this, "_canvasEle");
      __publicField(this, "_renderingQueueLaunched", false);
      __publicField(this, "_activeRenderLoops", new Array());
      __publicField(this, "_renderFunction", () => {
      });
      __publicField(this, "_requestNewFrameHandler", -1);
      __publicField(this, "_frameId", -1);
      __publicField(this, "_usingSafari", IsSafari());
      __publicField(this, "_resizeObserver");
      // FPS
      __publicField(this, "_fps", 60);
      __publicField(this, "_deltaTime", 0);
      __publicField(this, "_performanceMonitor", new PerformanceMonitor());
      __publicField(this, "_pointerMoveEvent");
      __publicField(this, "_pointerDownEvent");
      __publicField(this, "_pointerUpEvent");
      __publicField(this, "_pointerBlurEvent");
      __publicField(this, "_pointerWheelEvent");
      __publicField(this, "_pointerEnterEvent");
      __publicField(this, "_pointerLeaveEvent");
      __publicField(this, "_remainCapture", -1);
      /** previous pointer position */
      __publicField(this, "pointer", {});
      __publicField(this, "_mouseId", -1);
      __publicField(this, "_isUsingFirefox", navigator.userAgent.indexOf("Firefox") !== -1);
      __publicField(this, "_previousWidth", -1e3);
      __publicField(this, "_previousHeight", -1e3);
      this._canvas = new Canvas({
        mode,
        width: elemWidth,
        height: elemHeight,
        pixelRatio
      });
      this._canvasEle = this._canvas.getCanvasEle();
      this._handleKeyboardAction();
      this._handlePointerAction();
      this._matchMediaHandler();
    }
    get width() {
      return this._canvas.getWidth();
    }
    get height() {
      return this._canvas.getHeight();
    }
    get requestNewFrameHandler() {
      return this._requestNewFrameHandler;
    }
    /**
     * Gets the current frame id
     */
    get frameId() {
      return this._frameId;
    }
    setCanvasCursor(val) {
      const canvasEl = this.getCanvas().getCanvasEle();
      canvasEl.style.cursor = val;
    }
    clearCanvas() {
      this.getCanvas().clear();
    }
    getCanvas() {
      return this._canvas;
    }
    getCanvasElement() {
      return this._canvas.getCanvasEle();
    }
    /**
     * To ensure mouse events remain bound to the host element,
     * preventing the events from becoming ineffective once the mouse leaves the host.
     */
    setRemainCapture() {
      try {
        this._canvasEle.setPointerCapture(this._remainCapture);
      } catch {
        console.warn("no capture");
      }
    }
    getPixelRatio() {
      return this._canvas.getPixelRatio();
    }
    setContainer(elem, resize = true) {
      var _a2;
      this._container = elem;
      this._container.appendChild(this._canvasEle);
      if (resize) {
        this.resize();
        (_a2 = this._resizeObserver) == null ? void 0 : _a2.unobserve(this._container);
        let timer;
        this._resizeObserver = new ResizeObserver(() => {
          if (!timer) {
            timer = window.requestIdleCallback(() => {
              this.resize();
              timer = void 0;
            });
          }
        });
        this._resizeObserver.observe(this._container);
        this.disposeWithMe(
          toDisposable(() => {
            var _a3;
            (_a3 = this._resizeObserver) == null ? void 0 : _a3.unobserve(this._container);
          })
        );
      }
    }
    resize() {
      if (!this._container) {
        return;
      }
      const { width, height } = getSizeForDom(this._container);
      if (width === this._previousWidth && height === this._previousHeight) {
        return;
      }
      this._previousWidth = width;
      this._previousHeight = height;
      this.resizeBySize(width, height);
    }
    resizeBySize(width, height) {
      const preWidth = this.width;
      const preHeight = this.height;
      this._canvas.setSize(width, height);
      this.onTransformChangeObservable.notifyObservers({
        type: 1 /* resize */,
        value: {
          width,
          height
        },
        preValue: {
          width: preWidth,
          height: preHeight
        }
      });
    }
    dispose() {
      super.dispose();
      const eventPrefix = getPointerPrefix();
      this._canvasEle.removeEventListener(`${eventPrefix}leave`, this._pointerLeaveEvent);
      this._canvasEle.removeEventListener(`${eventPrefix}enter`, this._pointerEnterEvent);
      this._canvasEle.removeEventListener(`${eventPrefix}move`, this._pointerMoveEvent);
      this._canvasEle.removeEventListener(`${eventPrefix}down`, this._pointerDownEvent);
      this._canvasEle.removeEventListener(`${eventPrefix}up`, this._pointerUpEvent);
      this._canvasEle.removeEventListener("blur", this._pointerBlurEvent);
      this._canvasEle.removeEventListener(this._getWheelEventName(), this._pointerWheelEvent);
      this._activeRenderLoops = [];
      this._canvas.dispose();
      this.onBeginFrameObservable.clear();
      this.onEndFrameObservable.clear();
      this.onTransformChangeObservable.clear();
    }
    /**
     * Register and execute a render loop. The engine can have more than one render function
     * @param renderFunction defines the function to continuously execute
     */
    runRenderLoop(renderFunction) {
      if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
        return;
      }
      this._activeRenderLoops.push(renderFunction);
      if (!this._renderingQueueLaunched) {
        this._renderingQueueLaunched = true;
        this._renderFunction = this._renderLoop.bind(this);
        this._requestNewFrameHandler = requestNewFrame(this._renderFunction);
      }
    }
    /**
     * stop executing a render loop function and remove it from the execution array
     * @param renderFunction defines the function to be removed. If not provided all functions will be removed.
     */
    stopRenderLoop(renderFunction) {
      if (!renderFunction) {
        this._activeRenderLoops.length = 0;
        this._cancelFrame();
        return;
      }
      const index = this._activeRenderLoops.indexOf(renderFunction);
      if (index >= 0) {
        this._activeRenderLoops.splice(index, 1);
        if (this._activeRenderLoops.length === 0) {
          this._cancelFrame();
        }
      }
    }
    /**
     * Begin a new frame
     */
    beginFrame() {
      this._measureFps();
      this.onBeginFrameObservable.notifyObservers(this);
    }
    /**
     * End the current frame
     */
    endFrame() {
      this._frameId++;
      this.onEndFrameObservable.notifyObservers(this);
    }
    // FPS
    /**
     * Gets the current framerate
     * @returns a number representing the framerate
     */
    getFps() {
      return this._fps;
    }
    /**
     * Gets the time spent between current and previous frame
     * @returns a number representing the delta time in ms
     */
    getDeltaTime() {
      return this._deltaTime;
    }
    _renderFrame() {
      for (let index = 0; index < this._activeRenderLoops.length; index++) {
        const renderFunction = this._activeRenderLoops[index];
        renderFunction();
      }
    }
    _cancelFrame() {
      if (this._renderingQueueLaunched && this._requestNewFrameHandler) {
        this._renderingQueueLaunched = false;
        if (typeof window === "undefined") {
          if (typeof cancelAnimationFrame === "function") {
            return cancelAnimationFrame(this._requestNewFrameHandler);
          }
        } else {
          const { cancelAnimationFrame: cancelAnimationFrame2 } = this._getHostWindow() || window;
          if (typeof cancelAnimationFrame2 === "function") {
            return cancelAnimationFrame2(this._requestNewFrameHandler);
          }
        }
        return clearTimeout(this._requestNewFrameHandler);
      }
    }
    _getHostWindow() {
      var _a2, _b2;
      if (typeof window === "undefined") {
        return null;
      }
      if ((_b2 = (_a2 = this._canvasEle) == null ? void 0 : _a2.ownerDocument) == null ? void 0 : _b2.defaultView) {
        return this._canvasEle.ownerDocument.defaultView;
      }
      return window;
    }
    /** @hidden */
    _renderLoop() {
      let shouldRender = true;
      if (!this.renderEvenInBackground) {
        shouldRender = false;
      }
      if (shouldRender) {
        this.beginFrame();
        this._renderFrame();
        this.endFrame();
      }
      if (this._activeRenderLoops.length > 0) {
        this._requestNewFrameHandler = requestNewFrame(this._renderFunction);
      } else {
        this._renderingQueueLaunched = false;
      }
    }
    _measureFps() {
      this._performanceMonitor.sampleFrame();
      this._fps = this._performanceMonitor.averageFPS;
      this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
    }
    _handleKeyboardAction() {
      const keyboardDownEvent = (evt) => {
        const deviceEvent = evt;
        deviceEvent.deviceType = 1 /* Keyboard */;
        deviceEvent.inputIndex = evt.keyCode;
        deviceEvent.previousState = 0;
        deviceEvent.currentState = 1;
        this.onInputChangedObservable.notifyObservers(deviceEvent);
      };
      const keyboardUpEvent = (evt) => {
        const deviceEvent = evt;
        deviceEvent.deviceType = 1 /* Keyboard */;
        deviceEvent.inputIndex = evt.keyCode;
        deviceEvent.previousState = 1;
        deviceEvent.currentState = 0;
        this.onInputChangedObservable.notifyObservers(deviceEvent);
      };
      this._canvasEle.addEventListener("keydown", keyboardDownEvent);
      this._canvasEle.addEventListener("keyup", keyboardUpEvent);
    }
    _handlePointerAction() {
      const eventPrefix = getPointerPrefix();
      this._pointerMoveEvent = (evt) => {
        const deviceType = this._getPointerType(evt);
        const previousHorizontal = this.pointer[0 /* Horizontal */];
        const previousVertical = this.pointer[1 /* Vertical */];
        const previousDeltaHorizontal = this.pointer[10 /* DeltaHorizontal */];
        const previousDeltaVertical = this.pointer[11 /* DeltaVertical */];
        this.pointer[0 /* Horizontal */] = evt.clientX;
        this.pointer[1 /* Vertical */] = evt.clientY;
        this.pointer[10 /* DeltaHorizontal */] = evt.movementX;
        this.pointer[11 /* DeltaVertical */] = evt.movementY;
        const deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        if (previousHorizontal !== evt.clientX) {
          deviceEvent.inputIndex = 0 /* Horizontal */;
          deviceEvent.previousState = previousHorizontal;
          deviceEvent.currentState = this.pointer[0 /* Horizontal */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = 1 /* Vertical */;
          deviceEvent.previousState = previousVertical;
          deviceEvent.currentState = this.pointer[1 /* Vertical */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (this.pointer[10 /* DeltaHorizontal */] !== 0) {
          deviceEvent.inputIndex = 10 /* DeltaHorizontal */;
          deviceEvent.previousState = previousDeltaHorizontal;
          deviceEvent.currentState = this.pointer[10 /* DeltaHorizontal */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (this.pointer[11 /* DeltaVertical */] !== 0) {
          deviceEvent.inputIndex = 11 /* DeltaVertical */;
          deviceEvent.previousState = previousDeltaVertical;
          deviceEvent.currentState = this.pointer[11 /* DeltaVertical */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (!this._usingSafari && evt.button !== -1) {
          deviceEvent.inputIndex = evt.button + 2;
          deviceEvent.previousState = this.pointer[evt.button + 2];
          this.pointer[evt.button + 2] = this.pointer[evt.button + 2] ? 0 : 1;
          deviceEvent.currentState = this.pointer[evt.button + 2];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
      };
      this._pointerDownEvent = (nativeEvent) => {
        const evt = nativeEvent;
        const deviceType = this._getPointerType(evt);
        const previousHorizontal = this.pointer[0 /* Horizontal */];
        const previousVertical = this.pointer[1 /* Vertical */];
        const previousButton = this.pointer[evt.button + 2];
        if (deviceType === 2 /* Mouse */) {
          if (this._mouseId === -1) {
            if (evt.pointerId === void 0) {
              this._mouseId = this._isUsingFirefox ? 0 : 1;
            } else {
              this._mouseId = evt.pointerId;
            }
          }
          if (!document.pointerLockElement) {
            this._remainCapture = this._mouseId;
            this._canvasEle.setPointerCapture(this._mouseId);
          }
        } else {
          if (evt.pointerId && !document.pointerLockElement) {
            this._remainCapture = evt.pointerId;
            this._canvasEle.setPointerCapture(evt.pointerId);
          }
        }
        this.pointer[0 /* Horizontal */] = evt.clientX;
        this.pointer[1 /* Vertical */] = evt.clientY;
        this.pointer[evt.button + 2] = 1;
        const deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        if (previousHorizontal !== evt.clientX) {
          deviceEvent.inputIndex = 0 /* Horizontal */;
          deviceEvent.previousState = previousHorizontal;
          deviceEvent.currentState = this.pointer[0 /* Horizontal */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = 1 /* Vertical */;
          deviceEvent.previousState = previousVertical;
          deviceEvent.currentState = this.pointer[1 /* Vertical */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        deviceEvent.inputIndex = evt.button + 2;
        deviceEvent.previousState = previousButton;
        deviceEvent.currentState = this.pointer[evt.button + 2];
        this.onInputChangedObservable.notifyObservers(deviceEvent);
      };
      this._pointerUpEvent = (_evt) => {
        const evt = _evt;
        const deviceType = this._getPointerType(evt);
        const previousHorizontal = this.pointer[0 /* Horizontal */];
        const previousVertical = this.pointer[1 /* Vertical */];
        const previousButton = this.pointer[evt.button + 2];
        this.pointer[0 /* Horizontal */] = evt.clientX;
        this.pointer[1 /* Vertical */] = evt.clientY;
        this.pointer[evt.button + 2] = 0;
        const deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        if (previousHorizontal !== evt.clientX) {
          deviceEvent.inputIndex = 0 /* Horizontal */;
          deviceEvent.previousState = previousHorizontal;
          deviceEvent.currentState = this.pointer[0 /* Horizontal */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (previousVertical !== evt.clientY) {
          deviceEvent.inputIndex = 1 /* Vertical */;
          deviceEvent.previousState = previousVertical;
          deviceEvent.currentState = this.pointer[1 /* Vertical */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        deviceEvent.inputIndex = evt.button + 2;
        deviceEvent.previousState = previousButton;
        deviceEvent.currentState = this.pointer[evt.button + 2];
        if (deviceType === 2 /* Mouse */ && this._mouseId >= 0 && this._canvasEle.hasPointerCapture(this._mouseId)) {
          this._remainCapture = this._mouseId;
          this._canvasEle.releasePointerCapture(this._mouseId);
        } else if (deviceEvent.pointerId && this._canvasEle.hasPointerCapture(deviceEvent.pointerId)) {
          this._remainCapture = deviceEvent.pointerId;
          this._canvasEle.releasePointerCapture(deviceEvent.pointerId);
        }
        this.onInputChangedObservable.notifyObservers(deviceEvent);
        if (deviceType !== 2 /* Mouse */) {
          this.pointer = {};
        }
      };
      this._pointerEnterEvent = (evt) => {
        const deviceType = this._getPointerType(evt);
        const deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        deviceEvent.currentState = 2;
        this.onInputChangedObservable.notifyObservers(deviceEvent);
      };
      this._pointerLeaveEvent = (evt) => {
        const deviceType = this._getPointerType(evt);
        const deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        deviceEvent.currentState = 3;
        this.onInputChangedObservable.notifyObservers(deviceEvent);
      };
      this._pointerBlurEvent = (evt) => {
        if (this._mouseId >= 0 && this._canvasEle.hasPointerCapture(this._mouseId)) {
          this._canvasEle.releasePointerCapture(this._mouseId);
          this._remainCapture = this._mouseId;
          this._mouseId = -1;
        }
        this.pointer = {};
      };
      this._pointerWheelEvent = (evt) => {
        const deviceType = 2 /* Mouse */;
        const previousWheelScrollX = this.pointer[7 /* MouseWheelX */];
        const previousWheelScrollY = this.pointer[8 /* MouseWheelY */];
        const previousWheelScrollZ = this.pointer[9 /* MouseWheelZ */];
        this.pointer[7 /* MouseWheelX */] = evt.deltaX || 0;
        this.pointer[8 /* MouseWheelY */] = evt.deltaY || evt.wheelDelta || 0;
        this.pointer[9 /* MouseWheelZ */] = evt.deltaZ || 0;
        const deviceEvent = evt;
        deviceEvent.deviceType = deviceType;
        if (this.pointer[7 /* MouseWheelX */] !== 0) {
          deviceEvent.inputIndex = 7 /* MouseWheelX */;
          deviceEvent.previousState = previousWheelScrollX;
          deviceEvent.currentState = this.pointer[7 /* MouseWheelX */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (this.pointer[8 /* MouseWheelY */] !== 0) {
          deviceEvent.inputIndex = 8 /* MouseWheelY */;
          deviceEvent.previousState = previousWheelScrollY;
          deviceEvent.currentState = this.pointer[8 /* MouseWheelY */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
        if (this.pointer[9 /* MouseWheelZ */] !== 0) {
          deviceEvent.inputIndex = 9 /* MouseWheelZ */;
          deviceEvent.previousState = previousWheelScrollZ;
          deviceEvent.currentState = this.pointer[9 /* MouseWheelZ */];
          this.onInputChangedObservable.notifyObservers(deviceEvent);
        }
      };
      this._canvasEle.addEventListener(`${eventPrefix}enter`, this._pointerEnterEvent);
      this._canvasEle.addEventListener(`${eventPrefix}leave`, this._pointerLeaveEvent);
      this._canvasEle.addEventListener(`${eventPrefix}move`, this._pointerMoveEvent);
      this._canvasEle.addEventListener(`${eventPrefix}down`, this._pointerDownEvent);
      this._canvasEle.addEventListener(`${eventPrefix}up`, this._pointerUpEvent);
      this._canvasEle.addEventListener("blur", this._pointerBlurEvent);
      this._canvasEle.addEventListener(
        this._getWheelEventName(),
        this._pointerWheelEvent,
        this._getPassive() ? { passive: false } : false
      );
    }
    _getWheelEventName() {
      const wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
      return wheelEventName;
    }
    _getPassive() {
      let passiveSupported = false;
      const noop2 = () => {
      };
      try {
        const options = {
          passive: {
            get() {
              passiveSupported = true;
            }
          }
        };
        this._canvasEle.addEventListener("test", noop2, options);
        this._canvasEle.removeEventListener("test", noop2, options);
      } catch (e) {
      }
      return passiveSupported;
    }
    _getPointerType(evt) {
      let deviceType = 2 /* Mouse */;
      if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
        deviceType = 3 /* Touch */;
      }
      return deviceType;
    }
    _matchMediaHandler() {
      if (!(window == null ? void 0 : window.matchMedia)) {
        return;
      }
      const mediaQueryList = window.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      const _handleMediaChange = () => {
        this.resize();
      };
      mediaQueryList.addEventListener("change", _handleMediaChange);
      this.disposeWithMe(
        toDisposable(() => {
          mediaQueryList.removeEventListener("change", _handleMediaChange);
        })
      );
    }
  };

  // ../packages/engine-render/src/group.ts
  var Group = class extends BaseObject {
    constructor(key, ...objects) {
      super(key);
      __publicField(this, "_objects", []);
      this.addObjects(...objects);
    }
    get classType() {
      return "Group" /* GROUP */;
    }
    set cursor(val) {
      this.setCursor(val);
    }
    addObjects(...objects) {
      for (const object of objects) {
        this.addObject(object);
      }
    }
    addObject(o) {
      let object = o;
      if (isString(o)) {
        const scene = this.getScene();
        object = scene == null ? void 0 : scene.getObject(o);
        if (!object) {
          return;
        }
        object.parent = this;
        object.isInGroup = true;
        object.groupKey = this.oKey;
        this._objects.push(object);
      } else {
        o.parent = this;
        o.isInGroup = true;
        o.groupKey = this.oKey;
        this._objects.push(o);
      }
    }
    removeObject(object) {
      const objects = this.getObjects();
      const objectsLength = objects.length;
      if (isString(object)) {
        for (let i = 0; i < objectsLength; i++) {
          const o = objects[i];
          if (o.oKey === object) {
            objects.splice(i, 1);
            this.parent.removeObject(o);
            return;
          }
        }
      } else {
        for (let i = 0; i < objectsLength; i++) {
          const o = objects[i];
          if (o === object) {
            objects.splice(i, 1);
            this.parent.removeObject(o);
            return;
          }
        }
      }
    }
    getObjectsByOrder() {
      const objects = [];
      this._objects.sort(sortRules);
      for (const o of this._objects) {
        if (!o.isInGroup && o.visible) {
          objects.push(o);
        }
      }
      return objects;
    }
    getObjects() {
      return this._objects;
    }
    render(ctx, bounds) {
      ctx.save();
      const m = this.transform.getMatrix();
      ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
      this._objects.sort(sortRules);
      for (const object of this._objects) {
        object.render(ctx, this._transformBounds(bounds));
      }
      ctx.restore();
    }
    resize(width, height) {
      return this;
    }
    scale(scaleX, scaleY) {
      return this;
    }
    skew(skewX, skewY) {
      return this;
    }
    flip(flipX, flipY) {
      return this;
    }
    // 判断自己scope下的所有对象是否有被选中的
    isHit(coord) {
      return true;
    }
    // 判断被选中的唯一对象
    pick(coord) {
    }
    dispose() {
      this.getObjects().forEach((o) => {
        o.dispose();
      });
      super.dispose();
    }
    _transformBounds(bounds) {
      return bounds;
    }
  };

  // ../packages/engine-render/src/layer.ts
  var Layer = class extends Disposable {
    constructor(_scene, objects = [], _zIndex = 1, _allowCache = false) {
      super();
      this._scene = _scene;
      this._zIndex = _zIndex;
      this._allowCache = _allowCache;
      __publicField(this, "_objects", []);
      __publicField(this, "_cacheCanvas");
      __publicField(this, "_dirty", true);
      this.addObjects(objects);
      if (this._allowCache) {
        this._initialCacheCanvas();
      }
    }
    get scene() {
      return this._scene;
    }
    get zIndex() {
      return this._zIndex;
    }
    enableCache() {
      this._allowCache = true;
      this._initialCacheCanvas();
    }
    disableCache() {
      var _a2;
      this._allowCache = false;
      (_a2 = this._cacheCanvas) == null ? void 0 : _a2.dispose();
      this._cacheCanvas = null;
    }
    isAllowCache() {
      return this._allowCache;
    }
    getObjectsByOrder() {
      const objects = [];
      this._objects.sort(sortRules);
      for (const o of this._objects) {
        if (!o.isInGroup && o.visible) {
          objects.push(o);
        }
      }
      return objects;
    }
    getObjectsByOrderForPick() {
      const objects = [];
      this._objects.sort(sortRules);
      for (const o of this._objects) {
        if (!(o.classType === "Group" /* GROUP */) && o.visible) {
          objects.push(o);
        }
      }
      return objects;
    }
    getObjects() {
      return this._objects;
    }
    addObject(o) {
      if (o.classType === "Group" /* GROUP */) {
        const objects = o.getObjects();
        for (const object of objects) {
          if (this.scene.getObject(object.oKey)) {
            continue;
          }
          this._objects.push(object);
          this.scene.setObjectBehavior(object);
          this._layerBehavior(object);
        }
      }
      this._objects.push(o);
      this.scene.setObjectBehavior(o);
      this._layerBehavior(o);
      this.scene.applyTransformer(o);
      return this;
    }
    removeObject(object) {
      const objects = this.getObjects();
      const objectsLength = objects.length;
      if (object instanceof BaseObject) {
        for (let i = 0; i < objectsLength; i++) {
          const o = objects[i];
          if (o === object) {
            objects.splice(i, 1);
            return;
          }
        }
      } else {
        for (let i = 0; i < objectsLength; i++) {
          const o = objects[i];
          if (o.oKey === object) {
            objects.splice(i, 1);
            return;
          }
        }
      }
    }
    addObjects(objects) {
      objects.forEach((o) => {
        this.addObject(o);
      });
      return this;
    }
    removeObjects(objects) {
      const allObjects = this.getObjects();
      const allObjectsLength = allObjects.length;
      for (let i = allObjectsLength - 1; i >= 0; i--) {
        let o = allObjects[i];
        const objectsLength = objects.length;
        if (objectsLength === 0)
          break;
        for (let j = 0; j < objectsLength; j++) {
          const object = objects[j];
          o = object instanceof BaseObject ? o : o.oKey;
          if (o === object) {
            allObjects.splice(i, 1);
            break;
          }
        }
      }
    }
    makeDirty(state = true) {
      this._dirty = state;
      const parent = this.scene.getParent();
      if (parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        parent.makeDirty(true);
      }
      return this;
    }
    isDirty() {
      return this._dirty;
    }
    render(parentCtx, isMaxLayer = false) {
      var _a2;
      const mainCtx = parentCtx || ((_a2 = this._scene.getEngine()) == null ? void 0 : _a2.getCanvas().getContext());
      if (this._allowCache && this._cacheCanvas) {
        if (this.isDirty()) {
          const ctx = this._cacheCanvas.getContext();
          this._cacheCanvas.clear();
          ctx.save();
          ctx.setTransform(mainCtx.getTransform());
          this._draw(ctx, isMaxLayer);
          ctx.restore();
        }
        this._applyCache(mainCtx);
      } else {
        mainCtx.save();
        this._draw(mainCtx, isMaxLayer);
        mainCtx.restore();
      }
      this.makeDirty(false);
      return this;
    }
    _layerBehavior(o) {
      this.disposeWithMe(
        toDisposable(
          o.onTransformChangeObservable.add(() => {
            this.makeDirty(true);
          })
        )
      );
      o.layer = this;
    }
    _initialCacheCanvas() {
      this._cacheCanvas = new Canvas();
      this.disposeWithMe(
        toDisposable(
          this._scene.getEngine().onTransformChangeObservable.add(() => {
            this._resizeCacheCanvas();
          })
        )
      );
    }
    _draw(mainCtx, isMaxLayer) {
      var _a2;
      (_a2 = this._scene.getViewports()) == null ? void 0 : _a2.forEach((vp) => vp.render(mainCtx, this.getObjectsByOrder(), isMaxLayer));
    }
    _applyCache(ctx) {
      if (!ctx || this._cacheCanvas == null) {
        return;
      }
      const width = this._cacheCanvas.getWidth();
      const height = this._cacheCanvas.getHeight();
      ctx.drawImage(this._cacheCanvas.getCanvasEle(), 0, 0, width, height);
    }
    _resizeCacheCanvas() {
      var _a2;
      const engine = this._scene.getEngine();
      (_a2 = this._cacheCanvas) == null ? void 0 : _a2.setSize(engine.width, engine.height);
      this.makeDirty(true);
    }
    clear() {
      this._objects = [];
    }
    dispose() {
      var _a2;
      super.dispose();
      this.getObjects().forEach((o) => {
        o.dispose();
      });
      this.clear();
      (_a2 = this._cacheCanvas) == null ? void 0 : _a2.dispose();
    }
  };

  // ../packages/engine-render/src/scroll-timer.ts
  var ScrollTimer = class _ScrollTimer {
    constructor(_scene, _scrollTimerType = 3 /* ALL */, _padding, _smoothRatioX = 0.4, _smoothRatioY = 0.1) {
      this._scene = _scene;
      this._scrollTimerType = _scrollTimerType;
      this._padding = _padding;
      this._smoothRatioX = _smoothRatioX;
      this._smoothRatioY = _smoothRatioY;
      __publicField(this, "_requestNewFrameNumber", -1);
      __publicField(this, "_viewport");
      __publicField(this, "_offsetX", 0);
      __publicField(this, "_offsetY", 0);
      __publicField(this, "_moveX", 0);
      __publicField(this, "_moveY", 0);
      __publicField(this, "_scrollX", 0);
      __publicField(this, "_scrollY", 0);
      __publicField(this, "_scrollFunction");
      if (!this._padding) {
        this._padding = { t: 0, b: 15, l: 0, r: 60 };
      }
    }
    static create(scene, scrollTimerType = 3 /* ALL */, padding) {
      return new _ScrollTimer(scene, scrollTimerType, padding);
    }
    set scrollTimerType(type) {
      this._scrollTimerType = type;
    }
    get scrollTimerType() {
      return this._scrollTimerType;
    }
    setActiveViewport(viewport) {
      this._viewport = viewport;
    }
    getActiveViewport() {
      return this._viewport;
    }
    startScroll(offsetX, offsetY, targetViewport) {
      this._offsetX = offsetX;
      this._offsetY = offsetY;
      this._moveX = offsetX;
      this._moveY = offsetY;
      if (targetViewport != null) {
        this._viewport = targetViewport;
      } else {
        this._viewport = this.getViewportByCoord(this._scene);
      }
      this._runRenderLoop();
    }
    _scroll(viewport) {
      const topBounding = (viewport == null ? void 0 : viewport.top) || 0;
      const bottomBounding = topBounding + ((viewport == null ? void 0 : viewport.height) || 0);
      const leftBounding = (viewport == null ? void 0 : viewport.left) || 0;
      const rightBounding = leftBounding + ((viewport == null ? void 0 : viewport.width) || 0);
      const { t = 0, b = 0, r = 0, l = 0 } = this._padding;
      let x = 0;
      let y = 0;
      let shouldScroll = false;
      if (this._scrollTimerType & 1 /* X */) {
        if (this._moveX < leftBounding + l) {
          x = (this._moveX - leftBounding - l) * this._smoothRatioX;
          shouldScroll = true;
        }
        if (this._moveX > rightBounding - r) {
          x = (this._moveX - rightBounding + r) * this._smoothRatioX;
          shouldScroll = true;
        }
      }
      if (this._scrollTimerType & 2 /* Y */) {
        if (this._moveY < topBounding + t) {
          y = (this._moveY - topBounding - t) * this._smoothRatioY;
          shouldScroll = true;
        }
        if (this._moveY > bottomBounding - b) {
          y = (this._moveY - bottomBounding + b) * this._smoothRatioY;
          shouldScroll = true;
        }
      }
      if (!shouldScroll) {
        return;
      }
      const limited = viewport == null ? void 0 : viewport.scrollBy({
        x,
        y
      });
      const actualScroll = viewport == null ? void 0 : viewport.getActualScroll(x, y);
      this._scrollX = (actualScroll == null ? void 0 : actualScroll.x) || 0;
      this._scrollY = (actualScroll == null ? void 0 : actualScroll.y) || 0;
      if (limited) {
        const ancestorScene = this._findAncestorScene(viewport == null ? void 0 : viewport.scene);
        const newViewport = this.getViewportByCoord(ancestorScene);
        if (newViewport) {
          this._scroll(newViewport);
        }
      }
    }
    scrolling(offsetX, offsetY, scrollFunction) {
      this._moveX = offsetX;
      this._moveY = offsetY;
      this._scrollFunction = scrollFunction;
    }
    stopScroll() {
      cancelRequestFrame(this._requestNewFrameNumber);
    }
    dispose() {
      this.stopScroll();
      delete this._scrollFunction;
    }
    getViewportByCoord(scene) {
      return scene == null ? void 0 : scene.getActiveViewportByRelativeCoord(Vector2.FromArray([this._offsetX, this._offsetY]));
    }
    getScene() {
      return this._scene;
    }
    _runRenderLoop() {
      this._scroll(this._viewport);
      this._scrollFunction && this._scrollFunction(this._scrollX, this._scrollY);
      this._requestNewFrameNumber = requestNewFrame(this._runRenderLoop.bind(this));
    }
    _findAncestorScene(scene) {
      let parent = scene == null ? void 0 : scene.getParent();
      while (parent) {
        if (parent.classType === "Scene" /* SCENE */) {
          return parent;
        }
        parent = (parent == null ? void 0 : parent.getParent) && (parent == null ? void 0 : parent.getParent());
      }
    }
  };

  // ../packages/engine-render/src/shape/rect.ts
  var RECT_OBJECT_ARRAY = ["radius"];
  var Rect = class _Rect extends Shape {
    constructor(key, props) {
      super(key, props);
      __publicField(this, "_radius", 0);
      if (props == null ? void 0 : props.radius) {
        this._radius = props.radius;
      }
    }
    get radius() {
      return this._radius;
    }
    static drawWith(ctx, props) {
      let { radius, width, height } = props;
      radius = radius != null ? radius : 0;
      width = width != null ? width : 30;
      height = height != null ? height : 30;
      ctx.beginPath();
      if (props.strokeDashArray) {
        ctx.setLineDash(props.strokeDashArray);
      }
      if (!radius) {
        ctx.rect(0, 0, width, height);
      } else {
        let topLeft = 0;
        let topRight = 0;
        let bottomLeft = 0;
        let bottomRight = 0;
        topLeft = topRight = bottomLeft = bottomRight = Math.min(radius, width / 2, height / 2);
        ctx.moveTo(topLeft, 0);
        ctx.lineTo(width - topRight, 0);
        ctx.arc(width - topRight, topRight, topRight, Math.PI * 3 / 2, 0, false);
        ctx.lineTo(width, height - bottomRight);
        ctx.arc(width - bottomRight, height - bottomRight, bottomRight, 0, Math.PI / 2, false);
        ctx.lineTo(bottomLeft, height);
        ctx.arc(bottomLeft, height - bottomLeft, bottomLeft, Math.PI / 2, Math.PI, false);
        ctx.lineTo(0, topLeft);
        ctx.arc(topLeft, topLeft, topLeft, Math.PI, Math.PI * 3 / 2, false);
      }
      ctx.closePath();
      this._renderPaintInOrder(ctx, props);
    }
    toJson() {
      const props = {};
      RECT_OBJECT_ARRAY.forEach((key) => {
        if (this[key]) {
          props[key] = this[key];
        }
      });
      return {
        ...super.toJson(),
        ...props
      };
    }
    _draw(ctx) {
      _Rect.drawWith(ctx, this);
    }
  };

  // ../packages/engine-render/src/scene.transformer.ts
  var TransformerManagerTypeArray = [
    "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */,
    "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */,
    "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */,
    "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */,
    "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */,
    "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */,
    "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */,
    "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */
  ];
  var Transformer = class extends Disposable {
    constructor(_scene, config2) {
      super();
      this._scene = _scene;
      __publicField(this, "hoverEnabled", false);
      __publicField(this, "hoverEnterFunc");
      __publicField(this, "hoverLeaveFunc");
      __publicField(this, "resizeEnabled", true);
      __publicField(this, "rotateEnabled", true);
      __publicField(this, "rotationSnaps", []);
      __publicField(this, "rotationSnapTolerance", 5);
      __publicField(this, "rotateAnchorOffset", 50);
      __publicField(this, "rotateSize", 10);
      __publicField(this, "rotateCornerRadius", 10);
      __publicField(this, "borderEnabled", true);
      __publicField(this, "borderStroke", "rgb(97, 97, 97)");
      __publicField(this, "borderStrokeWidth", 1);
      __publicField(this, "borderDash", []);
      __publicField(this, "borderSpacing", 10);
      __publicField(this, "anchorFill", "rgb(255,255,255)");
      __publicField(this, "anchorStroke", "rgb(185,185,185)");
      __publicField(this, "anchorStrokeWidth", 1);
      __publicField(this, "anchorSize", 10);
      __publicField(this, "anchorCornerRadius", 10);
      __publicField(this, "keepRatio", true);
      __publicField(this, "centeredScaling", false);
      /**
       * leftTop centerTop rightTop
       * leftMiddle rightMiddle
       * leftBottom centerBottom rightBottom
       */
      __publicField(this, "enabledAnchors", [1, 1, 1, 1, 1, 1, 1, 1]);
      __publicField(this, "flipEnabled", false);
      __publicField(this, "ignoreStroke", false);
      __publicField(this, "boundBoxFunc");
      __publicField(this, "useSingleNodeRotation", false);
      __publicField(this, "shouldOverdrawWholeArea", false);
      __publicField(this, "onChangeStartObservable", new Observable2());
      __publicField(this, "onChangingObservable", new Observable2());
      __publicField(this, "onChangeEndObservable", new Observable2());
      __publicField(this, "onClearControlObservable", new Observable2());
      __publicField(this, "onCreateControlObservable", new Observable2());
      __publicField(this, "_startOffsetX", -1);
      __publicField(this, "_startOffsetY", -1);
      __publicField(this, "_viewportScrollX", -1);
      __publicField(this, "_viewportScrollY", -1);
      __publicField(this, "_moveObserver");
      __publicField(this, "_upObserver");
      __publicField(this, "_cancelFocusObserver");
      __publicField(this, "_transformerControlMap", /* @__PURE__ */ new Map());
      __publicField(this, "_selectedObjectMap", /* @__PURE__ */ new Map());
      this._initialProps(config2);
    }
    getScene() {
      return this._scene;
    }
    hideControl() {
      this._hideControl();
    }
    attachTo(applyObject) {
      if (!applyObject.isTransformer) {
        return;
      }
      if (this.hoverEnabled) {
        this.hoverEnterFunc && applyObject.onPointerEnterObserver.add(this.hoverEnterFunc);
        this.hoverLeaveFunc && applyObject.onPointerLeaveObserver.add(this.hoverLeaveFunc);
      }
      this.disposeWithMe(
        toDisposable(
          applyObject.onPointerDownObserver.add((evt, state) => {
            const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
            this._startOffsetX = evtOffsetX;
            this._startOffsetY = evtOffsetY;
            const scene = this._getTopScene();
            if (!scene) {
              return;
            }
            this._addCancelObserver(scene);
            scene.disableEvent();
            const scrollTimer = ScrollTimer.create(scene);
            scrollTimer.startScroll(evtOffsetX, evtOffsetY);
            const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
            this._viewportScrollX = scrollX2;
            this._viewportScrollY = scrollY2;
            this._updateActiveObjectList(applyObject, evt);
            this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
              const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
              this._moving(moveOffsetX, moveOffsetY, scrollTimer);
              this._hideControl();
              scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
                this._moving(moveOffsetX, moveOffsetY, scrollTimer);
              });
            });
            this._upObserver = scene.onPointerUpObserver.add(() => {
              scene.onPointerMoveObserver.remove(this._moveObserver);
              scene.onPointerUpObserver.remove(this._upObserver);
              scene.enableEvent();
              this._updateControl();
              scrollTimer.dispose();
              this.onChangeEndObservable.notifyObservers({
                objects: this._selectedObjectMap,
                type: 2 /* MOVE_END */
              });
            });
            state.stopPropagation();
          })
        )
      );
      return applyObject;
    }
    dispose() {
      var _a2, _b2, _c;
      (_a2 = this._moveObserver) == null ? void 0 : _a2.dispose();
      (_b2 = this._upObserver) == null ? void 0 : _b2.dispose();
      (_c = this._cancelFocusObserver) == null ? void 0 : _c.dispose();
      this._moveObserver = null;
      this._upObserver = null;
      this._cancelFocusObserver = null;
      this._transformerControlMap.forEach((control) => {
        control.dispose();
      });
      this._selectedObjectMap.forEach((control) => {
        control.dispose();
      });
      this.onChangeStartObservable.clear();
      this.onChangingObservable.clear();
      this.onChangeEndObservable.clear();
    }
    _initialProps(props) {
      if (!props) {
        return;
      }
      const propsKeys = Object.keys(props);
      if (propsKeys.length === 0) {
        return;
      }
      propsKeys.forEach((key) => {
        if (props[key] === void 0) {
          return true;
        }
        this[key] = props[key];
      });
    }
    _updateControlChildren() {
      this._updateControlIterator((control, applyObject) => {
        const { left, top, width, height, scaleX, scaleY } = applyObject.getState();
        const children = control.getObjects();
        children.forEach((o) => {
          const key = o.oKey;
          const type = this._checkTransformerType(key);
          if (!type) {
            return true;
          }
          if (type === "__SpreadsheetTransformerOutline__" /* OUTLINE */) {
            o.transformByState(this._getOutlinePosition(width, height, scaleX, scaleY));
          } else {
            const { left: left2, top: top2 } = this._getRotateAnchorPosition(type, height, width);
            o.transformByState({
              left: left2,
              top: top2
            });
          }
        });
        control.transformByState({
          left,
          top
        });
      });
    }
    _anchorMoving(type, moveOffsetX, moveOffsetY, scrollTimer) {
      const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
      const x = moveOffsetX - this._viewportScrollX + scrollX2;
      const y = moveOffsetY - this._viewportScrollY + scrollY2;
      const moveLeft = x - this._startOffsetX;
      const moveTop = y - this._startOffsetY;
      this._selectedObjectMap.forEach((moveObject) => {
        const { left, top, width, height } = moveObject;
        const state = {};
        switch (type) {
          case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
            state.left = left + moveLeft;
            state.top = top + moveTop;
            state.width = width - moveLeft;
            state.height = height - moveTop;
            break;
          case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
            state.top = top + moveTop;
            state.height = height - moveTop;
            break;
          case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
            state.top = top + moveTop;
            state.width = width + moveLeft;
            state.height = height - moveTop;
            break;
          case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
            state.left = left + moveLeft;
            state.width = width - moveLeft;
            break;
          case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
            state.width = moveLeft + width;
            break;
          case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
            state.left = left + moveLeft;
            state.width = width - moveLeft;
            state.height = height + moveTop;
            break;
          case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
            state.height = moveTop + height;
            break;
          case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
            state.width = moveLeft + width;
            state.height = moveTop + height;
            break;
        }
        moveObject.transformByState(state);
      });
      this._updateControlChildren();
      this.onChangingObservable.notifyObservers({
        objects: this._selectedObjectMap,
        moveX: moveLeft,
        moveY: moveTop,
        type: 1 /* MOVING */
      });
      this._startOffsetX = x;
      this._startOffsetY = y;
    }
    _attachEventToAnchor(anchor, type = "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */) {
      this.disposeWithMe(
        toDisposable(
          anchor.onPointerDownObserver.add((evt, state) => {
            const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
            this._startOffsetX = evtOffsetX;
            this._startOffsetY = evtOffsetY;
            const scene = this._getTopScene();
            if (scene == null) {
              return;
            }
            scene.disableEvent();
            const scrollTimer = ScrollTimer.create(scene);
            scrollTimer.startScroll(evtOffsetX, evtOffsetY);
            const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
            this._viewportScrollX = scrollX2;
            this._viewportScrollY = scrollY2;
            const cursor = this._getRotateAnchorCursor(type);
            this._moveObserver = scene.onPointerMoveObserver.add((moveEvt) => {
              const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
              this._anchorMoving(type, moveOffsetX, moveOffsetY, scrollTimer);
              scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
                this._anchorMoving(type, moveOffsetX, moveOffsetY, scrollTimer);
              });
              scene.setCursor(cursor);
            });
            this._upObserver = scene.onPointerUpObserver.add(() => {
              scene.onPointerMoveObserver.remove(this._moveObserver);
              scene.onPointerUpObserver.remove(this._upObserver);
              scene.enableEvent();
              scene.resetCursor();
              scrollTimer.dispose();
              this.onChangeEndObservable.notifyObservers({
                objects: this._selectedObjectMap,
                type: 2 /* MOVE_END */
              });
            });
            state.stopPropagation();
          })
        )
      );
    }
    _attachEventToRotate(rotateControl) {
      this.disposeWithMe(
        toDisposable(
          rotateControl.onPointerDownObserver.add((evt, state) => {
            const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
            this._startOffsetX = evtOffsetX;
            this._startOffsetY = evtOffsetY;
            const scene = this._getTopScene();
            if (scene == null) {
              return;
            }
            scene.disableEvent();
            this._viewportScrollX = scrollX;
            this._viewportScrollY = scrollY;
            this._upObserver = scene.onPointerUpObserver.add(() => {
              scene.onPointerMoveObserver.remove(this._moveObserver);
              scene.onPointerUpObserver.remove(this._upObserver);
              scene.enableEvent();
            });
            state.stopPropagation();
          })
        )
      );
    }
    _getOutlinePosition(width, height, scaleX, scaleY) {
      return {
        left: -this.borderSpacing - this.borderStrokeWidth,
        top: -this.borderSpacing - this.borderStrokeWidth,
        width: width + this.borderSpacing * 2,
        height: height + this.borderSpacing * 2
      };
    }
    _getRotateAnchorCursor(type) {
      let cursor = "nw-resize" /* NORTH_WEST_RESIZE */;
      switch (type) {
        case "__SpreadsheetTransformerRotate__" /* ROTATE */:
          cursor = "move" /* MOVE */;
          break;
        case "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */:
          cursor = "move" /* MOVE */;
          break;
        case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
          break;
        case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
          cursor = "n-resize" /* NORTH_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
          cursor = "ne-resize" /* NORTH_EAST_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
          cursor = "w-resize" /* WEST_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
          cursor = "e-resize" /* EAST_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
          cursor = "sw-resize" /* SOUTH_WEST_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
          cursor = "s-resize" /* SOUTH_RESIZE */;
          break;
        case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
          cursor = "se-resize" /* SOUTH_EAST_RESIZE */;
          break;
      }
      return cursor;
    }
    _getRotateAnchorPosition(type, height, width) {
      let left = -this.anchorSize / 2;
      let top = -this.anchorSize / 2;
      switch (type) {
        case "__SpreadsheetTransformerRotate__" /* ROTATE */:
          left = width / 2 - this.rotateSize / 2;
          top = -this.rotateAnchorOffset - this.borderSpacing - this.borderStrokeWidth * 2 - this.rotateSize;
          break;
        case "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */:
          left = width / 2;
          top = -this.rotateAnchorOffset - this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */:
          left += -this.borderSpacing - this.borderStrokeWidth;
          top += -this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */:
          left += width / 2;
          top += -this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */:
          left += width + this.borderSpacing - this.borderStrokeWidth;
          top += -this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */:
          left += -this.borderSpacing - this.borderStrokeWidth;
          top += height / 2;
          break;
        case "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */:
          left += width + this.borderSpacing - this.borderStrokeWidth;
          top += height / 2;
          break;
        case "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */:
          left += -this.borderSpacing - this.borderStrokeWidth;
          top += height + this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */:
          left += width / 2;
          top += height + this.borderSpacing - this.borderStrokeWidth;
          break;
        case "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */:
          left += width + this.borderSpacing - this.borderStrokeWidth;
          top += height + this.borderSpacing - this.borderStrokeWidth;
          break;
      }
      return {
        left,
        top
      };
    }
    _createResizeAnchor(type, applyObject, zIndex) {
      const { height, width, scaleX, scaleY } = applyObject.getState();
      const { left, top } = this._getRotateAnchorPosition(type, height, width);
      const cursor = this._getRotateAnchorCursor(type);
      const anchor = new Rect(`${type}_${zIndex}`, {
        zIndex: zIndex - 1,
        fill: this.anchorFill,
        stroke: this.anchorStroke,
        strokeWidth: this.anchorStrokeWidth,
        width: this.anchorSize,
        height: this.anchorSize,
        radius: this.anchorCornerRadius,
        left,
        top
      });
      this._attachHover(anchor, cursor, "default" /* DEFAULT */);
      return anchor;
    }
    _checkTransformerType(oKey) {
      if (oKey.indexOf("__SpreadsheetTransformerOutline__" /* OUTLINE */) > -1) {
        return "__SpreadsheetTransformerOutline__" /* OUTLINE */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerRotate__" /* ROTATE */) > -1) {
        return "__SpreadsheetTransformerRotate__" /* ROTATE */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */) > -1) {
        return "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */) > -1) {
        return "__SpreadsheetTransformerResizeLT__" /* RESIZE_LT */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */) > -1) {
        return "__SpreadsheetTransformerResizeCT__" /* RESIZE_CT */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */) > -1) {
        return "__SpreadsheetTransformerResizeRT__" /* RESIZE_RT */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */) > -1) {
        return "__SpreadsheetTransformerResizeLM__" /* RESIZE_LM */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */) > -1) {
        return "__SpreadsheetTransformerResizeRM__" /* RESIZE_RM */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */) > -1) {
        return "__SpreadsheetTransformerResizeLB__" /* RESIZE_LB */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */) > -1) {
        return "__SpreadsheetTransformerResizeCB__" /* RESIZE_CB */;
      }
      if (oKey.indexOf("__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */) > -1) {
        return "__SpreadsheetTransformerResizeRB__" /* RESIZE_RB */;
      }
    }
    _updateControlIterator(func) {
      this._transformerControlMap.forEach((control, oKey) => {
        const applyObject = this._selectedObjectMap.get(oKey);
        if (!applyObject) {
          return true;
        }
        func(control, applyObject);
      });
    }
    _updateControl() {
      this._updateControlIterator((control, applyObject) => {
        const { left, top } = applyObject.getState();
        control.transformByState({
          left,
          top
        });
        control.show();
        control.makeDirty(true);
      });
    }
    _hideControl() {
      this._transformerControlMap.forEach((control) => {
        control.hide();
        control.makeDirty(true);
      });
    }
    _attachHover(o, cursorIn, cursorOut) {
      this.disposeWithMe(
        toDisposable(
          o.onPointerEnterObserver.add(() => {
            o.cursor = cursorIn;
          })
        )
      );
      this.disposeWithMe(
        toDisposable(
          o.onPointerLeaveObserver.add(() => {
            o.cursor = cursorOut;
          })
        )
      );
    }
    _clearControl() {
      this._transformerControlMap.forEach((control) => {
        control.dispose();
      });
      this._transformerControlMap.clear();
      this.onClearControlObservable.notifyObservers(null);
    }
    _createControl(applyObject) {
      const { left, top, height, width, angle, scaleX, scaleY, skewX, skewY, flipX, flipY } = applyObject.getState();
      const oKey = applyObject.oKey;
      const zIndex = this._selectedObjectMap.size;
      const groupElements = [];
      if (this.borderEnabled) {
        const outline = new Rect(`${"__SpreadsheetTransformerOutline__" /* OUTLINE */}_${zIndex}`, {
          zIndex: zIndex - 1,
          evented: false,
          strokeWidth: this.borderStrokeWidth,
          stroke: this.borderStroke,
          ...this._getOutlinePosition(width, height, scaleX, scaleY)
        });
        groupElements.push(outline);
      }
      if (this.resizeEnabled) {
        const { left: lineLeft, top: lineTop } = this._getRotateAnchorPosition(
          "__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */,
          height,
          width
        );
        const rotateLine = new Rect(`${"__SpreadsheetTransformerRotateLine__" /* ROTATE_LINE */}_${zIndex}`, {
          zIndex: zIndex - 1,
          evented: false,
          left: lineLeft,
          top: lineTop,
          height: this.rotateAnchorOffset,
          width: 1,
          strokeWidth: this.borderStrokeWidth,
          stroke: this.borderStroke
        });
        const { left: left2, top: top2 } = this._getRotateAnchorPosition("__SpreadsheetTransformerRotate__" /* ROTATE */, height, width);
        const cursor = this._getRotateAnchorCursor("__SpreadsheetTransformerRotate__" /* ROTATE */);
        const rotate2 = new Rect(`${"__SpreadsheetTransformerRotate__" /* ROTATE */}_${zIndex}`, {
          zIndex: zIndex - 1,
          left: left2,
          top: top2,
          height: this.rotateSize,
          width: this.rotateSize,
          radius: this.rotateCornerRadius,
          strokeWidth: this.borderStrokeWidth * 2,
          stroke: this.borderStroke
        });
        this._attachEventToRotate(rotate2);
        this._attachHover(rotate2, cursor, "default" /* DEFAULT */);
        groupElements.push(rotateLine, rotate2);
      }
      if (this.resizeEnabled) {
        for (let i = 0, len = this.enabledAnchors.length; i < len; i++) {
          const isEnable = this.enabledAnchors[i];
          if (isEnable !== 1) {
            continue;
          }
          const type = TransformerManagerTypeArray[i];
          const anchor = this._createResizeAnchor(type, applyObject, zIndex);
          this._attachEventToAnchor(anchor, type);
          groupElements.push(anchor);
        }
      }
      const transformerControl = new Group(`${"__SpreadsheetTransformer__" /* GROUP */}_${zIndex}`, ...groupElements);
      transformerControl.zIndex = zIndex;
      transformerControl.evented = false;
      transformerControl.transformByState({
        left,
        top
      });
      const scene = this.getScene();
      scene.addObject(transformerControl, 2);
      this._transformerControlMap.set(oKey, transformerControl);
      this.onCreateControlObservable.notifyObservers(transformerControl);
      return transformerControl;
    }
    _getTopScene() {
      var _a2;
      const currentScene = this.getScene();
      return (_a2 = currentScene.getEngine()) == null ? void 0 : _a2.activeScene;
    }
    _moving(moveOffsetX, moveOffsetY, scrollTimer) {
      const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
      const x = moveOffsetX - this._viewportScrollX + scrollX2;
      const y = moveOffsetY - this._viewportScrollY + scrollY2;
      const moveLeft = x - this._startOffsetX;
      const moveTop = y - this._startOffsetY;
      this._selectedObjectMap.forEach((moveObject) => {
        moveObject.translate(moveLeft + moveObject.left, moveTop + moveObject.top);
      });
      this.onChangingObservable.notifyObservers({
        objects: this._selectedObjectMap,
        moveX: moveLeft,
        moveY: moveTop,
        type: 1 /* MOVING */
      });
      this._startOffsetX = x;
      this._startOffsetY = y;
    }
    _updateActiveObjectList(applyObject, evt) {
      if (this._selectedObjectMap.has(applyObject.oKey)) {
        return;
      }
      if (!evt.ctrlKey) {
        this._selectedObjectMap.clear();
        this._clearControl();
      }
      this._selectedObjectMap.set(applyObject.oKey, applyObject);
      this._createControl(applyObject);
    }
    _addCancelObserver(scene) {
      scene.onPointerDownObserver.remove(this._cancelFocusObserver);
      this._cancelFocusObserver = scene.onPointerDownObserver.add(() => {
        this._selectedObjectMap.clear();
        this._clearControl();
        scene.onPointerDownObserver.remove(this._cancelFocusObserver);
      });
    }
  };

  // ../packages/engine-render/src/scene.input-manager.ts
  var _InputManager = class _InputManager extends Disposable {
    constructor(scene) {
      super();
      /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */
      __publicField(this, "_alreadyAttached", false);
      // private _alreadyAttachedTo: HTMLElement;
      // WorkBookObserver
      __publicField(this, "_onInputObserver");
      // Pointers
      __publicField(this, "_onPointerMove");
      __publicField(this, "_onPointerDown");
      __publicField(this, "_onPointerUp");
      __publicField(this, "_onPointerEnter");
      __publicField(this, "_onPointerLeave");
      __publicField(this, "_onMouseWheel");
      // Keyboard
      __publicField(this, "_onKeyDown");
      __publicField(this, "_onKeyUp");
      __publicField(this, "_scene");
      __publicField(this, "_currentMouseEnterPicked");
      __publicField(this, "_startingPosition", new Vector2(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY));
      __publicField(this, "_delayedTimeout", -1);
      __publicField(this, "_delayedTripeTimeout", -1);
      __publicField(this, "_doubleClickOccurred", 0);
      __publicField(this, "_tripleClickState", false);
      __publicField(this, "_currentObject");
      this._scene = scene;
    }
    // Handle events such as triggering mouseleave and mouseenter.
    mouseLeaveEnterHandler(evt) {
      var _a2;
      const o = this._currentObject;
      if (o === null || o === void 0) {
        (_a2 = this._currentMouseEnterPicked) == null ? void 0 : _a2.triggerPointerLeave(evt);
        this._currentMouseEnterPicked = null;
      } else if (o !== this._currentMouseEnterPicked) {
        const previousPicked = this._currentMouseEnterPicked;
        this._currentMouseEnterPicked = o;
        previousPicked == null ? void 0 : previousPicked.triggerPointerLeave(evt);
        o == null ? void 0 : o.triggerPointerEnter(evt);
      }
    }
    attachControl(hasDown = true, hasUp = true, hasMove = true, hasWheel = true, hasEnter = true, hasLeave = true) {
      const engine = this._scene.getEngine();
      if (!engine) {
        return;
      }
      this._onPointerEnter = (evt) => {
        var _a2;
        if (evt.pointerId === void 0) {
          evt.pointerId = 0;
        }
        this._currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = (_a2 = this._currentObject) == null ? void 0 : _a2.triggerPointerMove(evt);
        this.mouseLeaveEnterHandler(evt);
      };
      this._onPointerLeave = (evt) => {
        if (evt.pointerId === void 0) {
          evt.pointerId = 0;
        }
        this._currentObject = null;
        this.mouseLeaveEnterHandler(evt);
      };
      this._onPointerMove = (evt) => {
        var _a2;
        if (evt.pointerId === void 0) {
          evt.pointerId = 0;
        }
        this._currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = (_a2 = this._currentObject) == null ? void 0 : _a2.triggerPointerMove(evt);
        this.mouseLeaveEnterHandler(evt);
        if (this._checkDirectSceneEventTrigger(!isStop, this._currentObject)) {
          if (this._scene.onPointerMoveObserver.hasObservers()) {
            this._scene.onPointerMoveObserver.notifyObservers(evt);
          }
        }
      };
      this._onPointerDown = (evt) => {
        if (evt.pointerId === void 0) {
          evt.pointerId = 0;
        }
        const currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = currentObject == null ? void 0 : currentObject.triggerPointerDown(evt);
        if (this._checkDirectSceneEventTrigger(!isStop, currentObject)) {
          if (this._scene.onPointerDownObserver.hasObservers()) {
            this._scene.onPointerDownObserver.notifyObservers(evt);
          }
        }
      };
      this._onPointerUp = (evt) => {
        if (evt.pointerId === void 0) {
          evt.pointerId = 0;
        }
        const currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = currentObject == null ? void 0 : currentObject.triggerPointerUp(evt);
        if (this._checkDirectSceneEventTrigger(!isStop, currentObject)) {
          if (this._scene.onPointerUpObserver.hasObservers()) {
            this._scene.onPointerUpObserver.notifyObservers(evt);
          }
        }
        this._prePointerDoubleOrTripleClick(evt);
      };
      this._onMouseWheel = (evt) => {
        const currentObject = this._getCurrentObject(evt.offsetX, evt.offsetY);
        const isStop = currentObject == null ? void 0 : currentObject.triggerMouseWheel(evt);
        this._scene.getViewports().forEach((vp) => {
          if (vp.onMouseWheelObserver.hasObservers()) {
            vp.onMouseWheelObserver.notifyObservers(evt);
          }
        });
        if (this._checkDirectSceneEventTrigger(!isStop, currentObject)) {
          if (this._scene.onMouseWheelObserver.hasObservers()) {
            this._scene.onMouseWheelObserver.notifyObservers(evt);
          }
        }
      };
      this._onKeyDown = (evt) => {
        if (this._scene.onKeyDownObservable.hasObservers()) {
          this._scene.onKeyDownObservable.notifyObservers(evt);
        }
      };
      this._onKeyUp = (evt) => {
        if (this._scene.onKeyUpObservable.hasObservers()) {
          this._scene.onKeyUpObservable.notifyObservers(evt);
        }
      };
      this._onInputObserver = engine.onInputChangedObservable.add((eventData) => {
        const evt = eventData;
        if (eventData.deviceType === 1 /* Keyboard */) {
          if (eventData.currentState === 1) {
            this._onKeyDown(evt);
          }
          if (eventData.currentState === 0) {
            this._onKeyUp(evt);
          }
        }
        if (eventData.deviceType === 2 /* Mouse */ || eventData.deviceType === 3 /* Touch */) {
          if (hasDown && eventData.inputIndex >= 2 /* LeftClick */ && eventData.inputIndex <= 4 /* RightClick */ && eventData.currentState === 1) {
            this._onPointerDown(evt);
          }
          if (hasUp && eventData.inputIndex >= 2 /* LeftClick */ && eventData.inputIndex <= 4 /* RightClick */ && eventData.currentState === 0) {
            this._onPointerUp(evt);
          }
          if (hasMove && (eventData.inputIndex === 0 /* Horizontal */ || eventData.inputIndex === 1 /* Vertical */ || eventData.inputIndex === 10 /* DeltaHorizontal */ || eventData.inputIndex === 11 /* DeltaVertical */)) {
            this._onPointerMove(evt);
          } else if (hasWheel && (eventData.inputIndex === 7 /* MouseWheelX */ || eventData.inputIndex === 8 /* MouseWheelY */ || eventData.inputIndex === 9 /* MouseWheelZ */)) {
            this._onMouseWheel(evt);
          } else if (hasEnter && eventData.currentState === 2) {
            this._onPointerEnter(evt);
          } else if (hasLeave && eventData.currentState === 3) {
            this._onPointerLeave(evt);
          }
        }
      });
      this.disposeWithMe(
        toDisposable(
          this._onInputObserver
        )
      );
      this._alreadyAttached = true;
    }
    /**
     * Detaches all event handlers
     */
    detachControl() {
      if (!this._alreadyAttached) {
        return;
      }
      const engine = this._scene.getEngine();
      if (!engine) {
        return;
      }
      engine.onInputChangedObservable.remove(this._onInputObserver);
      this._alreadyAttached = false;
    }
    _getCurrentObject(offsetX, offsetY) {
      var _a2;
      return (_a2 = this._scene) == null ? void 0 : _a2.pick(Vector2.FromArray([offsetX, offsetY]));
    }
    _checkDirectSceneEventTrigger(isTrigger, currentObject) {
      let notObject = false;
      if (currentObject == null) {
        notObject = true;
      }
      let isNotInSceneViewer = true;
      if (currentObject && currentObject.classType === "BaseObject" /* BASE_OBJECT */) {
        const scene = currentObject.getScene();
        if (scene) {
          const parent = scene.getParent();
          isNotInSceneViewer = parent.classType !== "SceneViewer" /* SCENE_VIEWER */;
        }
      }
      return !this._scene.evented && isTrigger && isNotInSceneViewer || notObject;
    }
    /**
     * @hidden
     * @returns Boolean if delta for pointer exceeds drag movement threshold
     */
    _isPointerSwiping(pointerX, pointerY) {
      return Math.abs(this._startingPosition.x - pointerX) > _InputManager.DragMovementThreshold || Math.abs(this._startingPosition.y - pointerY) > _InputManager.DragMovementThreshold;
    }
    _prePointerDoubleOrTripleClick(evt) {
      var _a2, _b2, _c, _d;
      const { clientX, clientY } = evt;
      const isMoveThreshold = this._isPointerSwiping(clientX, clientY);
      if (isMoveThreshold) {
        this._resetDoubleClickParam();
      }
      this._delayedTimeout = setTimeout(() => {
        this._resetDoubleClickParam();
      }, _InputManager.DoubleClickDelay);
      this._doubleClickOccurred += 1;
      if (this._tripleClickState) {
        (_b2 = (_a2 = this._scene) == null ? void 0 : _a2.pick(Vector2.FromArray([evt.offsetX, evt.offsetY]))) == null ? void 0 : _b2.triggerTripleClick(evt);
        if (this._scene.onTripleClickObserver.hasObservers()) {
          this._scene.onTripleClickObserver.notifyObservers(evt);
        }
      }
      if (this._doubleClickOccurred === 2) {
        (_d = (_c = this._scene) == null ? void 0 : _c.pick(Vector2.FromArray([evt.offsetX, evt.offsetY]))) == null ? void 0 : _d.triggerDblclick(evt);
        if (this._scene.onDblclickObserver.hasObservers()) {
          this._scene.onDblclickObserver.notifyObservers(evt);
        }
        this._resetDoubleClickParam();
        this._tripleClickState = true;
        clearTimeout(this._delayedTripeTimeout);
        this._delayedTripeTimeout = setTimeout(() => {
          this._tripleClickState = false;
        }, _InputManager.TripleClickDelay);
      }
      this._startingPosition.x = clientX;
      this._startingPosition.y = clientY;
    }
    _resetDoubleClickParam() {
      this._doubleClickOccurred = 0;
      clearTimeout(this._delayedTimeout);
    }
  };
  /** The distance in pixel that you have to move to prevent some events */
  __publicField(_InputManager, "DragMovementThreshold", 2);
  // in pixels
  /** Time in milliseconds to wait to raise long press events if button is still pressed */
  __publicField(_InputManager, "LongPressDelay", 500);
  // in milliseconds
  /** Time in milliseconds with two consecutive clicks will be considered as a double or triple click */
  __publicField(_InputManager, "DoubleClickDelay", 500);
  // in milliseconds
  __publicField(_InputManager, "TripleClickDelay", 300);
  // in milliseconds
  /** If you need to check double click without raising a single click at first click, enable this flag */
  __publicField(_InputManager, "ExclusiveDoubleClickMode", false);
  var InputManager = _InputManager;

  // ../packages/engine-render/src/thin-scene.ts
  var ThinScene = class extends Disposable {
    constructor(sceneKey) {
      super();
      __publicField(this, "onTransformChangeObservable", new Observable2());
      __publicField(this, "onFileLoadedObservable", new Observable2());
      __publicField(this, "onPointerDownObserver", new Observable2());
      __publicField(this, "onPointerMoveObserver", new Observable2());
      __publicField(this, "onPointerUpObserver", new Observable2());
      __publicField(this, "onPointerEnterObserver", new Observable2());
      __publicField(this, "onPointerLeaveObserver", new Observable2());
      __publicField(this, "onDblclickObserver", new Observable2());
      __publicField(this, "onTripleClickObserver", new Observable2());
      __publicField(this, "onMouseWheelObserver", new Observable2());
      __publicField(this, "onKeyDownObservable", new Observable2());
      __publicField(this, "onKeyUpObservable", new Observable2());
      __publicField(this, "debounceParentTimeout", -1);
      __publicField(this, "_sceneKey", "");
      __publicField(this, "_width", 100);
      __publicField(this, "_height", 100);
      __publicField(this, "_scaleX", 1);
      __publicField(this, "_scaleY", 1);
      __publicField(this, "_transform", new Transform());
      __publicField(this, "_evented", true);
      this._sceneKey = sceneKey;
    }
    get classType() {
      return "Scene" /* SCENE */;
    }
    get transform() {
      return this._transform;
    }
    get width() {
      return this._width;
    }
    get height() {
      return this._height;
    }
    get scaleX() {
      return this._scaleX;
    }
    get scaleY() {
      return this._scaleY;
    }
    get sceneKey() {
      return this._sceneKey;
    }
    get evented() {
      return this._evented;
    }
    set transform(trans) {
      this._transform = trans;
    }
    set width(num) {
      this._width = num;
    }
    set height(num) {
      this._height = num;
    }
    set scaleX(scaleX) {
      this._scaleX = scaleX;
    }
    set scaleY(scaleY) {
      this._scaleY = scaleY;
    }
    enableEvent() {
      this._evented = true;
    }
    disableEvent() {
      this._evented = false;
    }
    on(eventType, func) {
      const observable2 = this[`on${eventType}Observer`];
      const observer = observable2.add(func.bind(this));
      return observer;
    }
    off(eventType, observer) {
      const observable2 = this[`on${eventType}Observer`];
      observable2.remove(observer);
    }
    remove(eventType) {
      const observable2 = this[`on${eventType}Observer`];
      observable2.clear();
    }
    triggerKeyDown(evt) {
      this.onKeyDownObservable.notifyObservers(evt);
    }
    triggerKeyUp(evt) {
      this.onKeyUpObservable.notifyObservers(evt);
    }
    triggerPointerUp(evt) {
    }
    triggerMouseWheel(evt) {
    }
    triggerPointerMove(evt) {
    }
    triggerDblclick(evt) {
    }
    triggerTripleClick(evt) {
    }
    triggerPointerDown(evt) {
    }
    triggerPointerOut(evt) {
    }
    triggerPointerLeave(evt) {
    }
    triggerPointerOver(evt) {
    }
    triggerPointerEnter(evt) {
    }
    renderObjects(ctx, bounds) {
    }
    render(parentCtx) {
    }
    getParent() {
    }
    dispose() {
      super.dispose();
    }
    getObject(oKey) {
    }
    addObject(o, zIndex = 1) {
    }
    addObjects(objects, zIndex = 1) {
    }
    getEngine() {
    }
    setObjectBehavior(o) {
    }
    applyTransformer(o) {
    }
    makeDirtyNoParent(state = true) {
      return this;
    }
    makeDirty(state = true) {
      return this;
    }
    pick(coord) {
    }
    getViewports() {
      return [];
    }
    addViewport(...viewport) {
    }
    removeViewport(key) {
    }
    getAncestorScale() {
      return {
        scaleX: 1,
        scaleY: 1
      };
    }
    getPrecisionScale() {
      return {
        scaleX: 1,
        scaleY: 1
      };
    }
    setCursor(val) {
    }
    resetCursor() {
    }
  };

  // ../packages/engine-render/src/scene.ts
  var Scene = class extends ThinScene {
    constructor(sceneKey, _parent, state) {
      var _a2;
      super(sceneKey);
      this._parent = _parent;
      __publicField(this, "_layers", []);
      __publicField(this, "_viewports", []);
      __publicField(this, "_cursor", "default" /* DEFAULT */);
      __publicField(this, "_defaultCursor", "default" /* DEFAULT */);
      __publicField(this, "_addObject$", new BehaviorSubject(this));
      __publicField(this, "addObject$", this._addObject$.asObservable());
      /**
       * Transformer constructor.  Transformer is a special type of group that allow you transform
       * primitives and shapes. Transforming tool is not changing `width` and `height` properties of nodes
       * when you resize them. Instead it changes `scaleX` and `scaleY` properties.
       */
      __publicField(this, "_transformer");
      __publicField(this, "_transformerOpenState", false);
      /** @hidden */
      __publicField(this, "_inputManager");
      if (state) {
        this.transformByState(state);
      }
      if (this._parent.classType === "Engine" /* ENGINE */) {
        const parent = this._parent;
        parent.addScene(this);
        if (!parent.hasActiveScene()) {
          parent.setActiveScene(sceneKey);
        }
        this._inputManager = new InputManager(this);
      } else if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        const parent = this._parent;
        parent.addSubScene(this);
      }
      this.disposeWithMe(
        toDisposable(
          (_a2 = this._parent) == null ? void 0 : _a2.onTransformChangeObservable.add((change) => {
            this._setTransForm();
          })
        )
      );
    }
    get ancestorScaleX() {
      const p = this.getParent();
      let pScale = 1;
      if (p.classType === "SceneViewer" /* SCENE_VIEWER */) {
        pScale = p.ancestorScaleX;
      }
      return this.scaleX * pScale;
    }
    get ancestorScaleY() {
      const p = this.getParent();
      let pScale = 1;
      if (p.classType === "SceneViewer" /* SCENE_VIEWER */) {
        pScale = p.ancestorScaleY;
      }
      return this.scaleY * pScale;
    }
    set cursor(val) {
      this.setCursor(val);
    }
    attachControl(hasDown = true, hasUp = true, hasMove = true, hasWheel = true) {
      var _a2;
      if (!(this._parent.classType === "Engine" /* ENGINE */)) {
        return;
      }
      (_a2 = this._inputManager) == null ? void 0 : _a2.attachControl(hasDown, hasUp, hasMove, hasWheel);
      return this;
    }
    detachControl() {
      var _a2;
      (_a2 = this._inputManager) == null ? void 0 : _a2.detachControl();
      return this;
    }
    makeDirty(state = true) {
      var _a2;
      this._layers.forEach((layer) => {
        layer.makeDirty(state);
      });
      if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_a2 = this._parent) == null ? void 0 : _a2.makeDirty(state);
      }
      return this;
    }
    makeDirtyNoParent(state = true) {
      this._layers.forEach((layer) => {
        layer.makeDirty(state);
      });
      return this;
    }
    enableLayerCache(...layerIndexes) {
      layerIndexes.forEach((zIndex) => {
        this.getLayer(zIndex).enableCache();
      });
    }
    disableLayerCache(...layerIndexes) {
      layerIndexes.forEach((zIndex) => {
        this.getLayer(zIndex).disableCache();
      });
    }
    isDirty() {
      for (let i = 0; i < this._layers.length; i++) {
        const layer = this._layers[i];
        if (layer.isDirty() === true) {
          return true;
        }
      }
      return false;
    }
    getCursor() {
      return this._cursor;
    }
    resetCursor() {
      this.setCursor(this._defaultCursor);
    }
    setCursor(val) {
      this._cursor = val;
      const engine = this.getEngine();
      if (!engine) {
        return;
      }
      engine.setCanvasCursor(val);
    }
    setDefaultCursor(val) {
      this._defaultCursor = val;
      this.resetCursor();
    }
    resize(width, height) {
      const preWidth = this.width;
      if (width !== void 0) {
        this.width = width;
      }
      const preHeight = this.height;
      if (height !== void 0) {
        this.height = height;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 1 /* resize */,
        value: {
          width: this.width,
          height: this.height
        },
        preValue: { width: preWidth, height: preHeight }
      });
      return this;
    }
    /**
     * scale to value, absolute
     */
    scale(scaleX, scaleY) {
      const preScaleX = this.scaleX;
      if (scaleX !== void 0) {
        this.scaleX = scaleX;
      }
      const preScaleY = this.scaleY;
      if (scaleY !== void 0) {
        this.scaleY = scaleY;
      }
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 2 /* scale */,
        value: {
          scaleX: this.scaleX,
          scaleY: this.scaleY
        },
        preValue: { scaleX: preScaleX, scaleY: preScaleY }
      });
      return this;
    }
    /**
     * current scale plus offset, relative
     */
    scaleBy(scaleX, scaleY) {
      const preScaleX = this.scaleX;
      if (scaleX !== void 0) {
        this.scaleX += scaleX;
      }
      const preScaleY = this.scaleY;
      if (scaleY !== void 0) {
        this.scaleY += scaleY;
      }
      this.scaleX = precisionTo(this.scaleX, 1);
      this.scaleY = precisionTo(this.scaleY, 1);
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 2 /* scale */,
        value: {
          scaleX: this.scaleX,
          scaleY: this.scaleY
        },
        preValue: { scaleX: preScaleX, scaleY: preScaleY }
      });
      return this;
    }
    transformByState(state) {
      const optionKeys = Object.keys(state);
      const preKeys = {};
      if (optionKeys.length === 0) {
        return;
      }
      optionKeys.forEach((pKey) => {
        if (state[pKey] !== void 0) {
          preKeys[pKey] = this[pKey];
          this[pKey] = state[pKey];
        }
      });
      this._setTransForm();
      this.onTransformChangeObservable.notifyObservers({
        type: 5 /* all */,
        value: state,
        preValue: preKeys
      });
    }
    getParent() {
      return this._parent;
    }
    getEngine() {
      if (this._parent.classType === "Engine" /* ENGINE */) {
        return this._parent;
      }
      let parent = this._parent;
      while (parent) {
        if (parent.classType === "Engine" /* ENGINE */) {
          return parent;
        }
        parent = parent == null ? void 0 : parent.getParent();
      }
      return null;
    }
    getLayers() {
      return this._layers;
    }
    getLayer(zIndex = 1) {
      for (const layer of this._layers) {
        if (layer.zIndex === zIndex) {
          return layer;
        }
      }
      return this._createDefaultLayer(zIndex);
    }
    getLayerMaxZIndex() {
      let maxIndex = Number.MIN_VALUE;
      for (let i = 0; i < this._layers.length; i++) {
        const layer = this._layers[i];
        if (layer.zIndex >= maxIndex) {
          maxIndex = layer.zIndex;
        }
      }
      return maxIndex;
    }
    addLayer(...argument) {
      this._layers.push(...argument);
    }
    addObject(o, zIndex = 1) {
      var _a2;
      (_a2 = this.getLayer(zIndex)) == null ? void 0 : _a2.addObject(o);
      this._addObject$.next(this);
      return this;
    }
    setObjectBehavior(o) {
      if (!o.parent) {
        o.parent = this;
      }
      o.onIsAddedToParentObserver.notifyObservers(this);
    }
    addObjects(objects, zIndex = 1) {
      var _a2;
      (_a2 = this.getLayer(zIndex)) == null ? void 0 : _a2.addObjects(objects);
      this._addObject$.next(this);
      return this;
    }
    removeObject(object) {
      if (object == null) {
        return;
      }
      const layers = this.getLayers();
      for (const layer of layers) {
        layer.removeObject(object);
      }
      return this;
    }
    removeObjects(objects) {
      if (objects == null) {
        return;
      }
      const layers = this.getLayers();
      for (const layer of layers) {
        layer.removeObjects(objects);
      }
      return this;
    }
    // addBackObjects(...argument: BaseObject[]) {
    //     argument.forEach((o: BaseObject) => {
    //         this.addObjectBack(o);
    //     });
    //     return this;
    // }
    // addForwardObjects(...argument: BaseObject[]) {
    //     argument.forEach((o: BaseObject) => {
    //         this.addObjectForward(o);
    //     });
    //     return this;
    // }
    getAllObjects() {
      const objects = [];
      this._layers.sort(sortRules);
      for (const layer of this._layers) {
        objects.push(...layer.getObjectsByOrder());
      }
      return objects;
    }
    getAllObjectsByOrder(isDesc = false) {
      const objects = [];
      const useSortRules = isDesc ? sortRulesByDesc : sortRules;
      this._layers.sort(useSortRules);
      for (const layer of this._layers) {
        objects.push(...layer.getObjectsByOrder().sort(useSortRules));
      }
      return objects;
    }
    getAllObjectsByOrderForPick(isDesc = false) {
      const objects = [];
      const useSortRules = isDesc ? sortRulesByDesc : sortRules;
      this._layers.sort(useSortRules);
      for (const layer of this._layers) {
        objects.push(...layer.getObjectsByOrderForPick().sort(useSortRules));
      }
      return objects;
    }
    getObject(oKey) {
      for (const layer of this._layers) {
        const objects = layer.getObjectsByOrder();
        for (const object of objects) {
          if (object.oKey === oKey) {
            return object;
          }
        }
      }
    }
    fuzzyMathObjects(oKey) {
      const objects = [];
      for (const layer of this._layers) {
        const objects2 = layer.getObjectsByOrder();
        for (const object of objects2) {
          if (object.oKey.indexOf(oKey) > -1) {
            objects2.push(object);
          }
        }
      }
      return objects;
    }
    addViewport(...viewport) {
      this._viewports.push(...viewport);
      return this;
    }
    removeViewport(key) {
      for (let i = 0, len = this._viewports.length; i < len; i++) {
        const viewport = this._viewports[i];
        if (viewport.viewPortKey === key) {
          this._viewports.splice(i, 1);
          return viewport;
        }
      }
    }
    getViewports() {
      return this._viewports;
    }
    getViewport(key) {
      for (const viewport of this._viewports) {
        if (viewport.viewPortKey === key) {
          return viewport;
        }
      }
    }
    changeObjectOrder() {
    }
    // override renderObjects(ctx: UniverRenderingContext, bounds?: IViewportBound) {
    //     this.getAllObjectsByOrder().forEach((o) => {
    //         o.render(ctx, bounds);
    //     });
    //     return this;
    // }
    render(parentCtx) {
      var _a2;
      if (!this.isDirty()) {
        return;
      }
      !parentCtx && ((_a2 = this.getEngine()) == null ? void 0 : _a2.clearCanvas());
      const layers = this._layers.sort(sortRules);
      for (let i = 0, len = layers.length; i < len; i++) {
        layers[i].render(parentCtx, i === len - 1);
      }
    }
    async requestRender(parentCtx) {
      return new Promise((resolve, reject) => {
        this.render(parentCtx);
        requestNewFrame(resolve);
      });
    }
    openTransformer(config2) {
      if (!this._transformer) {
        this._transformer = new Transformer(this, config2);
      }
      this._transformerOpenState = true;
    }
    closeTransformer(isDestroyed = false) {
      if (isDestroyed) {
        this._transformer = null;
      }
      this._transformerOpenState = false;
    }
    applyTransformer(o) {
      var _a2;
      if (!this._transformerOpenState) {
        return;
      }
      (_a2 = this._transformer) == null ? void 0 : _a2.attachTo(o);
    }
    getTransformer() {
      return this._transformer;
    }
    getActiveViewportByRelativeCoord(coord) {
      return this._viewports.find((vp) => vp.isHit(coord));
    }
    getActiveViewportByCoord(coord) {
      coord = this.getRelativeCoord(coord);
      return this.getActiveViewportByRelativeCoord(coord);
    }
    getScrollXYByRelativeCoords(coord, viewPort) {
      if (!viewPort) {
        viewPort = this.getActiveViewportByRelativeCoord(coord);
      }
      if (!viewPort) {
        return {
          x: 0,
          y: 0
        };
      }
      return this.getScrollXY(viewPort);
    }
    getScrollXY(viewPort) {
      let x = 0;
      let y = 0;
      if (viewPort) {
        const actualX = viewPort.actualScrollX || 0;
        const actualY = viewPort.actualScrollY || 0;
        x += actualX;
        y += actualY;
      }
      return {
        x,
        y
      };
    }
    /**
     * In a nested scene scenario, it is necessary to obtain the relative offsets layer by layer.
     * @param coord Coordinates to be converted.
     * @returns
     */
    getRelativeCoord(coord) {
      let parent = this.getParent();
      const parentList = [];
      while (parent) {
        if (parent.classType === "Scene" /* SCENE */ || parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
          parentList.push(parent);
        }
        parent = (parent == null ? void 0 : parent.getParent) && (parent == null ? void 0 : parent.getParent());
      }
      parentList.reverse();
      for (const parent2 of parentList) {
        if (parent2.classType === "Scene" /* SCENE */) {
          const scene = parent2;
          const viewPort = scene.getActiveViewportByCoord(coord);
          if (viewPort) {
            const actualX = viewPort.actualScrollX || 0;
            const actualY = viewPort.actualScrollY || 0;
            coord = coord.addByPoint(actualX, actualY);
          }
        } else if (parent2.classType === "SceneViewer" /* SCENE_VIEWER */) {
          const sv = parent2;
          const transform = sv.transform.clone().invert();
          coord = transform.applyPoint(coord);
        }
      }
      return coord;
    }
    // transformToSceneCoord(coord: Vector2) {
    //     const pickedViewport = this.getActiveViewportByCoord(coord);
    //     return pickedViewport?.getRelativeVector(coord);
    // }
    clearLayer() {
      this._layers = [];
    }
    clearViewports() {
      this._viewports = [];
    }
    getAncestorScale() {
      let { scaleX = 1, scaleY = 1 } = this;
      if (this.classType === "SceneViewer" /* SCENE_VIEWER */) {
        scaleX = this.ancestorScaleX || 1;
        scaleY = this.ancestorScaleY || 1;
      }
      return {
        scaleX,
        scaleY
      };
    }
    getPrecisionScale() {
      var _a2;
      const pixelRatio = ((_a2 = this.getEngine()) == null ? void 0 : _a2.getPixelRatio()) || 1;
      const { scaleX, scaleY } = this.getAncestorScale();
      return {
        scaleX: scaleX * pixelRatio,
        scaleY: scaleY * pixelRatio
      };
    }
    dispose() {
      var _a2, _b2;
      this.getLayers().forEach((layer) => {
        layer.dispose();
      });
      this.getViewports().forEach((viewport) => {
        viewport.dispose();
      });
      this.clearLayer();
      this.clearViewports();
      this.detachControl();
      (_a2 = this.onTransformChangeObservable) == null ? void 0 : _a2.clear();
      (_b2 = this._transformer) == null ? void 0 : _b2.dispose();
      this.onPointerDownObserver.clear();
      this.onPointerMoveObserver.clear();
      this.onPointerUpObserver.clear();
      this.onPointerEnterObserver.clear();
      this.onPointerLeaveObserver.clear();
      this.onDblclickObserver.clear();
      this.onTripleClickObserver.clear();
      this.onMouseWheelObserver.clear();
      this.onKeyDownObservable.clear();
      this.onKeyUpObservable.clear();
      super.dispose();
    }
    // Determine the only object selected
    pick(coord) {
      let pickedViewport = this.getActiveViewportByCoord(coord);
      if (!pickedViewport) {
        pickedViewport = this._viewports[0];
      }
      if (!this.evented || !pickedViewport) {
        return;
      }
      const scrollBarRect = pickedViewport.pickScrollBar(coord);
      if (scrollBarRect) {
        return scrollBarRect;
      }
      const svCoordOrigin = pickedViewport.getRelativeVector(coord);
      let isPickedObject = null;
      const objectOrder = this.getAllObjectsByOrderForPick().reverse();
      const objectLength = objectOrder.length;
      for (let i = 0; i < objectLength; i++) {
        const o = objectOrder[i];
        if (!o.visible || !o.evented || o.classType === "Group" /* GROUP */) {
          continue;
        }
        let svCoord = svCoordOrigin;
        if (o.isInGroup && o.parent.classType === "Group" /* GROUP */) {
          const { cumLeft, cumTop } = this._getGroupCumLeftRight(o);
          svCoord = svCoord.clone().add(Vector2.FromArray([-cumLeft, -cumTop]));
        }
        if (o.isHit(svCoord)) {
          if (o.classType === "SceneViewer" /* SCENE_VIEWER */) {
            const pickedObject = o.pick(svCoord);
            if (pickedObject) {
              isPickedObject = pickedObject;
            } else {
              isPickedObject = o.getActiveSubScene();
            }
          } else {
            isPickedObject = o;
          }
          break;
        } else if (o.classType === "SceneViewer" /* SCENE_VIEWER */ && o.allowSelectedClipElement()) {
          const pickedObject = o.pick(svCoord);
          if (pickedObject) {
            isPickedObject = pickedObject;
            break;
          }
        }
      }
      if (!isPickedObject && this._parent.classType === "Engine" /* ENGINE */) {
        return this;
      }
      return isPickedObject;
    }
    triggerKeyDown(evt) {
      this.onKeyDownObservable.notifyObservers(evt);
    }
    triggerKeyUp(evt) {
      this.onKeyUpObservable.notifyObservers(evt);
    }
    triggerPointerUp(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerUpObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerUp(evt);
        return false;
      }
      return true;
    }
    triggerMouseWheel(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onMouseWheelObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerMouseWheel(evt);
        return false;
      }
      return true;
    }
    triggerPointerMove(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerMoveObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerMove(evt);
        return false;
      }
      return true;
    }
    triggerDblclick(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onDblclickObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerDblclick(evt);
        return false;
      }
      return true;
    }
    triggerTripleClick(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onTripleClickObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerTripleClick(evt);
        return false;
      }
      return true;
    }
    triggerPointerDown(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerDownObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerDown(evt);
        return false;
      }
      return true;
    }
    triggerPointerOut(evt) {
      var _a2;
      if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_a2 = this._parent) == null ? void 0 : _a2.triggerPointerOut(evt);
        return false;
      }
      return true;
    }
    triggerPointerLeave(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerLeaveObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerLeave(evt);
        return false;
      }
      return true;
    }
    triggerPointerOver(evt) {
      var _a2;
      if (this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_a2 = this._parent) == null ? void 0 : _a2.triggerPointerOver(evt);
        return false;
      }
      return true;
    }
    triggerPointerEnter(evt) {
      var _a2, _b2;
      if (!((_a2 = this.onPointerEnterObserver.notifyObservers(evt)) == null ? void 0 : _a2.stopPropagation) && this._parent.classType === "SceneViewer" /* SCENE_VIEWER */) {
        (_b2 = this._parent) == null ? void 0 : _b2.triggerPointerEnter(evt);
        return false;
      }
      return true;
    }
    _createDefaultLayer(zIndex = 1) {
      const defaultLayer = new Layer(this, [], zIndex);
      this.addLayer(defaultLayer);
      return defaultLayer;
    }
    _setTransForm() {
      const composeResult = Transform.create().composeMatrix({
        scaleX: this.scaleX,
        scaleY: this.scaleY
      });
      this.transform = composeResult;
      this.getViewports().forEach((vp) => {
        vp.resetSizeAndScrollBar();
      });
      this.makeDirty(true);
    }
    _getGroupCumLeftRight(object) {
      let parent = object.parent;
      let cumLeft = 0;
      let cumTop = 0;
      while (parent.classType === "Group" /* GROUP */) {
        const { left, top } = parent;
        cumLeft += left;
        cumTop += top;
        parent = parent.parent;
      }
      return { cumLeft, cumTop };
    }
  };

  // ../packages/engine-render/src/render-manager.service.ts
  var DEFAULT_SCENE_SIZE = { width: 1500, height: 1e3 };
  var SCENE_NAMESPACE = "_UNIVER_SCENE_";
  var RenderManagerService = class {
    constructor() {
      __publicField(this, "_defaultEngine");
      __publicField(this, "_currentUnitId", "");
      __publicField(this, "_renderMap", /* @__PURE__ */ new Map());
      __publicField(this, "_currentRender$", new BehaviorSubject(this._currentUnitId));
      __publicField(this, "currentRender$", this._currentRender$.asObservable());
      __publicField(this, "_createRender$", new BehaviorSubject(this._currentUnitId));
      __publicField(this, "createRender$", this._createRender$.asObservable());
    }
    get defaultEngine() {
      if (!this._defaultEngine) {
        this._defaultEngine = new Engine();
      }
      return this._defaultEngine;
    }
    dispose() {
      this._renderMap.forEach((item) => {
        this._disposeItem(item);
      });
      this._renderMap.clear();
      this._currentRender$.complete();
    }
    createRenderWithParent(unitId, parentUnitId) {
      const parent = this.getRenderById(parentUnitId);
      if (parent == null) {
        throw new Error("parent render is null");
      }
      const { scene, engine } = parent;
      const current = this._createRender(unitId, engine, false);
      const currentScene = current.scene;
      const sv = new SceneViewer(unitId);
      sv.addSubScene(currentScene);
      scene.addObject(sv);
      return current;
    }
    createRenderWithEngine(unitId, engine) {
      return this._createRender(unitId, engine, false);
    }
    create(unitId) {
      this._createRender$.next(unitId);
    }
    createRender(unitId) {
      const engine = new Engine();
      return this._createRender(unitId, engine);
    }
    _createRender(unitId, engine, isMainScene = true) {
      const existItem = this.getRenderById(unitId);
      let shouldDestroyEngine = true;
      if (existItem != null) {
        const existEngine = existItem.engine;
        if (existEngine === engine) {
          shouldDestroyEngine = false;
        }
      }
      this._disposeItem(existItem, shouldDestroyEngine);
      const { width, height } = DEFAULT_SCENE_SIZE;
      const scene = new Scene(SCENE_NAMESPACE + unitId, engine, {
        width,
        height
      });
      const item = {
        unitId,
        engine,
        scene,
        mainComponent: null,
        components: /* @__PURE__ */ new Map(),
        isMainScene
      };
      this.addItem(unitId, item);
      return item;
    }
    addItem(unitId, item) {
      this._renderMap.set(unitId, item);
    }
    removeItem(unitId) {
      const item = this._renderMap.get(unitId);
      if (item != null) {
        this._disposeItem(item);
      }
      this._renderMap.delete(unitId);
    }
    has(unitId) {
      return this._renderMap.has(unitId);
    }
    setCurrent(unitId) {
      this._currentUnitId = unitId;
      this._currentRender$.next(unitId);
    }
    getCurrent() {
      return this._renderMap.get(this._currentUnitId);
    }
    getFirst() {
      return [...this.getRenderAll().values()][0];
    }
    getRenderById(unitId) {
      return this._renderMap.get(unitId);
    }
    getRenderAll() {
      return this._renderMap;
    }
    _disposeItem(item, shouldDestroyEngine = true) {
      if (item == null) {
        return;
      }
      const { engine, scene, components, mainComponent } = item;
      components == null ? void 0 : components.forEach((component) => {
        component.dispose();
      });
      mainComponent == null ? void 0 : mainComponent.dispose();
      scene.dispose();
      if (shouldDestroyEngine) {
        engine.dispose();
      }
    }
  };
  var IRenderManagerService = createIdentifier("univer.render-manager-service");

  // ../packages/engine-render/src/render-engine.ts
  var IRenderingEngine = createIdentifier("univer.render-engine");
  var PLUGIN_NAME3 = "render-engine";
  var UniverRenderEnginePlugin = class extends Plugin {
    constructor(_config, _injector) {
      super(PLUGIN_NAME3);
      this._injector = _injector;
      this._injector.add([IRenderingEngine, { useFactory: () => new Engine() }]);
      this._injector.add([
        IRenderManagerService,
        {
          useClass: RenderManagerService
        }
      ]);
    }
  };
  __publicField(UniverRenderEnginePlugin, "type", 0 /* Univer */);
  UniverRenderEnginePlugin = __decorateClass([
    __decorateParam(1, Inject(Injector))
  ], UniverRenderEnginePlugin);

  // ../packages/engine-render/src/shape/regular-polygon.ts
  var REGULAR_POLYGON_OBJECT_ARRAY = ["pointsGroup"];
  var RegularPolygon = class _RegularPolygon extends Shape {
    constructor(key, props) {
      super(key, props);
      __publicField(this, "_pointsGroup");
      this._pointsGroup = (props == null ? void 0 : props.pointsGroup) || [[]];
      this._setFixBoundingBox();
      this.onTransformChangeObservable.add((changeState) => {
        const { type, value, preValue } = changeState;
        if (type === 1 /* resize */ || type === 5 /* all */) {
          this.resizePolygon(preValue);
        }
      });
    }
    get pointsGroup() {
      return this._pointsGroup;
    }
    static drawWith(ctx, props) {
      let { pointsGroup } = props;
      pointsGroup = pointsGroup != null ? pointsGroup : [[]];
      if (props.strokeDashArray) {
        ctx.setLineDash(props.strokeDashArray);
      }
      ctx.beginPath();
      for (const points of pointsGroup) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let n = 1; n < points.length; n++) {
          const point = points[n];
          ctx.lineTo(point.x, point.y);
        }
      }
      ctx.closePath();
      this._renderPaintInOrder(ctx, props);
    }
    updatePointGroup(pointGroup) {
      this._pointsGroup = pointGroup;
      this._setFixBoundingBox();
    }
    resizePolygon(preValue) {
      const { left, top, width, height } = this._getSelfRect();
      const { width: preWidth, height: preHeight } = preValue;
      let fixX;
      let fixY;
      if (!preWidth) {
        fixX = 0;
      } else {
        fixX = this.width - preWidth;
      }
      if (!preHeight) {
        fixY = 0;
      } else {
        fixY = this.height - preHeight;
      }
      const increaseScaleX = fixX / width;
      const increaseScaleY = fixY / height;
      this.scaleX += increaseScaleX;
      this.scaleY += increaseScaleY;
      this.left = this.left - left * increaseScaleX;
      this.top = this.top - top * increaseScaleY;
      this._setTransForm();
    }
    toJson() {
      const props = {};
      REGULAR_POLYGON_OBJECT_ARRAY.forEach((key) => {
        if (this[key]) {
          props[key] = this[key];
        }
      });
      return {
        ...super.toJson(),
        ...props
      };
    }
    getState() {
      const { left, top, width, height } = this.getRect();
      return {
        left,
        top,
        width,
        height,
        scaleX: this.scaleX,
        scaleY: this.scaleY,
        angle: this.angle,
        skewX: this.skewX,
        skewY: this.skewY,
        flipX: this.flipX,
        flipY: this.flipY
      };
    }
    getRect() {
      const { left, top, width, height } = this._getSelfRect();
      return {
        left: left * this.scaleX + this.left,
        top: top * this.scaleY + this.top,
        width: width * this.scaleX,
        height: height * this.scaleY
      };
    }
    _draw(ctx) {
      _RegularPolygon.drawWith(ctx, this);
    }
    _setFixBoundingBox() {
      const { width, height, left, top } = this._getSelfRect();
      this.left = this.left + left;
      this.top = this.top + top;
      this.width = width;
      this.height = height;
      const pointsGroup = this.pointsGroup;
      for (const points of pointsGroup) {
        for (const point of points) {
          point.x -= left;
          point.y -= top;
        }
      }
      this._setTransForm();
    }
    _getSelfRect() {
      const pointsGroup = this.pointsGroup;
      let minX = pointsGroup[0][0].x;
      let maxX = pointsGroup[0][0].x;
      let minY = pointsGroup[0][0].y;
      let maxY = pointsGroup[0][0].y;
      for (const points of pointsGroup) {
        for (const point of points) {
          minX = Math.min(minX, point.x);
          maxX = Math.max(maxX, point.x);
          minY = Math.min(minY, point.y);
          maxY = Math.max(maxY, point.y);
        }
      }
      return {
        left: minX,
        top: minY,
        width: maxX - minX,
        height: maxY - minY
      };
    }
  };

  // ../packages/engine-render/src/components/docs/text-selection/convert-cursor.ts
  var NodePositionType = /* @__PURE__ */ ((NodePositionType2) => {
    NodePositionType2[NodePositionType2["page"] = 0] = "page";
    NodePositionType2[NodePositionType2["section"] = 1] = "section";
    NodePositionType2[NodePositionType2["column"] = 2] = "column";
    NodePositionType2[NodePositionType2["line"] = 3] = "line";
    NodePositionType2[NodePositionType2["divide"] = 4] = "divide";
    NodePositionType2[NodePositionType2["glyph"] = 5] = "glyph";
    return NodePositionType2;
  })(NodePositionType || {});
  var NodePositionMap = {
    page: 0,
    section: 1,
    column: 2,
    line: 3,
    divide: 4,
    glyph: 5
  };
  function compareNodePositionLogic(pos1, pos2) {
    if (pos1.page > pos2.page) {
      return false;
    }
    if (pos1.page < pos2.page) {
      return true;
    }
    if (pos1.section > pos2.section) {
      return false;
    }
    if (pos1.section < pos2.section) {
      return true;
    }
    if (pos1.column > pos2.column) {
      return false;
    }
    if (pos1.column < pos2.column) {
      return true;
    }
    if (pos1.line > pos2.line) {
      return false;
    }
    if (pos1.line < pos2.line) {
      return true;
    }
    if (pos1.divide > pos2.divide) {
      return false;
    }
    if (pos1.divide < pos2.divide) {
      return true;
    }
    if (pos1.glyph > pos2.glyph) {
      return false;
    }
    if (pos1.glyph < pos2.glyph) {
      return true;
    }
    return true;
  }
  function compareNodePosition(pos1, pos2) {
    const compare2 = compareNodePositionLogic(pos1, pos2);
    if (compare2) {
      return {
        start: pos1,
        end: pos2
      };
    }
    return {
      start: pos2,
      end: pos1
    };
  }
  function getOneTextSelectionRange(rangeList) {
    const rangeCount = rangeList.length;
    if (rangeCount === 0) {
      return;
    }
    const firstCursor = rangeList[0];
    const lastCursor = rangeList[rangeCount - 1];
    const collapsed = rangeList.length === 1 && firstCursor.collapsed;
    return {
      startOffset: firstCursor.startOffset,
      endOffset: lastCursor.endOffset,
      collapsed
    };
  }
  function getOffsetInDivide(glyphGroup, startSpanIndex, endSpanIndex, st) {
    let startOffset = st;
    let endOffset = st;
    for (let i = 0; i < glyphGroup.length; i++) {
      const span = glyphGroup[i];
      const contentLength = span.count;
      if (i < startSpanIndex) {
        startOffset += contentLength;
      }
      if (i < endSpanIndex) {
        endOffset += contentLength;
      }
    }
    return {
      startOffset,
      endOffset
    };
  }
  var NodePositionConvertToCursor = class {
    constructor(_documentOffsetConfig, _docSkeleton) {
      this._documentOffsetConfig = _documentOffsetConfig;
      this._docSkeleton = _docSkeleton;
      __publicField(this, "_liquid", new Liquid());
      __publicField(this, "_currentStartState", {
        page: 0 /* NORMAL */,
        section: 0 /* NORMAL */,
        column: 0 /* NORMAL */,
        line: 0 /* NORMAL */,
        divide: 0 /* NORMAL */,
        glyph: 0 /* NORMAL */
      });
      __publicField(this, "_currentEndState", {
        page: 0 /* NORMAL */,
        section: 0 /* NORMAL */,
        column: 0 /* NORMAL */,
        line: 0 /* NORMAL */,
        divide: 0 /* NORMAL */,
        glyph: 0 /* NORMAL */
      });
    }
    getRangePointData(startOrigin, endOrigin) {
      const borderBoxPointGroup = [];
      const contentBoxPointGroup = [];
      const cursorList = [];
      if (startOrigin == null || endOrigin == null) {
        return {
          borderBoxPointGroup,
          contentBoxPointGroup,
          cursorList
        };
      }
      const { start, end } = compareNodePosition(startOrigin, endOrigin);
      this._selectionIterator(start, end, (start_sp, end_sp, isFirst, isLast, divide, line) => {
        const { lineHeight, marginTop, contentHeight } = line;
        const { glyphGroup, st } = divide;
        const { x: startX, y: startY } = this._liquid;
        let borderBoxPosition;
        let contentBoxPosition;
        const firstSpan = glyphGroup[start_sp];
        const lastSpan = glyphGroup[end_sp];
        const firstSpanLeft = (firstSpan == null ? void 0 : firstSpan.left) || 0;
        const firstSpanWidth = (firstSpan == null ? void 0 : firstSpan.width) || 0;
        const lastSpanLeft = (lastSpan == null ? void 0 : lastSpan.left) || 0;
        const lastSpanWidth = (lastSpan == null ? void 0 : lastSpan.width) || 0;
        const isCurrentList = (firstSpan == null ? void 0 : firstSpan.glyphType) === 2 /* LIST */;
        const { startOffset, endOffset } = getOffsetInDivide(glyphGroup, start_sp, end_sp, st);
        const isStartBack = start.glyph === start_sp && isFirst ? start.isBack : true;
        const isEndBack = end.glyph === end_sp && isLast ? end.isBack : false;
        const collapsed = start === end;
        if (start_sp === 0 && end_sp === glyphGroup.length - 1) {
          borderBoxPosition = {
            startX: startX + firstSpanLeft + (isCurrentList ? firstSpanWidth : 0),
            startY,
            endX: startX + lastSpanLeft + lastSpanWidth,
            endY: startY + lineHeight
          };
          contentBoxPosition = {
            startX: startX + firstSpanLeft + (isCurrentList ? firstSpanWidth : 0),
            startY: startY + marginTop,
            endX: startX + lastSpanLeft + lastSpanWidth,
            endY: startY + marginTop + contentHeight
          };
        } else {
          const isStartBackFin = isStartBack && !isCurrentList;
          borderBoxPosition = {
            startX: startX + firstSpanLeft + (isStartBackFin ? 0 : firstSpanWidth),
            startY,
            endX: startX + lastSpanLeft + (isEndBack ? 0 : lastSpanWidth),
            endY: startY + lineHeight
          };
          contentBoxPosition = {
            startX: startX + firstSpanLeft + (isStartBackFin ? 0 : firstSpanWidth),
            startY: startY + marginTop,
            endX: startX + lastSpanLeft + (isEndBack ? 0 : lastSpanWidth),
            endY: startY + marginTop + contentHeight
          };
        }
        borderBoxPointGroup.push(this._pushToPoints(borderBoxPosition));
        contentBoxPointGroup.push(this._pushToPoints(contentBoxPosition));
        cursorList.push({
          startOffset: isStartBack ? startOffset : startOffset + firstSpan.count,
          endOffset: isEndBack ? endOffset : endOffset + lastSpan.count,
          collapsed
        });
      });
      return {
        borderBoxPointGroup,
        contentBoxPointGroup,
        cursorList
      };
    }
    _resetCurrentNodePositionState() {
      this._currentStartState = {
        page: 0 /* NORMAL */,
        section: 0 /* NORMAL */,
        column: 0 /* NORMAL */,
        line: 0 /* NORMAL */,
        divide: 0 /* NORMAL */,
        glyph: 0 /* NORMAL */
      };
      this._currentEndState = {
        page: 0 /* NORMAL */,
        section: 0 /* NORMAL */,
        column: 0 /* NORMAL */,
        line: 0 /* NORMAL */,
        divide: 0 /* NORMAL */,
        glyph: 0 /* NORMAL */
      };
    }
    _setNodePositionState(type = 0 /* page */, start, end, current) {
      if (current === start) {
        this._currentStartState[type] = 1 /* START */;
      } else {
        this._currentStartState[type] = 0 /* NORMAL */;
      }
      if (current === end) {
        this._currentEndState[type] = 2 /* END */;
      } else {
        this._currentEndState[type] = 0 /* NORMAL */;
      }
    }
    _checkPreviousNodePositionState(typeIndex, isStart = true) {
      let index = typeIndex;
      let resultState;
      while (index >= 0) {
        const type = NodePositionType[index];
        let state;
        if (isStart) {
          state = this._currentStartState[type];
        } else {
          state = this._currentEndState[type];
        }
        if (state === void 0) {
          return;
        }
        if (resultState === void 0) {
          resultState = state;
        }
        if (state !== resultState) {
          return 0 /* NORMAL */;
        }
        index--;
      }
      return resultState;
    }
    _getSelectionRuler(typeIndex, startPosition, endPosition, nextLength, current) {
      let start_next = 0;
      let end_next = nextLength;
      const type = NodePositionType[typeIndex];
      const nextType = NodePositionType[typeIndex + 1];
      if (nextType === null || type === null) {
        return {
          start_next,
          end_next
        };
      }
      const start = startPosition[type];
      const end = endPosition[type];
      this._setNodePositionState(type, start, end, current);
      const preStartNestType = this._checkPreviousNodePositionState(typeIndex);
      const preEndNestType = this._checkPreviousNodePositionState(typeIndex, false);
      if (preStartNestType === 1 /* START */) {
        start_next = startPosition[nextType];
      }
      if (preEndNestType === 2 /* END */) {
        end_next = endPosition[nextType];
      }
      return {
        start_next,
        end_next
      };
    }
    _pushToPoints(position) {
      const { startX, startY, endX, endY } = position;
      const points = [];
      points.push({
        x: startX,
        y: startY
      });
      points.push({
        x: endX,
        y: startY
      });
      points.push({
        x: endX,
        y: endY
      });
      points.push({
        x: startX,
        y: endY
      });
      points.push({
        x: startX,
        y: startY
      });
      return points;
    }
    _selectionIterator(startPosition, endPosition, func) {
      const skeleton = this._docSkeleton;
      if (!skeleton) {
        return [];
      }
      this._liquid.reset();
      const skeletonData = skeleton.getSkeletonData();
      if (skeletonData == null) {
        return [];
      }
      const pages = skeletonData.pages;
      const { page: pageIndex } = startPosition;
      const { page: endPageIndex } = endPosition;
      this._resetCurrentNodePositionState();
      if (this._documentOffsetConfig == null) {
        return [];
      }
      const { pageLayoutType, pageMarginLeft, pageMarginTop } = this._documentOffsetConfig;
      for (let p = 0; p <= pageIndex - 1; p++) {
        const page = pages[p];
        this._liquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
      }
      for (let p = pageIndex; p <= endPageIndex; p++) {
        const page = pages[p];
        const sections = page.sections;
        const { start_next: start_s, end_next: end_s } = this._getSelectionRuler(
          NodePositionMap.page,
          startPosition,
          endPosition,
          sections.length - 1,
          p
        );
        this._liquid.translateSave();
        this._liquid.translatePagePadding(page);
        for (let s = start_s; s <= end_s; s++) {
          const section = sections[s];
          const columns = section.columns;
          const { start_next: start_c, end_next: end_c } = this._getSelectionRuler(
            NodePositionMap.section,
            startPosition,
            endPosition,
            columns.length - 1,
            s
          );
          this._liquid.translateSection(section);
          for (let c = start_c; c <= end_c; c++) {
            const column = columns[c];
            const lines = column.lines;
            const { start_next: start_l, end_next: end_l } = this._getSelectionRuler(
              NodePositionMap.column,
              startPosition,
              endPosition,
              lines.length - 1,
              c
            );
            this._liquid.translateColumn(column);
            for (let l = start_l; l <= end_l; l++) {
              const line = lines[l];
              const { divides } = line;
              const { start_next: start_d, end_next: end_d } = this._getSelectionRuler(
                NodePositionMap.line,
                startPosition,
                endPosition,
                divides.length - 1,
                l
              );
              this._liquid.translateSave();
              this._liquid.translateLine(line);
              for (let d = start_d; d <= end_d; d++) {
                const divide = divides[d];
                this._liquid.translateSave();
                this._liquid.translateDivide(divide);
                const glyphGroup = divide.glyphGroup;
                const { start_next: start_sp, end_next: end_sp } = this._getSelectionRuler(
                  NodePositionMap.divide,
                  startPosition,
                  endPosition,
                  glyphGroup.length - 1,
                  d
                );
                let isFirst = false;
                let isLast = false;
                if (p === pageIndex && s === start_s && c === start_c && l === start_l && d === start_d) {
                  isFirst = true;
                }
                if (p === endPageIndex && s === end_s && c === end_c && l === end_l && d === end_d) {
                  isLast = true;
                }
                func && func(start_sp, end_sp, isFirst, isLast, divide, line, column, section, page);
                this._liquid.translateRestore();
              }
              this._liquid.translateRestore();
            }
          }
        }
        this._liquid.translateRestore();
        this._liquid.translatePage(page, pageLayoutType, pageMarginLeft, pageMarginTop);
      }
    }
  };

  // ../packages/engine-render/src/components/docs/text-selection/text-range.ts
  var TEXT_RANGE_KEY_PREFIX = "__TestSelectionRange__";
  var TEXT_ANCHOR_KEY_PREFIX = "__TestSelectionAnchor__";
  var ID_LENGTH = 6;
  var BLINK_ON = 500;
  var BLINK_OFF = 500;
  var TEXT_RANGE_LAYER_INDEX = 1;
  function cursorConvertToTextRange(scene, range, docSkeleton, document2) {
    const { startOffset, endOffset, style = NORMAL_TEXT_SELECTION_PLUGIN_STYLE } = range;
    const anchorNodePosition = docSkeleton.findNodePositionByCharIndex(startOffset);
    const focusNodePosition = startOffset !== endOffset ? docSkeleton.findNodePositionByCharIndex(endOffset) : null;
    const textRange = new TextRange(scene, document2, docSkeleton, anchorNodePosition, focusNodePosition, style);
    textRange.refresh();
    return textRange;
  }
  function getAnchorBounding(pointsGroup) {
    const points = pointsGroup[0];
    const startPoint = points[0];
    const endPoint = points[2];
    const { x: startX, y: startY } = startPoint;
    const { x: endX, y: endY } = endPoint;
    return {
      left: startX,
      top: startY,
      width: endX - startX,
      height: endY - startY
    };
  }
  var TextRange = class {
    constructor(_scene, _document, _docSkeleton, anchorNodePosition, focusNodePosition, style = NORMAL_TEXT_SELECTION_PLUGIN_STYLE) {
      this._scene = _scene;
      this._document = _document;
      this._docSkeleton = _docSkeleton;
      this.anchorNodePosition = anchorNodePosition;
      this.focusNodePosition = focusNodePosition;
      this.style = style;
      // Identifies whether the range is the current one, most of which is the last range.
      __publicField(this, "_current", false);
      // The rendered range graphic when collapsed is false
      __publicField(this, "_rangeShape");
      // The rendered range graphic when collapsed is true
      __publicField(this, "_anchorShape");
      __publicField(this, "_cursorList", []);
      __publicField(this, "_anchorBlinkTimer", null);
      this._anchorBlink();
    }
    _anchorBlink() {
      setTimeout(() => {
        if (this._anchorShape) {
          if (this._anchorShape.visible) {
            this.deactivateStatic();
          }
        }
      }, BLINK_ON);
      this._anchorBlinkTimer = setInterval(() => {
        if (this._anchorShape) {
          if (this._anchorShape.visible) {
            this.activeStatic();
            setTimeout(() => {
              this.deactivateStatic();
            }, BLINK_ON);
          }
        }
      }, BLINK_OFF + BLINK_ON);
    }
    // The start position of the range
    get startOffset() {
      var _a2;
      const { startOffset } = (_a2 = getOneTextSelectionRange(this._cursorList)) != null ? _a2 : {};
      const body = this._docSkeleton.getViewModel().getBody();
      if (startOffset == null || body == null) {
        return startOffset;
      }
      const maxLength = body.dataStream.length - 2;
      return Math.min(maxLength, startOffset);
    }
    // The end position of the range
    get endOffset() {
      var _a2;
      const { endOffset } = (_a2 = getOneTextSelectionRange(this._cursorList)) != null ? _a2 : {};
      const body = this._docSkeleton.getViewModel().getBody();
      if (endOffset == null || body == null) {
        return endOffset;
      }
      const maxLength = body.dataStream.length - 2;
      return Math.min(endOffset, maxLength);
    }
    get collapsed() {
      const { startOffset, endOffset } = this;
      return startOffset != null && startOffset === endOffset;
    }
    get startNodePosition() {
      if (this.anchorNodePosition == null) {
        return null;
      }
      if (this.focusNodePosition == null) {
        return this.anchorNodePosition;
      }
      const { start } = compareNodePosition(this.anchorNodePosition, this.focusNodePosition);
      return start;
    }
    get endNodePosition() {
      if (this.anchorNodePosition == null) {
        return this.focusNodePosition;
      }
      if (this.focusNodePosition == null) {
        return null;
      }
      const { end } = compareNodePosition(this.anchorNodePosition, this.focusNodePosition);
      return end;
    }
    get direction() {
      const { collapsed, anchorNodePosition, focusNodePosition } = this;
      if (collapsed || anchorNodePosition == null || focusNodePosition == null) {
        return "none" /* NONE */;
      }
      const compare2 = compareNodePositionLogic(anchorNodePosition, focusNodePosition);
      return compare2 ? "forward" /* FORWARD */ : "backward" /* BACKWARD */;
    }
    getAnchor() {
      return this._anchorShape;
    }
    activeStatic() {
      var _a2, _b2;
      (_b2 = this._anchorShape) == null ? void 0 : _b2.setProps({
        stroke: ((_a2 = this.style) == null ? void 0 : _a2.strokeActive) || getColor(COLORS.black, 1)
      });
    }
    deactivateStatic() {
      var _a2, _b2;
      (_b2 = this._anchorShape) == null ? void 0 : _b2.setProps({
        stroke: ((_a2 = this.style) == null ? void 0 : _a2.stroke) || getColor(COLORS.black, 0)
      });
    }
    isActive() {
      return this._current === true;
    }
    activate() {
      this._current = true;
    }
    deactivate() {
      this._current = false;
    }
    dispose() {
      var _a2, _b2;
      (_a2 = this._rangeShape) == null ? void 0 : _a2.dispose();
      this._rangeShape = null;
      (_b2 = this._anchorShape) == null ? void 0 : _b2.dispose();
      this._anchorShape = null;
      if (this._anchorBlinkTimer) {
        clearInterval(this._anchorBlinkTimer);
        this._anchorBlinkTimer = null;
      }
    }
    isIntersection(compareRange) {
      const { startOffset: activeStart, endOffset: activeEnd } = this;
      const { startOffset: compareStart, endOffset: compareEnd } = compareRange;
      if (activeStart == null || activeEnd == null || compareStart == null || compareEnd == null) {
        return false;
      }
      return activeStart <= compareEnd && activeEnd >= compareStart;
    }
    refresh() {
      var _a2, _b2;
      const { _document, _docSkeleton } = this;
      const anchor = this.anchorNodePosition;
      const focus = this.focusNodePosition;
      (_a2 = this._anchorShape) == null ? void 0 : _a2.hide();
      (_b2 = this._rangeShape) == null ? void 0 : _b2.hide();
      if (this._isEmpty()) {
        return;
      }
      const documentOffsetConfig = _document.getOffsetConfig();
      const { docsLeft, docsTop } = documentOffsetConfig;
      const convertor = new NodePositionConvertToCursor(documentOffsetConfig, _docSkeleton);
      if (this._isCollapsed()) {
        const { contentBoxPointGroup, cursorList: cursorList2 } = convertor.getRangePointData(anchor, anchor);
        this._setCursorList(cursorList2);
        contentBoxPointGroup.length > 0 && this._createOrUpdateAnchor(contentBoxPointGroup, docsLeft, docsTop);
        return;
      }
      const { borderBoxPointGroup, cursorList } = convertor.getRangePointData(anchor, focus);
      this._setCursorList(cursorList);
      borderBoxPointGroup.length > 0 && this._createOrUpdateRange(borderBoxPointGroup, docsLeft, docsTop);
    }
    _isEmpty() {
      return this.anchorNodePosition == null && this.focusNodePosition == null;
    }
    _isCollapsed() {
      const anchor = this.anchorNodePosition;
      const focus = this.focusNodePosition;
      if (anchor != null && focus == null) {
        return true;
      }
      if (anchor == null || focus == null) {
        return false;
      }
      const keys = Object.keys(NodePositionMap);
      for (const key of keys) {
        const startNodeValue = anchor[key];
        const endNodeValue = focus[key];
        if (startNodeValue !== endNodeValue) {
          return false;
        }
      }
      if (anchor.isBack !== focus.isBack) {
        return false;
      }
      return true;
    }
    _createOrUpdateRange(pointsGroup, left, top) {
      var _a2;
      if (this._rangeShape) {
        this._rangeShape.translate(left, top);
        this._rangeShape.updatePointGroup(pointsGroup);
        this._rangeShape.show();
        return;
      }
      const OPACITY = 0.2;
      const polygon = new RegularPolygon(TEXT_RANGE_KEY_PREFIX + Tools.generateRandomId(ID_LENGTH), {
        pointsGroup,
        fill: ((_a2 = this.style) == null ? void 0 : _a2.fill) || getColor(COLORS.black, OPACITY),
        left,
        top,
        evented: false,
        debounceParentDirty: false
      });
      this._rangeShape = polygon;
      this._scene.addObject(polygon, TEXT_RANGE_LAYER_INDEX);
    }
    _createOrUpdateAnchor(pointsGroup, docsLeft, docsTop) {
      var _a2, _b2;
      const bounding = getAnchorBounding(pointsGroup);
      const { left, top, height } = bounding;
      if (this._anchorShape) {
        this._anchorShape.transformByState({ left: left + docsLeft, top: top + docsTop, height });
        this._anchorShape.show();
        return;
      }
      const anchor = new Rect(TEXT_ANCHOR_KEY_PREFIX + Tools.generateRandomId(ID_LENGTH), {
        left: left + docsLeft,
        top: top + docsTop,
        height,
        strokeWidth: ((_a2 = this.style) == null ? void 0 : _a2.strokeWidth) || 1,
        stroke: ((_b2 = this.style) == null ? void 0 : _b2.strokeActive) || getColor(COLORS.black, 1),
        evented: false
      });
      this._anchorShape = anchor;
      this._scene.addObject(anchor, TEXT_RANGE_LAYER_INDEX);
    }
    _setCursorList(cursorList) {
      if (cursorList.length === 0) {
        return;
      }
      this._cursorList = cursorList;
    }
  };

  // ../packages/engine-render/src/basics/position.ts
  function getOffsetRectForDom(ele) {
    const box = ele.getBoundingClientRect();
    const body = document.body;
    const docElem = document.documentElement;
    const scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
    const scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
    const clientTop = docElem.clientTop || body.clientTop;
    const clientLeft = docElem.clientLeft || body.clientLeft;
    const top = box.top + scrollTop - clientTop;
    const left = box.left + scrollLeft - clientLeft;
    return {
      // Math.round 兼容火狐浏览器 bug
      top,
      left
    };
  }

  // ../packages/engine-render/src/components/docs/text-selection/text-selection-render-manager.ts
  function getCanvasOffsetByEngine(engine) {
    const canvas = engine == null ? void 0 : engine.getCanvasElement();
    if (!canvas) {
      return {
        left: 0,
        top: 0
      };
    }
    const { top, left } = getOffsetRectForDom(canvas);
    return {
      left,
      top
    };
  }
  function getParagraphInfoBySpan(node) {
    var _a2;
    const line = (_a2 = node.parent) == null ? void 0 : _a2.parent;
    const column = line == null ? void 0 : line.parent;
    if (line == null || column == null) {
      return;
    }
    const { paragraphIndex } = line;
    const lines = column.lines.filter((line2) => line2.paragraphIndex === paragraphIndex);
    let nodeIndex = -1;
    let content = "";
    let hasFound = false;
    for (const line2 of lines) {
      for (const divide of line2.divides) {
        for (const glyph of divide.glyphGroup) {
          if (!hasFound) {
            nodeIndex += glyph.count;
          }
          if (glyph === node) {
            hasFound = true;
          }
          content += glyph.count > 0 ? glyph.content : "";
        }
      }
    }
    return {
      st: lines[0].st,
      ed: paragraphIndex,
      content,
      nodeIndex
    };
  }
  var TextSelectionRenderManager = class extends RxDisposable {
    constructor(_logService) {
      super();
      this._logService = _logService;
      __publicField(this, "_onInputBefore$", new BehaviorSubject(null));
      __publicField(this, "onInputBefore$", this._onInputBefore$.asObservable());
      __publicField(this, "_onKeydown$", new BehaviorSubject(null));
      __publicField(this, "onKeydown$", this._onKeydown$.asObservable());
      __publicField(this, "_onInput$", new BehaviorSubject(null));
      __publicField(this, "onInput$", this._onInput$.asObservable());
      __publicField(this, "_onCompositionstart$", new BehaviorSubject(null));
      __publicField(this, "onCompositionstart$", this._onCompositionstart$.asObservable());
      __publicField(this, "_onCompositionupdate$", new BehaviorSubject(null));
      __publicField(this, "onCompositionupdate$", this._onCompositionupdate$.asObservable());
      __publicField(this, "_onCompositionend$", new BehaviorSubject(null));
      __publicField(this, "onCompositionend$", this._onCompositionend$.asObservable());
      __publicField(this, "_onSelectionStart$", new BehaviorSubject(null));
      __publicField(this, "onSelectionStart$", this._onSelectionStart$.asObservable());
      __publicField(this, "_onPaste$", new Subject());
      __publicField(this, "onPaste$", this._onPaste$.asObservable());
      __publicField(this, "_textSelectionInner$", new BehaviorSubject(null));
      __publicField(this, "textSelectionInner$", this._textSelectionInner$.asObservable());
      __publicField(this, "_onFocus$", new Subject());
      __publicField(this, "onFocus$", this._onFocus$.asObservable());
      __publicField(this, "_onBlur$", new Subject());
      __publicField(this, "onBlur$", this._onBlur$.asObservable());
      __publicField(this, "_container");
      __publicField(this, "_inputParent");
      __publicField(this, "_input");
      __publicField(this, "_moveObservers", []);
      __publicField(this, "_upObservers", []);
      __publicField(this, "_scrollTimers", []);
      __publicField(this, "_viewportScrollX", 0);
      __publicField(this, "_viewportScrollY", 0);
      __publicField(this, "_rangeList", []);
      __publicField(this, "_currentSegmentId", "");
      __publicField(this, "_selectionStyle", NORMAL_TEXT_SELECTION_PLUGIN_STYLE);
      __publicField(this, "_isSelectionEnabled", true);
      __publicField(this, "_viewPortObserverMap", /* @__PURE__ */ new Map());
      __publicField(this, "_isIMEInputApply", false);
      __publicField(this, "_activeViewport");
      __publicField(this, "_docSkeleton");
      __publicField(this, "_scene");
      __publicField(this, "_document");
      this._initDOM();
    }
    __getEditorContainer() {
      return this._container;
    }
    getViewPort() {
      return this._activeViewport;
    }
    setSegment(id) {
      this._currentSegmentId = id;
    }
    setStyle(style = NORMAL_TEXT_SELECTION_PLUGIN_STYLE) {
      this._selectionStyle = style;
    }
    resetStyle() {
      this.setStyle();
    }
    enableSelection() {
      this._isSelectionEnabled = true;
    }
    disableSelection() {
      this._isSelectionEnabled = false;
    }
    addTextRanges(ranges, isEditing = true) {
      const { _scene: scene, _docSkeleton: docSkeleton } = this;
      for (const range of ranges) {
        const textSelection = cursorConvertToTextRange(scene, range, docSkeleton, this._document);
        this._add(textSelection);
      }
      this._textSelectionInner$.next({
        textRanges: this._getAllTextRanges(),
        segmentId: this._currentSegmentId,
        style: this._selectionStyle,
        isEditing
      });
      this._updateInputPosition();
    }
    // Sync canvas selection to dom selection.
    sync() {
      this._updateInputPosition();
    }
    activate(x, y) {
      this._container.style.left = `${x}px`;
      this._container.style.top = `${y}px`;
      this._container.style.zIndex = "1000";
      this.focus();
    }
    hasFocus() {
      return document.activeElement === this._input;
    }
    focus() {
      this._input.focus();
    }
    blur() {
      this._input.blur();
    }
    // FIXME: for editor cell editor we don't need to blur the input element
    deactivate() {
      this._container.style.left = "0px";
      this._container.style.top = "0px";
    }
    changeRuntime(docSkeleton, scene, document2) {
      if (docSkeleton !== this._docSkeleton) {
        this.removeAllTextRanges();
      }
      this._docSkeleton = docSkeleton;
      this._scene = scene;
      this._activeViewport = scene.getViewports()[0];
      this._document = document2;
      this._attachScrollEvent(this._activeViewport);
    }
    // Handler double click.
    handleDblClick(evt) {
      if (!this._scene || !this._isSelectionEnabled) {
        return;
      }
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
      const startNode = this._findNodeByCoord(evtOffsetX, evtOffsetY);
      if (startNode == null || startNode.node == null) {
        return;
      }
      const paragraphInfo = getParagraphInfoBySpan(startNode.node);
      if (paragraphInfo == null) {
        return;
      }
      const { content, st, nodeIndex } = paragraphInfo;
      if (nodeIndex === -1) {
        return;
      }
      if (Intl.Segmenter == null) {
        return;
      }
      const segmenter = new Intl.Segmenter(void 0, { granularity: "word" });
      const segments = segmenter.segment(content);
      let startOffset = Number.NEGATIVE_INFINITY;
      let endOffset = Number.NEGATIVE_INFINITY;
      for (const { segment, index, isWordLike } of segments) {
        if (index <= nodeIndex && nodeIndex < index + segment.length && isWordLike) {
          startOffset = index + st;
          endOffset = index + st + segment.length;
          break;
        }
      }
      if (Number.isFinite(startOffset) && Number.isFinite(endOffset)) {
        this.removeAllTextRanges();
        const textRanges = [
          {
            startOffset,
            endOffset
          }
        ];
        this.addTextRanges(textRanges, false);
      }
    }
    handleTripleClick(evt) {
      if (!this._scene || !this._isSelectionEnabled) {
        return;
      }
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
      const startNode = this._findNodeByCoord(evtOffsetX, evtOffsetY);
      if (startNode == null || startNode.node == null) {
        return;
      }
      const paragraphInfo = getParagraphInfoBySpan(startNode.node);
      if (paragraphInfo == null) {
        return;
      }
      this.removeAllTextRanges();
      const { st, ed } = paragraphInfo;
      const textRanges = [
        {
          startOffset: st,
          endOffset: ed,
          collapsed: st === ed
        }
      ];
      this.addTextRanges(textRanges, false);
    }
    setCursorManually(evtOffsetX, evtOffsetY) {
      const startNode = this._findNodeByCoord(evtOffsetX, evtOffsetY);
      const position = this._getNodePosition(startNode);
      if (position == null) {
        this._removeAllTextRanges();
        return;
      }
      if ((startNode == null ? void 0 : startNode.node.streamType) === "\r" /* PARAGRAPH */) {
        position.isBack = true;
      }
      this._updateTextRangeAnchorPosition(position);
      this._activeSelectionRefresh();
    }
    // Handle pointer down.
    eventTrigger(evt) {
      var _a2;
      if (!this._scene || !this._isSelectionEnabled) {
        return;
      }
      const scene = this._scene;
      const { offsetX: evtOffsetX, offsetY: evtOffsetY } = evt;
      const startNode = this._findNodeByCoord(evtOffsetX, evtOffsetY);
      const position = this._getNodePosition(startNode);
      if (position == null) {
        this._removeAllTextRanges();
        return;
      }
      if ((startNode == null ? void 0 : startNode.node.streamType) === "\r" /* PARAGRAPH */) {
        position.isBack = true;
      }
      if (evt.shiftKey && this._getActiveRangeInstance()) {
        this._updateActiveRangeFocusPosition(position);
      } else if (evt.ctrlKey || this._isEmpty()) {
        const newTextSelection = new TextRange(scene, this._document, this._docSkeleton, position);
        this._addTextRange(newTextSelection);
      } else {
        this._updateTextRangeAnchorPosition(position);
      }
      this._activeSelectionRefresh();
      scene.disableEvent();
      const scrollTimer = ScrollTimer.create(scene);
      this._scrollTimers.push(scrollTimer);
      scrollTimer.startScroll(evtOffsetX, evtOffsetY);
      const { scrollX: scrollX2, scrollY: scrollY2 } = getCurrentScrollXY(scrollTimer);
      this._viewportScrollX = scrollX2;
      this._viewportScrollY = scrollY2;
      this._onSelectionStart$.next((_a2 = this._getActiveRangeInstance()) == null ? void 0 : _a2.startNodePosition);
      let preMoveOffsetX = evtOffsetX;
      let preMoveOffsetY = evtOffsetY;
      this._moveObservers.push(scene.onPointerMoveObserver.add((moveEvt) => {
        const { offsetX: moveOffsetX, offsetY: moveOffsetY } = moveEvt;
        scene.setCursor("text" /* TEXT */);
        if (Math.sqrt((moveOffsetX - preMoveOffsetX) ** 2 + (moveOffsetY - preMoveOffsetY) ** 2) < 3) {
          return;
        }
        this._moving(moveOffsetX, moveOffsetY);
        scrollTimer.scrolling(moveOffsetX, moveOffsetY, () => {
          this._moving(moveOffsetX, moveOffsetY);
        });
        preMoveOffsetX = moveOffsetX;
        preMoveOffsetY = moveOffsetY;
      }));
      this._upObservers.push(scene.onPointerUpObserver.add(() => {
        this._moveObservers.forEach((obs) => {
          obs == null ? void 0 : obs.dispose();
        });
        this._upObservers.forEach((obs) => {
          obs == null ? void 0 : obs.dispose();
        });
        this._moveObservers = [];
        this._upObservers = [];
        scene.enableEvent();
        this._textSelectionInner$.next({
          textRanges: this._getAllTextRanges(),
          segmentId: this._currentSegmentId,
          style: this._selectionStyle,
          isEditing: false
        });
        this._scrollTimers.forEach((timer) => {
          timer == null ? void 0 : timer.dispose();
        });
        this._scrollTimers = [];
        this._updateInputPosition();
      }));
    }
    removeAllTextRanges() {
      this._removeAllTextRanges();
      this.deactivate();
    }
    _getAllTextRanges() {
      return this._rangeList;
    }
    _getActiveRange() {
      const activeRange = this._rangeList.find((range) => range.isActive());
      if (activeRange == null) {
        return null;
      }
      const { startOffset, endOffset, collapsed, startNodePosition, endNodePosition, direction } = activeRange;
      if (startOffset == null || endOffset == null) {
        return null;
      }
      return {
        startOffset,
        endOffset,
        collapsed,
        startNodePosition,
        endNodePosition,
        direction,
        segmentId: this._currentSegmentId,
        style: this._selectionStyle
      };
    }
    _add(textRange) {
      if (textRange == null) {
        return;
      }
      this._addTextRange(textRange);
      textRange.refresh();
    }
    _getActiveRangeInstance() {
      return this._rangeList.find((range) => range.isActive());
    }
    dispose() {
      super.dispose();
      this._detachEvent();
      this._container.remove();
    }
    _initDOM() {
      const container = document.createElement("div");
      container.style.position = "fixed";
      container.style.left = "0px";
      container.style.top = "0px";
      const inputParent = document.createElement("div");
      const inputDom = document.createElement("div");
      inputParent.appendChild(inputDom);
      container.appendChild(inputParent);
      this._container = container;
      this._inputParent = inputParent;
      this._input = inputDom;
      this._initInput();
      this._initInputEvents();
      document.body.appendChild(container);
    }
    _initInput() {
      this._inputParent.style.cssText = `
            position:absolute;
            height:1px;
            width:1px;
            overflow: hidden;
        `;
      this._input.contentEditable = "true";
      this._input.classList.add("univer-editor");
      this._input.style.cssText = `
            position: absolute;
            overflow: hidden;
            opacity: 1;
            background: #000;
            color: transparent;
            outline: none;
            z-index: -2;
            caret-color: transparent;
            white-space: pre-wrap;
            user-select: text;
        `;
    }
    _getNodePosition(node) {
      var _a2;
      if (node == null) {
        return;
      }
      const { node: glyph, ratioX } = node;
      const position = (_a2 = this._docSkeleton) == null ? void 0 : _a2.findPositionByGlyph(glyph);
      if (position == null) {
        return;
      }
      const HALF = 0.5;
      const isBack = ratioX < HALF;
      return {
        ...position,
        isBack
      };
    }
    _interactTextRange(textRange) {
      const newTextSelection = [];
      let hasIntersection = false;
      this._rangeList.forEach((range) => {
        if (range === textRange) {
          return true;
        }
        if (!textRange.isIntersection(range)) {
          newTextSelection.push(range);
        } else {
          hasIntersection = true;
          range.dispose();
        }
      });
      if (!hasIntersection) {
        return;
      }
      newTextSelection.push(textRange);
      this._rangeList = newTextSelection;
    }
    _removeAllTextRanges() {
      this._rangeList.forEach((range) => {
        range.dispose();
      });
      this._rangeList = [];
    }
    _deactivateAllTextRanges() {
      this._rangeList.forEach((range) => {
        range.deactivate();
      });
    }
    _addTextRange(textRange) {
      this._deactivateAllTextRanges();
      textRange.activate();
      this._rangeList.push(textRange);
    }
    _updateTextRangeAnchorPosition(position) {
      if (!this._scene) {
        return;
      }
      let lastRange = this._rangeList.pop();
      if (!lastRange) {
        lastRange = new TextRange(this._scene, this._document, this._docSkeleton, position);
      }
      this._removeAllTextRanges();
      lastRange.activate();
      lastRange.anchorNodePosition = position;
      lastRange.focusNodePosition = null;
      this._rangeList = [lastRange];
    }
    _updateActiveRangeFocusPosition(position) {
      if (!this._scene) {
        this._logService.error("[TextSelectionRenderManager] _updateActiveRangeFocusPosition: scene is null");
        return;
      }
      const activeTextRange = this._getActiveRangeInstance();
      if (activeTextRange == null || activeTextRange.anchorNodePosition == null) {
        this._logService.error(
          "[TextSelectionRenderManager] _updateActiveRangeFocusPosition: active range has no anchor"
        );
        return;
      }
      this._removeAllTextRanges();
      activeTextRange.activate();
      activeTextRange.focusNodePosition = position;
      this.deactivate();
      this._rangeList = [activeTextRange];
    }
    _isEmpty() {
      return this._rangeList.length === 0;
    }
    _getCanvasOffset() {
      var _a2;
      const engine = (_a2 = this._scene) == null ? void 0 : _a2.getEngine();
      return getCanvasOffsetByEngine(engine);
    }
    _updateInputPosition() {
      const activeRangeInstance = this._getActiveRangeInstance();
      const anchor = activeRangeInstance == null ? void 0 : activeRangeInstance.getAnchor();
      if (!anchor || anchor && !anchor.visible || this._activeViewport == null) {
        this.focus();
        return;
      }
      const { left, top } = anchor;
      const absoluteCoord = this._activeViewport.getAbsoluteVector(Vector2.FromArray([left, top]));
      const { x, y } = absoluteCoord;
      let { left: canvasLeft, top: canvasTop } = this._getCanvasOffset();
      canvasLeft += x;
      canvasTop += y;
      this.activate(canvasLeft, canvasTop);
    }
    _moving(moveOffsetX, moveOffsetY) {
      var _a2, _b2;
      if (this._docSkeleton == null) {
        return;
      }
      const endNode = this._findNodeByCoord(moveOffsetX, moveOffsetY);
      const focusNodePosition = this._getNodePosition(endNode);
      if (!focusNodePosition) {
        return;
      }
      const activeRangeInstance = this._getActiveRangeInstance();
      if (!activeRangeInstance) {
        return;
      }
      activeRangeInstance.focusNodePosition = focusNodePosition;
      activeRangeInstance.refresh();
      this.deactivate();
      this._interactTextRange(activeRangeInstance);
      (_b2 = (_a2 = this._scene) == null ? void 0 : _a2.getEngine()) == null ? void 0 : _b2.setRemainCapture();
    }
    _attachScrollEvent(viewport) {
      if (viewport == null || this._docSkeleton == null) {
        return;
      }
      const unitId = this._docSkeleton.getViewModel().getDataModel().getUnitId();
      const key = `${unitId}_${viewport.viewPortKey}`;
      if (this._viewPortObserverMap.has(key)) {
        return;
      }
      const scrollBefore = viewport.onScrollBeforeObserver.add((param) => {
        const viewport2 = param.viewport;
        if (!viewport2) {
          return;
        }
        const activeRangeInstance = this._getActiveRangeInstance();
        activeRangeInstance == null ? void 0 : activeRangeInstance.activeStatic();
      });
      const scrollStop = viewport.onScrollStopObserver.add((param) => {
        const viewport2 = param.viewport;
        if (!viewport2) {
          return;
        }
        const bounds = viewport2.getBounding();
        const activeRangeInstance = this._getActiveRangeInstance();
        const anchor = activeRangeInstance == null ? void 0 : activeRangeInstance.getAnchor();
        if (!anchor || anchor && !anchor.visible) {
          return;
        }
        if (bounds) {
          const { left, top, right, bottom } = bounds.viewBound;
          if (anchor.left < left || anchor.left > right || anchor.top < top || anchor.top > bottom) {
            activeRangeInstance == null ? void 0 : activeRangeInstance.deactivateStatic();
            return;
          }
        }
        this._updateInputPosition();
      });
      this._viewPortObserverMap.set(key, {
        scrollBefore,
        scrollStop
      });
    }
    // FIXME: listeners here are not correctly disposed
    _initInputEvents() {
      this.disposeWithMe(
        fromEvent(this._input, "keydown").subscribe((e) => {
          if (this._isIMEInputApply) {
            return;
          }
          this._eventHandle(e, (config2) => {
            this._onKeydown$.next(config2);
          });
        })
      );
      this.disposeWithMe(
        fromEvent(this._input, "input").subscribe((e) => {
          if (this._isIMEInputApply) {
            return;
          }
          this._eventHandle(e, (config2) => {
            this._onInputBefore$.next(config2);
            this._onInput$.next(config2);
          });
        })
      );
      this.disposeWithMe(
        fromEvent(this._input, "compositionstart").subscribe((e) => {
          this._isIMEInputApply = true;
          this._eventHandle(e, (config2) => {
            this._onCompositionstart$.next(config2);
          });
        })
      );
      this.disposeWithMe(
        fromEvent(this._input, "compositionend").subscribe((e) => {
          this._isIMEInputApply = false;
          this._eventHandle(e, (config2) => {
            this._onCompositionend$.next(config2);
          });
        })
      );
      this.disposeWithMe(
        fromEvent(this._input, "compositionupdate").subscribe((e) => {
          this._eventHandle(e, (config2) => {
            this._onInputBefore$.next(config2);
            this._onCompositionupdate$.next(config2);
          });
        })
      );
      this.disposeWithMe(
        fromEvent(this._input, "paste").subscribe((e) => {
          this._eventHandle(e, (config2) => {
            this._onPaste$.next(config2);
          });
        })
      );
      this.disposeWithMe(
        fromEvent(this._input, "focus").subscribe((e) => {
          this._eventHandle(e, (config2) => {
            this._onFocus$.next(config2);
          });
        })
      );
      this.disposeWithMe(
        fromEvent(this._input, "blur").subscribe((e) => {
          this._eventHandle(e, (config2) => {
            this._onBlur$.next(config2);
          });
        })
      );
    }
    _eventHandle(e, func) {
      const content = this._input.textContent || "";
      this._input.innerHTML = "";
      const activeRange = this._getActiveRange();
      const rangeList = this._getAllTextRanges();
      func({
        event: e,
        content,
        activeRange,
        rangeList
      });
    }
    _getTransformCoordForDocumentOffset(evtOffsetX, evtOffsetY) {
      const { documentTransform } = this._document.getOffsetConfig();
      if (this._activeViewport == null || documentTransform == null) {
        return;
      }
      const originCoord = this._activeViewport.getRelativeVector(Vector2.FromArray([evtOffsetX, evtOffsetY]));
      if (!originCoord) {
        return;
      }
      return documentTransform.clone().invert().applyPoint(originCoord);
    }
    _findNodeByCoord(evtOffsetX, evtOffsetY) {
      var _a2;
      const coord = this._getTransformCoordForDocumentOffset(evtOffsetX, evtOffsetY);
      if (coord == null) {
        return;
      }
      const {
        pageLayoutType = 0 /* VERTICAL */,
        pageMarginLeft,
        pageMarginTop
      } = this._document.getOffsetConfig();
      return (_a2 = this._docSkeleton) == null ? void 0 : _a2.findNodeByCoord(coord, pageLayoutType, pageMarginLeft, pageMarginTop);
    }
    _detachEvent() {
      this._onInputBefore$.complete();
      this._onKeydown$.complete();
      this._onInput$.complete();
      this._onCompositionstart$.complete();
      this._onCompositionupdate$.complete();
      this._onCompositionend$.complete();
      this._onSelectionStart$.complete();
    }
    _activeSelectionRefresh() {
      if (this._docSkeleton == null) {
        return;
      }
      const activeRangeInstance = this._getActiveRangeInstance();
      activeRangeInstance == null ? void 0 : activeRangeInstance.refresh();
    }
  };
  TextSelectionRenderManager = __decorateClass([
    __decorateParam(0, ILogService)
  ], TextSelectionRenderManager);
  var ITextSelectionRenderManager = createIdentifier(
    "univer.doc.text-selection-render-manager"
  );

  // src/sheets/worker.ts
  var univer = new Univer({
    locale: "zhCN" /* ZH_CN */
  });
  univer.registerPlugin(UniverSheetsPlugin);
  univer.registerPlugin(UniverFormulaEnginePlugin);
  univer.registerPlugin(UniverRPCWorkerThreadPlugin);
  self.univer = univer;
})();
//# sourceMappingURL=worker.js.map
